Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 1 - 1


					PAGE	 	59,132
					TITLE		GLaBIOS
				
				;----------------------------------------------------------------------------;
				; GLaBIOS (General Libraries and Basic Input Output System)
				;
				; An scratch-built, open-source 8088 PC/clone BIOS alternative.
				;
				; Copyright (c) 2022-2023, 640KB and contributors
				;
				;----------------------------------------------------------------------------;
				;
				; This program is free software: you can redistribute it and/or modify it under the terms 
				; of the GNU General Public License as published by the Free Software Foundation, either 
				; version 3 of the License, or (at your option) any later version.
				;
				; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
				; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
				; See the GNU General Public License for more details.
				;
				; You should have received a copy of the GNU General Public License along with this program. 
				; If not, see <https://www.gnu.org/licenses/>.
				;
				;----------------------------------------------------------------------------;
				; References, Credits and Inspiration:
				;
				;  https://stanislavs.org/helppc/
				;  http://www.minuszerodegrees.net/
				;  https://www.felixcloutier.com/x86/
				;  https://sites.google.com/site/pcdosretro/ (offline)
				;
				;  "Programmer's Guide to the IBM(R) PC", Peter Norton
				;  "System BIOS for IBM(R) PC/XT(TM)/AT(R) Computers and Compatibles",
				;	Phoenix Technologies Ltd.
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton
				;  (Many more inline...)
				;
				;  Font bitmaps by "VileR", (CC BY-SA 4.0)
				;  https://int10h.org/oldschool-pc-fonts/readme/#legal_stuff
				;
				;  @Raffzahn, Contributor and Meckerhut.
				;
				;  https://github.com/640-KB/GLaBIOS#further-credits-to
				;
				;  "Every byte is sacred, every byte is great,
				;  when a byte is wasted, God gets quite irate..."
				;  - David W. Plummer
				;----------------------------------------------------------------------------;
				; Build Instructions:
				;
				; Build using MASM 5 or later.
				;
				;  MAKE.BAT
				;
				; or
				;
				;  MASM GLABIOS;
				;  LINK GLABIOS;
				;  GLA2ROM GLABIOS.EXE GLABIOS.ROM		; Build 8K ROM
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 2 - 1


				;
				; MASM Build Options:
				;  /DVER_DATE='02/22/22'			; Must be MM/DD/YY format
				;  /DARCH_TYPE='X'				; P, X, Y or T (see ARCH_* below)
				;  /DCPU_TYPE='8'					; 8 or V (see CPU_* below)
				;
				;----------------------------------------------------------------------------;
				; POST Error Beep messages:
				;
				; Short  Long
				;	2	1	CPU register test failure
				;	3	1	CPU instruction test failed
				;	4	1	Build is V20 but not detected
				;	2	2	System BIOS ROM checksum error
				;	3	2	PIT counter 1 test failed
				;	4	2	DMA register test failed
				;	5	2	PIC test register failed
				;	5	3	PIC test interrupt failed
				;	1	3	Base RAM (0-16KB) read/write error
				;	3	3	Error loading video adapter ROM
				;	1	4	Base RAM (0-16KB) parity error
				;
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Build Target Architecture equates (do not edit these)
				;
 = 0050				ARCH_5150		EQU	'P'			; 5150
 = 0058				ARCH_5160		EQU	'X'			; 5160 v1
 = 0059				ARCH_5160v2		EQU	'Y'			; 5160 v2/3
 = 0054				ARCH_TURBO		EQU	'T'			; Standard Turbo or clone
 = 0053				ARCH_TD3300		EQU	'S'			; TD3300A (ST-xx/UNIQUE/Auva)
 = 0046				ARCH_FE2010		EQU	'F'			; Faraday FE2010A
 = 0048				ARCH_EHB		EQU	'H'			; EMM Computers/Homebrew8088
 = 0045				ARCH_EMU		EQU	'E'			; 86Box/Emulator
 = 004D				ARCH_M88		EQU	'M'			; micro_8088/NuXT
 = 0049				ARCH_MIST		EQU	'I'			; PCXT_MiSTer
 = 0055				ARCH_UM82		EQU	'U'			; UMC UM82C088 / ALi M1101
 = 0043				ARCH_MARTY		EQU	'C'			; MartyPC Emulator
 = 0056				ARCH_VEN888		EQU	'V'			; Vendex 888-XT
				
				;
				; CPU Instruction Set Target
				;
 = 0038				CPU_8088		EQU	'8'			; 808x compatible
 = 0056				CPU_V20		EQU	'V'			; V20 only
				
				;
				; Boot to Turbo or Normal Speed
				;
 = 0054				BOOT_TURBO		EQU	'T'
 = 004E				BOOT_NORMAL		EQU	'N'
				
				;
				; Turbo Switch Behavior
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 3 - 1


				;
 = 0000				TURBO_NONE		EQU	0			; fixed clock no turbo switching
 = 0001				TURBO_STD		EQU	1			; standard PPI B (bit 3)
 = 0002				TURBO_REV		EQU	2			; reversed PPI B (bit 3)
				
				;----------------------------------------------------------------------------;
				; BIOS Product Info
				;
 = 'GLaBIOS'			VER_NAME		EQU	'GLaBIOS'
					IFNDEF VER_NUM
 = '0.2.5'			VER_NUM		EQU	'0.2.5'		; (max 5 chars)
					ENDIF
					IFNDEF VER_DATE
 = '07/23/23'VER_DATE		EQU	'07/23/23' 		; must be MM/DD/YY format
					ENDIF
 = '2022-23'			COPY_YEAR		EQU	'2022-23'		; Copyright year range
				
				;----------------------------------------------------------------------------;
				; BEGIN Configurable Build Options
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Select Target Architecture Preset
				;
					IFNDEF ARCH_TYPE
				;ARCH_TYPE		EQU	ARCH_5150		; PC 5150
				;ARCH_TYPE		EQU	ARCH_5160		; PC 5160 (recommended for non-Turbo)
				;ARCH_TYPE		EQU	ARCH_5160v2		; PC 5160v2 (not recommended)
 = ARCH_TURBO			ARCH_TYPE		EQU	ARCH_TURBO		; Standard Turbo
				;ARCH_TYPE		EQU	ARCH_TD3300		; TD3300A (ST-xx/UNIQUE/Auva)
				;ARCH_TYPE		EQU	ARCH_FE2010		; Faraday FE2010A
				;ARCH_TYPE		EQU	ARCH_UM82		; UMC UM82C088 / ALi M1101
				;ARCH_TYPE		EQU	ARCH_EHB		; EMM Computers/Homebrew 8088
				;ARCH_TYPE		EQU	ARCH_EMU		; 86Box/Emulators (not for real hardware)
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Sub Architecture Types (use with the ARCH_TYPE in parentheses)
				;
					IFNDEF ARCH_SUB_TYPE
				;ARCH_SUB_TYPE	EQU	ARCH_M88		; micro_8088/NuXT (TYPE ARCH_FE2010)
				;ARCH_SUB_TYPE	EQU	ARCH_MIST		; PCXT_MiSTer (TYPE ARCH_EMU)
				;ARCH_SUB_TYPE	EQU	ARCH_MARTY		; MartyPC Emulator (TYPE ARCH_TURBO)
				;ARCH_SUB_TYPE	EQU	ARCH_VEN888		; Vendex 888-XT
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Default CPU Instruction Set Target
				;
					IFNDEF CPU_TYPE
 = CPU_8088			CPU_TYPE		EQU	CPU_8088		; CPU_8088 or CPU_V20
				;CPU_TYPE		EQU	CPU_V20		; use V20+ only instructions
					ENDIF
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 4 - 1


				; Turbo Type
				;
				; Some motherboards boot in Normal mode by default and the BIOS may or may not
				; switch to Turbo speed on boot. Others invert this behavior where it appears
				; reversed to the BIOS. Use these options to customize for your motherboard.
				;
					IFNDEF TURBO_TYPE
				;TURBO_TYPE		=	TURBO_NONE	; standard 4.77 MHz
				;TURBO_TYPE		=	TURBO_STD	; standard PPI 61h (1=turbo, 0=normal)
 = 0002				TURBO_TYPE		=	TURBO_REV	; reversed PPI 61h (1=normal, 0=turbo)
					ENDIF
				
				;----------------------------------------------------------------------------;
				; CGA Snow Removal Method
				;
 = 0000				CGA_SNOW_REMOVE	=	0		; 0: Snow, Normal Flashing, Fastest
										; 1: Less Snow, Some Flashing, Medium Fast
										; 2: No Snow, Moderate Flashing, Fast
										; 3: No Snow, More Flashing, Quite Fast
				
				;----------------------------------------------------------------------------;
				; Personality Traits
				;
 = 0000				POST_CLS		=	0		; clear screen after POST
 = 0000				POST_GLADOS		=	0		; say "Starting GLaDOS..." on boot
 = 0001				POST_HD_PARMS	=	1		; show hard drive parameters on POST
 = 0000				POST_OPT_ROM	=	0		; show option ROM address and loading info
 = 0001				POST_THEME		=	1		; color theme for POST screen (see below)
 = 0001				POST_VIDEO_TYPE	=	1		; show the video adapter type on POST
 = 0001				POST_WARM_COLD	=	1		; show boot WARM or COLD
 = 0001				WARM_ENABLE		=	1		; 1=enable WARM boot or 0=always COLD boot
 = 0001				RANDOM_TAGLINE	=	1		; randomize pithy tagline
 = 0000				UNITS_IEC		=	0		; 0=period-correct "KB" or 1=modern IEC "KiB"
				
				;----------------------------------------------------------------------------;
				; Enable/Disable POST tests (not all tests can be enabled due to 8K ROM space)
				;
 = 0001				POST_TEST_INST	=	1		; POST CPU Instruction/Flag Test
 = 0001				POST_TEST_DMA	=	1		; POST DMA Register Test
 = 0001				POST_TEST_PIT_1	=	1		; POST Timer Channel 1 Test
 = 0001				POST_TEST_PIC_REG	=	1		; POST PIC Register Test
 = 0001				POST_TEST_PIC_INT	=	1		; POST PIC Interrupt Test
 = 0001				POST_TEST_CHK_ROM	=	1		; POST Checksum ROM
 = 0000				POST_TEST_FD	=	0		; POST Floppy Drive Test
 = 0000				POST_TEST_SEEK	=	0		; POST Seek Floppy Drives
 = 0001				POST_TEST_KB	=	1		; POST Keyboard Test (PKI)
 = 0001				POST_TEST_KEY	=	1		; POST Key Test (PKEY)
				
				;----------------------------------------------------------------------------;
				; Advanced Options (may void your warranty)
				;
 = 0280				MAX_RAM_PC		EQU	640		; 0000-A000 (ought to be enough)
 = 02C0				MAX_RAM_MDA		EQU	704		; MDA include A000-B000
 = 02E0				MAX_RAM_CGA		EQU	736		; CGA include A000-B800
 = 0280				MAX_RAM 		=	MAX_RAM_PC	; Max detectable low RAM (in KB)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 5 - 1


										;   640 max using EGA/VGA
										;   704 max using MDA (MAX_RAM_MDA)
										;   736 max using CGA (MAX_RAM_CGA)
 = 0001				MAX_RAM_AUTO	=	1		; Auto-detect MAX_RAM from video DIP switches
 = 0000				DRAM_REFRESH	=	0		; 1=Use standard DMA DRAM refresh
										; 0=Disable refresh (use only with SRAM!)
 = 0000				RAM_PARITY		=	0		; Enable RAM parity checking
 = 0000				RAM_TEST_LONG	=	0		; Long RAM test on cold boot
 = 0000				BASIC_ROM		=	0		; BASIC ROM support at 0F600h
 = FE00				OPT_ROM_END		=	0FE00H	; Option ROM scan ending address
 = 0000				FDC_ENABLE		=	0		; Enable INT 13h floppy support
 = 0001				FDC_HLT_WAIT	=	1		; Halt CPU during FD access
										;   Some chipsets (TD3300A known affected)
										;   hang during floppy access if this is
										;   enabled
 = 0001				KB_HLT_WAIT		=	1		; Halt CPU during KB wait
 = 0000				MBR_CHECK		=	0		; Verify magic number of DOS MBR at boot
										;   note: DOS 1.0 does not use MBR, so
										;   will not boot if this is enabled
 = 0001				POST_HD_CHECK	=	1		; Enable POST HD drive count and size
										;   note: Some older WD controller ROMs 
										;   (version 62-000043-0xx known affected)
										;   have bugs where INT 13h function are
										;   unusable during POST. Set to 0 to
										;   work around (disables POST_HD_PARMS)
 = 0000				FD_AUTO_DETECT	=	0		; Auto-detect number of floppy drives
										;   use only for DIP switch-less PCs!
 = 0001				POST_ERR_WAIT	=	1		; Wait for Any Key press to continue if
										;   there is a POST error
 = 0000				INT_19_BOOT_HD	=	0		; Try IPL to floppy then hard drive (80h)
 = 00C0				SW1_FLP		=	MASK FLP	; Default max number of floppy drives
 = 0001				MDA_ATTR		=	1		; Display MDA character attributes
										; 2=all, 1=intensity only, 0=filter all
				
				;----------------------------------------------------------------------------;
				; END Configurable Build Options
				;----------------------------------------------------------------------------;
				
				
				;----------------------------------------------------------------------------;
				; ARCH/build-specific configuration
				;----------------------------------------------------------------------------;
				; Defaults / BIOS ID Byte
				;
				; https://stanislavs.org/helppc/id_bytes.html
				; NOTE: DOS may re-vector some interrupts or attempt bug workarounds 
				; depending on this byte.
				;
 = 00FE				ARCH_ID		=	0FEH			; 0xFE=XT v1/clone (default)
 = 0000				CASSETTE		=	0			; disable cassette (default)
				
					IFNDEF ARCH_SUB_TYPE
 = 0000				ARCH_SUB_TYPE	EQU	0			; make sure this is defined
					ENDIF
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 6 - 1


					IF ARCH_TYPE EQ ARCH_5150
				;----------------------------------------------------------------------------;
				; Configuration for 5150 board
				;
				ARCH_ID		=	0FFH			; 0xFF=5150
				CASSETTE		=	1			; enable INT 13h cassette
				MBR_CHECK		=	0			; disable MBR check for DOS 1.x
				TURBO_TYPE		=	TURBO_NONE
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Configuration for 5160 boards
				;
					IF ARCH_TYPE EQ ARCH_5160v2
				ARCH_ID		=	0FBH			; 0xFB=XT v2/v3
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
					ENDIF
					IF ARCH_TYPE EQ ARCH_5160
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_TD3300
				;----------------------------------------------------------------------------;
				; Configuration for TD3300A
				;
				BASIC_ROM		= 	0			; disable to free code space
				FDC_HLT_WAIT	=	0			; seems to cause issues on TD3300A
				TURBO_TYPE		=	TURBO_STD		; always use Standard
				TURBO_SWITCH	=	1			; boot under hardware Turbo control
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_UM82
				;----------------------------------------------------------------------------;
				; Configuration for UM82C088
				;
				BASIC_ROM		= 	0			; disable to free code space
						IF BASIC_ROM EQ 1			; if BASIC enabled, disable
				POST_TEST_PIC_REG	=	0			;  unnecessary tests to free code
				POST_TEST_PIC_INT	=	0			;  space since PIC is integrated
						ENDIF
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; Configuration for FE2010A
				;
				;BASIC_ROM		= 	0			; can be disabled to free code space
				FD_AUTO_DETECT	=	1			; auto-detect number of floppy drives
				;FE_CPU_CFG		=	110b			; boot to 9.54 MHz, 2 RAM WS
				FE_CPU_CFG		=	100b			; boot to 9.54 MHz, 4 RAM WS (safest)
				;FE_CPU_CFG		=	011b			; boot to 7.15 MHz, 0 RAM WS
				;FE_CPU_CFG		=	000b			; boot to 4.77 MHz, 0 RAM WS
				POST_TEST_PIT_1	=	0			; FE2010A chipset cannot read timer 1
				SW1_FLP		=	01b			; SW1 5/6 Max # of floppy drives (0-1)
				TURBO_TYPE		=	TURBO_REV		; always use reverse
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 7 - 1


					IF BASIC_ROM EQ 1				; if BASIC enabled, PIC tests are
				POST_TEST_PIC_REG	=	0			;  disabled to fit available code space
				POST_TEST_PIC_INT	=	0			; Since PIC is integrated on FE2010A
					ENDIF						;  these tests may be unnecessary
				
					IF ARCH_SUB_TYPE EQ ARCH_M88
				;----------------------------------------------------------------------------;
				; Additional Configuration for micro_8088 / NuXT
				;
				UNITS_IEC		=	1			; use modern IEC size units
				DRAM_REFRESH	=	0			; disable DRAM refresh (for SRAM)
				RAM_PARITY		=	0			; disable memory parity check
				CGA_SNOW_REMOVE	=	0			; disable snow removal
				FE_CPU_CFG		=	110b			; boot to 9.54 MHz, 2 RAM WS
					ENDIF
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_EHB
				;----------------------------------------------------------------------------;
				; Configuration for EMM/Homebrew
				;
				CGA_SNOW_REMOVE	=	0			; disable snow removal
				DRAM_REFRESH	=	0			; disable refresh (no DRAM)
				RAM_PARITY		=	0			; disable memory parity check
				DMA_INSTALLED	=	0			; no DMA 8237A installed
				;FDC_ENABLE		=	0			; disable all INT 13h floppy tests (if no DM
				A)
				;POST_TEST_FD	=	0			; disable Seek Floppy Drives
				POST_TEST_DMA	=	0			; disable DMA Register Test (no DMA)
				POST_TEST_KB	=	0			; disable PKEY and PKI errors
				POST_TEST_PIT_1	=	0			; disable Timer 1 Test (no DRAM)
				POST_TEST_PIC_REG	=	0			; disable PIC Register Test
				SW1_VID		=	00b			; SW1 5/6 Video Type (0=EGA/VGA
											;   1=CGA 40, 2=CGA 80, 3=MDA/Herc)
							IF FDC_ENABLE EQ 1
				SW1_FLP		=	01b			; SW1 7/8 Max # of floppy drives (0-3)
				FD_AUTO_DETECT	=	1			; auto-detect number of floppy drives
							ELSE
				SW1_FLP		=	00b			; SW1 7/8 Max # of floppy drives (0-3)
							ENDIF
							IF CPU_TYPE NE CPU_V20
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
							ENDIF
				POST_ERR_WAIT	=	0			; only warn POST errors (since DMA
											;   and FDC are optional)
				INT_19_BOOT_HD	=	1			; Try IPL to floppy then HD
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_EMU
				;----------------------------------------------------------------------------;
				; Configuration for 86Box/Emulators
				;
				CGA_SNOW_REMOVE	=	0			; disable CGA snow removal
				DRAM_REFRESH	=	0			; disable DRAM refresh
				POST_TEST_CHK_ROM	=	0			; disable Checksum ROM
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 8 - 1


				POST_TEST_DMA	=	0			; disable DMA Register Test
				POST_TEST_PIC_INT	=	0			; disable PIC Interrupt Test
				POST_TEST_PIC_REG	=	0			; disable PIC Register Test
				POST_TEST_PIT_1	=	0			; disable Timer Channel 1 Test
				POST_TEST_FD	=	0			; disable Floppy Drive Seek Test
											; disable Floppy Head Settle Delay
				RAM_TEST_LONG	=	0			; disable long RAM test
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
				MAX_RAM_AUTO	=	1			; select max RAM from video setting
				
					IF ARCH_SUB_TYPE EQ ARCH_MIST
				;----------------------------------------------------------------------------;
				; Additional Configuration for PCXT_MiSTer
				;
				TURBO_TYPE		=	TURBO_STD		; enable Turbo features
				;FDC_ENABLE		=	0			; disable all INT 13h floppy tests
					ENDIF
					ENDIF
				
					IF ARCH_SUB_TYPE EQ ARCH_MARTY
				;----------------------------------------------------------------------------;
				; Additional Configuration for MartyPC emulator
				;
				MAX_RAM 		=	736			; 736 KB Max detectable low RAM
				CASSETTE		=	0			; use all features on 5150
				CGA_SNOW_REMOVE	=	0			; disable CGA snow removal
				;RAM_TEST_LONG	=	0			; disable long RAM test
					ENDIF
				
					IF ARCH_SUB_TYPE EQ ARCH_VEN888
				;----------------------------------------------------------------------------;
				; Configuration for Vendex 888-XT/PB88/Samsung Unknown
				;
				BASIC_ROM		=	0			; disable to free code space
				TURBO_TYPE		=	TURBO_STD		; use inverse so toggle sets speed
				;MAX_RAM 		=	704			; if using integrated MDA
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Boot to normal or turbo speed (if supported)
				;
 =-0001				IS_TURBO		=	TURBO_TYPE NE TURBO_NONE	; use for conditionals
				
					IF IS_TURBO
 = BOOT_TURBO			BOOT_SPEED		EQU	BOOT_TURBO
					ELSE
				BOOT_SPEED		EQU	BOOT_NORMAL
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Reconfigure features as needed
				;----------------------------------------------------------------------------;
				; If Cassette enabled, the following features must be disabled to 
				; free code space.
				;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 9 - 1


					IF CASSETTE EQ 1
				POST_HD_PARMS	=	0			; disable HD size display
				RANDOM_TAGLINE	=	0			; disable random tagline
				POST_OPT_ROM	=	0			; display POST option ROM display
					ENDIF
				
					IF POST_HD_CHECK EQ 0
				POST_HD_PARMS	=	0			; disable HD PARM display also
					ENDIF
				
					IF WARM_ENABLE EQ 0
				POST_WARM_COLD	=	0			; disable show boot WARM or COLD
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Enable 186 instructions if V20
				;
					IF CPU_TYPE EQ CPU_V20
				.186
					ENDIF
				
				
				;----------------------------------------------------------------------------;
				; POST colors and visuals
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; PC Text Colors
				; https://stanislavs.org/helppc/colors.html
				;
 = 0000				BLACK			EQU	0
 = 0001				DARKBLUE		EQU	1
 = 0002				DARKGREEN		EQU	2
 = 0003				CYAN			EQU	3
 = 0004				DARKRED		EQU	4
 = 0005				DARKMAGENTA		EQU	5
 = 0006				BROWN			EQU	6
 = 0007				GRAY			EQU	7
 = 0008				DARKGRAY		EQU	8
 = 0009				BLUE			EQU	9
 = 000A				GREEN			EQU	10
 = 000B				LIGHTCYAN		EQU	11
 = 000C				RED			EQU	12
 = 000D				MAGENTA		EQU	13
 = 000E				YELLOW		EQU	14
 = 000F				WHITE			EQU	15
				
				;----------------------------------------------------------------------------;
				; Theme My POST Test!
				; Pick theme from below or roll your own!
				;----------------------------------------------------------------------------;
						IF POST_THEME EQ 3
				
				; Theme #3 - "Boring"
				POST_CLR_TXT	EQU	GRAY			; primary color for text
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 10 - 1


				POST_CLR_VAL1	EQU	GRAY			; value text color
				POST_CLR_VAL2	EQU	GRAY			; value text alternate color
				POST_CLR_COLD	EQU	BLUE			; COLD color
				POST_CLR_WARM	EQU	RED			; WARM color
				POST_CLR_GB		EQU	GRAY			; BIOS name in bootup screen
						ELSE
						IF POST_THEME EQ 2
				
				; Theme #2 - "Kinda l33t?"
				POST_CLR_TXT	EQU	DARKGRAY
				POST_CLR_VAL1	EQU	BLUE
				POST_CLR_VAL2	EQU	GREEN
				POST_CLR_COLD	EQU	BLUE
				POST_CLR_WARM	EQU	RED
				POST_CLR_GB		EQU	WHITE
						ELSE
				
				; Theme #1 - "Old skool BBS" (default)
 = CYAN				POST_CLR_TXT	EQU	CYAN
 = GREEN			POST_CLR_VAL1	EQU	GREEN
 = YELLOW			POST_CLR_VAL2	EQU	YELLOW
 = BLUE				POST_CLR_COLD	EQU	BLUE
 = DARKRED			POST_CLR_WARM	EQU	DARKRED
 = GRAY				POST_CLR_GB		EQU	GRAY
						ENDIF
						ENDIF
				
				;----------------------------------------------------------------------------;
				; POST screen column layout options
				;
 = ' [ '			POST_L		EQU	<' [ '>		; left separator string
 = ' ]'				POST_R		EQU	<' ]'>		; right separator string
 = 0002				L_POST_L		EQU	2			; length of separator
				
 = 0020				POST_TAB_COL	EQU	32			; horiz tab width for second column
 = 0007				POST_COL_LBL_W	EQU	7			; column label width
 = 0004				POST_COL_PAD	EQU	4			; padding (non colored) space between cols
				
 = 0006				POST_COL_W		EQU	POST_COL_LBL_W-1	; zero-based column index
				
				; column label width plus separator
 = 0009				POST_COL_VT		EQU	POST_COL_LBL_W + L_POST_L
				
				; space between next column
 = 0013				POST_TAB_COL_I	EQU	POST_TAB_COL - POST_COL_LBL_W - L_POST_L - POST_COL_PAD
				
				; prefer period-correct "KB" or IEC "KiB"
								IF UNITS_IEC EQ 1
				POST_K_UNIT		EQU	<'KiB'>		; KiB size unit abbrev.
				POST_M_UNIT		EQU	<'MiB'>		; MiB size
								ELSE
 = 'KB'				POST_K_UNIT		EQU	<'KB'>		; KB size unit abbrev.
 = 'MB'				POST_M_UNIT		EQU	<'MB'>		; MB size
								ENDIF
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 11 - 1


				;----------------------------------------------------------------------------;
				; Useful CP-437/Control Chars
				;
 = 000D				CR 			EQU	0DH 			; Carriage return
 = 000A				LF 			EQU	0AH 			; Line feed
 = 0008				BS			EQU	08H			; Backspace ASCII
 = 0007				BELL			EQU	07H			; BELL ASCII
 = 0016				SYN			EQU	16H			; SYN C0 control char
 = 00B3				VL			EQU	0B3H			; vertical line
 = 00C4				HL			EQU	0C4H			; horizontal line
 = 00F4				CURL_TOP		EQU	0F4H
 = 00F5				CURL_BOT		EQU	0F5H
 = 00F9				BULL			EQU	0F9H			; Bullet operator (medium centered dot)
 = 00FA				DOT			EQU	0FAH			; Small middle dot
 = 00FE				SQUARE		EQU	0FEH			; Black square (rectangle)
 = 0003				HEART			EQU	03H			; faithful companion
 = 000D				NOTE1			EQU	0DH
 = 000E				NOTE2			EQU	0EH
 = 001D				DBLARROW		EQU	01DH
				
				;----------------------------------------------------------------------------;
				; Beepin' Tones
				;----------------------------------------------------------------------------;
 = 0975				BEEP_B5		EQU	2421 			; B4 (493.88 Hz)
 = 08F1				BEEP_C5		EQU	2289			; C5 (523.25 Hz)
 = 06A5				BEEP_F5		EQU	1701			; F5 (698.46 Hz)
 = 05FA				BEEP_G5		EQU	1530			; G5 (783.99 Hz)
 = 054C				BEEP_A6		EQU	1356			; A5 (880.00 Hz)
 = 0474				BEEP_C6		EQU	1140			; C6 (1046.50 Hz)
 = 04B1				BEEP_1K		EQU	1201			; ~1 KHz tone
 = 04A0				BEEP_1K7		EQU	1184			; ~1007 Hz (cassette 1 bit)
 = 0250				BEEP_2K		EQU	BEEP_1K7 / 2	; ~2015 Hz (cassette 0 bit)
				
 = BEEP_A6			BEEP_DEFAULT	EQU	BEEP_A6		; default beep
 = BEEP_F5			BEEP_ERR_HIGH	EQU	BEEP_F5		; perfect fourth apart for
 = BEEP_C5			BEEP_ERR_LOW	EQU	BEEP_C5		;  alternating error beeps
				
				;----------------------------------------------------------------------------;
				; PC ISA (Instruction Set Architecture) I/O Port Addresses
				;----------------------------------------------------------------------------;
				
				; 8237A DMA Controller
 = 0000				DMA_0_A		EQU	00H 			; W   Start Address Register channel 0
 = 0001				DMA_0_C		EQU	01H			; W   Count Register channel 0
 = 0002				DMA_1_A		EQU	02H			; W   Start Address Register channel 1
 = 0003				DMA_1_C		EQU	03H			; W   Count Register channel 1
 = 0004				DMA_2_A		EQU	04H			; W   Start Address Register channel 2
 = 0005				DMA_2_C		EQU	05H			; W   Count Register channel 2
 = 0006				DMA_3_A		EQU	06H			; W   Start Address Register channel 3
 = 0007				DMA_3_C		EQU	07H			; W   Count Register channel 3
 = 0008				DMA_CMD		EQU	08H			; RW  Status / Command Register
 = 0009				DMA_REQ		EQU	09H			; W   Request Register
 = 000A				DMA_MASK		EQU	0AH 			; W   Single Channel Mask Register
 = 000B				DMA_MODE		EQU	0BH 			; W   Mode Register
 = 000C				DMA_FF		EQU	0CH 			; W   Flip-Flop Reset Register
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 12 - 1


 = 000D				DMA_RESET		EQU	0DH 			; W   Master Reset Register (Mask bits ON)
 = 000E				DMA_MASKR		EQU	0EH 			; W   Mask Reset Register (Mask bits OFF)
 = 000F				DMA_MMASK		EQU	0FH 			; RW  MultiChannel Mask Register
				
				; DMA Page Registers (74LS670)
 = 0087				DMA_P_C0		EQU	87H			; DMA Channel (unused on PC)
 = 0083				DMA_P_C1		EQU	83H			; DMA Channel 0 and 1
 = 0081				DMA_P_C2		EQU	81H			; DMA Channel 2
 = 0082				DMA_P_C3		EQU	82H			; DMA Channel 3
				
				; 8259 PIC Interrupt Controller
 = 0020				INT_P0		EQU	20H 			; Port 0
 = 0021				INT_IMR		EQU	21H 			; Port 1 - OCW1 Interrupt Mask Register
				
				; 8253 PIT Timer
 = 0040				PIT_CH0		EQU	40H			; Timer Channel/Counter 0
 = 0041				PIT_CH1		EQU	41H			; Timer Channel/Counter 1
 = 0042				PIT_CH2		EQU	42H			; Timer Channel/Counter 2 - Speaker
 = 0043				PIT_CTRL		EQU	43H			; Timer Control Word
				
				; 8255 PPI Peripheral Interface
 = 0060				PPI_A			EQU	60H			; PPI (8255) Port A IN  - Keyboard input
 = 0061				PPI_B			EQU	61H			; PPI (8255) Port B OUT - Speaker, Switch se
				lection, Misc
 = 0062				PPI_C			EQU	62H			; PPI (8255) Port C IN  - Switches
 = 0063				PPI_CW		EQU	63H			; PPI (8255) Port Control Word
				
				; 8042 (AT) Keyboard Controller
 = 0060				ATKB_IO		EQU	60H			; 8042 Keyboard input/output buffer register
 = 0064				ATKB_CMD		EQU	64H			; 8042 Keyboard command/status register
				
				; POST TEST card I/O
 = 0080				POST_CARD_PORT	EQU	80H			; can be 60H, 80H, 300H, 313H
				
				; TD3300A (ST-xx/UNIQUE/Auva) Control Registers (90h)
 = 0070				TD_WS			EQU	70H			; RAM, I/O wait state control
 = 0090				TD_TURBO		EQU	90H			; Write 2 for Turbo, 3 for Normal
 = 00E0				TD_UMA		EQU	0E0H			; Upper Memory bank switch
				
				; UM82C088 Speed / Status registers
 = 00C0				UM82_SPEED		EQU	0C0H			; write any value to toggle speed mode
 = 00E0				UM82_STATUS		EQU	0E0H			; read memory size, speed mode
				
				; NMI flip/flop
 = 00A0				NMI_R0		EQU	0A0H			; NMI Mask Register
				
				; Joystick / Game Port
 = 0201				GAME_CTRL		EQU	0201H			; Game Port
				
				; Hard Disk Controller
 = 0320				HDC_READ		EQU	0320H			; Read from/Write to controller
 = 0321				HDC_CTRL		EQU	0321H			; Read: Controller Status, Write: controller
				 reset
 = 0322				HDC_PULSE		EQU	0322H			; Write: generate controller select pulse
 = 0323				HDC_DMA		EQU	0323H			; Write: Pattern to DMA and interrupt mask register
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 13 - 1


 = 0324				HDC_STAT		EQU	0324H			; disk attention/status
				
				; Video 6845 CRT Controller
 = 03B8				MDA_CTRL		EQU	03B8H			; MDA CRT Control Port 1
 = 03BA				MDA_STAT		EQU	03BAH			; MDA Status Register
 = 03D8				CGA_CTRL		EQU	03D8H			; CGA Mode Select Register
 = 03DA				CGA_STAT		EQU	03DAH			; CGA Status Register
				
				; Serial (COM) ports
 = 03F8				COM1_DATA		EQU	03F8H 		; 03F8H: TX/RX Buffer, Divisor LSB (RW)
 = 03F9				COM1_IER		EQU	COM1_DATA+1		; 03F9H: Interrupt Enable Register, Divisor 
				MSB (RW)
 = 03FA				COM1_IIR		EQU	COM1_DATA+2		; 03FAH: Interrupt Identification Register (
				R)
 = 03FB				COM1_LCR		EQU	COM1_DATA+3		; 03FBH: Line Control Register (RW)
 = 03FC				COM1_MCR		EQU	COM1_DATA+4		; 03FCH: Modem Control Register (RW)
 = 03FD				COM1_LSR		EQU	COM1_DATA+5		; 03FDH: Line Status Register (R)
 = 03FE				COM1_MSR		EQU	COM1_DATA+6		; 03FEH: Modem Status Register (R)
 = 03FF				COM1_SPR		EQU	COM1_DATA+7		; 03FFH: Scratch Pad Register (RW)
 = 02F8				COM2_DATA		EQU	COM1_DATA-100H	; 02F8H: TX/RX Buffer, Divisor LSB (RW)
 = 03E8				COM3_DATA		EQU	COM2_DATA+0F0H	; 03E8H: TX/RX Buffer, Divisor LSB (RW)
 = 02E8				COM4_DATA		EQU	COM3_DATA-100H	; 02E8H: TX/RX Buffer, Divisor LSB (RW)
				
				; Default LPT/COM I/O timeouts (# of 64K LOOPs)
 = 0014				LPT_TO		EQU	20			; LPT default timeout
 = 0001				COM_TO		EQU	1			; COM default timeout
				
				; V40 Control Registers
 = FFF6				V40_WCR2		EQU	0FFF6H		; WCU Wait Cycle 2 Register
 = FFF5				V40_WCR1		EQU	0FFF5H		; WCU Wait Cycle 1 Register
				
				;----------------------------------------------------------------------------;
				; FDC (NEC PD765x) Controller 
				;
				
				; Floppy Disk Controller Ports
 = 03F0				FDC_A_STAT		EQU	03F0H			; Diskette controller status A
 = 03F1				FDC_B_STAT		EQU	03F1H			; Diskette controller status B
 = 03F2				FDC_CTRL		EQU	03F2H			; FD controller control port
 = 03F4				FDC_STAT		EQU	03F4H			; FD controller status register
 = 03F5				FDC_DATA		EQU	03F5H			; data register (write 1-9 byte command, see
				 INT 13)
				
				; FDC Commands
 = 0002				FDC_CMD_RTRK	EQU	00000010B		; 02H: Read Track (Diagnostic)
 = 0003				FDC_CMD_SPEC 	EQU	00000011B		; 03H: Specify Step & Head Load
 = 0004				FDC_CMD_STAT 	EQU	00000100B		; 04H: Sense Drive Status
 = 0005				FDC_CMD_WR		EQU	00000101B		; 05H: Write Sector
 = 0006				FDC_CMD_RD		EQU	00000110B		; 06H: Read Sector
 = 0007				FDC_CMD_RECAL	EQU	00000111B		; 07H: Recalibrate
 = 0008				FDC_CMD_SENSE	EQU	00001000B		; 08H: Sense Interrupt Status
 = 0009				FDC_CMD_WDEL	EQU	00001001B		; 09H: Write Deleted Sector
 = 000A				FDC_CMD_RSID	EQU	00001010B		; 0AH: Read Sector ID
 = 000C				FDC_CMD_RDEL	EQU	00001100B		; 0CH: Read Deleted Sector
 = 000D				FDC_CMD_FMT		EQU	00001101B		; 0DH: Format Track
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 14 - 1


 = 000F				FDC_CMD_SEEK	EQU	00001111B		; 0FH: Seek
				
				; BDA INT 13H Status Flags 
				; https://stanislavs.org/helppc/int_13-1.html
 = 0000				FDC_ST_OK		EQU	00H			; No error
 = 0001				FDC_ST_BADCMD	EQU	01H			; Bad command passed to driver
 = 0002				FDC_ST_ERR_MARK	EQU	02H			; Address mark not found or bad sector
 = 0003				FDC_ST_ERR_WP	EQU	03H			; Write Protect Error
 = 0004				FDC_ST_ERR_SEC	EQU	04H			; Sector not found
 = 0008				FDC_ST_DMA_OVR	EQU	08H			; DMA overrun
 = 0009				FDC_ST_DMA_64K	EQU 	09H			; DMA access across 64k boundary
 = 0010				FDC_ST_ERR_CRC	EQU	10H			; ECC/CRC error on disk read
 = 0020				FDC_ST_ERR_FDC	EQU	20H			; Controller error
 = 0040				FDC_ST_ERR_SEEK	EQU	40H			; Seek failure
 = 0080				FDC_ST_TIMEOUT	EQU	80H 			; Time out, drive not ready
 = 00FF				FDC_ST_SENSE	EQU	0FFH 			; Sense operation failed
				
				; Trivial RAM / data patterns
 = 95A5				RAM_TEST_1		EQU 	1001010110100101B	; Simple RAM test 095A5H
 = 739D				RAM_TEST_2		EQU 	0111001110011101B	; Alternate RAM test 0739DH
 = 95A5				RAM_TEST		=	RAM_TEST_1		; pick one!
 = AA55				MAGIC_WORD		EQU	0AA55H		; Magic Word used for option ROM, IPL device
				
				; Warm Boot Flag options set in BDA 40:72H
 = 0000				COLD_BOOT		EQU	0			; Cold Boot - All POST tests
 = 1234				WARM_BOOT		EQU	1234H			; Warm Boot - Skip some POST tests
 = 4321				WARM_BOOT_MEM	EQU	4321H			; Warm Boot - Preserve memory
 = 5678				WARM_BOOT_SUS	EQU	5678H			; Warm Boot - System suspend
 = 9ABC				WARM_BOOT_TEST	EQU	9ABCH			; Warm Boot - Manufacturer test
				
				; Video Related
 = 0050				VID_DEF_COLS	EQU	80			; standard video mode columns
 = 0018				VID_DEF_ROWS	EQU	24			; standard video mode rows
 = DNB <BLACK, GRAY>		VID_ATTR		EQU	DNB <BLACK, GRAY>	; fill byte for blank video attribute
 = 0020				VID_SP		EQU	' '			; fill byte for blank video RAM char
				
				
				;============================================================================;
				;
				; 			   * * *   S T R U C T S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; BDA Timer Counters (6CH-70H)
				;----------------------------------------------------------------------------;
 0005				TIMER_C STRUC
 0000  0000			LW		DW	?	; 6CH  Timer Counter Low Word (ticks)
 0002  0000			HW	  	DW	? 	; 6EH  Timer Counter High Word (hours)
 0004  00			OF 		DB	? 	; 70H  Timer Overflow flag
				TIMER_C ENDS
				
				;----------------------------------------------------------------------------;
				; INT 1E Disk Initialization Parameter Table Vector
				;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 15 - 1


				; https://stanislavs.org/helppc/dbt.html
				;----------------------------------------------------------------------------;
 000B				DBT	STRUC
 0000  00			SRT		DB	? 	; 00 step-rate time SRT (0CH), head unload time HUT (0FH)
 0001  00			HLT_ND	DB	? 	; 01 head load time HLT (01H), DMA mode ND (0)
 0002  00			FMCT		DB	? 	; 02 timer ticks to wait before disk motor shutoff
 0003  00			FBPS		DB	? 	; 03 bytes per sector (0=128, 1=256, 2=512, 3=1024)
 0004  00			SPT		DB	? 	; 04 sectors per track (last sector number)
 0005  00			SGAP		DB	? 	; 05 inter-block gap length/gap between sectors
 0006  00			LSEC		DB	? 	; 06 data length, if sector length not specified
 0007  00			FGAP		DB	? 	; 07 gap length between sectors for format
 0008  00			FFILL		DB	? 	; 08 fill byte for formatted sectors
 0009  00			HDST		DB	? 	; 09 head settle time in milliseconds
 000A  00			FMST		DB	? 	; 0A motor startup time in eighths of a second
				DBT	ENDS
				
				;----------------------------------------------------------------------------;
				; FDC Command Status Bytes (FDC_LAST_ST)
				;----------------------------------------------------------------------------;
 0007				FDC_CSB STRUC
 0000  00			SB0		DB	?	; 00 - status register 0
 0001  00			SB1		DB	?	; 01 - status register 1
 0002  00			SB2		DB	?	; 02 - status register 2
 0003  00			CYL		DB	?	; 03 - cylinder number
 0004  00			HEAD		DB	?	; 04 - head number
 0005  00			SEC		DB	?	; 05 - sector number
 0006  00			BPS		DB	?	; 06 - bytes per sector
				FDC_CSB ENDS
				
				;----------------------------------------------------------------------------;
				; INT 1D Video Initialization Parameter Table Vector (CRTC)
				;
				; https://stanislavs.org/helppc/6845.html
				;----------------------------------------------------------------------------;
 0010				CRTC	STRUC
 0000  00			H_TC		DB	?	; 00 - Horiz. total characters
 0001  00			H_CL		DB	?	; 01 - Horiz. displayed characters per line
 0002  00			H_SP		DB	?	; 02 - Horiz. synch position
 0003  00			H_SW		DB	?	; 03 - Horiz. synch width in characters
 0004  00			V_TL		DB	?	; 04 - Vert. total lines
 0005  00			V_SL		DB	?	; 05 - Vert. total adjust (scan lines)
 0006  00			V_DR		DB	?	; 06 - Vert. displayed rows
 0007  00			V_SP		DB	?	; 07 - Vert. synch position (character rows)
 0008  00			IL		DB	?	; 08 - Interlace mode
 0009  00			MSL		DB	?	; 09 - Maximum scan line address
 000A  00			CSL		DB	?	; 0A - Cursor start (scan line)
 000B  00			CEL		DB	?	; 0B - Cursor end (scan line)
 000C  00			SA_H		DB	0	; 0C - Start address (MSB)
 000D  00			SA_L		DB	0	; 0D - Start address (LSB)
 000E  00			CA_H		DB	0	; 0E - Cursor address (MSB) (read/write)
 000F  00			CA_L		DB	0	; 0F - Cursor address (LSB) (read/write)
				CRTC	ENDS
				
				;============================================================================;
				;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 16 - 1


				; 			   * * *   R E C O R D S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; Define Nibbles to Byte
				; Convert two nibbles to byte (big endian)
				;----------------------------------------------------------------------------;
				DNB	RECORD	HBN:4, LBN:4
				
				;----------------------------------------------------------------------------;
				; Define Bytes to Word
				; Convert two bytes to word (big endian)
				;----------------------------------------------------------------------------;
				DBW	RECORD	HWB:8, LWB:8
				
				;----------------------------------------------------------------------------;
				; x86 EFLAGS
				;----------------------------------------------------------------------------;
				EFLAGS86	RECORD FSF:1,FZF:1,FR1:1,FAF:1,FR2:1,FPF:1,FR3:1=1,FCF:1
				
				;----------------------------------------------------------------------------;
				; BDA Equipment Flags (40:10H)
				;----------------------------------------------------------------------------;
				; 00      |			- LPT : # of LPT ports
				;   x     |			- X1  :  unused, PS/2 internal modem
				;    0    |			- GAM : Game port present
				;     000 |			- COM : # of COM ports present
				;        0| 		- DMA : DMA (should always be 0)
				;         |00	 	- FLP : Floppy drives present (+1) (0=1 drive,1=2,etc)
				;         |  00		- VIDM: Video mode (00=EGA/VGA, 01=CGA 40x25, 
				; 				-	10=CGA 80x25, 11=MDA 80x25)
				;         |    11 	- MBRAM: MB RAM (00=64K, 01=128K, 10=192K, 11=256K+)
				;         |      0	- FPU : FPU installed
				;         |       1	- IPL : Floppy drive(s) installed (always 1 on 5160)
				;----------------------------------------------------------------------------;
								IF FDC_ENABLE EQ 1
				EQFLAGS RECORD	LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VIDM:2,MBRAM:2=11b,FPU:1,IPL:1=1
								ELSE
				EQFLAGS RECORD	LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VIDM:2,MBRAM:2=11b,FPU:1,IPL:1=0
								ENDIF
				
				;----------------------------------------------------------------------------;
				; GLaBIOS Equipment Flags (40:12H)
				;----------------------------------------------------------------------------;
				; 76543210
				; xxxx    |			- TBD		Reserved
				;     x   |			- TURBO	Turbo supported
				;      x  |			- V20		1 if V20, 0 if 8088
				;       xx|			- TBD		Reserved
				; 84218421
				;----------------------------------------------------------------------------;
				GFLAGS RECORD	GTBD1:4,TURBO:1,V20:1,GTBD2:2
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 17 - 1


				; POST status flags are stored in BP
				;----------------------------------------------------------------------------;
				; BP:
				; 76543210
				; x 	    |			- WARM  	Warm Boot flag
				;  x 	    |			- PKI   	POST Keyboard Interrupt Received
				;   x     |			- PKEY  	Keyboard key stuck
				;    x    |			- PFDC  	FDC init failure
				;     x   |			- PFSK  	FDC seek test failure
				;      x  |			- PDMA  	DMA error
				;       x |			- PMEM  	Memory Error
				;        x|			- PFXX  	Reserved (do not use)
				;         |xxxxxx		- TBD
				;         |      xx	- GRND	Random number for tagline
				; 84218421
				;----------------------------------------------------------------------------;
				PFLAGS RECORD WARM:1,PKI:1,PKEY:1,PFDC:1,PFSK:1,PDMA:1,PMEM:1,PFXX:1,PTBD:6,GRND:2
				
				;----------------------------------------------------------------------------;
				; BDA Keyboard Flags
				;----------------------------------------------------------------------------;
				; 40:17	Keyboard Flags Byte 1 (Low)
				;----------------------------------------------------------------------------;
				;          84218421
				; 	    |7 	    	- K1IN	insert is active
				; 	    | 6 	    	- K1CL	caps-lock is active
				; 	    |  5	    	- K1NL	num-lock is active
				; 	    |   4    	- K1SL	scroll-lock is active
				; 	    |    3   	- K1AL	ALT key depressed
				; 	    |     2  	- K1CT	CTRL key depressed
				; 	    |      1 	- K1LS	left shift key depressed
				; 	    |       0	- K1RS	right shift key depressed
				;----------------------------------------------------------------------------;
				KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1
				
				;----------------------------------------------------------------------------;
				; 40:18	Keyboard Flags Byte 2 (High)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- K2IN	insert key is depressed
				;  6 	    |			- K2CL	caps-lock key is depressed
				;   5	    |			- K2NL	num-lock key is depressed
				;    4    |			- K2SL	scroll lock key is depressed
				;     3   |			- K2PA	pause (Ctrl-NumLock) is active
				;      2  |			- K2SY	system key depressed and held
				;       1 |			- K2LA	left ALT key depressed
				;        0|			- K2LC	left CTRL key depressed
				;----------------------------------------------------------------------------;
				KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1
				
				;----------------------------------------------------------------------------;
				; BDA Keyboard Flags - Enhanced
				;----------------------------------------------------------------------------;
				; 40:96	Keyboard mode/type
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 18 - 1


				;          84218421
				; 	    |7 	    	- KERD	read ID in process
				; 	    | 6 	    	- KEFI	last char was first ID char
				; 	    |  5	    	- KENL	force num-lock if Rd ID & KBX
				; 	    |   4    	- KEEN	101/102 enhanced keyboard installed
				; 	    |    3   	- KERA	right ALT key depressed
				; 	    |     2  	- KERC	right CTRL key depressed
				; 	    |      1 	- KEE0	last code was the E0 hidden code
				; 	    |       0	- KEE1	last code was the E1 hidden code
				;----------------------------------------------------------------------------;
				KBFLAGS3 RECORD	KERD:1,KEFI:1,KENL:1,KEEN:1,KERA:1,KERC:1,KEE0:1,KEE1:1
				
				;----------------------------------------------------------------------------;
				; 40:97	Keyboard LED flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- KLTE	keyboard transmit error flag
				;  6 	    |			- KLMU	mode indicator update
				;   5	    |			- KLRF	re-send received flag
				;    4    |			- KLAK	ACK received
				;     3   |			- KLCI	circus system indicator
				;      2  |			- KLCL	caps-lock indicator
				;       1 |			- KLNL	num-lock indicator
				;        0|			- KLSL	scroll lock indicator
				;----------------------------------------------------------------------------;
				KBFLAGS4 RECORD	KLTE:1,KLMU:1,KLRF:1,KLAK:1,KLCI:1,KLCL:1,KLNL:1,KLSL:1
				
				;----------------------------------------------------------------------------;
				; FDC BDA Status Flags
				;----------------------------------------------------------------------------;
				; 40:3E	FD_CAL_ST	Drive recalibration status flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FWIF	1=working interrupt flag
				;  654    |			- FSTBD	unused
				;     3   |			- FCAL3	1=recalibrate drive 3
				;      2  |			- FCAL2	1=recalibrate drive 2
				;       1 |			- FCAL1	1=recalibrate drive 1
				;        0|			- FCAL0	1=recalibrate drive 0
				;----------------------------------------------------------------------------;
				FDC_SF RECORD	FWIF:1,FSTBD:3,FCAL3:1,FCAL2:1,FCAL1:1,FCAL0:1
				
				;----------------------------------------------------------------------------;
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FWRT	1=write operation
				;  654    |			- FMTBD	unused
				;     3210|			- FMOT	1=drive 3 motor on
				;----------------------------------------------------------------------------;
				FDC_MF RECORD	FWRT:1,FMTBD:3,FMOT:4
				
				;----------------------------------------------------------------------------;
				; 40:8F	FD_MODE	Floppy drive mode
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 19 - 1


				; 84218421
				; 7 	    |			- FM1X	unused
				;  6      |			- FM1D	1=drive 1 determined
				;   5     |			- FM1M	1=drive 1 supports multiple data rates
				;    4    |			- FM18	1=drive 1 supports 80-track
				;     3   |			- FM0X	unused
				;      2  |			- FM0D	1=drive 0 determined
				;       1 |			- FM0M	1=drive 0 supports multiple data rates
				;        0|			- FM08	1=drive 0 supports 80-track
				;----------------------------------------------------------------------------;
				FDC_MODE RECORD	FM1X:1,FM1D:1,FM1M:1,FM18:1,FM0X:1,FM0D:1,FM0M:1,FM08:1
				
				;----------------------------------------------------------------------------;
				; 40:90H-93H	Floppy drive media state (drives 0-3)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76      |			- FSR		data xfr rate in Kb/s (0=500,1=300,2=250)
				;   5     |			- FDDS	1=dub step required
				;    4    |			- FSE		1=media established
				;     3   |			- FSX		unused
				;      210|			- FSD		(see below)
				;----------------------------------------------------------------------------;
				; FSD values:
				;	0 = 360K disk/360K drive not established
				;	1 = 360K disk/1.2M drive not established
				;	2 = 1.2M disk/1.2M drive not established
				;	3 = 360K disk/360K drive established
				;	4 = 360K disk/1.2M drive established
				;	5 = 1.2M disk/1.2M drive established
				;	6 = reserved
				;	7 = none of the above
				;----------------------------------------------------------------------------;
				FDC_STATE RECORD	FSR:2,FDDS:1,FSE:1,FDX:1,FSD:3
				
				;----------------------------------------------------------------------------;
				; FDC Digital Output Register at 3F2h (write only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FDMD	1 = turn floppy drive D motor on
				;  6      |			- FDMC	1 = turn floppy drive C motor on
				;   5     |			- FDMB	1 = turn floppy drive B motor on
				;    4    |			- FDMA	1 = turn floppy drive A motor on
				;     3   |			- FDDMA	1 = DMA & I/O interface enabled
				;      2  |			- FDCEN	1 = FDC enable, 0 = hold FDC at reset
				;       10|			- FDDRV	floppy drive select (0=A, 1=B, 2=C, 3=D)
				;----------------------------------------------------------------------------;
				FDC_DOR RECORD	FDMD:1,FDMC:1,FDMB:1,FDMA:1,FDDMA:1,FDCEN:1,FDSEL:2
				
				;----------------------------------------------------------------------------;
				; FDC 765 Status Flags
				;----------------------------------------------------------------------------;
				; FDC Main Status Register at 3F4h (read only)
				; 84218421
				; 7 	    |			- FDRR	data reg ready for I/O to/from CPU
				;  6      |			- FIOD	I/O direction; 1=FDC to CPU; 0=CPU to FDC
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 20 - 1


				;   5     |			- FDND	FDC is in non-DMA mode
				;    4    |			- FDRW	FDC read or write command in progress
				;     3   |			- F3SK	floppy drive 3 in seek mode/busy
				;      2  |			- F2SK	floppy drive 2 in seek mode/busy
				;       1 |			- F1SK	floppy drive 1 in seek mode/busy
				;        0|			- F0SK	floppy drive 0 in seek mode/busy
				;----------------------------------------------------------------------------;
				FDC_MSR RECORD	FDRR:1,FIOD:1,FDND:1,FDRW:1,F3SK:1,F2SK:1,F1SK:1,F0SK:1
				
				;----------------------------------------------------------------------------;
				; FDC Command Status Register 0 at 3F5h
				;----------------------------------------------------------------------------;
				; 84218421
				; 76	    |			- ST0CS	last command status (see below)
				;   5     |			- ST0SK	set to 1 when FDD completes a seek command
				;    4    |			- ST0CHK	equipment check (see note)
				;     3   |			- ST0NR	not ready on read/write or SS access to head 1
				;      2  |			- ST0HD	head number at interrupt (head 0 or 1)
				;       10|			- ST0DRV	unit selected at interrupt (0=A, 1=B, 2=...)
				;----------------------------------------------------------------------------;
				; Bits
				;	 76  Last Command Status
				;	 00  command terminated successfully
				;	 01  command execution started but terminated abnormally
				;	 10  invalid command issued
				;	 11  command terminated abnormally due to a change in state of
				;	     the Ready Signal from the FDC  (reserved on PS/2)
				;
				;	- equipment check can occur if FDD signals a fault or track zero is
				;	  not found after 77 steps on a recalibrate command
				;----------------------------------------------------------------------------;
				FDC_ST0 RECORD	ST0CS:2,ST0SK:1,ST0CHK:1,ST0NR:1,ST0HD:1,ST0DRV:2
				
				;----------------------------------------------------------------------------;
				; FDC Command Byte 0
				;----------------------------------------------------------------------------;
				; 84218421
				; 7       |			- FC0MT	MT = Multi-Track
				;  6      |			- FC0MF	MF = MFM mode
				;   5     |			- FC0SK	SK = SKip Deleted-data address mark
				;    43210|			- FC0CMD	FDC command number
				;----------------------------------------------------------------------------;
				FDC_CB RECORD	FC0MT:1,FC0MF:1=1,FC0SK:1,FC0CMD:5
				
				;----------------------------------------------------------------------------;
				; Port 3BD Printer Status Flags returned from INT 17
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- LPBZ	not busy (note: 0 means busy)
				;  6      |			- LPACK	acknowledge (printer is attached)
				;   5     |			- LPOP	20H out of paper
				;    4    |			- LPSEL	10H selected (0 means off-line)
				;     3   |			- LPIO	08H I/O error
				;      21 |			- LPX		06H unused
				;        0|			- LPTO	01H time-out error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 21 - 1


				;----------------------------------------------------------------------------;
				PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1
				
				;----------------------------------------------------------------------------;
				; Port 3BE printer control register   (Parallel Printer Port)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |			- LCX		unused
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK
				;     3   |			- LCDR	1 = printer reads output,  (pin 17)
				;      2  |			- LCINI	0 = initialize printer,  (pin 16)
				;       1 |			- LCLF	1 = auto line feed,  (pin 14)
				;        0|			- LCOUT	1 = output data to printer,  (pin 1)
				;----------------------------------------------------------------------------;
				PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1
				
				;----------------------------------------------------------------------------;
				; Port 3FB - Line Control Register - LCR (read/write)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- DLAB	1 = baud rate divisor (DLAB)
				;  6      |			- LCBK	0 = turn break off, 1 = force spacing break state
				;   5     |			- LCPD	0 = parity disabled, 1 = enabled
				;    4    |			- LCEPS	0 = odd parity, 1 = even (EPS)
				;     3   |			- LCPEN	0 = no parity, 1 = parity (PEN)
				;      2  |			- LCSB	0 = 1 stop bit, 1 = 1.5 or 2
				;       10|			- LCWLS	word length select bits
				;----------------------------------------------------------------------------;
				COM_LCR RECORD	DLAB:1,LCBK:1,LCPD:1,LCEPS:1,LCPEN:1,LCSB:1,LCWLS:2
				
				;----------------------------------------------------------------------------;
				; Port 3FC - Modem Control Register - MCR (read/write)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |			- MCRX	unused
				;    4    |			- MCLB	0 = normal, 1 = loop back test
				;     3   |			- MCO2	OUT2
				;      2  |			- MCO1	OUT1
				;       1 |			- RTS		1 = activate RTS
				;        0|			- DTR		1 = activate DTR
				;----------------------------------------------------------------------------;
				COM_MCR RECORD	MCRX:3,MCLB:1,MCO2:1,MCO1:1,RTS:1,DTR:1
				
				;----------------------------------------------------------------------------;
				; Port 3FE - Modem Status Register - MSR (read only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- MLSD	1 = receive line signal detect
				;  6      |			- MRI		1 = ring indicator (RI)
				;   5     |			- MDSR	1 = DSR
				;    4    |			- MCTS	1 = CTS
				;     3   |			- DDCD	1 = DDCD Delta Data Carrier Detect (DCD changed)
				;      2  |			- DRI		1 = RI ring indicator changed
				;       1 |			- DDSR	1 = DDSR Delta DSR (DSR changed)
				;        0|			- DCTS	1 = DCTS Delta CTS (CTS changed)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 22 - 1


				;----------------------------------------------------------------------------;
				COM_MSR RECORD	MLSD:1,MRI:1,MDSR:1,MCTS:1,DDCD:1,DRI:1,DDSR:1,DCTS:1
				
				;----------------------------------------------------------------------------;
				; Port 3FD/2FD - Line Status Register - LSR (read only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- LSX		unused
				;  6      |			- TSRE	1 = transmitter shift register empty (TSRE)
				;   5     |			- THRE	1 = transmitter holding register empty (THRE)
				;    4    |			- LBI		1 = break interrupt  (BI)
				;     3   |			- LFE		1 = framing error (FE)
				;      2  |			- LPE		1 = parity error (PE)
				;       1 |			- LOE		1 = overrun error (OE)
				;        0|			- LDR		1 = data ready
				;----------------------------------------------------------------------------;
				COM_LSR RECORD	LSX:1,TSRE:1,THRE:1,LBI:1,LFE:1,LPE:1,LOE:1,LDR:1
				
				;----------------------------------------------------------------------------;
				; HALT_BEEP Pattern - Short / Long
				;----------------------------------------------------------------------------;
				BEEP_SL RECORD	BEEP_S:4, BEEP_L: 4
				
				;----------------------------------------------------------------------------;
				; PIT Timer CW
				;----------------------------------------------------------------------------;
				; Control Word Counter 1 (port 43H) - System Timer:
				;  01 		- SC: Select Counter 1
				;    11		- RW: Read/Write 2xR/2xW
				;      010		- M:  Mode 2, Rate Gen
				;         0		- BCD: 0
				;----------------------------------------------------------------------------;
				PIT_CW RECORD	PCWSC:2, PCWRW:2, PCWM:3, PCWBCD:1
				
				;----------------------------------------------------------------------------;
				; DMA Mode Register
				;----------------------------------------------------------------------------;
				; 01 			; Mode 1 (Single)
				;   0 		; INC: address decrement
				;    1 		; Auto-initialization
				;     10 		; Operation: Read from memory
				;       00 		; Channel 0
				;----------------------------------------------------------------------------;
				DMA_MR RECORD	DMM:2=01B, DMINC:1, DMAI:1=1, DMOP:2, DMCH:2
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Command Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- DACK	1 = DACK sense active high, 0 = low
				;  6      |		- DREQ	1 = DREQ sense active high, 0 = low
				;   5     |		- DWS		1 = Extended write selection, 0 = Late write
				;    4    |		- DPRI	1 = Rotating priority, 0 = Fixed priority
				;     3   |		- DTIM	1 = Compressed timing, 0 = Normal timing
				;      2  |		- DDIS	1 = Controller disable, 0 = Controller enable
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 23 - 1


				;       1 |		- DHLD	1 = Channel 0 address hold enable, 0 = disable
				;        0|		- DM2M	1 = Memory-to-memory enable, 0 = disable
				;----------------------------------------------------------------------------;
				DMA_CR RECORD	DACK:1,DREQ:1,DWS:1,DPRI:1,DTIM:1,DDIS:1,DHLD:1,DM2M:1
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Status Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- CR3		1 = Channel 3 request
				;  6      |		- CR2		1 = Channel 2 request
				;   5     |		- CR1		1 = Channel 1 request
				;    4    |		- CR0		1 = Channel 0 request
				;     3   |		- TC3		1 = Channel 3 has reached TC
				;      2  |		- TC2		1 = Channel 2 has reached TC
				;       1 |		- TC1		1 = Channel 1 has reached TC
				;        0|		- TC0		1 = Channel 0 has reached TC
				;----------------------------------------------------------------------------;
				DMA_SR RECORD	CR3:1,CR2:1,CR1:1,CR0:1,TC3:1,TC2:1,TC1:1,TC0:1
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Single Channel Mask Register
				;----------------------------------------------------------------------------;
				; 84218421
				;      2  |		- SMCLR	1 = Set mask bit, 0 = Clear mask bit
				;       10|		- SMCH	Select channel mask bit (0-3)
				;----------------------------------------------------------------------------;
				DMA_SMR RECORD	SMCLR:6,SMCH:2
				
				;----------------------------------------------------------------------------;
				; PIC Control Registers
				;----------------------------------------------------------------------------;
				; ICW1:
				;  000 		- A7-A5: unused on 8086 mode
				;     1 		- D4:   1 = ICW1 (and Port 0)
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition)
				;       0 		- ADI:  0 = Call Address Interval of 8
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3)
				;         1		- IC4:  1 = ICW4 Needed
				;----------------------------------------------------------------------------;
				ICW1	RECORD	D4:4=1, LTIM:1, ADI:1, SNGL:1=1, IC4:1=1
				
				; ICW2:
				;  00001 		- T7-T3: Interrupt Vector Address:
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15
				;       000 	- D2-D0: unused on 8086 mode
				;----------------------------------------------------------------------------;
				ICW2	RECORD	ICW2IVA:5, ICW2X:3=0
				
				; ICW4:
				;  000 		- D7-D5: unused
				;     0		- SFNM: 0 = Not Special Fully Nested Mode
				;      10		- BUF:  2 = Buffered Mode/Slave
				;        0		- AEOI: 0 = normal EOI
				;         1		- uPM:  1 = 8086 system
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 24 - 1


				;----------------------------------------------------------------------------;
				ICW4	RECORD	SFNM:4=0, ICWBUF:2, AEOI:1, uPM:1
				
				;----------------------------------------------------------------------------;
				; IMR / OCW1 Interrupt Mask
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- IRQ7	1=interrupt masked (disabled), 0=not masked
				;  6      |		- IRQ6
				;   5     |		- IRQ5
				;    4    |		- IRQ4
				;     3   |		- IRQ3
				;      2  |		- IRQ2
				;       1 |		- IRQ1
				;        0|		- IRQ0
				;----------------------------------------------------------------------------;
				OCW1	RECORD	IRQ7:1,IRQ6:1,IRQ5:1,IRQ4:1,IRQ3:1,IRQ2:1,IRQ1:1,IRQ0:1
				
				;----------------------------------------------------------------------------;
				; OCW3
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |		- O2CMD	Rotate and End of Interrupt Mode Command
				;					001b = Non-Specific EOI Command (default)
				;    43   |		- O2X		unused (00)
				;      210|		- O2L		Interrupt level acted upon
				;----------------------------------------------------------------------------;
				OCW2	RECORD	O2CMD:3=001b, O2X:2, O2L:3
 = 0020				EOI	EQU		OCW2 <>		; Non-Specific EOI
				
				;----------------------------------------------------------------------------;
				; OCW3
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- O3D7	unused (0)
				;  65     |		- ESMM/SMM	Enable/special mask mode
				;    43   |		- O3D3	unused (01b)
				;      2  |		- O3P		1=Poll command, 0=No Poll command
				;       10|		- O3RR	Read Register command
				;----------------------------------------------------------------------------;
				OCW3	RECORD	O3D7:1, ESMM:2, O3D3:2=1, O3P:1, O3RR:2
				
				;----------------------------------------------------------------------------;
				; NMI Mask Register
				;----------------------------------------------------------------------------;
				; 84218421
				; x 	    |		- NMIE	1=enable NMI, 0=disable
				;  0000000|		- NMIX	unused (0)
				;----------------------------------------------------------------------------;
				NMI	RECORD	NMIE:1, NMIX:7
				
				;----------------------------------------------------------------------------;
				; V40 WCY1
				;----------------------------------------------------------------------------;
				; 84218421
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 25 - 1


				; 76 	    |		- IOW		I/O Wait States (0-3)
				;   54    |		- UMW		Upper Memory Block Wait States (0-3)
				;     32  |		- MMW		Middle Memory Block Wait States (0-3)
				;       10|		- LMW		Lower Memory Block Wait States (0-3)
				;----------------------------------------------------------------------------;
				V40_WCY1	RECORD	IOW:2, UMW:2, MMW:2, LMW:2
				
				;----------------------------------------------------------------------------;
				; 6845 Video - Port 3DA Status Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7654    |			- VSX		unused
				;     3   |			- VSVS	vertical retrace, RAM access OK (next 1.25ms)
				;      2  |			- VSPE	0 = light pen on, 1 = light pen off
				;       1 |			- VSPT	light pen trigger set
				;        0|			- VSHS	horiz or vert retrace, RAM access OK
				;----------------------------------------------------------------------------;
				VID_STAT	RECORD	VSX:4, VSVS:1, VSPE:1, VSPT:1, VSHS:1
				
				;----------------------------------------------------------------------------;
				; 6845 Video - 3D9 Color Select Register (Text)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765     |			- CTX		unused
				;    4    |			- CTBI	background intensity
				;     3   |			- CTIN	select intensity setting
				;      210|			- CTBC	screen/border RGB
				;----------------------------------------------------------------------------;
				VID_CSTXT	RECORD	CTX:3=001B, CTBI:1=1B, CTIN:1, CTBC:3
				
				;----------------------------------------------------------------------------;
				; 6845 Video - 3D9 Color Select Register (Graphics)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76      |			- CGPH	palette high bits (unused)
				;   5     |			- CGPL	1 = palette 1, 0=palette 0
				;    4    |			- CGX		unused
				;     3   |			- CGIN	intensity
				;      210|			- CGBG	RGB for background
				;----------------------------------------------------------------------------;
				VID_CSGFX	RECORD	CGPH:2,CGPL:1=1B,CGX:1=1B,CGIN:1=1B,CGBG:3=111B
				
				;----------------------------------------------------------------------------;
				; MDA Character Attributes
				;----------------------------------------------------------------------------;
				; 84218421
				; 7       |			- MDBK	1 = blink, 0 = no blink
				;  654    |			- MDBG	000b = normal, 111b = Reverse
				;     3   |			- MDIN	0 = normal, 1 = bold
				;      210|			- MDFG	111 = normal, 001 = underline, 000 = none
				;----------------------------------------------------------------------------;
				MDA_CH_ATTR	RECORD	MDBK:1,MDBG:3,MDIN:1,MDFG:3=111B
				
				;----------------------------------------------------------------------------;
				; 8255 PPI Channel Control Register Byte (Port 63h) Flags
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 26 - 1


				;----------------------------------------------------------------------------;
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT
				; 84218421
				; 1 	    |			- PPEN	1=Active
				;  00     |			- PPAM	Port A Mode: (0 default)
				;    1    |			- PPAD	Port A Dir: 0=output, 1=input (default)
				;     1   |			- PPCU	Port C (Upper): 0=output, 1=input (default)
				;      0  | 		- PPBM	Port B Mode: (0 default)
				;       0 | 		- PPBD	Port B Dir: 0=output (default), 1=input
				;        1|			- PPCL	Port C (Lower): 0=output, 1=input (default)
				;----------------------------------------------------------------------------;
				PPI_CR RECORD	PPEN:1=1,PPAM:2=00b,PPAD:1=1,PPCU:1=1,PPBM:1,PPBD:1,PPCL:1=1
				
				;----------------------------------------------------------------------------;
				; TD3300A Wait State Config Register (70H)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76 	    |			- TDWSI	Slot I/O  (# of wait states 0-3)
				;   54    |			- TDWSR	Slot RAM
				;     32  |			- TDWIO	Board I/O
				;       1 |			- TDWRA	Board RAM (# of wait states 0-1)
				;        0| 		- TDWRO	Board ROM
				;----------------------------------------------------------------------------;
				TD_WS_CR	RECORD	TDWSI:2,TDWSR:2,TDWIO:2,TDWRA:1,TDWRO:1
				
;----------------------------------------------------------------------------;
				; TD3300A Speed (Turbo/Normal) Register (90H)
				;----------------------------------------------------------------------------;
				; 765432  |			- TDSX	Unused
				;       1 |			- TDSH	0=use hardware switch, 1=use bit 0 (TDSS)
				;        0| 		- TDSS	if TDSH=1: 1=4.77, 0=turbo
				;----------------------------------------------------------------------------;
							IF ARCH_TYPE EQ ARCH_TD3300
							IF TURBO_SWITCH EQ 1
				TD_TURBO_CR	RECORD	TDSX:6,TDSH:1=0,TDSS:1	; hardware switch enabled
							ELSE
				TD_TURBO_CR	RECORD	TDSX:6,TDSH:1=1,TDSS:1	; hardware switch disabled
							ENDIF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; TD3300A Upper Memory bank switch Register (E0H)
				;----------------------------------------------------------------------------;
				; 7654321 |			- TDUX	Unused
				;        0| 		- TDUB	map 2000h-F000h: 0=lower bank,1=upper bank
				;----------------------------------------------------------------------------;
				TD_UMA_CR	RECORD	TDUX:7,TDUB:1
				
							IF ARCH_TYPE EQ ARCH_UM82
				;----------------------------------------------------------------------------;
				; UM82C088 Status Register (E0H)
				;----------------------------------------------------------------------------;
				; 7       |			- U8SPD	Speed: 0=Low, 1=High
				;  6      | 		- U8X1	Unused
				;   54    |			- U8MEM	11b=256K, 01b=512K, x0b=640K
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 27 - 1


				;     32  |			- U8VID	Video adapter
				;       10|			- U8FLP	Floppy drives
				;----------------------------------------------------------------------------;
				UM82_ST	RECORD	U8SPD:1,U8X1:1,U8MEM:2,U8VID:2,U8FLP:2
				UM82_256K	EQU		UM82_ST <0,0,11b>		; 256K RAM
				UM82_512K	EQU		UM82_ST <0,0,01b>		; 512K RAM
				UM82_640K	EQU		UM82_ST <0,0,10b>		; 640K RAM
							ENDIF
				
							IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; FE2010A Configuration Register (Port 63h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 100	    |			- FSPD	CPU Clock Frequency and Wait States
				;         |						00x = 4.77, 1 IOWS, 0 MBWS *
				;         |						010 = 7.15, 4 IOWS, 2 MBWS
				;         |						011 = 7.15, 4 IOWS, 0 MBWS *
				;         |						100 = 9.54, 6 IOWS, 4 MBWS * default
				;         |						110 = 9.54, 6 IOWS, 2 MBWS
				;         |						101 = 9.54, 6 IOWS, 0 MBWS
				;         |						111 = 9.54, 6 IOWS, 0 MBWS
				;    0    |			- FME1	RAM size high bit
				;     0   |			- FLCK	1=lock bits 0-4 until next restart
				;      0  |			- FME2	RAM size low bit
				;         |						00  = 640K
				;         |						01  = 256K
				;         |						10  = 512K
				;       0 |			- FFPU	0=No FPU/NMI, 1=enable FPU/NMI
				;        1|			- FPAR	0=Parity check enabled, 1=Parity disabled
				;----------------------------------------------------------------------------;
								IF RAM_PARITY EQ 1
				FE_CR RECORD	FSPD:3=FE_CPU_CFG,FME1:1,FLCK:1,FME2:1,FFPU:1,FPAR:1
								ELSE
				FE_CR RECORD	FSPD:3=FE_CPU_CFG,FME1:1,FLCK:1,FME2:1,FFPU:1,FPAR:1=1
								ENDIF
				
				;----------------------------------------------------------------------------;
				; FE2010A: 8255 PPI Channel B (Port 61h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock
				;   5     |			- PBIO	0=enable i/o check, 1=disable
				;    4    |			- PBPC	0=enable memory parity check, 1=disable
				;     3   |			- PBTB	0=turbo, 1=normal*
				;      2  |			- PBSW	0=read SW1-4, 1=read SW-5-8*
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				; * Note: bits 2 and 3 are reversed on FE2010A motherboards
				;----------------------------------------------------------------------------;
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBTB:1,PBSW:1,PBSP:1,PBST:1
				
							ELSE					; NOT ARCH_FE2010
								IF ARCH_TYPE EQ ARCH_5150
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 28 - 1


				;----------------------------------------------------------------------------;
				; 5150: 8255 PPI Channel B (Port 61h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock
				;   5     |			- PBIO	0=enable i/o check, 1=disable
				;    4    |			- PBPC	0=enable memory parity check, 1=disable
				;     3   |			- PBCM	0=cassette motor
				;      2  |			- PBSW	0=read SW1-4, 1=read SW-5-8
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				;----------------------------------------------------------------------------;
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBCM:1,PBSW:1,PBSP:1,PBST:1
				
								ELSE
				;----------------------------------------------------------------------------;
				; 5160/Standard: 8255 PPI Channel B (Port 61h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock
				;   5     |			- PBIO	0=enable i/o check, 1=disable
				;    4    |			- PBPC	0=enable memory parity check, 1=disable
				;     3   |			- PBSW	0=read SW1-4, 1=read SW-5-8
				;      2  |			- PBTB	0=turbo, 1=normal
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				;----------------------------------------------------------------------------;
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBSW:1,PBTB:1,PBSP:1,PBST:1
								ENDIF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; 5160: 8255 PPI Channel C (Port 62h) Flags
				; * When PPI B PBSW = 0
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PCPE	0=no parity error, 1=memory parity error
				;  6      |			- PCIE	0=no i/o channel error, 1=i/o channel error
				;   5     |			- PCT2	timer 2 output / cassette data output
				;    4    |			- PCCI	cassette data input
				;     32  |			- PCMB	SW 3,4: MB RAM (00=64K, 01=128K, 10=192K, 11=256K)
				;       1 |			- PCFP	SW 2: 0=no FPU, 1=FPU installed
				;        0|			- PCFD	SW 1: Floppy drive (IPL) installed
				;----------------------------------------------------------------------------;
				PPI_C_X_L RECORD	PCPE:1,PCIE:1,PCT2:1,PCCI:1,PCMB:2,PCFP:1,PCFD:1
				
				;----------------------------------------------------------------------------;
				; 8255 PPI Channel C Flags (Port 62h)
				; * When PPI B PBSW = 1
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PC2PE	0=no parity error, 1 r/w memory parity check error
				;  6      |			- PC2IE	0=no i/o channel error, 1 i/o channel check error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 29 - 1


				;   5     |			- PC2T2	timer 2 output
				;    4    |			- PC2CI	cassette data input
				;     32  |			- PCDRV	SW 7,8: # of drives (00=1, 01=2, 10=3, 11=4)
				;       10|			- PCVID	SW 5,6: video Mode (00=ROM, 01=CG40, 10=CG80, 11=MDA)
				;----------------------------------------------------------------------------;
				PPI_C_X_H RECORD	PC2PE:1,PC2IE:1,PC2T2:1,PC2CI:1,PCDRV:2,PCVID:2
				
				;----------------------------------------------------------------------------;
				; Set up boot mode (PPI_B_BOOT) for PPI Channel B
				;----------------------------------------------------------------------------;
				
							IF ARCH_TYPE EQ ARCH_5150
				;----------------------------------------------------------------------------;
				; 5150 Power-On: KB hold low+disable, NMI on, spkr data off, cassette off
				;
				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW OR MASK PBST OR MASK PBCM
				
							ELSE				; ARCH_TYPE NE ARCH_5150
								IF BOOT_SPEED EQ BOOT_TURBO
				;----------------------------------------------------------------------------;
				; Turbo Std Power-On: KB hold low+disable, NMI on, spkr data off, turbo ON/OFF
				;
 = 00A9				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW OR MASK PBST
				
								ELSE			; BOOT_SPEED NE BOOT_TURBO
				;----------------------------------------------------------------------------;
				; Default Power-On: KB hold low+disable, NMI on, spkr data off, turbo OFF/ON
				;
				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW OR MASK PBST OR MASK PBTB
				
								ENDIF			; /BOOT_SPEED EQ BOOT_TURBO
				
								IF TURBO_TYPE EQ TURBO_REV
				;----------------------------------------------------------------------------;
				; Turbo Reverse Power-On: Reverse PBTB
				;
 = 00AD				PPI_B_BOOT	= PPI_B_BOOT XOR MASK PBTB
								ENDIF			; /TURBO_TYPE EQ TURBO_REV
				
							ENDIF				; /ARCH_TYPE EQ ARCH_5150
				
								IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST)
				;----------------------------------------------------------------------------;
				; PCXT_MiSTer XTCTL register (port 8888h)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- MCAT4	1=4MHz AT speed (high), 0=use MCSP speed
				;  6      |			- MCA0	a000h off
				;   5     |			- MCMD	MDA (Reserved)
				;    4    |			- MCAD	adlib off
				;     32  |			- MCSP	Speed: 01=5MHz, 10=8MHz, 11=10MHz
				;         |					(with MCAT4=0)
				;       1 |			- MCBR	border
				;        0|			- MCCP	composite
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 30 - 1


				MC_XTCTL	RECORD	MCAT4:1,MCA0:1,MCMD:1,MCAD:1,MCSP:2,MCBR:1,MCCP:1
				
				MC_PORT	EQU	8888h			; PCXT_MiSTer control port
				MCSP_AT4	EQU	1b			; AT clock speed (with MCSP_4)
				MCSP_4	EQU	00b			; 4 MHz (MCSP)
				MCSP_5	EQU	01b			; 5 MHz (MCSP)
				MCSP_8	EQU	10b			; 8 MHz (MCSP)
				MCSP_10	EQU	11b			; 10 MHz (MCSP)
				MCSP_TOG	EQU	MC_XTCTL <MCSP_AT4,,,,MCSP_5>		; toggle high/low
				;MCSP_HIGH	EQU	MC_XTCTL <MCSP_AT4>			; AT speed bit
				MCSP_LOW	EQU	MC_XTCTL <,,,,MCSP_8 AND MCSP_10>	; clear 8/10 bit
				MCSP_SPD	EQU	MASK MCAT4 OR MASK MCSP			; speed bits
								ENDIF
				
				;============================================================================;
				;
				;	 			* * *   M A C R O S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; CALL NO STACK - a CALL without a writable stack
				;----------------------------------------------------------------------------;
				; Input:
				;	CALL_JMP = address for CALL
				;	JMP_SHORT = force SHORT jump
				;
				; - SS must be CS
				;----------------------------------------------------------------------------;
				CALL_NS 	MACRO CALL_JMP, JMP_SHORT
						LOCAL	CALL_JMP_PTR, CALL_JMP_RET	MOV	SP, OFFSET CALL_JMP_PTR
							IFNB <JMP_SHORT>
					JMP	SHORT CALL_JMP
							ELSE	JMP	CALL_JMP
							ENDIFCALL_JMP_PTR:
					DW	OFFSET CALL_JMP_RET
				CALL_JMP_RET:
						ENDM
				
				;----------------------------------------------------------------------------;
				; Introduce a short delay of ~15 clock cycles for I/O
				;----------------------------------------------------------------------------;
				; - Code size: 2 bytes
				; - 15 clock cycles
				; - Affects no registers or flags
				; - CPU Instruction cache is purged
				; - No stack required
				;----------------------------------------------------------------------------;
				IO_DELAY_SHORT	MACRO
						LOCAL _DONE			IF ARCH_TYPE NE ARCH_EMU
					JMP	SHORT _DONE
				_DONE:
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 31 - 1


				; Variable delay ~ CX * 15 clock cycles
				;----------------------------------------------------------------------------;
				; Input: CX delay in 15 clock cycle increments
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY	MACRO
						LOCAL _DONE_DONE:
					LOOP	_DONE					; long delay for I/O
						ENDM
				
				;----------------------------------------------------------------------------;
				; Long delay ~1.18m clock cycles (roughly 1/4 second on 4.77MHz)
				;----------------------------------------------------------------------------;
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY_LONG	MACRO
							IF ARCH_TYPE NE ARCH_EMU
					XOR	CX, CX 				; delay 65535 LOOPs	IO_DELAY
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Variable delay with slowdown for Turbo builds
				;----------------------------------------------------------------------------;
				; Input: CX delay in 30 clock cycle increments
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY_TURBO	MACRO
						LOCAL _DONE_DONE:
						IF IS_TURBO	IO_DELAY_SHORT
						ENDIF	LOOP	_DONE					; long delay for I/O
						ENDM
				
				;----------------------------------------------------------------------------;
				; Get an equipment flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from EQUIP_FLAGS RECORD
				;	SET_BDA = if defined, saves CX and sets DS = BDA
				;		otherwise assumes DS = BDA and clobbers CX
				; Output: AX = flag value
				;
				; Note: flags must not cross byte boundary (which they don't)
				;----------------------------------------------------------------------------;
				GET_EFLAG	MACRO	FLAG, SET_BDA
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM			IFNB <SET_BDA>
					PUSH	CX					; save CX	PUSH	DS	MOV	CX, 
				SEG _BDA			; DS = BDA
					MOV	DS, CX			ENDIF
				;----------------------------------------------------------------------------;; Shift if flag is in
				 high byte to low for byte operations;			IF FLAG LT 8		; is in low 
				byte?
				FLAG_MASK	= MASK FLAG
				FLAG_BIT	= FLAG AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte
							ELSE				; is in high byteFLAG_MASK	= HIGH MASK 
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 32 - 1


				FLAG
				FLAG_BIT	= (FLAG - 8) AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte
							ENDIF
					MOV	AL, BYTE PTR FLAG_MEM
					AND	AX, FLAG_MASK			; clear AH
				;----------------------------------------------------------------------------;; Determine optimal 
				number of shifts based on bit position and shift; right or left depending on fewest.;		
					IF CPU_TYPE	EQ CPU_V20
								IF FLAG_BIT GT 4
					ROL	AL, 8-FLAG_BIT			; shift value into position
								ELSE	ROR	AL, FLAG_BIT			; shift value into p
				osition
								ENDIF			ELSE				IF FLAG_BIT 
				GT 4
					MOV	CL, 8-FLAG_BIT			; CL = bit(s) position of record
					ROL	AL, CL				; shift value into position				
				ELSE	MOV	CL, FLAG_BIT			; CL = bit(s) position of record
					ROR	AL, CL				; shift value into position				
				ENDIF			ENDIF			IFNB <SET_BDA>
					POP	DS	POP	CX			ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Set an equipment flag
				;----------------------------------------------------------------------------;
				; Input: 
				;	AL = flag value (clobbered)
				;	FLAG = field name from EQUIP_FLAGS RECORD
				;	SET_BDA = if defined, saves CL and set DS = BDA 
				;		otherwise *requires* DS = BDA and CL clobbered
				; Output: none
				;----------------------------------------------------------------------------;
				SET_EFLAG	MACRO	FLAG, SET_BDA
							IFNB	<SET_BDA>
					PUSH	CX	PUSH	DS	MOV	CX, SEG _BDA			; DS = BDA
					MOV	DS, CX			ENDIF
							IF FLAG LT 8		; is in low byte?
				FLAG_MASK	= MASK FLAG
				FLAG_BIT	= FLAG AND 111B
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte
							ELSE				; is in high byteFLAG_MASK	= HIGH MASK 
				FLAG
				FLAG_BIT	= (FLAG - 8) AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte
							ENDIF
					AND	AL, MASK FLAG SHR FLAG		; isolate flag's bit width
				;----------------------------------------------------------------------------;; Determine optimal 
				number of shifts based on bit position and shift; right or left depending on fewest.;		
					IF CPU_TYPE	EQ CPU_V20
								IF FLAG_BIT GT 4
					ROR	AL, 8-FLAG_BIT			; shift value into position
								ELSE	ROL	AL, FLAG_BIT			; shift value into p
				osition
								ENDIF			ELSE				IF FLAG_BIT 
				GT 4
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 33 - 1


					MOV	CL, 8-FLAG_BIT			; CL = bit(s) position of record
					ROR	AL, CL				; shift value into position				
				ELSE	MOV	CL, FLAG_BIT			; CL = bit(s) position of record
					ROL	AL, CL				; shift value into position				
				ENDIF			ENDIF
					AND	BYTE PTR FLAG_MEM, NOT FLAG_MASK	; clear existing bits(s)
					OR	BYTE PTR FLAG_MEM, AL			; set new bit(s)
							IFNB <SET_BDA>
					POP	DS	POP	CX			ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Test a single BDA equipment flag
				;----------------------------------------------------------------------------;
				; Input: FLAG = field name from EQUIP_FLAGS RECORD
				; Output: ZF if 0, NZ if 1
				;
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				TEST_EFLAG	MACRO	FLAG
							IF FLAG LT 8
					TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FLAG
							ELSE	TEST	BYTE PTR EQUIP_FLAGS[1], HIGH MASK FLAG
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Set a single GLaBIOS flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from GB_FLAGS RECORD
				;	FLAG_CLR = if set, zeros flags first
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				SET_GFLAG	MACRO	FLAG, FLAG_CLR
							IFNB	<FLAG_CLR>
					AND	GB_FLAGS, MASK FLAG		; clear existing flag(s)
							ENDIF	OR	GB_FLAGS, MASK FLAG		; set flag(s)
						ENDM
				
				;----------------------------------------------------------------------------;
				; Test a single GLaBIOS flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from GB_FLAGS RECORD
				; Output: ZF if 0, NZ if 1
				;
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				TEST_GFLAG	MACRO	FLAG
					TEST	GB_FLAGS, MASK FLAG
						ENDM
				
				;----------------------------------------------------------------------------;
				; Shortcut to write a null-terminated string to console
				;----------------------------------------------------------------------------;
				; Input:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 34 - 1


				;	SZ = string to print
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes)
				;----------------------------------------------------------------------------;
				PRINT_SZ	MACRO	SZ, SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	SI					; save SI		ENDIF		IFDI
				FI <SZ>,<SI>			; if SZ is not SI
					MOV	SI, OFFSET SZ
						ENDIF	CALL	OUT_SZ
						IFNB	<SAVE_REGS>
					POP	SI		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Same as above but print CRLF at the end
				;----------------------------------------------------------------------------;
				; Input:
				;	SZ = string to print
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes)
				;
				; If called as PRINTLN_SZ SI, will use SI (effectively an alias to 
				;	'CALL OUTLN_SZ')
				;----------------------------------------------------------------------------;
				PRINTLN_SZ	MACRO	SZ, SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	SI					; save SI		ENDIF		IFDI
				FI <SZ>,<SI>			; if SZ is not SI
					MOV	SI, OFFSET SZ
						ENDIF	CALL	OUTLN_SZ
						IFNB	<SAVE_REGS>
					POP	SI		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Set text attribute for a block of chars starting at current cursor
				;----------------------------------------------------------------------------;
				; This is a more efficient way to set text colors so any normal way to write
				; to console may be used.
				;
				; Example usage:
				;   SET_SZ_ATTR 0EH, 10			; set attribute to 0EH for next 10 chars
				;
				; Code size:
				; 	16 bytes if registers NOT saved
				;	22 bytes if registers saved
				; 	-3 bytes if ATTR is BL
				;----------------------------------------------------------------------------;
				SET_SZ_ATTR	MACRO	ATTR, LN, SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	AX	PUSH	BX	PUSH	CX		ENDIF ; IFNB	MOV	AX, DBW <9, 
				VID_SP>	; AH = write char w/attr, AL = space		IFDIFI <ATTR>,<BL>	; if ATTR is not BL
					MOV	BX, LOW ATTR		; BH = video page 0, BL = attribute
						ENDIF	; IFDIFI	MOV	CX, LN			; CX = repeat times
					INT	10H		IFNB	<SAVE_REGS>
					POP	CX	POP	BX	POP	AX		ENDIF	; IFNB		ENDM
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 35 - 1


				; POST column UI
				;----------------------------------------------------------------------------;
				POST_COL_1	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF		IFNB
					<ZERO_BH>
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute
						ELSE	MOV	BL, LOW INNER_ATTR		; BL = attribute
						ENDIF	MOV	SI, OFFSET LBL_STR
					CALL	POST_START_COL_1
						IFNB	<SAVE_REGS>
					POP	BX		ENDIF
						ENDM
				
				POST_COL_2	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF		IFNB
					<ZERO_BH>
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute
						ELSE	MOV	BL, LOW INNER_ATTR		; BL = attribute
						ENDIF	MOV	SI, OFFSET LBL_STR
					CALL	POST_START_COL_2
						IFNB	<SAVE_REGS>
					POP	BX		ENDIF		ENDM
				
				POST_COL_END	MACRO	SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF	CALL	POST
				_END_COL
						IFNB	<SAVE_REGS>
					POP	BX		ENDIF		ENDM
				
				POST_COL_END_NL	MACRO SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF	CALL	POST
				_END_COL_NL
						IFNB	<SAVE_REGS>
	POP	BX		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Beepin' MACROs
				;----------------------------------------------------------------------------;
				; Beep on Man
				;----------------------------------------------------------------------------;
				BEEP_ON MACRO 	TONE, NO_SAVE_REGS
						IFNB	<TONE>
					MOV	AX, TONE 				; custom tone
						ELSE	MOV	AX, BEEP_DEFAULT
						ENDIF		IFB	<NO_SAVE_REGS>
					PUSH	BX		ENDIF	CALL	BEEP_ON_P
						IFB	<NO_SAVE_REGS>
					POP	BX		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Beep off Man
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 36 - 1


				;----------------------------------------------------------------------------;
				BEEP_OFF MACRO
					CALL	BEEP_OFF_P
						ENDM
				
				;----------------------------------------------------------------------------;
				; BYTES_HERE - Track and enforce code/byte space around fixed ORGs
				;----------------------------------------------------------------------------;
				; Use to mark a block of free code space. Outputs assembly warning if code 
				; overruns NEXT_LBL, and defines LBL so space can be viewed. Values displayed
				; in generated listing.
				;
				; WTF: why can't MASM %OUT display the value of NEXT_LBL-$?
				; WTF2: how to fix for MASM 6.1?
				;
					.LALL
				BYTES_HERE	MACRO	NEXT_LBL
						LOCAL LBL
				BYTES_HERE_&NEXT_LBL = NEXT_LBL-$
						IFDEF BYTES_HERE_&NEXT_LBL
						IF2		IF BYTES_HERE_&NEXT_LBL LT 0
						.ERR2	%OUT WARNING: Out of space at: NEXT_LBL (&BYTES_HERE_&NEXT_LBL)
						ENDIF		ENDIF		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; V20 MACROs
				;
				; Polyfill for V20 instruction mnemonics not supported by MASM.
				; Not comprehensive of course.
				;
				TEST1_BP	MACRO IMM4
					DB	0FH, 19H, 0C5H, IMM4	; TEST1 BP, IMM4
						ENDM
				
				SET1_BP	MACRO IMM4
					DB	0FH, 1DH, 0C5H, IMM4	; SET1  BP, IMM4
						ENDM
				
				NOT1_BP	MACRO IMM4
					DB	0FH, 1FH, 0C5H, IMM4	; NOT1  BP, IMM4
						ENDM
				
				CLR1_BP	MACRO IMM4
					DB	0FH, 1BH, 0C5H, IMM4	; CLR1  BP, IMM4
						ENDM
				
				;----------------------------------------------------------------------------;
				; Operations on POST test FLAGs
				;----------------------------------------------------------------------------;
				POST_FLAG_TEST MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					TEST1_BP  FLAG				; V20 only: TEST1 BP, FLAG
							ELSE	TEST	BP, MASK FLAG			; Is flag set?
							ENDIF		ENDM
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 37 - 1


				POST_FLAG_SET MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					SET1_BP   FLAG				; V20 only: SET1 BP, FLAG
							ELSE	OR	BP, MASK FLAG			; Set flag
							ENDIF		ENDM
				
				POST_FLAG_FLIP MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					NOT1_BP   FLAG				; V20 only: NOT1 BP, FLAG
							ELSE	XOR	BP, MASK FLAG			; Invert flag
							ENDIF		ENDM
				
				POST_FLAG_CLR MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					CLR1_BP   FLAG				; V20 only: CLR1 BP, FLAG
							ELSE	AND	BP, NOT MASK FLAG			; Clear flag
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Jump if Warm Boot
				;----------------------------------------------------------------------------;
				JWB		MACRO	LBL
							IF WARM_ENABLE EQ 1	TEST	BP, BP				; is warm bo
				ot?	JS	LBL					; jump if so
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Jump if not Warm Boot
				;----------------------------------------------------------------------------;
				JNWB		MACRO	LBL
					TEST	BP, BP				; is warm boot?	JNS	LBL			
						; jump if not
						ENDM
				
				;----------------------------------------------------------------------------;
				; Wait for a video retrace to enable RAM access for CGA 80 column
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = 03DAH (CGA Status Port)
				;
				; Output:
				;	Display is in retrace
				;	CLI: Interrupts OFF - must be re-enabled after read/write operation
				;
				; https://forum.vcfed.org/index.php?threads/cant-get-rid-of-cga-snow.39319/post-478150
				;
				; Due to timing requirements this must be unrolled - CALL/PROC too slow
				;----------------------------------------------------------------------------;
				CGA_WAIT_SYNC	MACRO
						LOCAL	WAIT_NO_HSYNC, WAIT_BLANK, IN_VSYNC			IF CGA_SNOW_REMOVE E
				Q 1	CLI						; [2] disable interrupts			
				ENDIFWAIT_NO_HSYNC:
							IF CGA_SNOW_REMOVE GT 1	STI						
				; [2] enable interrupts	NOP						; [3] handle pending
				 interrupts	CLI						; [2] disable interrupts		
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 38 - 1


					ENDIF	IN	AL, DX				; [12] read CGA status register		
					IF CGA_SNOW_REMOVE GT 1	TEST	AL, MASK VSVS			; [5] in vertical?	
				JNZ	IN_VSYNC				; [4/16] if so, do CGA I/O
							ENDIF	SHR	AL, 1					; [2] in horizontal?
					JC	WAIT_NO_HSYNC			; [4/16] if so, wait for next one
				WAIT_BLANK:
					IN	AL, DX				; [12] read CGA status register			
				IF CGA_SNOW_REMOVE GT 1	TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync?	JZ	
				WAIT_BLANK				; [4/16]
							ELSE	SHR	AL, 1					; [2] in horizontal 
				sync?	JNC	WAIT_BLANK				; [4/16]
							ENDIFIN_VSYNC:
						ENDM
				
				;----------------------------------------------------------------------------;
				; IRET with all current flags
				;----------------------------------------------------------------------------;
				IRET_F	MACRO
					RETF	2		ENDM
				
				;----------------------------------------------------------------------------;
				; PUSH multiple registers (up to 8)
				;----------------------------------------------------------------------------;
				PUSHX	MACRO r1, r2, r3, r4, r5, r6, r7, r8
							IFNB <r1>			; exit if last reg
					PUSH	r1 					; push register and repeat
					PUSHX	r2, r3, r4, r5, r6, r7, r8
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; POP multiple registers (up to 8)
				;----------------------------------------------------------------------------;
				POPX	MACRO r1, r2, r3, r4, r5, r6, r7, r8
							IFNB <r1>			; exit if last reg
					POP	r1 					; pop register and repeat
					POPX	r2, r3, r4, r5, r6, r7, r8
							ENDIF		ENDM
				
				;============================================================================;
				;
				;	   		   * * *   S E G M E N T S   * * * 
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; 0000:0000 - 8086 INT vector table
				;----------------------------------------------------------------------------;
				_IVT		SEGMENT AT 0H
						ORG 8H*4
				IVT_08 		DW	?			; INT 08H - Timer
				IVT_08_SEG		DW	?			; INT 08H - Timer Segment
				IVT_09 		DW	?			; INT 09H - Keyboard
				IVT_09_SEG		DW	?			; INT 09H - Keyboard Segment
						ORG 10H*4
				IVT_10		DW	?			; INT 10H - BIOS video services
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 39 - 1


				IVT_10_SEG		DW	?			; INT 10H - Segment
						ORG 18H*4
				IVT_18		DW	?			; INT 18H - ROM BASIC
				IVT_18_SEG		DW	?			; INT 18H - Segment
						ORG 1DH*4
				IVT_1D		DD	?			; INT 1DH - CRTC param table
				IVT_1E		DD	?			; INT 1EH - Floppy param table
				IVT_1F		DD	?			; INT 1FH - User Font bitmap table
				_IVT 		ENDS
				
				;----------------------------------------------------------------------------;
				; 0000:0400 - BIOS data area (BDA) - Zero Page Segment Addressing
				; (Only used during early POST)
				;----------------------------------------------------------------------------;
				_BDA_ABS	SEGMENT AT 0H
						ORG 440H
				FD_MOTOR_CT_ABS	DB	?			; 40:40H FD motor shutoff counter
						ORG 46BH
				INT_LAST_ABS	DB	?			; 40:6BH POST / Interrupt happened?
						ORG 472H
				WARM_FLAG_ABS	DW	?			; 40:72H Warm Boot Flag
				_BDA_ABS	ENDS
				
				;----------------------------------------------------------------------------;
				; 0030:0000 - Bootstrap temporary stack
				;----------------------------------------------------------------------------;
				_BOOT_STACK	SEGMENT AT 30H
							DW 	80H DUP(?)
				STACK_TOP		DW 	?
				_BOOT_STACK	ENDS
				
				;----------------------------------------------------------------------------;
				; 0040:0000 - BIOS data area (BDA)
				;----------------------------------------------------------------------------;
				; https://stanislavs.org/helppc/bios_data_area.html
				; http://www.bioscentral.com/misc/bda.htm
				;----------------------------------------------------------------------------;
				_BDA		SEGMENT AT 40H
				COM_ADDR		DW	4 DUP(?) 		; 00H  COM1-4 base addresses
				LPT_ADDR_B		EQU	08H			;	 Low byte hack to force short sign-e
				xtend encoding
				LPT_ADDR		DW	3 DUP(?) 		; 08H  LPT1-3 base addresses
							DW	? 			; 0EH  Extended BIOS data area segment
				EQUIP_FLAGS		EQFLAGS <> 			; 10H  Equipment Flags
				GB_FLAGS		GFLAGS <> 			; 12H  Custom Equipment Flags
				MEM_SZ_KB		DW	?			; 13H  Memory size in kilobytes
				MEM_SZ_PC		DW	?			; 15H  Memory size SW2 on 5150
				KB_FLAGS		LABEL WORD
				KB_FLAGS1		KBFLAGS1 <>			; 17H  Keyboard flags 1
				KB_FLAGS2		KBFLAGS2 <>			; 18H  Keyboard flags 2
				KB_ALT 		DB	?			; 19H  Alt-keypad entry byte
				KB_BUF_HD		DW	?			; 1AH  Keyboard buffer head ptr
				KB_BUF_TL		DW	?			; 1CH  Keyboard buffer tail ptr
				KB_BUF		DW	16 DUP(?) 		; 1EH  Keyboard buffer
				KB_BUF_END		LABEL WORD			; 3EH  End of keyboard buffer (not inclusive
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 40 - 1


				)
				KB_BUF_END_B	EQU	3EH			;	 Low byte to force short sign-extend encodin
				g
				FD_CAL_ST		FDC_SF <>			; 3EH  Floppy drive recalibration status
											;	0 = drive not calibrated
											;	high bit = working interrupt flag
				FD_MOTOR_ST		FDC_MF <>			; 3FH  FD motor status
											;	high bit = write operation
				FD_MOTOR_CT		DB	?			; 40H  FD motor shutoff counter (decr. by IN
				T 8)
				FD_LAST_OP		DB	?			; 41H  BIOS Status of last FD operation
				FDC_LAST_ST		FDC_CSB <>			; 42H  FDC command status last result (7 byt
				es)
				VID_MODE		DB	?			; 49H  Current video mode
				VID_COLS		DW	?			; 4AH  Number of screen columns
				VID_BUF_SZ		DW	?			; 4CH  Size of video regen buffer in bytes
				VID_SEG		DW	? 			; 4EH  Starting address in video regen buffer (offse
				t) 
				VID_CURS_POS	DW	8 DUP(?)		; 50H-5FH Cursor position of pages 1-8, high=row, lo
				w=col
				VID_CURS_TYPE	DW	? 			; 60H  Starting (Top), Ending (bottom) scan line for
				 cursor
				VID_PAGE		DB	? 			; 62H  Active display page number
				VID_PORT		DW	?			; 63H  Base port address for active 6845 CRT
				 controller
				VID_MODE_REG	DB	?			; 65H  6845 CRT mode control register value (port 3x
				8H)
				VID_COLOR		DB	? 			; 66H  CGA current color palette setting (po
				rt 3D9H)
				L_VID_BDA		EQU	$-VID_MODE		;      Length in bytes of video data in BDA
				CAS_TIME_CNT	LABEL WORD			; 67H  5150 Cassette: Counter
				ROM_INIT_SS		DW	?			; 67H   or Temp location for SS:SP during bl
				ock move
				CAS_CRC		LABEL	WORD			; 69H  5150 Cassette: CRC
				ROM_INIT_SP 	DW	? 			; 69H	  or Option ROM init
				CAS_PREV		LABEL	BYTE			; 6BH  5150 Cassette: Previous byte
				;FE2010_CONF_REG	LABEL BYTE			; 6BH  FE2010A Config Reg (Standard 63H)
				INT_LAST		DB	? 			; 6BH  Reserved for POST / Interrupt happene
				d?
				TIMER			TIMER_C <>			; 6CH-70H Timer Counter
				BIOS_BREAK		DB	?			; 71H  BIOS break flag (high bit means ctrl-
				break)
				WARM_FLAG		DW	?			; 72H  Warm Boot Flag (1234H to bypass RAM t
				est)
				HD_LAST_ST		DB 	? 			; 74H  Status of last hard disk operation (s
				ee INT 13,1)
				HD_COUNT		DB 	? 			; 75H  Number of hard disks attached
				HD_CTRL		DB 	? 			; 76H  XT fixed disk drive control byte
				HD_PORT		DB 	? 			; 77H  Port offset to current fixed disk adapter
				LPT_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding
				LPT_TIME		DB	4 DUP(?) 		; 78H  Time-out value for LPT1-4 (in # of 64
				K LOOPs)
				COM_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 41 - 1


				COM_TIME		DB	4 DUP(?) 		; 7CH  Time-out value for COM1-4
				KB_BUF_ST		DW	?			; 80H  Keyboard buffer start
							DW	?			; 82H  Keyboard buffer end
						ORG	08BH
							DB	?			; 8BH  Last diskette data rate selected
						ORG	08FH
				FD_MODE		FDC_MODE <>			; 8FH  FDC Drive Mode (see FDC_MODE)
				FD_MEDIA_ST		FDC_STATE 4 DUP(<>)	; 90H-93H  Drive 0-3 media state
				FD0_TRACK		DB	?			; 94H  Drive 0 current track
				FD1_TRACK		DB	?			; 95H  Drive 1 current track
				EKB_FLAGS1		KBFLAGS3 <>			; 96H  Keyboard mode/type (Enhanced)
				EKB_FLAGS2		KBFLAGS4 <>			; 97H  Keyboard LED flags (Enhanced)
						ORG	0A0H
				RTC_WAIT		DB	?			; A0H  RTC wait function flag
						ORG	0ACH				; ACH-B3H "Reserved" (can be used?)
						ORG	0B0H
				RTC_DATA		DW	?			; B0H  GLaTICK address and RTC type
						ORG	0E8H				; E8H-EFH "Reserved" (can be used?)
				CURSOR_DEFAULT	DW	?			; E8H  Power on cursor bottom:top scan line (for Tur
				bo)
				VID_MEM_SEG		DW	?			; EAH	 Video mem segment (MDA = B000, CGA 
				= B800)
				FE2010_CONF_REG	DB	?			; ECH  FE2010A Config Reg (63H) (alternate)
				;			DB	2 DUP(?)
				_BDA		ENDS
				
				;----------------------------------------------------------------------------;
				; 0050:0000 - BIOS/DOS Data Area
				;----------------------------------------------------------------------------;
				_DOS_DAT	SEGMENT AT 50H
				PTRSCN_ST		DB 	?			; 00H  Print screen status
							DB	3  DUP(?)		; 01H  Used by BASIC
							DB	?			; 04H  Floppy drive flag for single
											;	  drive systems (0=A,1=B)
							DB	10 DUP(?)		; 05H  POST work area
							DB	19 DUP(?)		
				DOS_FD_PARAM	DB	14 DUP(?)		; 22H  Floppy drive parameter table
					 		DB	4  DUP(?)		; 30H  Mode command
				_DOS_DAT	ENDS
				
				;----------------------------------------------------------------------------;
				; 0070:0000 - "Kernel" of PC-DOS
				;----------------------------------------------------------------------------;
				_DOS_SEG	SEGMENT AT 70H
				_DOS_SEG	ENDS
				
				;----------------------------------------------------------------------------;
				; 0000:7C00 - IPL / MBR / Boot Block Segment
				;----------------------------------------------------------------------------;
				_IPL_SEG	SEGMENT AT 0H
						ORG	07C00H
				IPL_TOP		DB	510 DUP(?)		; MBR code then MBR magic number
				IPL_ID		DW	?			; 0AA55H if valid MBR
				_IPL_SEG	ENDS
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 42 - 1


 0000				;----------------------------------------------------------------------------;
				; B000:0000 - MDA Video Memory
 0020 0000			;----------------------------------------------------------------------------;
 0022 0000			_MDA_MEM	SEGMENT AT 0B000H
 0024 0000						DB	1000H DUP(?)
 0026 0000			MDA_MEM	LABEL BYTE				; 4KiB (1000H) total MDA memory
				_MDA_MEM	ENDS
 0040 0000			
 0042 0000			;----------------------------------------------------------------------------;
				; B800:0000 - CGA Video Memory
 0060 0000			;----------------------------------------------------------------------------;
 0062 0000			_CGA_MEM	SEGMENT AT 0B800H
				CGA_MEM_TOP		DB	0800H DUP(?)	; page 1 of CGA 40 column
 0074 00000000			CGA_MEM_40		DB	0800H DUP(?)	; page 1 of CGA 80 column
 0078 00000000			CGA_MEM_80		DB	3000H DUP(?)
 007C 00000000			CGA_MEM_GFX	LABEL BYTE
 0080				CGA_MEM	LABEL BYTE				; End of CGA memory offset
				CGA_MEM_SZ		= CGA_MEM - CGA_MEM_TOP	; 16 KiB (4000H) total CGA memory
				CGA_MEM_FLD 	= CGA_MEM_SZ / 2		;  8 KiB (2000H) CGA memory field
				_CGA_MEM	ENDS
				
				;----------------------------------------------------------------------------;
 0000				; C000:0000 - Video Option ROM segment
				;----------------------------------------------------------------------------;
 0440 00			_VID_BIOS	SEGMENT AT 0C000H
				VID_MN		DW	?			; magic number (0AA55H)
 046B 00			VID_BIOS_SZ		DB	?			; length in 512 byte blocks
				VID_VEC		DW	?			; FAR call to ROM init routine
 0472 0000			_VID_BIOS	ENDS
 0474				
				;----------------------------------------------------------------------------;
				; C800:0000 - Start of Storage/Other Option ROM segment
				;----------------------------------------------------------------------------;
				_OPT_ROM	SEGMENT AT 0C800H
 0000				_OPT_ROM	ENDS
 0000  0080 [			
        0000
       ]
 0100 0000			;----------------------------------------------------------------------------;
 0102				; F000:E000 - System BIOS ROM segment map
				;----------------------------------------------------------------------------;
				_BIOS		SEGMENT AT 0F000H
						ORG	0E000H
				_BIOS_TOP	LABEL WORD
						ORG	0E05BH
				_BOOT		LABEL WORD				; BIOS boot offset
						ORG	0FFF0H
 0000				_POWER_ON	LABEL WORD				; CPU power-on jump address
 0000  0004 [			_BIOS		ENDS
        0000
       ]
 = 0008				
 0008  0003 [			;----------------------------------------------------------------------------;
        0000
       ]
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 43 - 1


 000E  0000			; F600:0000 - ROM BASIC segment
 0010 000C			;----------------------------------------------------------------------------;
GLABIOS.asm(2246): warning A4013: instructions and initialized data not supported in AT segments
 0012 00			_BASIC	SEGMENT AT 0F600H
 0013 0000			BASIC_TOP	LABEL WORD 				; ROM BASIC load offset
 0015 0000			_BASIC	ENDS
 0017				
 0017 00			
 0018 00			;============================================================================;
 0019 00			;
 001A 0000			;				* * *   C O D E   * * * 
 001C 0000			;
 001E  0010 [			;============================================================================;
        0000
       ]
 003E				
 = 003E				;----------------------------------------------------------------------------;
 003E 00			; Main BIOS ROM begins
				;----------------------------------------------------------------------------;
				; Note: Memory space from F000:0000 - F000:E05A is available, though a
 003F 00			; BIOS identifier string is typically at or near the top of this segment
				;----------------------------------------------------------------------------;
 0040 00					ASSUME	DS:BIOS, SS:BIOS, CS:BIOS, ES:BIOS
 0041 00			BIOS    	SEGMENT
 0042 00 00 00 00 00 00		
       00
 0049 00			;----------------------------------------------------------------------------;
 004A 0000			; F000:FFF0: 8086 power-on reset vector
 004C 0000			;----------------------------------------------------------------------------;
 004E 0000			; The x86 CPU begins code excution at hard-coded address F000:FFF0.
 0050  0008 [			; This is that address. Welcome to the party!
        0000
       ]
 0060 0000			;----------------------------------------------------------------------------;
 0062 00					ORG	0FFF0H
 0063 0000			POWER_ON	PROC	FAR
 0065 00				JMP	FAR	PTR _BOOT 		; always jump to power on routine
 0066 00			
 0067 = 001E					ORG	0FFF5H
 0067				REL_DATE 	DB	VER_DATE		; Release date
 0067 0000			
 0069						ORG	0FFFEH
 0069 0000			ISA_TYPE	DB	ARCH_ID		; Architecture model
 006B				
						ORG	0FFFFH		; BIOS ROM checksum byte 
 006B 00					DB	?			; (computed at build time)
 006C 0000 0000 00		POWER_ON	ENDP
 0071 00			
 0072 0000			;----------------------------------------------------------------------------;
 0074 00			; F000:E000: Top of BIOS ROM 8K segment
 0075 00			;----------------------------------------------------------------------------;
 0076 00					ORG	0E000H
 0077 00			BIOS_TOP	PROC	NEAR
 0078 = 0078			
 0078  0004 [			TOP_BANNER	DB	LF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 44 - 1


        00
       ]
 007C = 007C					DB	VER_NAME, ' [', HEART, '] '
 007C  0004 [							IF RANDOM_TAGLINE EQ 1
        00
       ]
 0080 0000					DB	0				; null terminate BANNER string
 0082  0000							ENDIF
				TAG0		DB	"The hero we need but don't deserve"
 008B  00							IF RANDOM_TAGLINE EQ 1
						DB	0				; null terminate TAG0 string
 008F 00							ENDIF
 0090  0004 [			COPYRIGHT	DB	CR, LF
        00
       ]
 0094 00					DB	'(C) ', COPY_YEAR, ' '
 0095 00					DB	'640KB Released under GPLv3'
 0096 00					DB	LF
 0097 00					DB	0
				
 00A0 00			BIOS_TOP 	ENDP
				
				;
 00B0 0000			; 0 BYTES HERE
				;
 00E8 0000			BYTES_HERE	BOOT
 00EA 0000			
 00EC 00						ASSUME CS:BIOS, DS:NOTHING, ES:NOTHING, SS:NOTHING
				;----------------------------------------------------------------------------;
 00ED				; F000:E05B: Beginning of boot execution
				;----------------------------------------------------------------------------;
				; Loosely follow these specs for BIOS POST operations:
				;
				; http://minuszerodegrees.net/5160/post/5160%20-%20POST%20-%20Detailed%20breakdown.htm
 0000				; http://minuszerodegrees.net/5150/post/5150%20-%20POST%20-%20Detailed%20breakdown.htm
 0000 00			; https://stanislavs.org/helppc/cold_boot.html
 0001  0003 [			; http://philipstorr.id.au/pcbook/book1/post.htm
        00
       ]
 0004  00			;----------------------------------------------------------------------------;
						ORG	0E05BH
 0005  000A [			BOOT 	PROC NEAR
        00
       ]
 000F  0013 [				CLI 					; disable CPU interrupts
        00
       ]
 0022  000E [				CLD					; clear direction flag
        00
       ]
 0030  0004 [			
        00
       ]
 0034				;----------------------------------------------------------------------------;
				; Early Chipset Setup for non-standard builds
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 45 - 1


				;----------------------------------------------------------------------------;
							IF ARCH_TYPE EQ ARCH_EHB
					JMP	INIT_V40			; Setup V40 for EMM
 0000				INIT_V40_RET:
 0000							ENDIF
				
				;----------------------------------------------------------------------------;
				; POST Hardware/System Tests
				;----------------------------------------------------------------------------;
 0000				
				POST_CPU_TEST:
 7C00  01FE [			;----------------------------------------------------------------------------;
        00
       ]
 7DFE 0000			; [1] Test and clear all CPU Registers
 7E00				;----------------------------------------------------------------------------;
				; Check and set all registers to 0.
				;
				; On Failure: 2 short and 1 long beep
				;----------------------------------------------------------------------------;
 0000							ASSUME DS:_BDA_ABS, ES:_IVT
 0000  1000 [				MOV	AX, RAM_TEST		; use the standard test pattern
        00
       ]
 1000				CPU_REG_TEST:
 1000					MOV	BX, AX			; the game of telephone
					MOV	DS, BX			;  pass a
					MOV	CX, DS			;  known value
					MOV	ES, CX			;  through all
					MOV	SI, ES			;  registers and
 0000					MOV	SS, SI			;  ensure the
 0000  0800 [				MOV	DI, SS			;  same value
        00
       ]
 0800  0800 [				MOV	BP, DI			;  makes it all
        00
       ]
 1000  3000 [				MOV	SP, BP			;  the way
        00
       ]
 4000					MOV	DX, SP			;  to the end
 4000					TEST	DX, NOT RAM_TEST		; expected result?
 = 4000					MOV	BL, BEEP_SL <2,1>		; on Failure: 2 short and 1 long beep
 = 2000					JNZ	HALT_ERROR
 4000					XOR	AX, AX 			; otherwise repeat with AX = 0
					TEST	DX, DX			; if zero it was second pass
					JNZ	CPU_REG_TEST		; Loop again to zero all registers
				CPU_REG_PASS:
				
 0000				;----------------------------------------------------------------------------;
 0000 0000			; Disable non-maskable interrupts (NMIs)
 0002 00			;----------------------------------------------------------------------------;
 0003 0000			DISABLE_NMI:
 0005					OUT	NMI_R0, AL			; write AL = 0 to NMI register port
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 46 - 1


				;----------------------------------------------------------------------------;
				; [1B] A brief test of flags and CPU instructions
				;----------------------------------------------------------------------------;
 0000				; On Failure: 3 short and 1 long beep
 0000				;----------------------------------------------------------------------------;
							IF POST_TEST_INST EQ 1
				CPU_INST_TEST:
					MOV	AL, 1				; start off with some complicated math
					MOV	BL, BEEP_SL <3,1>		; on error, 3 short and 1 long beep
 0000					ADD	AL, AL			; can little Billy add 1 + 1?
					JS	HALT_ERROR			; ...better not be negative
 E000					JZ	HALT_ERROR			; ...better not be zero
					JP	HALT_ERROR			; ...better have an odd number of 1 bits
 E05B					JC	HALT_ERROR			; ...better not be a borrower
					SUB	AL, 3				; 2 - 3 = ?
 FFF0					JNS	HALT_ERROR			; ...better be negative
 FFF0					JNP	HALT_ERROR			; ...better have even bits
					JNC	HALT_ERROR			; ...better have had to borrow
					CBW					; zero extend the result
					INC	AX				; roll it back over to 0
					JNZ	HALT_ERROR			; AX = 0
 0000				CPU_TEST_PASS:
 0000							ENDIF
 0000				
				;----------------------------------------------------------------------------;
				; [3] Set Zero Page Register for DMA channels 0 and 1
				;----------------------------------------------------------------------------;
					OUT	DMA_P_C1, AL 		; AL = high nibble of segment for DMA (0)
				
				;----------------------------------------------------------------------------;
				; [4] Disable MDA/CGA adapters (for now)
				;----------------------------------------------------------------------------;
				INIT_VIDEO:
					MOV	DX, CGA_CTRL		; DX = 03D8H
					OUT	DX, AL 			; send Disable to CGA Mode Select Register
					INC	AX 				; clear MDA control, disable video signal
					MOV	DL, LOW MDA_CTRL		; DX = 03B8H
					OUT	DX, AL 			; send to MDA CRT Control Port
				
 0000				;----------------------------------------------------------------------------;
				; Set up POST flags in BP
				;----------------------------------------------------------------------------;
					CMP	WARM_FLAG_ABS, WARM_BOOT
					JNZ	POST_FLAG_DONE
					MOV	BP, MASK WARM		; clear and set POST warm boot flag
				POST_FLAG_DONE:
				
							IF RANDOM_TAGLINE EQ 1
 FFF0				;----------------------------------------------------------------------------;
 FFF0  EA ---- E05B R		; Read PIT for seed of random pithy tagline
				;----------------------------------------------------------------------------;
					DEC	AX				; Counter 0, Latch (00b)
 FFF5 30 37 2F 32 33 2F			OUT	PIT_CTRL, AL		; write command to CTC
       32 33
					IN	AL, PIT_CH0			; read low byte of Counter 0 latch
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 47 - 1


					SHR	AL, 1				; low bit is always 0
 FFFE FE				AND	AL, MASK GRND		; use only last two bits
					OR	BP, AX			; save to low bits of BP
							ENDIF
 FFFF  00			
 00010000			;----------------------------------------------------------------------------;
				; Setup SS = CS
				;----------------------------------------------------------------------------;
				; Set up temporary stack to point at ROM to enable CALL_NS MACRO
				;----------------------------------------------------------------------------;
					MOV	DX, CS 			; DX = 0F000h (BIOS segment)
 E000					MOV	SS, DX			; SS = temp boot stack in CS
				
 E000 0A			;----------------------------------------------------------------------------;
 E001  47 4C 61 42 49 4F	; [5] Setup 8255 PPI to normal operating state
       53 20 5B 03 5D 20
				;----------------------------------------------------------------------------;
 E00D  00			; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT
				;----------------------------------------------------------------------------;
 E00E 54 68 65 20 68 65		RESET_PPI:
       72 6F 20 77 65 20
       6E 65 65 64 20 62
       75 74 20 64 6F 6E
       27 74 20 64 65 73
       65 72 76 65
							IF ARCH_TYPE EQ ARCH_FE2010
 E030  00				MOV	AL, FE_CR <>		; set speed 9.54MHz, Memory 640KB, no FPU
							ELSE
 E031 0D 0A				MOV	AL, PPI_CR <>		; set 8255 A,C to INPUT, B to OUTPUT
 E033  28 43 29 20 32 30				ENDIF
       32 32 2D 32 33 20
 E03F  36 34 30 4B 42 20		OUT	PPI_CW, AL 			; send to PPI control port (63H)
       52 65 6C 65 61 73
       65 64 20 75 6E 64
       65 72 20 47 50 4C
       76 33
 E059  0A			
 E05A  00			;----------------------------------------------------------------------------;
				; Set up PPI port B
 E05B				;
					MOV	AL, PPI_B_BOOT		; KB hold low+disable, NMI on, spkr off
					OUT	PPI_B, AL			; send to 8255 Port B
				
							IF ARCH_TYPE EQ ARCH_TD3300
					IN	AL, TD_TURBO		; read current register
 E05B			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_BOOT = BOOT-$
			     1	
			     1			IFDEF BYTES_HERE_BOOT
			     1			IF2
			     1			IF BYTES_HERE_BOOT LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: BOOT (BYTES_HERE_BOOT)
			     1			ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 48 - 1


			     1			ENDIF
			     1			ENDIF
								IF BOOT_SPEED EQ BOOT_TURBO
					MOV	AL, TD_TURBO_CR<,,0>	; switch to turbo
								ELSE
					MOV	AL, TD_TURBO_CR<,,1>	; switch to normal (4.77)
								ENDIF
					OUT	TD_TURBO, AL		; write new register
							ENDIF			; ENDIF ARCH_TD3300
				
				;			IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST)
				;----------------------------------------------------------------------------;
				; Set up Turbo mode for PCXT_MiSTer
				;
				;	MOV	DX, MC_PORT			; DX = XTCTL port
 E05B				;	IN	AL, DX			; read current speed
 E05B  FA			;	AND	AL, NOT MCSP_SPD		; clear speed bits
 E05C  FC			;			IF BOOT_SPEED EQ BOOT_TURBO
				;	OR	AL, MC_XTCTL <MCSP_AT4>	; boot to AT 4MHz
				;			ELSE
				;	OR	AL, MC_XTCTL <,,,,MCSP_5> ; boot to XT 5MHz
				;			ENDIF
				;	OUT	DX, AL			; set new speed
				;	MOV	DX, SS			; restore DX
				;			ENDIF			; ARCH_MIST
				
							IF POST_TEST_CHK_ROM EQ 1
				;----------------------------------------------------------------------------;
				; [8] Checksum (8 bit) the main ROM to ensure it is not corrupt
				;----------------------------------------------------------------------------;
				; Input: AH = 0, CX = 0, DX = 0F000h
 E05D				; On Failure: 2 long and 2 short beeps
				;----------------------------------------------------------------------------;
					JWB	CHECKSUM_OK			; skip on warm boot
				CHECKSUM_ROM:
							ASSUME DS:BIOS
					MOV	DS, DX			; DS to 0F000h BIOS segment
					MOV	SI, OFFSET BIOS_TOP 	; offset to top of BIOS ROM
					MOV	CH, HIGH (8 * 1024 / 2)	; checksum 8KB (in 2 byte words)
				CHECKSUM:
 E05D  B8 95A5				LODSW 				; next two bytes into AL and AH
 E060					ADD	DL, AL			; DL = accumulator for sum
 E060  8B D8				ADD	DL, AH			; ZF if sum is 0
 E062  8E DB				LOOP	CHECKSUM 			; loop through entire ROM
 E064  8C D9				MOV	BL, BEEP_SL <2,2>		; on failure, 2 short and 2 long beeps
 E066  8E C1				JNZ	HALT_ERROR			; if sum not 0, fail
 E068  8C C6			CHECKSUM_OK:
 E06A  8E D6						ENDIF
 E06C  8C D7			
 E06E  8B EF			;----------------------------------------------------------------------------;
 E070  8B E5			; [9] Disable the 8237 DMA controller chip.
 E072  8B D4			;----------------------------------------------------------------------------;
 E074  F7 C2 6A5A		INIT_DMA1:
 E078  B3 21				MOV	AL, MASK DDIS		; Set Controller Disable bit
 E07A  74 03 E9 008F			OUT	DMA_CMD, AL 		; write to DMA Command Register
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 49 - 1


 E07F  33 C0			
 E081  85 D2						IF POST_TEST_PIT_1 EQ 1
 E083  75 DB			;----------------------------------------------------------------------------;
 E085				; [10] Test Channel #1 on 8253 timer chip.
				;----------------------------------------------------------------------------;
				; Channel #1 on 8253 timer chip. Channel #1 is used in RAM refresh process.  
				; If the test fails, beep failure code
				;
 E085				; Test that all data lines are working by reading counter and checking 
 E085  E6 A0			; that all bits from counter go both high and low.
				;----------------------------------------------------------------------------;
				; Use 16-bit mode to test low three address lines using high byte of counter.
				; This avoids a situation where the read counter code is a binary multiple
				; of the counter causing a bit to not be observed as changing.
				;
				; Control Word Counter 1 (port 43H) - System Timer:
				;  01 		- SC: Select Counter 1
 E087				;    11		- RW: Read/Write 2xR/2xW
 E087  B0 01			;      010		- M:  Mode 2, Rate Gen
 E089  B3 31			;         0		- BCD: 0
 E08B  02 C0			;
 E08D  78 7F			; Output: Success SI and DI = 0, Failure 3 short, 2 long beeps
 E08F  74 7D			;----------------------------------------------------------------------------;
 E091  7A 7B				MOV	AL, PIT_CW <1, 11B, 2>	; Control Word: Counter 1
 E093  72 79									;   Format: R/W low/high byte: 11b
 E095  2C 03									;   Mode: 2 Rate Gen, BCD: 0
 E097  79 75				OUT	PIT_CTRL, AL		; set Counter mode
 E099  7B 73				MOV	DX, LOW PIT_CH1		; DX = PIT channel 1
 E09B  73 71				OUT	DX, AL			; set low byte (any value)
 E09D  98				MOV	SI, 0FFH SHL 3		; flag bits 10-3 for 1 check
 E09E  40				MOV	DI, NOT 0FFH SHL 3	; flag bits 10-3 for 0 check
 E09F  75 6D				OUT	DX, AL			; set high byte (any value)
 E0A1				INIT_PIT1_TEST:
					TEST	DI, DI			; have all bits flipped to 0?
					JNZ	INIT_PIT1_TEST_READ	; if not, keep reading PIT
					INC	SI				; have all bits flipped to 1?
					JZ	INIT_PIT1_TEST_DONE	; if so, success
					DEC	SI				; if not, undo INC and keep reading PIT
 E0A1  E6 83			INIT_PIT1_TEST_READ:
					MOV	AL, PIT_CW <1,0>		; latch Counter 1 command
					OUT	PIT_CTRL, AL		; write command to CTC
					IN	AL, DX			; read timer LSB
					MOV	AH, AL			; save LSB
 E0A3					IN	AL, DX			; read timer MSB
 E0A3  BA 03D8				AND	DI, AX			; clear all lines read as 0
 E0A6  EE				OR	SI, AX			; set all lines read as 1
 E0A7  40				LOOP	INIT_PIT1_TEST		; loop until timeout
 E0A8  B2 B8				MOV	BL, BEEP_SL <3,2>		; beep pattern (3 short, 2 long)
 E0AA  EE			HALT_ERROR:
					JMP	SHORT HALT_BEEP_1		; NEAR jump for POST errors
							ELSE
					JMP	SHORT INIT_PIT1_TEST_DONE ; jump over the NEAR jump
				HALT_ERROR:
 E0AB  81 3E 0472 R 1234		JMP	SHORT HALT_BEEP_1		; must still be here if PIT test is off
 E0B1  75 03				IO_DELAY_SHORT			; I/O delay
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 50 - 1


 E0B3  BD 8000						ENDIF
 E0B6				
				INIT_PIT1_TEST_DONE:
				
				;----------------------------------------------------------------------------;
				; [9B] 8253 PIT Programmable Interval Timer Initialization Channel 1
				;----------------------------------------------------------------------------;
 E0B6  48			; Counter 1 - DRAM Refresh
 E0B7  E6 43			;----------------------------------------------------------------------------;
 E0B9  E4 40			INIT_PIT1:
 E0BB  D0 E8				MOV	AL, PIT_CW <1, 01B, 2>	; Control Word: Select Counter(SC): 1
 E0BD  24 03									;   Format(RW): 01b (R/W byte LE)
 E0BF  0B E8									;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary)
					OUT	PIT_CTRL, AL		; set Counter mode
				
				;----------------------------------------------------------------------------;
				; [12] Reset, Clear and test DMA Offset and Block Size Registers
				;----------------------------------------------------------------------------;
				; - Master Reset of DMA controller
				; - Test 8237 DMA Address/Count Register channels 0-3
 E0C1  8C CA			;----------------------------------------------------------------------------;
 E0C3  8E D2				OUT	DMA_RESET, AL 		; Master Reset (send any value of AL)
				
							IF POST_TEST_DMA EQ 1
					MOV	BH, 8				; test 8 ports
					XOR	DX, DX			; starting at port 00H
					CALL_NS  PORT_TEST		; ZF and CX = 0 if pass, NZ if failed
					MOV	BL, BEEP_SL <4,2>		; beep pattern (4 short, 2 long)
 E0C5					JNZ	HALT_ERROR
				DMA_PASS:
					OUT	DMA_RESET, AL 		; master reset of DMA again
							ENDIF			; POST_TEST_DMA
 E0C5  B0 99			
							IF DRAM_REFRESH EQ 1
 E0C7  E6 63			;----------------------------------------------------------------------------;
				; [13] Set Counter DMA Channel 0 for memory refresh
				;----------------------------------------------------------------------------;
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/
				;----------------------------------------------------------------------------;
 E0C9  B0 AD				MOV	AL, 0FFH			; Memory refresh counter (16-bit) is 0FFFFH
 E0CB  E6 61				OUT	DMA_0_C, AL			; write low order bits
					NOP					; very short I/O delay
					OUT	DMA_0_C, AL			; write high order bits
				
				;----------------------------------------------------------------------------;
				; [13] Set Mode DMA Channel 0
				;----------------------------------------------------------------------------;
				; 01 			; Mode 1 (Single)
				;   0 		; INC: address decrement
				;    1 		; Auto-initialization
				;     10 		; type: Read from memory (2)
				;       00 		; Channel 0
				;----------------------------------------------------------------------------;
					MOV	AL, DMA_MR <1,0,1,2,0>
					OUT	DMA_MODE, AL		; write to DMA Mode Register
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 51 - 1


				
				;----------------------------------------------------------------------------;
				; [13B] 8253 Timer set channel #1 for DMA/DRAM refresh
				;----------------------------------------------------------------------------;
					MOV	AL, 18 			; divisor: 1.19318 MHz / 18 = 66,287.7 Hz
					OUT	PIT_CH1, AL			; refresh DRAM every 2ms
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [13C] Enable DMA and clear mask register on Channels 0-3
				;----------------------------------------------------------------------------;
					MOV	AL, DMA_CR <>		; Set Controller Enable bit
					OUT	DMA_CMD, AL 		; write to DMA Command Register
					MOV	CL, 3				; Set mode on Channels 1-3 for [13D]
										;  (and I/O delay between OUTs)
					OUT	DMA_MASK, AL		; clear mask (enable) on all channels
				
				;----------------------------------------------------------------------------;
				; [13D] Set default Mode for DMA Channels 1-3
				;----------------------------------------------------------------------------;
				; 01 			; Mode 1 (Single)
			     1				IF WARM_ENABLE EQ 1
 E0CD  85 ED		     1		TEST	BP, BP				; is warm boot?
 E0CF  78 12		     1		JS	CHECKSUM_OK					; jump if so
			     1				ENDIF
 E0D1				;   0 		; INC: address decrement
				;    0 		; No Auto-initialization
 E0D1  8E DA			;     00 		; type: Verify (0)
 E0D3  BE E000 R		;       xx 		; Channels 1-3
 E0D6  B5 10			;
 E0D8				; Input: CL = 3 (from [13C]), CH = 0 (from CALL_NS in [12])
 E0D8  AD			;----------------------------------------------------------------------------;
 E0D9  02 D0				MOV	AL, DMA_MR <1,0,0,0,1>	; start with channel 1
 E0DB  02 D4			DMA_SETUP_CH:
 E0DD  E2 F9				OUT	DMA_MODE, AL		; write to DMA Mode Register
 E0DF  B3 22				INC	AX				; next channel
 E0E1  75 2B				LOOP	DMA_SETUP_CH		; (delay 13-17 clocks between OUTs)
 E0E3				
				;----------------------------------------------------------------------------;
				; [14] Detect and enable expansion chassis / extension card
				;----------------------------------------------------------------------------;
				; http://minuszerodegrees.net/5161/doco/5161_documentation.htm
				;
 E0E3				; http://minuszerodegrees.net/5161/misc/5161_not_supported.htm
 E0E3  B0 04			; "note: research revealed that the substituted code is not required; the circuit 
 E0E5  E6 08			; diagram of the extender card shows that the card is automatically enabled 
				; at application of power."
				;
				; Based on the above, it would appear this is not necessary at all.
				;----------------------------------------------------------------------------;
				;INIT_EXP_CHASSIS:
				;	MOV	DX, 213H			; PC Expansion Chassis
				;	IN	AL, DX
				;	INC	AL 				; Is 213H == 0FFH?
				;	JZ	NO_EXP_CHASSIS 		; if so, no expansion chassis
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 52 - 1


				;	MOV	AL, 1 			; otherwise, send 1 to enable
				;	OUT	DX, AL
				;NO_EXP_CHASSIS:
				
				;----------------------------------------------------------------------------;
				; [15] Test and zero first 16KB of RAM
				;----------------------------------------------------------------------------;
				; This is necessary to utilize the BIOS Data Area and a usable stack
				;
				; Parity bits are in an indeterminate state on power up so parity check must
				; be disabled until memory is written once.
				;
				; On failure: 
				; - Read/Write Error: 1 short, 3 long beeps
 E0E7  B0 74			; - Parity Error: 1 short, 4 long beeps
				;
				; Input: CX = 0 from [13D]
 E0E9  E6 43			;----------------------------------------------------------------------------;
 E0EB  BA 0041						ASSUME DS:_BDA_ABS, ES:_IVT
 E0EE  EE			BASE_RAM_TEST:
 E0EF  BE 07F8				IN	AL, PPI_B 				; AL = PB0 flags
 E0F2  BF F807				OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags
 E0F5  EE				OUT	PPI_B, AL
 E0F6					XCHG	AX, CX				; AX = 0 = MEM_CHECK pattern and
 E0F6  85 FF				MOV	DS, AX				; DS and ES = IVT segment 0000
 E0F8  75 04				MOV	SI, OFFSET WARM_FLAG_ABS	; SI = warm boot flag offset
 E0FA  46				MOV	DX, [SI]				; save warm boot flag
 E0FB  74 13				CALL_NS  MEM_CHECK			; clear memory and parity bits
 E0FD  4E				JNZ	BASE_RAM_ERROR
 E0FE					IN	AL, PPI_B				; read PPI channel B
 E0FE  B0 40				OR	AL, MASK PBPC 			; clear MB RAM parity flag only
 E100  E6 43				OUT	PPI_B, AL
 E102  EC				AND	AL, NOT MASK PBPC 		; enable MB RAM parity for test
 E103  8A E0				OUT	PPI_B, AL
 E105  EC				CALL_NS  MEM_ADDR_TEST			; test address lines
 E106  23 F8				JZ	BASE_RAM_ZERO			; continue if no errors
 E108  0B F0			BASE_RAM_ERROR:
 E10A  E2 EA				MOV	BL, BEEP_SL <1,3>			; on failure, 1 short and 3 long beeps
 E10C  B3 32			HALT_BEEP_1:
 E10E					JMP	HALT_BEEP				; NEAR jump to HALT BEEP PROC
 E10E  EB 55			BASE_RAM_ZERO:
					MOV	AX, RAM_TEST			; test pattern
					CALL_NS  MEM_CHECK			; write and verify test pattern
					JNZ	BASE_RAM_ERROR			; ZF and AX = 0 if okay
					CALL_NS  MEM_CHECK			; write and verify zeros
					JNZ	BASE_RAM_ERROR
					XCHG	[SI], DX				; restore warm boot flag, DX = 0
					INC	AX					; AL = 1
 E110					MOV	FD_MOTOR_CT_ABS, AL 		; set motor to turn off on next tick
							IF RAM_PARITY EQ 1
					IN	AL, PPI_C				; read PPI channel C
					AND	AL, MASK PCPE			; check MB RAM parity flag
					JZ	BASE_RAM_TEST_DONE		; either set?
					MOV	BL, BEEP_SL <1,4>			; Halt with 1 short beep, 4 long beeps
					JMP	SHORT HALT_BEEP_1
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 53 - 1


 E110				BASE_RAM_TEST_DONE:
 E110  B0 54				IN	AL, PPI_B
					OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags
					OUT	PPI_B, AL
 E112  E6 43						ENDIF				; END RAM_PARITY EQ 1
				
				;----------------------------------------------------------------------------;
				;
				; YAY! It's now okay to use the first 16KB of RAM: 0000:0000-0000:1FFF
				;
				;----------------------------------------------------------------------------;
				
 E114  E6 0D			;----------------------------------------------------------------------------;
				; [18] Setup BOOT R/W stack memory segment
				;----------------------------------------------------------------------------;
 E116  B7 08						ASSUME SS:_BOOT_STACK
 E118  33 D2				MOV	AX, SEG STACK_TOP 		; SP to temp boot stack 0030:0100
					MOV	SS, AX
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E11A  BC E120 R	     1		MOV	SP, OFFSET ??0001
			     1				IFNB <>
			     1		JMP	SHORT PORT_TEST
			     1				ELSE
 E11D  E9 06CE		     1		JMP	PORT_TEST
			     1				ENDIF
 E120			     1	??0001:
 E120  E122 R		     1		DW	OFFSET ??0002
 E122			     1	??0002:
 E122  B3 42				MOV	SP, OFFSET STACK_TOP
 E124  75 E8			
 E126				;----------------------------------------------------------------------------;
 E126  E6 0D			; [19] 8259A PIC Interrupt controller Initialization
				;----------------------------------------------------------------------------;
				; PIC chip Initialization as follows:
				;
				; ICW1:
				;     1 		- D4:   1 = ICW1 (and Port 0)
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition)
				;       0 		- ADI:  0 = Call Address Interval of 8
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3)
				;         1		- IC4:  1 = ICW4 Needed
				;----------------------------------------------------------------------------;
				; ICW2:
				;  00001 		- T7-T3: Interrupt Vector Address:
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15
				;       000 	- D2-D0: unused on 8086 mode
				;----------------------------------------------------------------------------;
				; ICW4:
				;     0		- SFNM: 0 = Not Special Fully Nested Mode
				;      10		- BUF:  2 = Buffered Mode/Slave
				;        0		- AEOI: 0 = normal EOI
				;         1		- uPM:  1 = 8086 system
				;----------------------------------------------------------------------------;
					MOV	DL, LOW INT_P0		; DX = PIC Port 0
					MOV	AL, ICW1 <1,0,0,1,1>	; ICW1 - Port 0
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 54 - 1


					OUT	DX, AL
					INC	DX				; DX = PIC Port 1
					MOV	AL, ICW2 <1>		; ICW2 - Port 1
					OUT	DX, AL
					MOV	BH, 1				; short delay and test 1 port for [22]
					MOV	AL, ICW4 <0,2,0,1>	; ICW4 - Port 1
					OUT	DX, AL
				
							IF POST_TEST_PIC_REG EQ 1
				;----------------------------------------------------------------------------;
				; [22] 8259A PIC Test
				;----------------------------------------------------------------------------;
 E128  B0 00			; - Read and write registers (IMR) and verify result
 E12A  E6 08			;----------------------------------------------------------------------------;
 E12C  B1 03				CALL	PORT_TEST			; test of PIC IMR register
					MOV	BL, BEEP_SL <5,2>		; beep error 5 short, 2 long
 E12E  E6 0A				JZ	PIC_REG_PASS
				PIC_INT_FAIL:
					JMP	SHORT HALT_BEEP_1
				PIC_REG_PASS:
					DEC	DX				; DX = Port 1 (0021h)
							ELSE
					NOP
							ENDIF			; IF POST_TEST_PIC_REG EQ 1
				
					MOV	AL, OCW1 <1,1,1,1,1,1,1,1> ; OCW1 - mask all interrupts (for now)
					OUT	DX, AL			; write IMR to PIC
				
							IF POST_TEST_PIC_INT EQ 1
 E130  B0 41			;----------------------------------------------------------------------------;
 E132				; - Set up test interrupt handler for all interrupts
 E132  E6 0B			;
 E134  40			PIC_INT_TEST:
 E135  E2 FB				MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE)
					XOR	DI, DI			; DI = beginning to IVT
				PIC_VECT_TMP_LOOP:
					MOV	AX, OFFSET INT_IRQ	; offset for handler
					STOSW					; write to IVT
					MOV	AX, CS			; segment for hanlder (BIOS)
					STOSW					; write to IVT
					LOOP	PIC_VECT_TMP_LOOP
				
				;----------------------------------------------------------------------------;
				; - Mask all interrupts and ensure none are received
				; Input: AL = 0 (from MOV AX, CS)
				;
					MOV	DI, OFFSET INT_LAST_ABS
					MOV	[DI], AL			; clear last interrupt flag
					STI					; enable interrupts
					IO_DELAY				; wait for it...
					CLI
					INC	BX				; beep error 5 short, 3 long
					OR	[DI], AL			; did any interrupts happen?
				
							IF POST_TEST_PIC_REG EQ 1
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 55 - 1


					JNZ	PIC_INT_FAIL
							ELSE
					JZ	PIC_INT_PASS
					JMP	SHORT HALT_BEEP_1
							ENDIF			; IF POST_TEST_PIC_REG EQ 1
							ENDIF			; IF POST_TEST_PIC_INT EQ 1
				
					MOV	AL, NOT MASK IRQ0		; OCW1 - unmask timer
					OUT	DX, AL			; write IMR to PIC
				
				PIC_INT_PASS:
				
				;----------------------------------------------------------------------------;
				; [23] Setup Channel #0 on 8253 timer chip.
				;----------------------------------------------------------------------------;
				; Control Word Counter 0 (port 43H) - System Timer:
 E137				;  00 		- SC: Select Counter 0
 E137  E4 61			;    11		- RW: Read/Write 2xR/2xW
 E139  0C 30			;      011		- M:  Mode 3, Square Wave
 E13B  E6 61			;         0		- BCD: 0
 E13D  91			;----------------------------------------------------------------------------;
 E13E  8E D8				MOV	AL, PIT_CW <0, 11B, 3>	; Control Word: Select Counter(SC): 1
 E140  BE 0472 R								;   Format(RW): 11b (Read/Write 2xR/2xW)
 E143  8B 14									;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary)
					OUT	PIT_CTRL, AL
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E145  BC E14B R	     1		MOV	SP, OFFSET ??0003
			     1				IFNB <>
			     1		JMP	SHORT MEM_CHECK
			     1				ELSE
 E148  E9 04C8		     1		JMP	MEM_CHECK
			     1				ENDIF
 E14B			     1	??0003:
 E14B  E14D R		     1		DW	OFFSET ??0004
 E14D			     1	??0004:
 E14D  75 14				PUSH	CS				; I/O delay and set up for DS = CS below
 E14F  E4 61			
 E151  0C 10			;----------------------------------------------------------------------------;
 E153  E6 61			; This is what generates IRQ 0 (system timer).
 E155  24 EF			; Timer set channel #0 output to a square wave of approx. 18.2 Hz based on
 E157  E6 61			;	f = 1,193,180 / 10000H = ~ 18.2Hz
				; Reload counter to WORD (0) to port 40H
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E159  BC E15F R	     1		MOV	SP, OFFSET ??0005
			     1				IFNB <>
			     1		JMP	SHORT MEM_ADDR_TEST
			     1				ELSE
 E15C  E9 0486		     1		JMP	MEM_ADDR_TEST
			     1				ENDIF
 E15F			     1	??0005:
 E15F  E161 R		     1		DW	OFFSET ??0006
 E161			     1	??0006:
 E161  74 05			;
 E163					XOR	AL, AL			; reload counter is 2^16 (0) ~ 18.2Hz
 E163  B3 13				OUT	PIT_CH0, AL	  		; send low byte
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 56 - 1


 E165					POP	DS				; I/O delay and set DS = CS
 E165  E9 070C				OUT	PIT_CH0, AL 		; send high byte
 E168				
 E168  B8 95A5			;----------------------------------------------------------------------------;
				; [25] Setup default BIOS interrupt vectors (00h - 01Eh)
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E16B  BC E171 R	     1		MOV	SP, OFFSET ??0007
			     1				IFNB <>
			     1		JMP	SHORT MEM_CHECK
			     1				ELSE
 E16E  E9 04A2		     1		JMP	MEM_CHECK
			     1				ENDIF
 E171			     1	??0007:
 E171  E173 R		     1		DW	OFFSET ??0008
 E173			     1	??0008:
 E173  75 EE			;----------------------------------------------------------------------------;
				; All segments are set to BIOS (CS) segment by default.
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E175  BC E17B R	     1		MOV	SP, OFFSET ??0009
			     1				IFNB <>
			     1		JMP	SHORT MEM_CHECK
			     1				ELSE
 E178  E9 0498		     1		JMP	MEM_CHECK
			     1				ENDIF
 E17B			     1	??0009:
 E17B  E17D R		     1		DW	OFFSET ??000A
 E17D			     1	??000A:
 E17D  75 E4			; INT 1Fh is skipped and left as 0000:0000.
 E17F  87 14			; Exceptions (such as ROM BASIC) are reset below.
 E181  40			;----------------------------------------------------------------------------;
 E182  A2 0440 R					ASSUME DS:BIOS, ES:_IVT
				INIT_SW_INT_VECTORS:
					MOV	AX, CS 			; AX to BIOS segment
					MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE)
					XOR	DI, DI			; DI = beginning to IVT
					MOV	SI, OFFSET VECTOR_TABLE
				BIOS_INT_VECTORS_LOOP:
					MOVSW 				; copy vector offset to IVT
					STOSW 				; write BIOS/CS segment
					LOOP	BIOS_INT_VECTORS_LOOP	; loop and set CX = 0
				
							IF BASIC_ROM EQ 1
				;----------------------------------------------------------------------------;
				; Check for valid BASIC ROMs and set INT 18H vector if detected
				;----------------------------------------------------------------------------;
				; - Scan 4 x 8K ROMs starting at seg 0F600h.
				; - BASIC dectected if for all ROMs, all of the folowing are true:
				; 	- first two bytes not option ROM (0AAFFh)
				;	- first two bytes not the same as the previous ROM (this checks to
				;		 make sure are not all 0000 or FFFF)
				;	- 8K ROM block has a valid checksum at offset 1FFE
				;----------------------------------------------------------------------------;
							ASSUME DS:_BASIC
 E185  B8 ---- R		INIT_ROM_BASIC_SEG:
 E188  8E D0				MOV	BX, SEG _BASIC 			; BX = BASIC SEG in ROM
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 57 - 1


 E18A  BC 0100 R			MOV	SI, BX				; SI = save first BASIC SEG
					MOV	DI, MAGIC_WORD			; start with a negative check result
					MOV	CL, 4					; checksum 4 x 8K ROMs
				CHECK_BASIC_ROM:
					MOV	DS, BX				; set DS to current segment
					MOV	AX, BASIC_TOP			; AX = first two bytes of ROM
					CMP	AX, MAGIC_WORD			; is an option ROM?
					JE	INIT_ROM_BASIC_DONE		; if so, not ROM BASIC
					XCHG	AX, DI				; save last ROM's header to DI
					CMP	AX, DI				; is same as last ROM?
					JE	INIT_ROM_BASIC_DONE		; if so, valid ROM not present
					MOV	AL, 8 * 1024 / 512 		; 8K ROM size (in 512B blocks)
					ADD	BH, HIGH (8 * 1024 SHR 4)	; BX = next BASIC 8K ROM segment
					CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, size AL
					LOOPZ	CHECK_BASIC_ROM			; loop 4 ROMs or checksum fail
					JNZ	INIT_ROM_BASIC_DONE		; if NZ, checksum failed
				
				;----------------------------------------------------------------------------;
				; BASIC ROM detected - set as INT 18h in IVT
				;
					MOV	DI, OFFSET IVT_18			; DI = BASIC offset in IVT
					XCHG	AX, CX				; AX = vector offset 0000
					STOSW 					; write to IVT
					XCHG	AX, SI 				; AX = BASIC SEG
					STOSW						; write to IVT
 E18D  B2 20			INIT_ROM_BASIC_DONE:
 E18F  B0 13						ENDIF
 E191  EE			
 E192  42			;----------------------------------------------------------------------------;
 E193  B0 08			; [18] Setup DS and ES to BDA segment
 E195  EE			;----------------------------------------------------------------------------;
 E196  B7 01						ASSUME DS:_BDA, ES:_BDA
 E198  B0 09				MOV	AX, SEG _BDA 			; DS and ES to BDA
 E19A  EE				MOV	DS, AX
					MOV	ES, AX
				
				;----------------------------------------------------------------------------;
				; Check CPU type
				;----------------------------------------------------------------------------;
				; If V20 is build target but V20 not detected - beep 1 long, 4 short
				;----------------------------------------------------------------------------;
 E19B  E8 0650			CPU_IS_V20:
 E19E  B3 52				MOV	AX, DBW <1,1>			; Attempt to pack bytes into nibbles
 E1A0  74 02				DB	0D5H, 10H				; AAD	10H
 E1A2					CMP	AL, 0BH				; result is 0Bh if V20, 11h if x86
 E1A2  EB C1										;   ZF = 1 if V20, ZF = 0 if 8088
 E1A4					JNZ	CPU_TYPE_8088			; jump if not V20
 E1A4  4A				SET_GFLAG	V20				; set V20 flag
							IF CPU_TYPE	EQ CPU_V20
					JMP	SHORT CPU_TYPE_DONE		; continue booting
				CPU_TYPE_8088:
					MOV	BL, BEEP_SL <4,1>			; Build is V20 but not detected
 E1A5  B0 FF				JMP	SHORT HALT_BEEP_2			;  beep 4 short, 1 long
 E1A7  EE						ELSE
				CPU_TYPE_8088:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 58 - 1


							ENDIF
				CPU_TYPE_DONE:
				
				;----------------------------------------------------------------------------;
 E1A8				; [14] Read DIP switch settings and init proper EQUIP_FLAGS
 E1A8  B1 1F			;----------------------------------------------------------------------------;
 E1AA  33 FF			;
 E1AC				; https://sites.google.com/site/pcdosretro/biosdata
 E1AC  B8 FF23 R		; https://stanislavs.org/helppc/int_11.html
 E1AF  AB			;
 E1B0  8C C8			; 5150 Sense Switches:
 E1B2  AB			;  Port A - when Port B bit 7 = 1
 E1B3  E2 F7			;     High| Low
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4)
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA)
				;	    |00		; MB RAM (00=16KB, 01=32K, 10=48K, 11=64K)
				;	    |  0		; FPU installed ("Reserved")
				; 	    |   0		; IPL Floppy Disk Drive (0=floppy drive installed)
 E1B5  BF 046B R		;  Port C - I/O RAM (x 32KB)
 E1B8  88 05			;	High| Low
 E1BA  FB			;	    |4321		; RAM size bits 1-4   when Port B bit 2 = 1
				;	     4325		; RAM size bits 5,2-4 when Port B bit 2 = 0
			     1			LOCAL _DONE
 E1BB			     1	??000B:
 E1BB  E2 FE		     1		LOOP	??000B					; long delay for I/O
 E1BD  FA			;----------------------------------------------------------------------------;
 E1BE  43			; 5160 Sense Switches:
 E1BF  08 05			;  Port C
				;	High| Low
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4)
 E1C1  75 DF			; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA)
				;	    |00		; MB RAM Banks (00=Bank 0, Bank 0/1, 10=0/1/2, 11=0/1/2/3)
				;	    |  0		; FPU installed
				; 	    |   0		; Test Loop (always 0)
				;
				; EQUIP_FLAGS: LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VIDM:2,MBRAM:2,FPU:1,IPL:1
				;----------------------------------------------------------------------------;
 E1C3  B0 FE			GET_SW_SETTINGS:
 E1C5  EE				IN	AL, PPI_B 				; read Port B register
					PUSH	AX					; save original switches, AH = 0
 E1C6				
						IF ARCH_TYPE EQ ARCH_5150
				;----------------------------------------------------------------------------;
				; Is a 5150 build
				;
				SETTINGS_5150:
					OR	AL, MASK PBKB OR MASK PBSW	; Enable SW1 switches, SW2 1-4
					OUT	PPI_B, AL
					XCHG	AX, CX				; save modified settings
				
				;----------------------------------------------------------------------------;
 E1C6  B0 36			; Read 5150 memory size from SW1 3,4 (motherboard) and SW2 1-5 (expansion)
				;
					IN	AL, PPI_C				; get expansion card memory size
 E1C8  E6 43				AND	AL, 1111B				; isolate memory size (in 32KB)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 59 - 1


 E1CA  0E				MOV	CH, AL				; save low 4 bits
					XCHG	AX, CX				; AL = switches, AH = low 4 bits
					AND	AL, NOT MASK PBSW			; Read SW2 5
					OUT	PPI_B, AL
					IN	AL, PPI_C				; read bit 5
					AND	AL, 0001B				; isolate memory size bit 5
					MOV	CL, 4
					SHL	AL, CL				; shift into correct position
 E1CB  32 C0				OR	AL, AH				; combine with bits 1-4
 E1CD  E6 40				CBW						; clear AH
 E1CF  1F				INC	CX					; convert to KB (CL = 5)
 E1D0  E6 40				SHL	AX, CL				; AX = blocks * 32
					XCHG	AX, DX				; DX = expansion RAM in KB
				
				;----------------------------------------------------------------------------;
				; Get motherboard RAM size
				;
					IN	AL, PPI_A				; get drive, MB RAM, video
					PUSH	AX					; save SW1
					AND	AL, MASK PCMB			; isolate MB RAM
					ADD	AL, 4					; start at 16KB since SW1 00 = 16KB
 E1D2					SHL	AX, 1					; AX = MB RAM size in KB
 E1D2  8C C8				SHL	AX, 1					; (AX = AX * 4)
 E1D4  B1 1F				ADD	AX, DX				; add expansion RAM to total
 E1D6  33 FF				MOV	MEM_SZ_PC, AX			; save to BDA
 E1D8  BE FEE3 R			POP	AX					; restore SW1
 E1DB				
 E1DB  A5					ELSE
 E1DC  AB					IF ARCH_TYPE EQ ARCH_FE2010
 E1DD  E2 FC			;----------------------------------------------------------------------------;
				; Is a FE2010A PC
				; Note: FPU won't be detected if BOOT_NORMAL (too many bytes to fix)
				;
				; Set AL for BDA / switch register
				; Set AH for system config register
				;
				SETTINGS_FE2010:
					AND	AL, NOT MASK PBSW			; select register for PPI Bits 4-7
					OUT	PPI_B, AL				; port 61H Control Register
					AND	AL, MASK PBTB			; Turbo bit set?
					JZ	SETTINGS_FE2010_1			; jump if not turbo (AH already 0)
					MOV	AX, DBW <FE_CR <,,,,1,>>	; set AH default with FPU bit, clear AL
				SETTINGS_FE2010_1:
					OUT	PPI_C, AL				; write 0 to port 62H Switch Register
					IN	AL, PPI_C				; port 62H Switch Register
							IF CPU_TYPE	EQ CPU_V20
					SHL	AL, 4					; shift drives and video to high nibble
							ELSE
					MOV	CL, 4
					SHL	AL, CL				; shift drives and video to high nibble
							ENDIF
					AND	AL, MASK VIDM			; Bits 4-5 Video only
					OR	AL, EQFLAGS <,,,,,SW1_FLP AND 1,,,1>; set FPU: 1, defaults and SW1_FLP
											;   FD: 00b=1 drive, 01b=2 drives
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 60 - 1


						ELSE					; not ARCH_5150 OR ARCH_FE2010
						IF ARCH_TYPE EQ ARCH_EHB
				;----------------------------------------------------------------------------;
				; Is EMM/Homebrew 8088
				;
					MOV	AL, EQFLAGS <,,,,,SW1_FLP,SW1_VID>	; use preconfigured values
				
						ELSE
				;----------------------------------------------------------------------------;
				; Is a 5160 or standard PPI
				;
				SETTINGS_5160:
					AND	AL, NOT MASK PBSW			; set bit 3 = 0 for low switch select
					PUSH	AX		 			; save port settings
					OUT	PPI_B, AL
					IN	AL, PPI_C 				; get low switches
					AND	AL, MASK MBRAM OR MASK FPU OR MASK IPL ; isolate MB RAM and FPU bits
					MOV	CH, AL				; save to CH
					POP	AX 					; get port settings
					OR	AL, MASK PBSW 			; set bit 3 = 1 for high switch select
					OUT	PPI_B, AL
					IN	AL, PPI_C 				; get high switches
 E1DF  B8 ---- R					IF CPU_TYPE	EQ CPU_V20
 E1E2  8E D8				SHL	AL, 4					; shift drives and video to high nibble
 E1E4  8E C0						ELSE
					MOV	CL, 4
					SHL	AL, CL				; shift drives and video to high nibble
							ENDIF
					OR	AL, CH				; combine RAM, FPU with drives and vid
				
							IF MAX_RAM_AUTO EQ 1
 E1E6				;----------------------------------------------------------------------------;
 E1E6  B8 0101			; Set MAX_RAM from video DIP switches: CGA=736, MDA=704 else 640
 E1E9  D5 10			; 21 bytes
 E1EB  3C 0B			;
					PUSH	AX					; save original equipment byte
 E1ED  75 05				MOV	DX, MAX_RAM_PC			; default 640K
					AND	AL, MASK VIDM			; bits 4-5 video only
			     1				IFNB	<>
			     1		AND	GB_FLAGS, MASK V20		; clear existing flag(s)
			     1				ENDIF
 E1EF  80 0E 0012 R 04	     1		OR	GB_FLAGS, MASK V20		; set flag(s)
					JZ	MAX_RAM_AUTO_DONE			; done if EGA/VGA (off, off)
					MOV	DL, LOW MAX_RAM_MDA		; try MDA 704K
					CMP	AL, 11b SHL 4			; is MDA (on, on)?
					JE	MAX_RAM_AUTO_DONE			; done if MDA
					MOV	DL, LOW MAX_RAM_CGA		; else CGA 736K
				MAX_RAM_AUTO_DONE:
 E1F4					MOV	MEM_SZ_PC, DX			; save to BDA
					POP	AX					; restore equipment byte
 E1F4							ENDIF
				
						ENDIF					; not ARCH_TYPE EQ ARCH_EHB
						ENDIF					; not ARCH_TYPE EQ ARCH_FE2010
						ENDIF					; not ARCH_TYPE EQ ARCH_5150
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 61 - 1


				
				SETTINGS_DONE:
				;----------------------------------------------------------------------------;
				; If set on MB DIP SW1, test and verify FPU. If not detected, disable in BDA.
				;
					TEST	AL, MASK FPU			; is FPU set?
					JZ	SETTINGS_SAVE			; if not, skip to save flags
					CALL	HAS_FPU				; check FPU, ZF=0 if not detected
					JZ	SETTINGS_SAVE			; if detected, save flags
							IF ARCH_TYPE EQ ARCH_FE2010
					AND	AX, NOT DBW <MASK FPU, MASK FPU> ; otherwise clear FPU flags
							ELSE
					AND	AL, NOT MASK FPU			; otherwise clear FPU flag
							ENDIF
				SETTINGS_SAVE:
					MOV	BYTE PTR EQUIP_FLAGS, AL	; set to low byte of EQUIP_FLAGS
				
							IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; Write to FE2010A switch registers
				;
					OUT	PPI_C, AL				; write to switch register
					XCHG	AH, AL
					CALL	FE2010_SETUP_SAVE			; save to memory and register
					XCHG	AH, AL
					CBW						; clear AH (cannot have > 2 FDs)
							ENDIF
				
 E1F4					XCHG	AX, DX				; save EQUIP_FLAGS to DL for later
 E1F4  E4 61				POP	AX					; AL = original settings, AH = 0
 E1F6  50				OUT	PPI_B, AL				; restore original settings
				
							IF ARCH_SUB_TYPE EQ ARCH_VEN888
				;----------------------------------------------------------------------------;
				; Set initial speed for Vendex 888-XT
				;
					CALL	TOGGLE_TURBO			; set speed according to PPI (reversed)
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [21] Video BIOS Option ROM scan
				;----------------------------------------------------------------------------;
				; Scan 0C000H - 0C800H for video option ROMs (EGA, VGA, etc)
				;
				; A video option ROM should set the BDA video type flag to a non-zero value
				; If the flag is still 0 afterwards, no ROMs loaded succesfully.
				;----------------------------------------------------------------------------;
					MOV	AX, SEG _VID_BIOS			; starting segment (C000H)
					MOV	DI, SEG _OPT_ROM			; ending segment (C800H)
					PUSH	DX					; save EQUIP_FLAGS for below
					CALL	BIOS_ROM_SCAN			; scan segments AX to DI for ROMs
					POP	DX					; restore EQUIP_FLAGS
				
				;----------------------------------------------------------------------------;
				; Check for a valid video mode in BDA:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 62 - 1


				;  - If BDA video mode is 0, video option ROM was not loaded. Beep and halt
				;  - If MB video switch is 0 (option ROM), skip reset
				;  - If not 0, determine correct 6845 video mode and do INT 10H reset
				;----------------------------------------------------------------------------;
					GET_EFLAG  VIDM				; AX = 00=error(ZF), 01=CGA 40, 10=CGA 80, 11=MDA
					XCHG	AX, DX				; AL = EQUIP_FLAGS, DX = BDA initial video mode
					JNZ	VID_MODE_OK				; jump if mode valid or video option ROM loa
				ded
					MOV	BL, BEEP_SL <3,3>			; Beep 3 long, 3 short
				HALT_BEEP_2:
					JMP	HALT_BEEP				; NEAR jump to beep
				VID_MODE_OK:
					TEST	AL, MASK VIDM			; is SW1 mode 00?
					JZ	RESET_VIDEO_DONE			; if custom video ROM, skip reset
					DEC	DX
					MOV	AX, 1					; CGA 40x25 color, AH = 0 (for INT 10h below
				)
					JZ	RESET_VIDEO				; ZF if CGA 40
					MOV	AL, 3					; CGA 80x25 color
					DEC	DX					; ZF if CGA 80
					JZ	RESET_VIDEO				; jump if CGA, fall through if Mono
					MOV	AL, 7					; else Mono
				
				;----------------------------------------------------------------------------;
				; Clear screen and reset the video display.
				;
				RESET_VIDEO:
					INT	10H					; AH = 0 - Set Video Mode
				RESET_VIDEO_DONE:
				
				;----------------------------------------------------------------------------;
				; Hello Computer ("just use the keyboard")
				;----------------------------------------------------------------------------;
				HELLO_WORLD:
							IF RANDOM_TAGLINE EQ 1
					CALL	HELLO_RAND_TAGLINE		; display banner and random tagline
							ELSE
					PRINTLN_SZ	TOP_BANNER			; display banner and fixed tagline
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Save the initial cursor mode to BDA for hot key and POST display
				;
					XOR	BX, BX				; BH = video page 0
					MOV	AH, 3					; get cursor: CX = power-on cursor
					INT	10H					;  DX = position
					MOV	CURSOR_DEFAULT, CX		; save to BDA for Turbo toggle
				
				;----------------------------------------------------------------------------;
				; Display VERSION notice in bottom left
				;
					PUSH	DX					; save cursor position
					MOV	DX, DBW <24, 0> 			; bottom left row = 24, col = 0
					MOV	AH, 2 				; set bottom cursor position 
					INT	10H 					; row = DH, column = DL
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 63 - 1


					PRINT_SZ  VER				; display version
					PRINT_SZ  REL_DATE			; display build date
					POP	DX					; restore previous cursor
					MOV	AH, 2 				; reset cursor position
 E1F7					INT	10H 					; row = DH, column = DL
 E1F7  24 F7			
 E1F9  50			;----------------------------------------------------------------------------;
 E1FA  E6 61			; Jump over INT 02h fixed ORG to continue...
 E1FC  E4 62			;
 E1FE  24 0F						IF (ARCH_TYPE EQ ARCH_EMU) OR (ARCH_TYPE EQ ARCH_EHB) OR (ARCH_TYPE EQ ARCH_
				FE2010)
 E200  8A E8				JMP	 NEAR PTR INT_02_AFTER			; (jump hack)
 E202  58						ELSE
 E203  0C 08				JMP	 SHORT INT_02_AFTER
 E205  E6 61						ENDIF
 E207  E4 62			
							IF IS_TURBO
				;----------------------------------------------------------------------------;
				; Toggle Turbo mode on/off
 E209  B1 04			;----------------------------------------------------------------------------;
 E20B  D2 E0			; Note: some references state that flipping both bit 2 and 3 (0Ch) are
				; required, and some only bit 2 (04h). Flipping only bit 2 seems to work fine.
 E20D  0A C5			;
				; Size: 25 bytes
				;
				; Clobbers AX, CX, DX
				;----------------------------------------------------------------------------;
				; NOTE: ORG located here to fill the space taken up by additional 5150 code
				;----------------------------------------------------------------------------;
 E20F  50			TOGGLE_TURBO PROC
 E210  BA 0280						ASSUME DS:_BDA
 E213  24 30				CLI						; interrupts off
 E215  74 08			
 E217  B2 C0					IF ARCH_TYPE EQ ARCH_TD3300
 E219  3C 30			;----------------------------------------------------------------------------;
 E21B  74 02			; TD3300A Port 90h Turbo switch
 E21D  B2 E0			; If port 90 == 1, send 2 (0010b) Normal -> Turbo
 E21F				; If port 90 == 0, send 3 (0011b) Turbo -> Normal
 E21F  89 16 0015 R		;
 E223  58				IN	AL, TD_TURBO			; read current state
					CMP	AL, MASK TDSS			; is 1 or 0?
					JA	TOGGLE_TURBO_DONE			; exit if register not valid
					JZ	TOGGLE_TURBO_TD_1			; jump if 1 (currently Turbo)
					OR	AL, MASK TDSH			; set software speed bit
				TOGGLE_TURBO_TD_1:
					XOR	AL, MASK TDSS			; toggle turbo bit
 E224					OUT	TD_TURBO, AL			; write to board
					CMP	AL, MASK TDSH OR MASK TDSS	; turbo on? (NZ = turbo)
				
							ELSE				; NOT ARCH_TD3300
 E224  A8 02			;----------------------------------------------------------------------------;
 E226  74 07			; Standard PPI B Turbo switch
 E228  E8 1D98			;
 E22B  74 02				IN	AL, PPI_B				; read PPI
					XOR	AL, MASK PBTB			; flip turbo bit
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 64 - 1


					OUT	PPI_B, AL
				
 E22D  24 FD						IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
 E22F				; FE2010 Turbo switch
 E22F  A2 0010 R		;
					XCHG	AX, CX				; save AX
					MOV	AL, FE2010_CONF_REG		; get current register
					XOR	AL, FE_CR <> AND MASK FSPD	; flip speed bit(s)
					CALL	FE2010_SETUP_SAVE			; write to memory and register
					XCHG	AX, CX				; restore AX
							ENDIF				; ARCH_FE2010
				
							IF ARCH_TYPE EQ ARCH_UM82
				;----------------------------------------------------------------------------;
				; UM82C088 speed mode
				;
					OUT	UM82_SPEED, AL			; write any value to toggle speed
 E232  92						ENDIF				; ARCH_UM82
 E233  58			
 E234  E6 61						IF ARCH_SUB_TYPE EQ ARCH_VEN888
				;----------------------------------------------------------------------------;
				; Vendex 888-XT
				; For turbo: Write 3 then 1 to 0C0H
				; For slow:  Write 2 then 1 to 0C0H
				;----------------------------------------------------------------------------;
				; Input:
				;	Turbo: AL = xxxxx1xx	-> 3 (0011)
				;	Slow:  AL = xxxxx0xx	-> 2 (0010)
				;
					AND	AL, MASK PBTB			; AL = 4 (NZ) if turbo, 0 (ZF) if slow
					XCHG	AX, CX				; save original turbo bit
					MOV	AL, 3					; AL = 3 - assume turbo
					JNZ	VEN888_TURBO
					DEC	AX					; AL = 2 - speed normal
				VEN888_TURBO:
					OUT	0C0H, AL				; write speed
 E236  B8 ---- R			MOV	AL, 1					; software select bit
 E239  BF ---- R			OUT	0C0H, AL				; write bit
 E23C  52				XCHG	AX, CX				; restore original turbo bit
 E23D  E8 02AD						ENDIF
 E240  5A			
							IF ARCH_TYPE EQ ARCH_EHB
				;----------------------------------------------------------------------------;
				; EMM Homebrew/V40 - Toggle wait state FF = 3 W/S, 0 = zero W/S
				;
					MOV	DX, V40_WCR1			; V40 wait state register
					IN	AL, DX				; read current register
					NOT	AL					; toggle FF to 0
					OUT	DX, AL				; write register
			     1			LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
			     1				IFNB <>
			     1		PUSH	CX					; save CX
			     1		PUSH	DS
			     1		MOV	CX, SEG _BDA			; DS = BDA
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 65 - 1


			     1		MOV	DS, CX
			     1				ENDIF
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Shift if flag is in high byte to low for byte operations
			     1	;
			     1				IF VIDM LT 8		; is in low byte?
 = 0030			     1	??000C	= MASK VIDM
 = 0004			     1	??000D	= VIDM AND 0111B
 = 0010			     1	??000E	= EQUIP_FLAGS[0]			; low BDA flags byte
			     1				ELSE				; is in high byte
			     1	??000C	= HIGH MASK VIDM
			     1	??000D	= (VIDM - 8) AND 0111B
			     1	??000E	= EQUIP_FLAGS[1]			; high BDA flags byte
			     1				ENDIF
			     1	
 E241  A0 0010 R	     1		MOV	AL, BYTE PTR ??000E
 E244  83 E0 30		     1		AND	AX, ??000C			; clear AH
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Determine optimal number of shifts based on bit position and shift
			     1	; right or left depending on fewest.
			     1	;
			     1				IF CPU_TYPE	EQ CPU_V20
			     1					IF ??000D GT 4
			     1		ROL	AL, 8-??000D			; shift value into position
			     1					ELSE
			     1		ROR	AL, ??000D			; shift value into position
			     1					ENDIF
			     1				ELSE
			     1					IF ??000D GT 4
			     1		MOV	CL, 8-??000D			; CL = bit(s) position of record
			     1		ROL	AL, CL				; shift value into position
			     1					ELSE
 E247  B1 04		     1		MOV	CL, ??000D			; CL = bit(s) position of record
 E249  D2 C8		     1		ROR	AL, CL				; shift value into position
			     1					ENDIF
			     1				ENDIF
			     1				IFNB <>
			     1		POP	DS
			     1		POP	CX
			     1				ENDIF
 E24B  92				NOT	AL					; revert since NZ is Turbo
 E24C  75 05						ENDIF				; ARCH_EHB
 E24E  B3 33			
 E250							IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST)
 E250  E9 0621			;----------------------------------------------------------------------------;
 E253				; PCXT_MiSTer - Toggle between 4 MHz AT and 5MHz XT
 E253  A8 30			;
 E255  74 0F				MOV	DX, MC_PORT				; DX = XTCTL port
 E257  4A				IN	AL, DX				; read current speed
 E258  B8 0001				AND	AL, NOT MCSP_LOW			; clear high bit (if set by XTCTL)
 E25B  74 07	XOR	AL, MCSP_TOG			; toggle speed bits
 E25D  B0 03				OUT	DX, AL				; set new speed
 E25F  4A				TEST	AL, MASK MCAT4			; high speed bit set?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 66 - 1


 E260  74 02						ELSE				; NOT ARCH_MIST AND NOT ARCH_TD3300
 E262  B0 07				TEST	AL, MASK PBTB			; standard turbo bit set?
							ENDIF				; ARCH_MIST
						ENDIF					; ARCH_TD3300
				
					MOV	CX, CURSOR_DEFAULT		; original power-on cursor (fast)
 E264					JNZ	TOGGLE_TURBO_CURSOR		; Jump if turbo, use original cursor
 E264  CD 10				XOR	CH, CH 				; starting scan line 0 ("big cursor")
 E266				TOGGLE_TURBO_CURSOR:
					CALL	SET_CURSOR				; Video set cursor
				
				TOGGLE_TURBO_DONE:
					STI						; Enable interrupts
 E266					RET
				TOGGLE_TURBO ENDP
 E266  E8 165E						ENDIF				; IF IS_TURBO
				
							IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; Initial Set up Memory
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = memory in paragraphs
 E269  33 DB			; 	FE2010_CONF_REG set for 640K
 E26B  B4 03			;
 E26D  CD 10			; AX clobbered
 E26F  89 0E 00E8 R		;----------------------------------------------------------------------------;
				FE2010_SETUP_MEM PROC
					MOV	AL, FE2010_CONF_REG		; get register
					CMP	DH, HIGH 8000H			; is memory size 8000H? (512K)
					JA	FE2010_SETUP_OUT			; is > 512K (already set for 640K)
 E273  52				MOV	AH, MASK FME1			; set for 512K
 E274  BA 1800				JE	FE2010_SETUP_SET			; is 512K, set to 512K
 E277  B4 02				MOV	AH, MASK FME2			; else set for 256K
 E279  CD 10			FE2010_SETUP_SET:
					OR	AL, AH				; set bits if not 640K
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <VER>,<SI>			; if SZ is not SI
 E27B  BE FFE0 R	     1		MOV	SI, OFFSET VER
			     1			ENDIF
 E27E  E8 146C		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
				
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <REL_DATE>,<SI>			; if SZ is not SI
 E281  BE FFF5 R	     1		MOV	SI, OFFSET REL_DATE
			     1			ENDIF
 E284  E8 1466		     1		CALL	OUT_SZ
			     1			IFNB	<>
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 67 - 1


			     1		POP	SI
			     1			ENDIF
 E287  5A			;----------------------------------------------------------------------------;
 E288  B4 02			; Write AL to memory and control register
 E28A  CD 10			;
				FE2010_SETUP_SAVE PROC
					MOV	FE2010_CONF_REG, AL		; save register to memory
				FE2010_SETUP_OUT:
					OUT	PPI_CW, AL				; write to config register
					RET
				FE2010_SETUP_SAVE ENDP
				
 E28C  EB 58			FE2010_SETUP_MEM ENDP
							ENDIF
				
							IF ARCH_TYPE EQ ARCH_UM82
				;----------------------------------------------------------------------------;
				; Read UM82 memory size
				;----------------------------------------------------------------------------;
				; Output: CX = memory in # of 16K blocks above the first 16K block
				;----------------------------------------------------------------------------;
				UM82_IS_512	= NOT UM82_512K AND MASK U8MEM
				UM82_IS_640	= NOT UM82_640K AND MASK U8MEM
				UM82_MEM_SIZE PROC
					IN	AL, UM82_STATUS			; read UM82 status
					MOV	CX, 40 - 1				; 40 * 16K = 640K
					TEST	AL, UM82_IS_640			; is 640K?
					JE	UM82_DONE				; if so, done
 E28E					MOV	CL, 32 - 1				; 32 * 16K = 512K
					TEST	AL, UM82_IS_512			; is 512K?
 E28E  FA				JE	UM82_DONE				; if so, done
					MOV	CL, 16 - 1				; 16 * 16K = 256K
				UM82_DONE:
					RET
				UM82_MEM_SIZE ENDP
							ENDIF
				
							IF ARCH_TYPE EQ ARCH_EHB
				;----------------------------------------------------------------------------;
				; V40 Compatibility Register Setup
				;----------------------------------------------------------------------------;
				; Use with EMM Computers/homebrew8088.com
				; Contributed by @Hak Foo
				;
				; Size: 45 bytes
				;----------------------------------------------------------------------------;
				INIT_V40 PROC
							IF CPU_TYPE	EQ CPU_V20
					MOV	CX, 10			; counter = size of V40_REG
					MOV	SI, OFFSET V40_REG	; register data
					MOV	DH, 0FFH			; high byte of DX is always FF
				V40_REG_LOOP:
 E28F  E4 61				LODS	WORD PTR CS:[SI]		; AH = low byte of reg, AL = reg value
 E291  34 04				MOV	DL, AH			; DX = next register
 E293  E6 61				OUT	DX, AL			; write to register
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 68 - 1


					LOOP	V40_REG_LOOP
							ENDIF			; IF CPU_TYPE EQ CPU_V20
				
				;----------------------------------------------------------------------------;
				; EMM/8042 Keyboard reset
				;
					MOV	AL, 0AAH		; Test Controller
					OUT	ATKB_CMD, AL	; OUT Command Port (64h)
					IO_DELAY
					IN	AL, ATKB_IO		; Read Data Port and discard (60h)
				
					MOV	AL, 01100000B	; Write Command Byte to Keyboard Controller
					OUT	ATKB_CMD, AL	; OUT Command Port (64h)
					INC	AX			; PC Mode, Enable Interrupt (01100001b)
					OUT	ATKB_IO, AL		; OUT Data Port (60h)
					JMP	INIT_V40_RET	; continue POST
				
							IF CPU_TYPE	EQ CPU_V20
				V40_REG LABEL BYTE
					DB	00000000B,	0FEH 	; FFFE: OPCN - INT Select
					DB	00000110B,	0FDH 	; FFFD: OPSEL - Enable TCU/ICU, Disable DMAU/SCU
									;	Only Enable The Interrupt Controller And Timer
					DB	00H, 		0FCH	; FFFC: OPHA - On-chip Peripheral High Address Register
									;	Any 256K Block Except Overlap with Registers
					DB	00100000B,	0FAH	; FFFA: IULA - 8259 Lower Address Register
					DB	01000000B,	0F9H 	; FFF9: TULA - 8254 Lower Address Register
					DB	00000000B		; FFF6: WCY2 - Number of wait cycles for DMA and refresh
					DB	LOW V40_WCR2	;	00 seems safe for SRAM since no refresh happens
							IF NOT PPI_B_BOOT AND MASK PBTB 	; Boot to Turbo/0-WS speed?
					DB	V40_WCY1<0,0,0,0>	;	WCY1 - All Zero wait state
							ELSE
					DB	V40_WCY1<3,3,3,3>	;	WCY1 - 3 W/S everywhere
							ENDIF
					DB	LOW V40_WCR1	; FFF5: WCY1 - WAIT Wait bits 7-6 = IO, 5-4 = Upper Mem,
									;	3-2 = Middle Mem, 1-0 Lower Mem
									;	0FFH: Super conservative: 3WS everywhere
									;	025H: Bolder: Zero wait-state I/O
									;	 00H: Full Zero wait state, best performance
					DB	00000110B,	0F4H 	; FFF4: WMB - Memory Boundaries
									;	Bits 6-4 are size of "high" memory, 2-0 "low"
									;	in 32k units.  Default puts bottom 32k "low"
									;	and above 640k in "high" for stuff like slow
									;	video cards and option BIOSes
					DB	00H,		0F2H	; FFF2: RFC - Refresh Control
									;	00 (disabled refresh) for SRAM
					DB	00011100B,	0F0H 	; FFF0: TCKS - Timer Pin Selection
									; 	Bits 4-2 set sources for timers (1 for TCLK)
									;	1=Pin, 0=internal, Bits 1-0 Prescale Div For Interna
				l
				L_V40_REG	=	($-V40_REG)/2
							ENDIF		; /IF CPU_TYPE EQ CPU_V20
				
				INIT_V40 ENDP
							ENDIF		; /IF ARCH_TYPE EQ ARCH_EHB
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 69 - 1


							IF FD_AUTO_DETECT EQ 1
				;----------------------------------------------------------------------------;
				; Set BDA Floppy disk count in to AL
				;----------------------------------------------------------------------------;
				SET_EFLAG_FLP PROC
					TEST	AX, AX				; zero drives found?
					JZ	SHORT SET_EFLAG_FLP_RET		; don't change BDA (no option for 0)
					PUSH	AX
					DEC	AX					; adjust 0-based count
 E295  A8 04				AND	AL, SW1_FLP				; max number of drives
					SET_EFLAG  FLP				; set floppy count
					POP	AX
				SET_EFLAG_FLP_RET:
 E297  8B 0E 00E8 R			RET
 E29B  75 02			SET_EFLAG_FLP ENDP
 E29D  32 ED						ENDIF
 E29F				
 E29F  E8 0D9C			;
				; 2 BYTES HERE
 E2A2				;
 E2A2  FB			BYTES_HERE	INT_02
 E2A3  C3			
 E2A4				;----------------------------------------------------------------------------;
				; INT 2 - NMI 
				;----------------------------------------------------------------------------;
				; If NMI / IRQ 2 occurs (a parity or I/O exception), display error type and
				; halt. Exit if it was an 8087 exception as that should be intercepted by 
				; a user coprocessor exception handler.
				;----------------------------------------------------------------------------;
						ORG 0E2C3H
				INT_02 PROC
						ASSUME DS:_BDA
					PUSH	AX
					IN	AL, PPI_C 				; get PC0 register
					TEST	AL, MASK PCPE OR MASK PCIE	; parity or I/O error?
					JNZ	INT_02_NMI_PAR 			; first, check parity
					POP	AX					; if neither, exit
					IRET						; must have been an 8087 NMI
				INT_02_NMI_PAR:
					MOV	SI, OFFSET NMI_ERR_PAR 		; Parity error string
					TEST	AL, MASK PCPE			; parity error?
					JNZ	INT_02_NMI_HALT
					MOV	SI, OFFSET NMI_ERR_IO 		; otherwise is I/O error
				INT_02_NMI_HALT:
					XOR	AX, AX				; reset video, clear screen
					OUT	NMI_R0, AL				; mask the unmaskable
					INT	10H					; switch to text video mode
					CALL	OUT_SZ 				; display string in CS:SI
					CALL	NMI_RESET				; clear NMI/parity flags
				INT_02_LOOP:
					CLI						; ensure interrupts off
					HLT						; halt CPU
					JMP	SHORT INT_02_LOOP
				INT_02 ENDP
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 70 - 1


				INT_02_AFTER:
				
				;----------------------------------------------------------------------------;
				; [37] Setup LPT/COM default timeouts
				;----------------------------------------------------------------------------;
					MOV	DI, OFFSET LPT_TIME
					MOV	AX, DBW <LPT_TO, LPT_TO>	; LPT timeout values
					STOSW						; write x 4 to BDA
					STOSW
					MOV	AX, DBW <COM_TO, COM_TO>	; COM timeout values
					STOSW
					STOSW
				
				POST_DETECT_PORTS:
					MOV	BX, OFFSET EQUIP_FLAGS[1]	; BX = high byte of EQUIP_FLAGS
				
				;----------------------------------------------------------------------------;
				; [38] Detect and enable Game port
				;----------------------------------------------------------------------------;
				; Port 201H
				; Input: 
				;	BX = high byte of EQUIP_FLAGS
				;
				; Equipment Bit is set if the lower nibble of an I/O port 201h read is zero
				; http://www.minuszerodegrees.net/5150_5160/post/IBM%205150%20and%205160%20-%20Bit%2012%20of%20Equip
				ment%20Flag.htm
				;----------------------------------------------------------------------------;
				POST_DETECT_GAM:
					MOV	DX, GAME_CTRL
					IN	AL, DX 				; will be 0FFH if no port
					TEST	AL, 0FH
					JNZ	NO_GAME_PORT
					OR	BYTE PTR [BX], HIGH MASK GAM	; enable Game Port bit
				NO_GAME_PORT:
				
				;----------------------------------------------------------------------------;
				; [37] Detect and enable COM ports 1-4
				;----------------------------------------------------------------------------;
				; Ports 3F8H, 2F8H, 3E8H, 2E8H
				; Input:
				;	BX = high byte of EQUIP_FLAGS
				;	ES, DS = BDA segment
				;----------------------------------------------------------------------------;
				POST_DETECT_COM:
					MOV	CX, 4
					XOR	DI, DI 				; 00H BDA COM1-4 base addresses
					MOV	DX, COM1_IIR			; 03FAH: COM1 Interrupt Ident Reg
				COM_DETECT_LOOP:
					XOR	AL, AL				; AL = 0
					OUT	DX, AL				; clear FIFO Control Register (FCR)
					IN	AL, DX 				; read IIR to clear DMA flags
					IN	AL, DX 				; read IIR again
					DEC	DX
					DEC	DX					; get base port
					TEST	AL, 11110000B 			; check if any high 4 bits are set
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 71 - 1


					JNZ	NO_COM_PORT				; if so, not a valid port
					XCHG	AX, DX				; AX = detected port
					STOSW 					; write I/O port to COM BDA table
					XCHG	AX, DX
					ADD	BYTE PTR[BX], HIGH(1 SHL COM)	; INC COM port count in flags
				NO_COM_PORT:
					SUB	DX, 3F8H-2FAH			; base port to next data port
					CMP	CL, 3 				; is 2F8H (COM3)?
					JNZ	NEXT_COM_PORT
					ADD	DX, 3EAH-(2F8H-0FEH)		; if so, diff to get to 3EAH again
				NEXT_COM_PORT:
					LOOP	COM_DETECT_LOOP
				
				;----------------------------------------------------------------------------;
				; [36] Detect and enable LPT ports
				;----------------------------------------------------------------------------;
				; Ports 3BCH, 378H, 278H
				; Input: 
				;	BX = high byte of EQUIP_FLAGS
				;	CH = 0
				;----------------------------------------------------------------------------;
				POST_DETECT_LPT:
					MOV	DI, OFFSET LPT_ADDR		; 08H BDA LPT1-3 base addresses
					MOV	DX, 03BCH				; start with MDA printer base
					MOV	CL, 3
				LPT_DETECT_LOOP:
					MOV	AL, MASK LCDR OR MASK LCINI-1	; use init byte - 1 as test data
					OUT	DX, AL				; send to LPT data port
					INC	DX
					INC	DX					; DX = control port
					INC	AX					; AL = Strobe off / init (1100b)
					OUT	DX, AL				; send to LPT control port
					DEC	DX
					DEC	DX					; DX = data port
					IN	AL, DX				; read from LPT data port
					XOR	AL, MASK LCDR OR MASK LCINI-1	; valid port if same test data
					JNZ	NO_LPT_PORT
					XCHG	AX, DX				; AX = detected port
					STOSW 					; store to LPT BDA table
					XCHG	AX, DX
					ADD	BYTE PTR[BX], HIGH(1 SHL LPT)	; INC LPT port count in flags
				NO_LPT_PORT:
					DEC	DH 					; DX = DX - 100H
					CMP	CL, 3 				; is 3BCH?
					JNZ	NEXT_LPT_PORT
					ADD	DX, 378H-(3BCH-100H)		; if so, add diff to get to 378H
				NEXT_LPT_PORT:
					LOOP	LPT_DETECT_LOOP
				
				;----------------------------------------------------------------------------;
				; Reset Keyboard Interface
				;----------------------------------------------------------------------------;
				; http://minuszerodegrees.net/5160/keyboard/5160_keyboard_startup.jpg
				;
				; KB Status Port 61h high bits:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 72 - 1


				; 01 - normal operation. wait for keypress, when one comes in,
				;		force data line low (forcing keyboard to buffer additional
				;		keypresses) and raise IRQ1 high
				; 11 - stop forcing data line low. lower IRQ1 and don't raise it again.
				;		drop all incoming keypresses on the floor.
				; 10 - lower IRQ1 and force clock line low, resetting keyboard
				; 00 - force clock line low, resetting keyboard, but on a 01->00 transition,
				;		IRQ1 would remain high
				;----------------------------------------------------------------------------;
 E2A4			     1			LOCAL LBL
			     1	
 = 001F			     1	BYTES_HERE_INT_02 = INT_02-$
			     1	
			     1			IFDEF BYTES_HERE_INT_02
			     1			IF2
			     1			IF BYTES_HERE_INT_02 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_02 (BYTES_HERE_INT_02)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				POST_KB_RESET PROC
					MOV	DX, PPI_B 				; DX = PPI port B (61H)
					IN	AL, DX
					AND	AL, NOT (MASK PBKB OR MASK PBKC) ; keyboard clock hold LOW and enable
					OUT	DX, AL				; send to PPI port B
					XCHG	AX, SI				; save modified PPI port B
				
				;----------------------------------------------------------------------------;
				; [31] - Set up and clear keyboard buffer
 E2C3				;----------------------------------------------------------------------------;
					MOV	AX, OFFSET KB_BUF 		; AX = initial start of buffer
 E2C3  50				MOV	DI, OFFSET KB_BUF_HD 		; DI = buffer head
 E2C4  E4 62				STOSW 					; write to head pointer
 E2C6  A8 C0				STOSW 					; write to tail pointer
 E2C8  75 02				MOV	DI, OFFSET KB_BUF_ST 		; setup buffer start and end
 E2CA  58				STOSW
 E2CB  CF				MOV	AL, LOW OFFSET KB_BUF_END	; (AH already 00)
 E2CC					STOSW						; DI = KB_BUF_ST + 4
 E2CC  BE E4E5 R		
 E2CF  A8 80			;----------------------------------------------------------------------------;
 E2D1  75 03			; Hold clock low 20+ ms to signal keyboard to reset. Clear and re-enable.
 E2D3  BE E4E3 R		;
 E2D6					MOV	AL, 30				; I/O delay for at least 20ms
 E2D6  33 C0				CALL	IO_DELAY_MS
 E2D8  E6 A0				XCHG	AX, SI				; restore modified PPI port B
 E2DA  CD 10			
 E2DC  E8 140E				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E2DF  E8 053B				OUT	DX, AL				; send to PPI port B
 E2E2					AND	AL, NOT MASK PBKB			; keyboard enable (clear low)
 E2E2  FA				OUT	DX, AL				; send to PPI port B
 E2E3  F4			
 E2E4  EB FC			;----------------------------------------------------------------------------;
 E2E6				; Unmask KB interrupt IRQ1
				;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 73 - 1


 E2E6					IN	AL, INT_IMR 			; get PIC Port 1 INT mask
					XCHG	AX, SI 				; SI = save previous INT mask
					MOV	AL, NOT MASK IRQ1			; unmask only keyboard interrupt
					OUT	INT_IMR, AL
				
 E2E6  BF 0078 R		;----------------------------------------------------------------------------;
 E2E9  B8 1414			; Check if reset scan code was received
 E2EC  AB			;
 E2ED  AB			; Temporary INT_09_POST interrupt will set 4000H flag on BP
 E2EE  B8 0101			; when IRQ1 is received with successful reset code of 0AAh
 E2F1  AB			;
 E2F2  AB						IF POST_TEST_KB NE 0
					STI 						; enable interrupts
 E2F3				KB_RESET_TEST:
 E2F3  BB 0011 R			NOP 						; give a little more time
					POST_FLAG_TEST  PKI			; KB test flag yet?
					LOOPZ	KB_RESET_TEST			; Loop until KB flag OR CX is 0 (timeout)
					CLI 						; disable interrupts again
					POST_FLAG_FLIP  PKI			; invert PKI flag: 1 = error, 0 = success
							ENDIF
					IO_DELAY_LONG 				; additional delay, CX = 0
				
				;----------------------------------------------------------------------------;
				; Ack scan code, clear keyboard again and check that no scan codes were received
				;
					IN	AL, DX				; read PPI port B
 E2F6					OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E2F6  BA 0201				OUT	DX, AL				; send to PPI port B
 E2F9  EC				AND	AL, NOT MASK PBKB			; keyboard enable (clear low)
 E2FA  A8 0F				OUT	DX, AL				; send to PPI port B
 E2FC  75 03				IO_DELAY					; delay for KBC, CX = 0
 E2FE  80 0F 10				IN	AL, PPI_A 				; check KB for extraneous key
 E301							IF POST_TEST_KB NE 0	; all KB tests enabled?
							IF POST_TEST_KEY NE 0	; Key Stuck test enabled?
					TEST	AL, AL				; AL should be 0
					JZ	KB_HAPPY				; if so, KB is ready
					POST_FLAG_SET  PKEY			; otherwise set flag for keyboard error
							ENDIF				; end Key Stuck test
							ELSE
					POST_FLAG_CLR  PKI			; clear any KB error
							ENDIF
				
 E301				KB_HAPPY:
 E301  B9 0004			;----------------------------------------------------------------------------;
 E304  33 FF			; Disable keyboard for rest of POST
 E306  BA 03FA			;
 E309					IN	AL, DX
 E309  32 C0				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E30B  EE				OUT	DX, AL				; send to PPI port B
 E30C  EC			
 E30D  EC				XCHG	AX, SI 				; restore interrupt mask register
 E30E  4A				OUT	INT_IMR, AL
 E30F  4A			
 E310  A8 F0			;----------------------------------------------------------------------------;
 E312  75 06			; Set up the real INT 09H keyboard interrupt handler
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 74 - 1


 E314  92			;
 E315  AB				MOV	ES, CX 				; ES = IVT seg (CX is 0 from above)
 E316  92				MOV	DI, OFFSET IVT_09 		; DI = INT 9H offset in IVT (24H)
 E317  80 07 02				MOV	AX, OFFSET INT_09 		; Vector offset
 E31A					STOSW 					; replace in IVT
 E31A  81 EA 00FE		
 E31E  80 F9 03			POST_KB_RESET ENDP
 E321  75 04			
 E323  81 C2 01F0		;----------------------------------------------------------------------------;
 E327				; Begin Hardware POST Test Results
 E327  E2 E0			;----------------------------------------------------------------------------;
					CALL	HIDE_CURSOR				; cursor movement is distracting
				
							IF POST_WARM_COLD EQ 1
					CALL	POST_BOOT_TYPE			; Display "WARM" or "COLD" boot
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [17] Detect and test conventional memory
				;----------------------------------------------------------------------------;
 E329					CALL	DETECT_MEMORY			; detect and display memory count
 E329  BF 0008 R		
 E32C  BA 03BC						IF POST_VIDEO_TYPE NE 1
 E32F  B1 03				CALL	CRLF					; clear row if video type not shown
 E331							ENDIF
 E331  B0 0B			
 E333  EE						IF DRAM_REFRESH EQ 1
 E334  42			;----------------------------------------------------------------------------;
 E335  42			; [27B] Verify that the 8237 DMA Channel 0 Terminal Count (TC 0) status bit 
 E336  40			; is on. This test is only done on a cold boot.
 E337  EE			;----------------------------------------------------------------------------;
 E338  4A				JWB	DMA_STATUS_OK			; skip on warm boot
 E339  4A				IN	AL, DMA_CMD				; verify DMA status register
 E33A  EC				TEST	AL, MASK TC0			; Channel 0 TC
 E33B  34 0B				JNZ	DMA_STATUS_OK			; jump if zero reached
 E33D  75 06				POST_FLAG_SET  PDMA			; else mark in POST error flags
 E33F  92			DMA_STATUS_OK:
 E340  AB						ENDIF
 E341  92			
 E342  80 07 40			;----------------------------------------------------------------------------;
 E345				; Display Additional Configuration Items such as COM/LPT, CPU, FPU, etc
 E345  FE CE			;----------------------------------------------------------------------------;
 E347  80 F9 03				CALL	POST_SYS_CONFIG
 E34A  75 04				CALL	CRLF_SHOW_CURSOR			; CRLF and re-enable cursor
 E34C  81 C2 00BC		
 E350				;----------------------------------------------------------------------------;
 E350  E2 DF			; Unmask IRQs for Timer (IRQ0), Keyboard (IRQ1) and Floppy (IRQ6)
				;----------------------------------------------------------------------------;
					IN	AL, INT_IMR 			; get current OCW1/IMR register
					AND	AL, NOT (MASK IRQ6 OR MASK IRQ1 OR MASK IRQ0) ; unmask IR6, IR1, IR0
					OUT	INT_IMR, AL 			; send to A1 (Port 1)
				
				;----------------------------------------------------------------------------;
				; [28] Option ROM scan for other ROMs (storage, etc)
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 75 - 1


					MOV	AX, SEG _OPT_ROM			; start at 0C800H
					MOV	DI, OPT_ROM_END 			; end below 0FE00H
					CALL	BIOS_ROM_SCAN
				
				;----------------------------------------------------------------------------;
				; [31] Enable interrupts
				;----------------------------------------------------------------------------;
					STI 						; Interrupts now enabled
 E352				
 E352  BA 0061						IF FDC_ENABLE EQ 1
 E355  EC			;----------------------------------------------------------------------------;
 E356  24 3F			; [30] Recalibrate and test seek the floppy drive
 E358  EE			;----------------------------------------------------------------------------;
 E359  96			FDC_POST PROC
					XOR	AX, AX 				; AH = reset (0)
					CWD						; DL = start at drive 0
					INT	13H					; Reset the controller
					JC	FDC_POST_CT_ERR			; jump if controller reset failed
 E35A  B8 001E R			GET_EFLAG  FLP				; AX = # of floppy drives (0 based)
 E35D  BF 001A R			INC	AX					; fixup for 1 based drive count
 E360  AB			
 E361  AB						IF POST_TEST_FD EQ 1
 E362  BF 0080 R		;----------------------------------------------------------------------------;
 E365  AB			; Test FDC drives - seek on cold boot, recal on warm boot
 E366  B0 3E R			;
 E368  AB				XCHG	AX, CX				; CX = number of floppy drives
				FDC_POST_TESTS_DRV:
								IF POST_TEST_SEEK EQ 1
					CALL	FDC_RECAL_SEEK_TEST		; recal and seek test
								ELSE
 E369  B0 1E				CALL	FDC_RECAL				; do a recal only
 E36B  E8 1406							ENDIF
 E36E  96				JC	FDC_POST_DRV_ERR			; jump if error
					INC	DX					; DL = next drive
 E36F  0C C0				LOOP	FDC_POST_TESTS_DRV
 E371  EE				JMP	SHORT FDC_POST_TESTS_DONE	; tests successful
 E372  24 7F			FDC_POST_DRV_ERR:					; POST: drive seek error
 E374  EE							IF FD_AUTO_DETECT EQ 0
					POST_FLAG_SET  PFSK			; mark in POST error flags
								ENDIF
					JMP	SHORT FDC_POST_TESTS_DONE	; end POST test at failed drive
					;LOOP	FDC_POST_TESTS_DRV		;  or continue to next drive
 E375  E4 21			
 E377  96						ELSE				; No POST seek test
 E378  B0 FD				JMP	SHORT	FDC_POST_TESTS_COL
 E37A  E6 21						ENDIF				; /POST_TEST_FD EQ 1
				
				FDC_POST_CT_ERR:					; POST: controller error
					POST_FLAG_SET  PFDC			; mark in POST error flags
				
							IF POST_TEST_FD EQ 1
					XOR	DX, DX				; DX = 0 drives detected
				FDC_POST_TESTS_DONE:
					XCHG	AX, DX				; AX = drive count
 E37C  FB			
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 76 - 1


 E37D								IF FD_AUTO_DETECT EQ 1
 E37D  90			;----------------------------------------------------------------------------;
				; Update BDA FD count based on successfully tested drives
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		TEST1_BP  PKI				; V20 only: TEST1 BP, PKI
			     1				ELSE
 E37E  F7 C5 4000	     1		TEST	BP, MASK PKI			; Is flag set?
			     1				ENDIF
 E382  E1 F9			;
 E384  FA				CALL	SET_EFLAG_FLP			; set drive count in AL
								ENDIF			; /FD_AUTO_DETECT EQ 1
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		NOT1_BP   PKI				; V20 only: NOT1 BP, PKI
			     1				ELSE
 E385  81 F5 4000	     1		XOR	BP, MASK PKI			; Invert flag
			     1				ENDIF
				
							ENDIF				; /POST_TEST_FD EQ 1
			     1				IF ARCH_TYPE NE ARCH_EMU
 E389  33 C9		     1		XOR	CX, CX 				; delay 65535 LOOPs
			     1		IO_DELAY
			     2			LOCAL _DONE
 E38B			     2	??0010:
 E38B  E2 FE		     2		LOOP	??0010					; long delay for I/O
			     1				ENDIF
				
				FDC_POST_TESTS_COL:
				;----------------------------------------------------------------------------;
				; Display FDC POST drive count column in AX
 E38D  EC			;
 E38E  0C C0				POST_COL_1  POST_FDD, POST_CLR_VAL2	; display FDC column label
 E390  EE				CALL	NIB_HEX				; display decimal value in AL
 E391  24 7F				POST_COL_END				;  NIB_HEX returns AL <= 46h
 E393  EE			
				FDC_POST ENDP
			     1			LOCAL _DONE
 E394			     1	??0011:
 E394  E2 FE		     1		LOOP	??0011					; long delay for I/O
 E396  E4 60						ENDIF				; IF FDC_ENABLE
				
				;----------------------------------------------------------------------------;
 E398  84 C0			; Detect and show hard drive info
 E39A  74 04			;----------------------------------------------------------------------------;
				HDD_POST PROC
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		SET1_BP   PKEY				; V20 only: SET1 BP, PKEY
			     1				ELSE
 E39C  81 CD 2000	     1		OR	BP, MASK PKEY			; Set flag
			     1				ENDIF
							IF POST_HD_CHECK EQ 1
					CBW						; AH = 0 reset
					MOV	DL, 80H				; reset C: (80H)
					INT	13H
					JC	HDD_POST_NONE			; if CF, no HD or reset failure
 E3A0				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 77 - 1


					MOV	DL, 80H
					CALL	GET_DISK_PARAMS			; return # HD's in DX
					JC	HDD_POST_NONE
 E3A0  EC			
 E3A1  0C C0			HDD_POST_COUNT PROC
 E3A3  EE			;----------------------------------------------------------------------------;
				; Display HDD POST drive count column
 E3A4  96			;
 E3A5  E6 21				POST_COL_2	POST_HDD, POST_CLR_VAL2	; display HDC column label
				
					PUSH	DX					; save drive count
					XCHG	AX, DX				; AL = drive count
					CALL	NIB_HEX				; write as hex to console (clobs AX)
 E3A7  8E C1				POST_COL_END_NL				; end column
 E3A9  BF 0024 R			POP	CX					; CX = drive count
 E3AC  B8 E987 R			JCXZ	HDD_POST_DONE			; reset passed but 0 drives
 E3AF  AB			
				HDD_POST_COUNT ENDP
 E3B0				
							IF POST_HD_PARMS EQ 1
				;----------------------------------------------------------------------------;
				; Display HDD drive letter(s) and size(s)
				;	
 E3B0  E8 0C88				MOV	DL, 80H				; start with drive 80H (C:)
				HDD_POST_SHOW_LOOP:
					CALL	SHOW_DISK_PARAMS			; show drive letter and geometry
 E3B3  E8 026C				INC	DX					; move to next drive
					LOOP	HDD_POST_SHOW_LOOP
					JMP	SHORT HDD_POST_DONE
							ENDIF				; ENDIF POST_HD_PARMS EQ 1
				HDD_POST_NONE:
							ENDIF				; ENDIF POST_HD_CHECK EQ 1
 E3B6  E8 0193				CALL	CRLF
				HDD_POST_DONE:
				HDD_POST ENDP
				
				;----------------------------------------------------------------------------;
				; [39] Clear and enable I/O and parity NMIs
				;----------------------------------------------------------------------------;
					CALL	NMI_RESET				; reset NMI flags
				
							IF RAM_PARITY EQ 1
				ENABLE_NMI:
					MOV	AL, NMI <1>				; AL = enable NMI
					OUT	NMI_R0, AL				; write to controller
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Enable keyboard
				;
					CALL	KB_BUF_CLEAR			; clear any stray keys in buffer
					IN	AL, PPI_B 				; AL = PB0 flags
					AND	AL, NOT MASK PBKB			; keyboard clear LOW (enable KB)
					IO_DELAY_SHORT
 E3B9  E8 125B				OUT	PPI_B, AL				; send to PPI port B
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 78 - 1


 E3BC  E8 0C73			
				;----------------------------------------------------------------------------;
				; Check for POST errors and clear warm boot flag
				;
					XOR	AX, AX				; AX = 0
 E3BF  E4 21				MOV	WARM_FLAG, AX			; clear warm boot flag in BDA
 E3C1  24 BC				POST_FLAG_CLR  WARM			; remove warm boot flag, NZ if error
 E3C3  E6 21				JZ	POST_OK				; if no errors, go ahead and boot
				
				;----------------------------------------------------------------------------;
				; Display any POST errors
				;
 E3C5  B8 ---- R		POST_ERROR:
 E3C8  BF FE00				PRINT_SZ  POST_ERR			; display "Post Error"
 E3CB  E8 011F				MOV	AX, BP				; AX = POST error flags
					CALL	WORD_HEX				; display POST error value
					CALL	CRLF
					CALL	POST_ERROR_MSG			; display POST error messages, BP=0
				
 E3CE  FB						IF POST_ERR_WAIT GT 0
				;----------------------------------------------------------------------------;
				; Wait for Any Key if there was an error
				;
					CALL	MEEPMEEP				; alert that there was an error, CX=0
					PRINT_SZ  NL_ANY_KEY			; "Any key" string
					XCHG	AX, CX				; wait for key press (AH=0)
					INT	16H
					CALL	CRLF					; move to next line
							ENDIF
				
				POST_OK:
				;----------------------------------------------------------------------------;
				; Clear screen (partially or completely) and attempt boot
				;
				CLEAR_POST_SCREEN:
					MOV	BH, 7					; attribute fill for on blank line
							IF POST_CLS EQ 1		; clear the whole screen
					MOV	AX, DBW <7, 25>			; AH = 7, scroll down 25 lines
					MOV	CX, DBW <0, 0>			; upper left row 0, column 0
							ELSE				; clear only the lower two rows
					MOV	AX, DBW <7, 2>			; AH = 7, scroll down 2 lines
					MOV	CX, DBW <23, 0>			; upper left row 23, column 0
							ENDIF
				
					MOV	DX, DBW <25, 80>			; lower right row 25, column 80
					INT	10H
				
							IF POST_CLS EQ 1		; set cursor to top of screen
					MOV	AH, 2					; set cursor position
					MOV	BH, 0					; video page 0
					CWD						; row = 0, col = 0
					INT	10H
							ENDIF
				
					CALL	BEEP 					; beep to signify POST test is done
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 79 - 1


							IF POST_GLADOS EQ 1
					PRINT_SZ  BOOT_BEGIN			; Starting DOS...
							ELSE
					CALL	CRLF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [40] DO BOOTSTRAP!
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Attempt to IPL three times. If failure, call INT 18h / ROM BASIC.
				; If INT_19_BOOT_HD is 1, BIOS will also attempt to IPL from 80h (C:)
				;
					CWD						; start IPL from drive 0 (A:)
				BOOT_DEVICE:
					MOV	CX, 3 				; retry three times
				BOOT_RETRY:
					PUSH	CX					; save retry counter
							IF INT_19_BOOT_HD EQ 1
					PUSH	DX					; save drive number
							ENDIF
					INT	19H
					IO_DELAY_LONG				; delay between attempts
							IF INT_19_BOOT_HD EQ 1
					POP	DX					; restore drive number
							ENDIF
					POP	CX					; restore retry counter
					LOOP	BOOT_RETRY
							IF INT_19_BOOT_HD EQ 1
					XOR	DL, 80H				; flip to HD
					JNZ	BOOT_DEVICE				; retry if HD, otherwise INT 18
							ENDIF
				
				TRY_INT_18:
 E3CF					INT	18H					; Try vectored ROM BASIC or boot failure
											; INT 18h should never return...
 E3CF  98										;  fall through just in case
 E3D0  B2 80			
 E3D2  CD 13			;----------------------------------------------------------------------------;
 E3D4  72 24			; INT 18 - Unbootable IPL
				;----------------------------------------------------------------------------;
 E3D6  B2 80			; Display a disk boot failure message and wait for a key to cold reboot.
 E3D8  E8 0343			;
 E3DB  72 1D			; This may be re-vectored to ROM BASIC, if present.
				;
 E3DD				; Size: 18 bytes
				;----------------------------------------------------------------------------;
				INT_18 PROC
						ASSUME DS:_BDA_ABS
					PRINT_SZ  BOOT_FAIL			; print boot failure string
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 80 - 1


			     1		MOV	BX, LOW POST_CLR_VAL2		; BH = 0, BL = attribute
			     1			ELSE
 E3DD  B3 0E		     1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute
			     1			ENDIF
 E3DF  BE E4D8 R	     1		MOV	SI, OFFSET POST_HDD
 E3E2  E8 12D6		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
					XOR	AX, AX				; AH = 0 (wait for key)
 E3E5  52				MOV	DS, AX				; DS = 0000
 E3E6  92				MOV	WARM_FLAG_ABS, AX			; do a cold boot
 E3E7  E8 1374				INT	16H					; wait for key press
					JMP	BOOT					; reboot
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E3EA  E8 12E0		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E3ED  59			INT_18 ENDP
 E3EE  E3 0D			
				BOOT ENDP
 E3F0				
				;----------------------------------------------------------------------------;
				;
				; END OF BIOS POST/BOOTSTRAP
				;
				;----------------------------------------------------------------------------;
 E3F0  B2 80			
 E3F2						ASSUME DS:_BDA
 E3F2  E8 146E			STRINGS PROC
 E3F5  42			
 E3F6  E2 FA			BANNER_STRINGS PROC
 E3F8  EB 03			;----------------------------------------------------------------------------;
				; Banner Strings
 E3FA				;
									IF POST_GLADOS EQ 1
 E3FA  E8 1319			BOOT_BEGIN		DB	CR, LF
 E3FD							DB	'Starting GLaDOS...'
 E3FD				NL2_Z			DB	LF				; two NL's, null term'd
									ENDIF
				NL_Z			DB	CR, LF, 0			; one NL, null term'd
				BOOT_FAIL		DB	'Disk Boot Fail.'
							DB	' You monster.'
 E3FD  E8 041D			NL2_ANY_KEY		DB	LF
				NL_ANY_KEY		DB	CR, LF
				ANY_KEY		DB	'Press the Any Key...'
							DB	 0
				BANNER_STRINGS ENDP
				
				POST_STRINGS PROC
				;----------------------------------------------------------------------------;
				; POST Test Strings
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 81 - 1


				;
				POST_CPU		DB	'CPU',  0			; 'CPU' followed by default
 E400  E8 054C						DB	'8088', 0			;  *must be after POST_CPU
 E403  E4 61			POST_FPU		DB	'FPU',  0			; 'FPU' followed by default
 E405  24 7F						DB	'8087', 0			;  *must be after POST_FPU
				POST_HD		DB	':',    0			; HD size letter display
			     1			LOCAL _DONE
			     1				IF ARCH_TYPE NE ARCH_EMU
 E407  EB 00		     1		JMP	SHORT ??0012
 E409			     1	??0012:
			     1				ENDIF
 E409  E6 61						DB	' ', POST_M_UNIT		;  MB or MiB units display
							DB	0				;  *must be after POST_HD
				POST_MEMORY		DB	'RAM',  0			; RAM Memory test
							DB	'000 ', POST_K_UNIT	;  and KB or KiB
							DB	' OK',  0			;  *must be after POST_MEMORY
 E40B  33 C0			POST_V20		DB	'V20'
 E40D  A3 0072 R							IF ARCH_TYPE EQ ARCH_EHB
							DB	'/V40'			; could be a V40 on EHB
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		CLR1_BP   WARM				; V20 only: CLR1 BP, WARM
			     1				ELSE
 E410  81 E5 7FFF	     1		AND	BP, NOT MASK WARM			; Clear flag
			     1				ENDIF
 E414  74 20								ENDIF
							DB	0
				POST_LPT		DB	'LPT',  0
				POST_COM		DB	'COM',  0
				POST_FDD		DB	'FDD',  0
 E416				POST_HDD		DB	'HDD',  0
				POST_LSEP		DB	POST_L, 0
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <POST_ERR>,<SI>			; if SZ is not SI
 E416  BE E8F5 R	     1		MOV	SI, OFFSET POST_ERR
			     1			ENDIF
 E419  E8 12D1		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E41C  8B C5			POST_RSEP		DB	POST_R, 0
 E41E  E8 1329			POST_STRINGS ENDP
 E421  E8 12F2			
 E424  E8 04F7			NMI_ERR_IO		DB	'IO'				; NMI I/O Error string
				NMI_ERR_PAR		DB	' PAR'
									IF POST_OPT_ROM NE 1
							DB	'ITY'				; TODO: fix size hack
									ENDIF
							DB	0				; NMI Parity Error
 E427  E8 0498			
				STRINGS ENDP
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 82 - 1


			     1			IFDIFI <NL_ANY_KEY>,<SI>			; if SZ is not SI
 E42A  BE E48B R	     1		MOV	SI, OFFSET NL_ANY_KEY
			     1			ENDIF
 E42D  E8 12BD		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E430  91			
 E431  CD 16			;============================================================================;
 E433  E8 12E0			;
				;		        * * *   P R O C s  &  I N T s  * * *
				;
 E436				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; Scan, checksum and call BIOS ROMs
 E436				;----------------------------------------------------------------------------;
 E436  B7 07			; Input:
				;	AX = starting segment
				;	DI = ending segment
				; Output:
				;	AX, DI = ending segment
 E438  B8 0702			;
 E43B  B9 1700			; Note: ROM init's can clobber any or all registers so important to save
				; any that are used here between calls.
				;
 E43E  BA 1950			; Clobbers: AX, BX, SI (anything else the ROM might, except for DS, ES and BP)
 E441  CD 10			; Size: 73 bytes
				;----------------------------------------------------------------------------;
				BIOS_ROM_SCAN PROC
							ASSUME ES:_BDA
					PUSHX	BP, DS, ES				; some option ROMs may clobber BP
					MOV	DS, AX 				; DS = starting segment
				CHECK_ROM:
					CLD						; direction flag forward
					MOV	BX, SEG _BDA 			; ES = 0040H (BIOS BDA segment)
 E443  E8 0468				MOV	ES, BX				; re-set ES for each ROM call
					PUSH	DS					; save current DS segment
					MOV	BL, 2048 SHR 4			; next 2K segment boundary length
					PUSH	BX					; save for use if no ROM found
 E446  E8 12CD				XOR	SI, SI 				; reset offset to 0
					LODSW 					; AX = first word (should be 0AA55H)
					CMP	AX, MAGIC_WORD			; is it an extension ROM?
					JNE	NEXT_ROM 				; if not, check next 2K block
				FOUND_ROM:
					LODSB						; AL = ROM size in 512B blocks
					CMP	AL, 0					; is size "reasonable"?
					JLE	NEXT_ROM				; if not 1-127, skip it
					CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, size AL
							IF POST_OPT_ROM
					CALL	ROM_SCAN_POST			; show ROM offset, size and errors
 E449  99						ENDIF
 E44A					JNZ	NEXT_ROM				; if NZ, checksum failed, skip it
 E44A  B9 0003				POP	BX					; discard previous boundary size
 E44D							IF CPU_TYPE	EQ CPU_V20
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 83 - 1


 E44D  51				SHR	AX, 4					; V20: 512 byte blocks to paragraph
							ELSE
					MOV	CL, 4					; 8088: 512 byte blocks to paragraph
					SHR	AX, CL
 E44E  CD 19						ENDIF
					PUSH	AX					; replace next boundary size
			     1				IF ARCH_TYPE NE ARCH_EMU
 E450  33 C9		     1		XOR	CX, CX 				; delay 65535 LOOPs
			     1		IO_DELAY
			     2			LOCAL _DONE
 E452			     2	??0013:
 E452  E2 FE		     2		LOOP	??0013					; long delay for I/O
			     1				ENDIF
				
				;----------------------------------------------------------------------------;
				; Call Option ROM's BIOS init routine
 E454  59			;
 E455  E2 F6				IN	AL, INT_IMR 			; get current OCW1/IMR register
					PUSH	AX					; save IMR
					PUSH	DI					; save ending segment
					MOV	DI, OFFSET ROM_INIT_SS		; BDA = temp location for FAR CALL
					MOV	ES:[DI], SI				; init vector offset (always 3)
					MOV	ES:[DI][2], DS			; init vector segment
 E457					CALL	DWORD PTR ES:[DI]			; CALL Option ROM init
 E457  CD 18				CLI						; make sure interrupts are disabled
					POP	DI					; restore ending segment
					POP	AX					; restore IMR
					OUT	INT_IMR, AL				; reset IMR
				NEXT_ROM:
					POP	BX					; restore next boundary size
					POP	AX					; restore current DS segment
					ADD	AX, BX				; next boundary
					MOV	DS, AX
					CMP	AX, DI 				; end of extension ROM regions?
					JB	CHECK_ROM 				; if not, check next
				ROM_SCAN_DONE:
					POPX	ES, DS, BP				; restore regs
 E459					RET
				BIOS_ROM_SCAN ENDP
				
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <BOOT_FAIL>,<SI>			; if SZ is not SI
 E459  BE E46E R	     1		MOV	SI, OFFSET BOOT_FAIL
			     1			ENDIF
 E45C  E8 128E		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E45F  33 C0			;----------------------------------------------------------------------------;
 E461  8E D8			; Perform 8 bit Checksum on a ROM at DS:0000
 E463  A3 0472 R		;----------------------------------------------------------------------------;
 E466  CD 16			; Input:
 E468  E9 FBF0			;	DS = segment for ROM
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 84 - 1


 E46B				;	AL = ROM size in 512k blocks (1-127)
				; Output:
 E46B				;	ZF if checksum is valid
				;	AX = number of bytes read
				;	DX = 8 bit checksum value
				;
				; Size: 20 bytes
				;----------------------------------------------------------------------------;
				ROM_CHECKSUM PROC
							ASSUME DS:BIOS
					PUSH	CX
 E46B					PUSH	SI
					CBW					; AH = 0
 E46B					CWD					; DL = 0 (accumulator for sum)
					MOV	SI, DX			; start at offset 0
					XCHG	AL, AH			; convert 512 byte blocks to 16 bit words
					XCHG	AX, CX			; CX = size in 2 byte WORDs
				CHECKSUM_LOOP:
					LODSW					; next two bytes into AL and AH
					ADD	DL, AL			; add both to sum
					ADD	DL, AH			; ZF if sum is 0
					LOOP	CHECKSUM_LOOP		; loop through entire ROM
 E46B 0D 0A 00				XCHG	AX, SI			; AX = bytes read
 E46E 44 69 73 6B 20 42			POP	SI
       6F 6F 74 20 46 61
       69 6C 2E
 E47D  20 59 6F 75 20 6D		POP	CX
       6F 6E 73 74 65 72
       2E
 E48A 0A				RET
 E48B 0D 0A			ROM_CHECKSUM ENDP
 E48D 50 72 65 73 73 20		
       74 68 65 20 41 6E
       79 20 4B 65 79 2E
       2E 2E
 E4A1  00			;----------------------------------------------------------------------------;
 E4A2				; DETECT_MEMORY - Detect, test and clear RAM
				;----------------------------------------------------------------------------;
 E4A2				; Attempt to determine how much RAM is installed using MEM_ADDR_TEST for 
				; more reliable memory detection.
				;
				; Output: Memory count to console
 E4A2 43 50 55 00		;
 E4A6  38 30 38 38 00		; NOTE: Testing first two bytes of each block is problematic:
 E4AB 46 50 55 00		; http://minuszerodegrees.net/5160/problems/5160_known_problems_issues.htm
 E4AF  38 30 38 37 00		; http://minuszerodegrees.net/5160/problems/5160_ram_size_flaw.htm
 E4B4 3A 00			;----------------------------------------------------------------------------;
 E4B6  20 4D 42			DETECT_MEMORY PROC
 E4B9  00						ASSUME DS:_BDA, ES:NOTHING
 E4BA 52 41 4D 00			PUSH	ES
 E4BE  30 30 30 20 4B 42		PUSH	DS
 E4C4  20 4F 4B 00			MOV	AX, SEG _BDA
 E4C8 56 32 30				MOV	DS, AX
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 85 - 1


				; 5150 or MAX_RAM_AUTO: get MAX RAM from MEM_SZ_PC
 E4CB  00			;
 E4CC 4C 50 54 00					IF ARCH_TYPE EQ ARCH_5150 OR MAX_RAM_AUTO EQ 1
 E4D0 43 4F 4D 00			MOV	AX, MEM_SZ_PC			; SW2 RAM size in KB
 E4D4 46 44 44 00			MOV	CL, 4					; shift counter
 E4D8 48 44 44 00			SHR	AX, CL				; Number of 16KB RAM blocks
 E4DC 20 5B 20 00			XCHG	AX, CX				; CX = 16KB RAM blocks
 E4E0 20 5D 00				DEC	CX					;  after first 16K block
 E4E3							ELSE
				
 E4E3 49 4F			;----------------------------------------------------------------------------;
 E4E5 20 50 41 52		; UM82C088: get RAM status register
				;
 E4E9  49 54 59							IF ARCH_TYPE EQ ARCH_UM82
					CALL	UM82_MEM_SIZE			; CX = 16KB RAM blocks - 1
 E4EC  00			
				;----------------------------------------------------------------------------;
 E4ED				; Otherwise, use default for MAX_RAM and detect
				;
								ELSE
					MOV	CX, (MAX_RAM SHR 4) - 1		; Max number of 16KB RAM blocks
											; (ex: 640K / 16K = 40)
								ENDIF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Detect RAM size in 16K blocks
				; Output: ES = highest memory segment "detected"
				;
					MOV	DX, 16 * 1024 SHR 4		; Start at second 16KB block
					MOV	ES, DX				; ES = seg 0400H
				BLOCK_LOOP:
					CALL	MEM_ADDR_TEST			; address test on 16KB RAM block at ES
					JNZ	BLOCK_LOOP_DONE			; exit loop if test failed
					ADD	DH, 4					; add 400h paras (4000h bytes)
					MOV	ES, DX
					LOOP	BLOCK_LOOP				; loop until MAX_RAM
				BLOCK_LOOP_DONE:
				
				;----------------------------------------------------------------------------;
 E4ED				; Test and clear RAM, show memory count
				;
				; Input:
			     1				IFNB <BP>			; exit if last reg
 E4ED  55		     1		PUSH	BP 					; push register and repeat
			     1		PUSHX	DS, ES, , , , , 
			     2				IFNB <DS>			; exit if last reg
 E4EE  1E		     2		PUSH	DS 					; push register and repeat
			     2		PUSHX	ES, , , , , , 
			     3				IFNB <ES>			; exit if last reg
 E4EF  06		     3		PUSH	ES 					; push register and repeat
			     3		PUSHX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		PUSH	 					; push register and repeat
			     4		PUSHX	, , , , , , 
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 86 - 1


			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 E4F0  8E D8			;	ES = highest memory segment "detected"
 E4F2				;	DX = size of memory in paras
 E4F2  FC			;
 E4F3  BB ---- R					IF ARCH_TYPE EQ ARCH_FE2010
 E4F6  8E C3				CALL	FE2010_SETUP_MEM			; set up FE2010 configuration
 E4F8  1E						ENDIF
 E4F9  B3 80			
 E4FB  53						IF CPU_TYPE	EQ CPU_V20
 E4FC  33 F6				SHR	DX, 6					; V20: shift right 6 times to get K
 E4FE  AD						ELSE
 E4FF  3D AA55				MOV	CL, 6					; 8088: shift right 6 times to get K
 E502  75 26				SHR	DX, CL
 E504							ENDIF
 E504  AC				MOV	MEM_SZ_KB, DX 			; save to BDA
 E505  3C 00				MOV	DX, ES				; DX = highest RAM segment detected
 E507  7E 21			
 E509  E8 002C			;----------------------------------------------------------------------------;
				; Display RAM row
				;
					POST_COL_1	POST_MEMORY, POST_CLR_VAL1 ; display RAM column, SI returned
 E50C  75 1C										;  as POST_KB_OK (next string)
 E50E  5B				CALL	OUT_SZ				; display '000 KB OK'
					POST_COL_END				; end post column
					XOR	BX, BX				; BX = 0, segment and memory test counter
					MOV	ES, BX				; start at segment 0000
 E50F  B1 04			ZERO_ALL_RAM:
 E511  D3 E8				XOR	AX, AX				; zero AX
					ADD	BX, 16				; increment Memory count value
 E513  50				CMP	BX, 100				; CF if two digit number
					ADC	AL, POST_COL_VT			; space inner column for 2 or 3 digits
					CALL	MOVE_COL				; move to start of inner column
					MOV	AX, BX				; move RAM size to AX for display
					PUSH	BX					; save RAM size
 E514  E4 21				CALL	OUT_DECU				; display AX as decimal
 E516  50				POP	BX					; restore RAM size
 E517  57				MOV	AX, ES				; AX = last segment tested
 E518  BF 0067 R			ADD	AX, 16 * 1024 SHR 4		; move to next 16K segment/block
 E51B  26: 89 35			CMP	AX, DX				; is last segment of RAM?
 E51E  26: 8C 5D 02			JNB	DONE_ZERO_ALL_RAM			; exit if end
 E522  26: FF 1D			MOV	ES, AX				; ES = last segment tested
 E525  FA			
 E526  5F						IF RAM_TEST_LONG EQ 1
 E527  58				JWB	ZERO_ALL_START			; skip long tests on warm boot
 E528  E6 21			
 E52A				;----------------------------------------------------------------------------;
 E52A  5B			; Perform memory checks on this block
 E52B  58			;
 E52C  03 C3			TEST_MEM_LONG:
 E52E  8E D8				CALL	NMI_RESET				; clear NMI/parity flags
 E530  3B C7				CALL	MEM_TEST				; read/write test on 16KB RAM block at ES
 E532  72 BE				JNZ	DETECT_MEMORY_ERR
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 87 - 1


 E534				
							IF RAM_PARITY EQ 1
			     1				IFNB <ES>			; exit if last reg
 E534  07		     1		POP	ES 					; pop register and repeat
			     1		POPX	DS, BP, , , , , 
			     2				IFNB <DS>			; exit if last reg
 E535  1F		     2		POP	DS 					; pop register and repeat
			     2		POPX	BP, , , , , , 
			     3				IFNB <BP>			; exit if last reg
 E536  5D		     3		POP	BP 					; pop register and repeat
			     3		POPX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		POP	 					; pop register and repeat
			     4		POPX	, , , , , , 
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 E537  C3				XCHG	AX, DX				; save AX
 E538					IN	AL, PPI_C				; read PPI Port C
					AND	AL, MASK PCPE OR MASK PCIE	; was there parity or NMI error?
					XCHG	AX, DX				; DL = parity error flag(s)
					JNZ	DETECT_MEMORY_ERR			; jump if parity error
							ENDIF				; END RAM_PARITY EQ 1
							ENDIF				; END RAM_TEST_LONG EQ 1
				
				;----------------------------------------------------------------------------;
				; Write 0's to all memory in this block
				;
				ZERO_ALL_START:
					XOR	AX, AX 				; write zeros
					MOV	CX, 16 * 1024 / 2			; loop 16KB in WORDs
					MOV	DI, AX				; DI = beginning of segment
					REP	STOSW 				; write zero to next 16KB
 E538					JMP	SHORT ZERO_ALL_RAM
				DONE_ZERO_ALL_RAM:
 E538  51				POP	DS
 E539  56				POP	ES
 E53A  98				RET
 E53B  99			
 E53C  8B F2			;----------------------------------------------------------------------------;
 E53E  86 C4			; Compare the result read from memory to the expected results to determine
 E540  91			; which bit(s) did not match.
 E541				;
 E541  AD			; Error will be displayed as SEG:OFF BBBB.
 E542  02 D0			;
 E544  02 D4			; - SEG: location/bank in memory of the failed IC, which can be calculated
 E546  E2 F9			;   using the following:
 E548  96			;   http://minuszerodegrees.net/5160/ram/5160_ram_201_error_breakdown.jpg
 E549  5E			; - OFF: offset where the failure occurred
 E54A  59			; - BBBB: bit pattern difference between what was expected and what was 
 E54B  C3			;   read. This should reveal which IC in that bank failed.
 E54C				;----------------------------------------------------------------------------;
				; Input:
				; 	DL = 0 if no parity error, bit 7 or 6 set if error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 88 - 1


				;
				DETECT_MEMORY_ERR:
					POST_FLAG_SET  PMEM			; set POST Memory error flag
					CALL	CRLF					; start on new line
					POST_COL_1	POST_ERR_ERR, RED
					DEC	DI					; move back to last address
					DEC	DI
					XOR	AX, ES:[DI]				; determine incorrect bit(s)
					XCHG	AX, DI				; DI = bit pattern, AX = err offset
					MOV	BX, ES				; segment of error
					CALL	DWORD_HEX				; write address
 E54C					TEST	DL, DL				; was there a parity error?
					JZ	DETECT_MEMORY_ERR_2		; jump if not
 E54C  06				PRINT_SZ  NMI_ERR_PAR			; print 'PARITY'
 E54D  1E				JMP	SHORT DETECT_MEMORY_ERR_DONE
 E54E  B8 ---- R		DETECT_MEMORY_ERR_2:
 E551  8E D8				XCHG	AX, DI				; restore failed bit pattern
					CALL	WORD_HEX
				DETECT_MEMORY_ERR_DONE:
					POST_COL_END
					JMP	SHORT DONE_ZERO_ALL_RAM
				DETECT_MEMORY ENDP
 E553  A1 0015 R		
 E556  B1 04			;----------------------------------------------------------------------------;
 E558  D3 E8			; Test Memory Address Lines on a 16KB block
 E55A  91			;----------------------------------------------------------------------------;
 E55B  49			; Write a byte to the first address in a segment and write a different
				; value with one address line toggled. Read back the values to ensure
				; they are both correct. Repeat 8 times for each starting bit.
				;
				; Input:
				;	ES = segment to test
				; Output:
				;	ZF if okay, NZ if fail
				;	BX = offset of failed byte/line, DI
				;
				; Clobbers AL
				;
				; Inspired by:
				; http://www.ganssle.com/testingram.htm
				; http://www.paul.de/tips/ramtest.htm
				; https://www.memtest86.com/tech_memtest-algoritm.html
				; Size: 38 bytes
				;----------------------------------------------------------------------------;
				MEM_ADDR_TEST PROC
					MOV	AL, 1					; pattern to rotate
					XOR	BX, BX				; base address
					MOV	DI, 2000H				; highest address in 16KB segment
 E55C  BA 0400			MEM_ADDR_LOOP:
 E55F  8E C2				MOV	ES:[BX], AL				; write to base address
 E561					NOT	AL					; invert value
 E561  E8 0081				MOV	ES:[DI], AL				; write inverted value
 E564  75 07				NOT	AL					; revert value
 E566  80 C6 04				CMP	ES:[BX], AL				; is base value the same?
 E569  8E C2				JNZ	MEM_ADDR_ERR			; jump if not
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 89 - 1


 E56B  E2 F4				NOT	AL					; invert value again
 E56D					CMP	ES:[DI], AL				; is second value the same?
					JNZ	MEM_ADDR_ERR			; jump if not
					NOT	AL					; revert value again
					ROL	AL, 1					; walk test value
					SHR	DI, 1					; move to next address line
					JNZ	MEM_ADDR_LOOP			; loop until offset is 0
				MEM_ADDR_ERR:
					RET
				MEM_ADDR_TEST ENDP
				
				;----------------------------------------------------------------------------;
				; Test a 16KB block of Memory at ES:0000
				;----------------------------------------------------------------------------;
				; Trivial read/write test - Write pattern RAM_TEST and reads it back, then 
				; repeat with inverse RAM_TEST. If NMI is on, this could trigger a parity
				; error.
 E56D  B1 06			;
 E56F  D3 EA			; Input:
				; 	ES = segment to test
 E571  89 16 0013 R		;
 E575  8C C2			; Clobbers AX, CX, DI
				;
				; ZF and AX = 0 if pass, NZ if fail
				; Size: 22 bytes
				;----------------------------------------------------------------------------;
				MEM_TEST PROC
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 E577  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 E579  BE E4BA R	     1		MOV	SI, OFFSET POST_MEMORY
 E57C  E8 1115		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
					MOV	AX, RAM_TEST			; test pattern
 E57F  E8 116B				CALL	MEM_CHECK
					NOT	AX					; invert pattern
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E582  E8 114D		     1		CALL	POST_END_COL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E585  33 DB			
 E587  8E C3			;----------------------------------------------------------------------------;
 E589				; Write and verify a 16KB block of Memory at ES:0000
 E589  33 C0			;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 90 - 1


 E58B  83 C3 10			; Input:
 E58E  83 FB 64			;	AX = pattern to write
 E591  14 09			; 	ES = segment for test
 E593  E8 1166			;
 E596  8B C3			; ZF and AX = 0 if pass, NZ if fail
 E598  53			;----------------------------------------------------------------------------;	
 E599  E8 118B			MEM_CHECK PROC
 E59C  5B				MOV	CX, 16 * 1024 / 2			; loop 16KB in WORDs
 E59D  8C C0				XOR	DI, DI 				; start at offset 0
 E59F  05 0400				REP	STOSW 				; write test pattern
 E5A2  3B C2			MEM_TEST_VERIFY:
 E5A4  73 0D				MOV	CH, HIGH (16 * 1024 / 2)	; restart loop 16KB in WORDs
 E5A6  8E C0				XOR	DI, DI 				; start at offset 0
					REPZ	SCASW 				; loop until CX = 0 OR WORD is not AX
					XCHG	AX, CX				; AX = 0 if success
					RET
				MEM_CHECK ENDP
				MEM_TEST ENDP
				
							IF POST_WARM_COLD EQ 1
				;----------------------------------------------------------------------------;
				; Display "WARM" or "COLD" boot
				;----------------------------------------------------------------------------;
				; Size: 39 bytes
				;----------------------------------------------------------------------------;
				POST_BOOT_TYPE PROC
					MOV	SI, OFFSET POST_BOOT		; BOOT string
					MOV	BL, POST_CLR_WARM			; attribute to warm color
					CALL	POST_START_COL_1			; display column label
											;  CX=POST_TAB_COL_I, SI=WARM string
					JWB	POST_BOOT_TYPE_OUT		; jump if warm boot
					MOV	BL, POST_CLR_COLD			; attribute to cold color
					MOV	SI, OFFSET POST_COLD		; COLD string
				POST_BOOT_TYPE_OUT:
					CALL	OUT_SZ_ATTR				; write string with attribute
					POST_COL_END_NL				; end of column end NL
					RET
 E5A8				
 E5A8  33 C0			POST_BOOT	DB	'Boot', 0
 E5AA  B9 2000			POST_WARM	DB	'WARM', 0
 E5AD  8B F8			POST_COLD	DB	'COLD', 0
 E5AF  F3/ AB			
 E5B1  EB D6			POST_BOOT_TYPE ENDP
 E5B3							ENDIF
 E5B3  1F			
 E5B4  07						IF POST_VIDEO_TYPE EQ 1
 E5B5  C3			;----------------------------------------------------------------------------;
				; Display Video Type
				;----------------------------------------------------------------------------;
				; Size: 109 bytes
				;----------------------------------------------------------------------------;
				POST_SYS_VIDEO PROC
					POST_COL_2	POST_VIDEO, POST_CLR_VAL1 ; display "Video" left column
											; default to "None"
				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 91 - 1


				;----------------------------------------------------------------------------;
				; Check if INT 10 is using the BIOS. If so, must be CGA or MDA.
				;
				; Necessary to check both segment and offset? (would save a few bytes if not)
				;
					PUSH	DS
					XOR	AX, AX				; AX = SEG _IVT
					MOV	DS, AX				; set IVT segment for LDS
							ASSUME DS:_IVT
 E5B6					LDS	AX, DWORD PTR IVT_10		; if BIOS, DS = 0F000H, AX = 0F065H
					CMP	AX, OFFSET INT_10			; is offset the BIOS IRR for INT 10?
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		SET1_BP   PMEM				; V20 only: SET1 BP, PMEM
			     1				ELSE
 E5B6  81 CD 0200	     1		OR	BP, MASK PMEM			; Set flag
			     1				ENDIF
 E5BA  E8 1159				MOV	AX, DS				; save for next compare
					POP	DS					; restore DS
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW RED		; BH = 0, BL = attribute
			     1			ELSE
 E5BD  B3 0C		     1		MOV	BL, LOW RED		; BL = attribute
			     1			ENDIF
 E5BF  BE E8FC R	     1		MOV	SI, OFFSET POST_ERR_ERR
 E5C2  E8 10CF		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
 E5C5  4F						ASSUME DS:_BDA
 E5C6  4F				JNE	CHECK_VGA				; jump to VGA check if not
 E5C7  26: 33 05			MOV	BX, CS				; AX = BIOS code segment
 E5CA  97				CMP	AX, BX				; is segment BIOS?
 E5CB  8C C3				JNE	CHECK_VGA
 E5CD  E8 116E			
 E5D0  84 D2			;----------------------------------------------------------------------------;
 E5D2  74 08			; Read BDA for video type
				;
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <NMI_ERR_PAR>,<SI>			; if SZ is not SI
 E5D4  BE E4E5 R	     1		MOV	SI, OFFSET NMI_ERR_PAR
			     1			ENDIF
 E5D7  E8 1113		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E5DA  EB 04			BIOS_VIDEO:
 E5DC					CALL	INT_10_IS_TXT			; CF = 1 if MDA mode 7
 E5DC  97				MOV	SI, OFFSET POST_MDA		; default "MDA"
 E5DD  E8 116A				JC	POST_SYS_VIDEO_DONE
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 92 - 1


 E5E0					MOV	SI, OFFSET POST_CGA		; otherwise "CGA"
					JMP	SHORT POST_SYS_VIDEO_DONE
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E5E0  E8 10EF		     1		CALL	POST_END_COL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E5E3  EB CE			
 E5E5				;----------------------------------------------------------------------------;
				; Check if VGA
				; stanislavs.org/helppc/int_10-1a.html
				;
				CHECK_VGA:
					MOV	AX, DBW <1AH, 0>			; AH = 1AH, get video display
					INT	10H					; BL = display type
					CMP	AL, 1AH				; is VGA?
					JNE	CHECK_EGA				; jump if not VGA
					MOV	SI, OFFSET POST_VGA		; is "VGA"
					JMP	SHORT POST_SYS_VIDEO_DONE
				
				;----------------------------------------------------------------------------;
				; Check if EGA
				; stanislavs.org/helppc/int_10-12.html
				;
				CHECK_EGA:
					MOV 	AH, 12H				; AH = 12H, get video configuration
					MOV	BL, 10H				; configuration info
					INT	10H
					CMP	BL, 10H				; check if param hasn't changed
					JE	POST_SYS_VIDEO_DONE		; jump if not EGA
					MOV	SI, OFFSET POST_EGA		; is "EGA"
 E5E5				
 E5E5  B0 01			POST_SYS_VIDEO_DONE:
 E5E7  33 DB				CALL	OUT_SZ				; display detected video adapter
 E5E9  BF 2000				POST_COL_END_NL
 E5EC					RET
 E5EC  26: 88 07		
 E5EF  F6 D0			POST_SYS_VIDEO ENDP
 E5F1  26: 88 05						ENDIF
 E5F4  F6 D0			
 E5F6  26: 38 07		;
 E5F9  75 0F			; 0 BYTES HERE
 E5FB  F6 D0			;
 E5FD  26: 38 05		BYTES_HERE	INT_19
 E600  75 08			
 E602  F6 D0			;----------------------------------------------------------------------------;
 E604  D0 C0			; INT 19 - Bootstrap Loader
 E606  D1 EF			;----------------------------------------------------------------------------;
 E608  75 E2			; IPL: track 0, sector 1 is loaded into address 0:7C00 and control 
 E60A				; is transferred.
 E60A  C3			;
 E60B				; Input:
				; 	DL = physical drive where boot sector is located (00=A:,80h=C:)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 93 - 1


				; Output:
				;	Transfer control to bootable MBR if success
				;	IRET if failure
				;
				; Clobbers AX, BX, CX, DH, DI, DS, ES
				;----------------------------------------------------------------------------;
						ORG 0E6F2H
				INT_19 PROC
							ASSUME DS:_IPL_SEG, ES:_IPL_SEG
					STI						; enable interrupts
					CLD						; clear direction for STOS
					XOR	CX, CX				; CX = 0
					MOV	DS, CX				; DS = IPL Segment (0000)
					MOV	ES, CX				; ES = IPL Segment (0000)
					MOV	DI, OFFSET IVT_1E			; INT 1E vector table address
 E60B					MOV	AX, OFFSET INT_1E 		; INT 1E DBT address
 E60B  B8 95A5				STOSW
 E60E  E8 0002				MOV	AX, CS				; INT 1E DBT segment
 E611  F7 D0				STOSW
				INT_19_READ_MBR:
					XCHG	AX, CX				; AH = 0 (reset)
					INT	13H					; reset disk 0
					JC	INT_19_IPL_FAIL			; exit if error
					MOV	AX, DBW <2, 1>			; AH = 2 (read), AL = 1 sector
					MOV	BX, OFFSET IPL_TOP		; ES:BX = IPL boot sector offset
					MOV	CX, DBW <0, 1>			; CH = cyl 0, CL = sec 1
					MOV	DH, CH 				; DH = head 0, DL = drive #
					INT	13H					; read 1 sector into ES:BX
					JC	INT_19_IPL_FAIL			; exit if error
 E613							IF MBR_CHECK EQ 1
 E613  B9 2000				CMP	IPL_ID, MAGIC_WORD		; verify bootable MBR signature
 E616  33 FF				JNZ	INT_19_IPL_FAIL			; jump if MBR not bootable
 E618  F3/ AB						ENDIF
 E61A					JMP 	FAR PTR IPL_TOP 			; jump to IPL segment and boot!
 E61A  B5 20			INT_19_IPL_FAIL:
 E61C  33 FF				IRET
 E61E  F3/ AF			INT_19 ENDP
 E620  91			
 E621  C3					IF POST_HD_CHECK EQ 1
 E622				;----------------------------------------------------------------------------;
 E622				;  Get Hard Drive Parameters
				;----------------------------------------------------------------------------;
				;  Input:
				;	DL = drive number
				;  Output:
				; 	CF if Error
				;	AL = number of heads (AX if no error)
				; 	AH = return code
 E622				;	BX = last cylinder
 E622  BE E63A R		; 	CX = logical last index of sectors/track
 E625  B3 04			;	DX = number of hard disk drives (all)
 E627  E8 106A			;----------------------------------------------------------------------------;
				GET_DISK_PARAMS PROC
					MOV	AH, 8 			; Get Drive in DL Parameters: 
			     1				IF WARM_ENABLE EQ 1
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 94 - 1


 E62A  85 ED		     1		TEST	BP, BP				; is warm boot?
 E62C  78 05		     1		JS	POST_BOOT_TYPE_OUT					; jump if so
			     1				ENDIF
 E62E  B3 09				INT	13H				;  CH = Last cyl, CL = # cylinders
 E630  BE E644 R								;  DH = heads, DL = # drives
 E633										;  ES:DI = drive table
 E633  E8 10A5				JC	GET_DISK_PARAMS_ERR 	; if error, exit
					MOV	BX, CX 			; BX = last cylinder
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E636  E8 1094		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E639  C3				XCHG	BH, BL 			; swap bytes
					ROL	BH, 1 			; rotate high two bits into low bits
 E63A 42 6F 6F 74 00			ROL	BH, 1
 E63F 57 41 52 4D 00			AND	BH, 11B			; BX = cylinder (10 bits)
 E644 43 4F 4C 44 00			AND	CX, 00111111B		; CX = logical last index of sectors/track
					MOV	AL, DH
 E649					INC	AX				; convert heads to 1 index (count)
					INC	BX				; convert cylinders to 1 index
					XOR	DH, DH			; clear high byte of DX, CF = 0
				GET_DISK_PARAMS_ERR:
					RET
				GET_DISK_PARAMS ENDP
						ENDIF
				
				;
 E649				; 0 BYTES HERE
				;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 E649  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 E64B  BE FF47 R	     1		MOV	SI, OFFSET POST_VIDEO
 E64E  E8 106A		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				BYTES_HERE	INT_14
				
				;----------------------------------------------------------------------------;
				; INT 14 - BIOS COM Port Services
				;----------------------------------------------------------------------------;
				;	INT 14,0  Initialize serial port parameters
				;	INT 14,1  Send/write character in AL
 E651  1E			;	INT 14,2  Receive/read character in AL
 E652  33 C0			;	INT 14,3  Get Serial port status
 E654  8E D8			;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 95 - 1


				; All functions have:
 E656  C5 06 0040 R		;	  AH = function number
 E65A  3D F065 R		;	  AL = character to send or receive
 E65D  8C D8			;	  DX = zero based RS232 card number
 E65F  1F			;
				; All registers call-preserved (except AX)
 E660  75 13			;----------------------------------------------------------------------------;
 E662  8C CB			; Ref:
 E664  3B C3			; https://stanislavs.org/helppc/int_14.html
 E666  75 0D			;----------------------------------------------------------------------------;
						ORG 0E739H
				INT_14 PROC
							ASSUME DS:_BDA
					STI 					; enable interrupts
 E668					PUSH	CX 				; call-preserve CX
 E668  E8 0A1A				MOV	CX, 3 			; will use this 3 in multiple places
 E66B  BE F7B1 R			CMP	DX, CX			; is port number less than 4?
 E66E  72 21				JA	INT_14_EXIT 		; if not, exit
 E670  BE F7AD R			PUSHX	DI, BX, DX, DS		; call-preserve registers
 E673  EB 1C				MOV	DI, SEG _BDA 		; DS = BDA
					MOV	DS, DI
					MOV	DI, DX 			; DI = COM port index (0-3)
					SHL	DI, 1 			; convert to word index
					MOV	DX, [DI] 			; DX = 3F8/2F8 base port address
					SHR	DI, 1 			; back to byte index
 E675					TEST	DX, DX 			; is port index valid (detected)?
 E675  B8 1A00				JZ	INT_14_DONE 		; if not, exit
 E678  CD 10				CMP	AH, CL			; check function number (CL = 3)
 E67A  3C 1A				JA	INT_14_DONE			; > 3? Not valid
 E67C  75 05				JZ 	INT_14_3	 		; = 3 then status
 E67E  BE F7A5 R			CMP	AH, 1				; check remaining functions
 E681  EB 0E				JA	INT_14_2 			; = 2 then read
					JZ	INT_14_1 			; = 1 then write
										; = 0 fall through to init
				
				;----------------------------------------------------------------------------;
				; INT 14,0  Initialize serial port parameters
 E683				;----------------------------------------------------------------------------;
 E683  B4 12			; https://stanislavs.org/helppc/int_14-0.html
 E685  B3 10			; https://stanislavs.org/helppc/8250.html
 E687  CD 10			;----------------------------------------------------------------------------;
 E689  80 FB 10			; Baud rate divisor table:
 E68C  74 03			;	0 (000) = 110 baud -> 417H	|	4 (100) = 1200 baud -> 60H
 E68E  BE F7A9 R		;	1 (001) = 150 baud -> 300H	|	5 (101) = 2400 baud -> 30H
				;	2 (010) = 300 baud -> 180H	|	6 (110) = 4800 baud -> 18H
 E691				;	3 (011) = 600 baud -> 0C0H	|	7 (111) = 9600 baud -> 0CH
 E691  E8 1059			;
				; Formula:
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E694  E8 1036		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 96 - 1


 E697  C3			;	if (baud == 110) then
				; 		divisor = 417H
 E698				;	else
				;		divisor = 600H >> index
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = base port address
				;	AL = port params, AH = 0
				;	CX = 3 (from earlier)
 E698			     1			LOCAL LBL
			     1	
 = 005A			     1	BYTES_HERE_INT_19 = INT_19-$
			     1	
			     1			IFDEF BYTES_HERE_INT_19
			     1			IF2
			     1			IF BYTES_HERE_INT_19 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_19 (BYTES_HERE_INT_19)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				;----------------------------------------------------------------------------;
				
				INT_14_0 PROC
				;----------------------------------------------------------------------------;
				; Set baud rate
				;
					MOV	DI, DX 			; DX = 3F8/2F8 base port
					ADD	DX, CX			; DX = 3FB/2FB Line Control Register (LCR), CX = 3
					XCHG	AX, BX			; save port params to BL
					MOV	AL, MASK DLAB 		; set baud rate divisor (DLAB); 0 = RBR, THR or IER
					OUT	DX, AL 			; write to 3FB/2FB (LCR)
					SHL	BX, CL 			; BH = baud rate, CL = 3
					SHR	BL, CL 			; BL = flags
					MOV	AX, 417H 			; divisor for 110 baud
					MOV	CL, BH 			; CL = shift counter or 0 for 110 baud (CH = 0)
					JCXZ	INT_14_0_SET_BAUD		; Jump if 110 baud
 E6F2					MOV	AX, 600H 			; AX = divisor base (see above formula)
					SHR	AX, CL			; divisor = 600H >> CL
 E6F2  FB			INT_14_0_SET_BAUD:
 E6F3  FC				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4)
 E6F4  33 C9									; AL = Divisor LSB, AH = Divisor MSB (4)
 E6F6  8E D9				OUT	DX, AX			; write LSB, then MSB to ports 3F8/3F9
 E6F8  8E C1			;----------------------------------------------------------------------------;
 E6FA  BF 0078 R		; Set parity, stop and word bits
 E6FD  B8 EFC7 R		; 
 E700  AB			INT_14_0_SET_PSW:
 E701  8C C8				XCHG	AX, BX 			; AL = parity, stop and word bits (4)
 E703  AB				XCHG	DX, DI 			; DX = 3FB/2FB, DI = 3F8/2F8 (4)
 E704					OUT	DX, AL			; set LCR parity, stop and word bits
 E704  91				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4)
 E705  CD 13			;----------------------------------------------------------------------------;
 E707  72 14			; Disable IER
 E709  B8 0201			;
 E70C  BB 7C00 R			XOR	AX, AX 			; AL = 0 (3)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 97 - 1


 E70F  B9 0001				INC	DX 				; DX = 3F9/2F9 (3)
 E712  8A F5				OUT	DX, AL			; DX = 3F9 - Interrupt Enable Register (IER) disabled
 E714  CD 13				DEC	DX 				; DX = 3F8 (3)
 E716  72 05									; fall through to get status
				
				;----------------------------------------------------------------------------;
				; INT 14,3  Get Serial port status
				;----------------------------------------------------------------------------;
 E718  EA ---- 7C00 R		; Input:
 E71D				; 	DX = base port address
 E71D  CF			; Output:
 E71E				;	AH = port status
				;	AL = modem status
				;----------------------------------------------------------------------------;
				INT_14_3 PROC
					ADD	DX, 5 			; DX = 3FD/2FD LSR - Line Status Register
					PUSH	BX				; delay for I/O
					IN	AL, DX 			; get line/port status 
					XCHG	AH, AL 			; save to AH
					INC	DX 				; DX = 3FE/2FE MSR - Modem Status Register
					POP	BX 				; delay for I/O
					IN	AL, DX 			; get modem status 
				INT_14_3 ENDP
				
				INT_14_DONE PROC
					POPX	DS, DX, BX, DI		; restore all registers
				INT_14_EXIT PROC
 E71E					POP	CX
 E71E  B4 08				IRET
 E720  CD 13			INT_14_EXIT ENDP
				INT_14_DONE ENDP
				
 E722  72 14			INT_14_0 ENDP
 E724  8B D9			
 E726  86 FB			;----------------------------------------------------------------------------;
 E728  D0 C7			; INT 14, 1 - Send/write character in AL
 E72A  D0 C7			;----------------------------------------------------------------------------;
 E72C  80 E7 03			; Input:
 E72F  83 E1 3F			; 	DX = base port address
 E732  8A C6			;	BL = port timeout
 E734  40			;----------------------------------------------------------------------------;
 E735  43			INT_14_1 PROC
 E736  32 F6				PUSH	DX 					; save base port
 E738					PUSH	AX
 E738  C3				ADD	DX, 4 				; DX = 3FC/2FC - Modem Control Register
 E739					MOV	AL, MASK RTS OR MASK DTR	; activate DTR & RTS
					OUT	DX, AL				; set DTR or RTS
					INC	DX
					INC	DX 					; DX = 3FE - Modem Status Register
					MOV	BX, DBW <MASK THRE OR MASK LBI, MASK MDSR> ; BH = line (THRE)
											;  BL = modem (DSR/CTS)
					CALL	INT_14_POLL 			; poll both registers, AH = status
 E739			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_14 = INT_14-$
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 98 - 1


			     1	
			     1			IFDEF BYTES_HERE_INT_14
			     1			IF2
			     1			IF BYTES_HERE_INT_14 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_14 (BYTES_HERE_INT_14)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					POP	BX
					MOV	AL, BL 				; AL = output char
					POP	DX 					; restore base port
					JNZ	INT_14_RW_ERR			; Jump if port timeout
					OUT	DX, AL
					JMP	SHORT INT_14_DONE
				INT_14_RW_ERR:
					OR	AH, 10000000B			; set error bit
					JMP	SHORT INT_14_DONE
				INT_14_1 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 14, 2 - Receive/read character in AL
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = base port address
				;	BL = port timeout
				; Output:
				;	AH = port status
				;	AL = character read
 E739				;	NZ = timeout or failure occurred
				;
 E739  FB			; Clobbers: BX
 E73A  51			;----------------------------------------------------------------------------;
 E73B  B9 0003			INT_14_2 PROC
 E73E  3B D1				PUSH	DX 					; save base port
 E740  77 56				ADD	DX, 4 				; DX = 3FC/2FC - Modem Control Register
					MOV	AL, MASK DTR			; activate DTR
			     1				IFNB <DI>			; exit if last reg
 E742  57		     1		PUSH	DI 					; push register and repeat
			     1		PUSHX	BX, DX, DS, , , , 
			     2				IFNB <BX>			; exit if last reg
 E743  53		     2		PUSH	BX 					; push register and repeat
			     2		PUSHX	DX, DS, , , , , 
			     3				IFNB <DX>			; exit if last reg
 E744  52		     3		PUSH	DX 					; push register and repeat
			     3		PUSHX	DS, , , , , , 
			     4				IFNB <DS>			; exit if last reg
 E745  1E		     4		PUSH	DS 					; push register and repeat
			     4		PUSHX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		PUSH	 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 99 - 1


			     2				ENDIF
			     1				ENDIF
 E746  BF ---- R			OUT	DX, AL				; set DTR
 E749  8E DF				INC	DX
 E74B  8B FA				INC	DX 					; DX = 3FE/2FE - Modem Status Register
 E74D  D1 E7				MOV	BX, DBW <MASK MDSR, MASK LDR>	; BH = modem (DSR), BL = line (data ready)
 E74F  8B 15				CALL	INT_14_POLL 			; poll both registers, AH = status
 E751  D1 EF				POP	DX 					; restore base port
 E753  85 D2				AND	AH, MASK LBI OR MASK LFE OR MASK LPE OR MASK LOE ; include only 
 E755  74 3D										;  error bits in port status
 E757  38 CC				IN	AL, DX				; read char from buffer
 E759  77 39				JMP	SHORT INT_14_DONE
 E75B  74 2D			INT_14_2 ENDP
 E75D  80 FC 01			
 E760  77 56			;----------------------------------------------------------------------------;
 E762  74 36			; INT 14 - Poll line then modem status registers
				;----------------------------------------------------------------------------;
				; Input:
				;	DI = port index (0 based byte)
				; 	DX = 3FE Modem Status Register
				;	BL = line status expected masked
				;	BH = modem status expected masked
				; Output:
				;	AH = port status
				;	DX = 3FD Line Status Register
				;	NZ = timeout or failure occurred
				;
				; Clobbers: AX, CX
				;----------------------------------------------------------------------------;
				INT_14_POLL PROC
					CALL	INT_14_POLL_PORT 		; first poll modem status
					JNZ	INT_14_POLL_RET  		; jump if ZF = 0, timeout or failure occurred
					XCHG	BH, BL 			; BH = line status
					DEC	DX				; DX = 3FD Line Status Register (LSR)
				
				;----------------------------------------------------------------------------;
				; INT 14 - Poll status register in DX
				;----------------------------------------------------------------------------;
				INT_14_POLL_PORT PROC
					PUSH	SI 				; call-preserve SI
					XOR	CX, CX			; reset poll loop counter
					MOV	AL, COM_TIME_B[DI]	; AL = port timeout (< 127)
 E764					CBW					; zero extend AX
					XCHG	AX, SI 			; SI = port timeout
				INT_14_POLL_LOOP:
					IN	AL, DX 			; check port status
 E764  8B FA				MOV	AH, AL 			; save to AH
 E766  03 D1				XOR	AL, BH 			; mask result bits
 E768  93				TEST	AL, BH 			; did it match expected result?
 E769  B0 80				JZ	INT_14_POLL_DONE
 E76B  EE				LOOP	INT_14_POLL_LOOP		; poll port 65,535 * timeout times
 E76C  D3 E3				DEC	SI 				; 
 E76E  D2 EB				JNZ	INT_14_POLL_LOOP		; Jump if timeout not expired
 E770  B8 0417			INT_14_POLL_DONE:
 E773  8A CF				POP	SI
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 100 - 1


 E775  E3 05			INT_14_POLL_RET:
 E777  B8 0600				RET
 E77A  D3 E8			INT_14_POLL_PORT ENDP
 E77C				INT_14_POLL ENDP
 E77C  87 D7			
				INT_14 ENDP
 E77E  EF			
				;----------------------------------------------------------------------------;
				; I/O port register test
				;----------------------------------------------------------------------------;
 E77F				; Do a Walking Bit/March test on I/O port registers.
 E77F  93			;
 E780  87 D7			; Input:
 E782  EE			;	DX = starting port
 E783  87 D7			;	BH = number of sequential ports to test
				; Output:
				;	ZF and CX = 0 if success
				;	NZ if failed
 E785  33 C0			;
 E787  42			; Adapted from:
 E788  EE			; https://barrgroup.com/embedded-systems/how-to/memory-test-suite-c
 E789  4A			; https://www.edaboard.com/threads/walking-1-0-test-for-memory-bist.241278/
				;
				; Size: 47 bytes
				; Clobbers AX, BX, CX, DX, DI
				;----------------------------------------------------------------------------;
				PORT_TEST PROC
					MOV	AH, 1				; start with low order bit
					XOR	CX, CX			; clear counter
					MOV	DI, DX			; save starting port
				
				;----------------------------------------------------------------------------;
				; Write a single 1 bit to a different position in each register
 E78A				;
 E78A  83 C2 05			WB_WRITE_1:
 E78D  53				MOV	CL, BH			; register counter
 E78E  EC				MOV	DX, DI 			; start at first register
 E78F  86 E0				MOV	AL, AH			; AL = starting bit to write
 E791  42			WB_WRITE_LOOP:
 E792  5B				OUT	DX, AL			; write to low byte
 E793  EC				IO_DELAY_SHORT
 E794					OUT	DX, AL			; write to high byte
					INC	DX				; next register/port
 E794					ROL	AL, 1				; walk bit to next position
					LOOP	WB_WRITE_LOOP
			     1				IFNB <DS>			; exit if last reg
 E794  1F		     1		POP	DS 					; pop register and repeat
			     1		POPX	DX, BX, DI, , , , 
			     2				IFNB <DX>			; exit if last reg
 E795  5A		     2		POP	DX 					; pop register and repeat
			     2		POPX	BX, DI, , , , , 
			     3				IFNB <BX>			; exit if last reg
 E796  5B		     3		POP	BX 					; pop register and repeat
			     3		POPX	DI, , , , , , 
			     4				IFNB <DI>			; exit if last reg
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 101 - 1


 E797  5F		     4		POP	DI 					; pop register and repeat
			     4		POPX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		POP	 					; pop register and repeat
			     5		POPX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 E798				
 E798  59			;----------------------------------------------------------------------------;
 E799  CF			; Read back bit pattern from each register
 E79A				;
 E79A					MOV	CL, BH			; register counter
					MOV	DX, DI 			; start at first register
 E79A					MOV	BL, AH			; BL = starting bit to compare
				WB_READ_LOOP:
					IN	AL, DX			; read low byte
					CMP	AL, BL			; compare to correct bit
					JNZ	PORT_TEST_DONE		; jump if not okay
				WB_LOW_CHECK_OK:
					IN	AL, DX			; read high byte
					CMP	AL, BL			; compare to correct bit
					JNZ	PORT_TEST_DONE		; jump if not okay
 E79A					INC	DX				; next register/port
 E79A  52				ROL	BL, 1				; rotate for next register/bit
 E79B  50				LOOP	WB_READ_LOOP		; loop all eight registers
 E79C  83 C2 04				SHL	AH, 1				; rotate to next starting bit
 E79F  B0 03				JNZ	WB_WRITE_1			; loop until AH = 0
 E7A1  EE			PORT_TEST_DONE:
 E7A2  42				RET
 E7A3  42			PORT_TEST ENDP
 E7A4  BB 3020			
				;----------------------------------------------------------------------------;
 E7A7  E8 0024			; Reset NMI enable flags
 E7AA  5B			;----------------------------------------------------------------------------;
 E7AB  8A C3			; Output:
 E7AD  5A			;	AL = current PPI B flags
 E7AE  75 03			;
 E7B0  EE			; Size: 11 bytes
 E7B1  EB E1			;----------------------------------------------------------------------------;
 E7B3				NMI_RESET PROC
 E7B3  80 CC 80				IN	AL, PPI_B				; read current flags
 E7B6  EB DC				OR	AL, MASK PBIO OR MASK PBPC	; parity, I/O flags high (disable)
 E7B8					OUT	PPI_B, AL				; write to PPI
					XOR	AL, MASK PBIO OR MASK PBPC	; flags low (enable)
					OUT	PPI_B, AL				; write to PPI
					RET
				NMI_RESET ENDP
				
				;
				; 6 BYTES HERE
				;
				BYTES_HERE	INT_16
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 102 - 1


				
				;----------------------------------------------------------------------------;
				; INT 16 - Keyboard BIOS Services
				;----------------------------------------------------------------------------;
				;	INT 16,0	Wait for keystroke and read
 E7B8				;	INT 16,1	Get keystroke status
 E7B8  52			;	INT 16,2	Get shift status
 E7B9  83 C2 04			; Enhanced:
 E7BC  B0 01			;	INT 16,5	Keyboard buffer write
 E7BE  EE			;	INT 16,10	Wait for keystroke and read
 E7BF  42			;	INT 16,11	Get keystroke status
 E7C0  42			;	INT 16,12	Get shift status
 E7C1  BB 2001			;----------------------------------------------------------------------------;
 E7C4  E8 0007					ORG 0E82EH
 E7C7  5A			INT_16 PROC
 E7C8  80 E4 1E					ASSUME DS:_BDA
					STI
 E7CB  EC				CLD
 E7CC  EB C6				PUSH	DS
 E7CE					PUSH	SI
					MOV	SI, SEG _BDA
					MOV	DS, SI 			; DS = BDA segment
					CMP	AH, 2
					JE	KB_SHIFT_STATUS 		; AH = 2 - Get Shift Status
					JA	INT_16_DONE			; AH > 2 - Not valid, exit
					JNP	KB_WAIT_READ_1		; AH = 0 - Wait for keystroke and read
										; AH = 1 - Get keystroke (fall through)
				
				;----------------------------------------------------------------------------;
				; AH = 1 - Get keystroke status
				;----------------------------------------------------------------------------;
				; Check if a key press is in buffer and return. Does not wait or remove.
				; Output:
				;	ZF = 0 if a key pressed (even Ctrl-Break)
				;	AH = scan code
				;	AL = ASCII character or zero if special function key
 E7CE				;----------------------------------------------------------------------------;
 E7CE  E8 0005			;	KB_BUF_HD (1Ah) = "head" next character stored in keyboard buffer
 E7D1  75 1A			;	KB_BUF_TL (1Ch) = "tail" next spot available in keyboard buffer
 E7D3  86 FB			;----------------------------------------------------------------------------;
 E7D5  4A			KB_KEY_STATUS PROC
					MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr
					CLI 					; disable interrupts
					LODSW 				; AX = head, SI = tail ptr
					CMP	AX, [SI]	 		; head == tail?
 E7D6					JNE	KB_BUF_HAS_KEY 		; if not, buffer has a key
 E7D6  56			KB_KEY_STATUS_DONE:
 E7D7  33 C9				STI					; re-enable interrupts
 E7D9  8A 45 7C				POP	SI
 E7DC  98				POP	DS
 E7DD  96				IRET_F				; IRET with current flags
 E7DE				KB_BUF_HAS_KEY:
 E7DE  EC				XCHG	AX, SI 			; SI = head
 E7DF  8A E0				LODSW 				; AX = buffer[head], SI = next
 E7E1  32 C7				JMP	KB_KEY_STATUS_DONE
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 103 - 1


 E7E3  84 C7			KB_KEY_STATUS ENDP
 E7E5  74 05			
 E7E7  E2 F5			;----------------------------------------------------------------------------;
 E7E9  4E			; AH = 0 - Wait for keystroke and read
 E7EA  75 F2			;----------------------------------------------------------------------------;
 E7EC				; Wait until keystroke is in buffer. Key press is removed from buffer.
 E7EC  5E			; Output:
 E7ED				;	AH = scan code
 E7ED  C3			;	AL = ASCII code
 E7EE				;----------------------------------------------------------------------------;
 E7EE				KB_WAIT_READ PROC
					STI					; enable interrupts
 E7EE						IF KB_HLT_WAIT EQ 1
					HLT					; wait for keystroke interrupt
						ELSE
					NOP					; wait for any interrupt
						ENDIF
				KB_WAIT_READ_1:
					MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr
					CLI 					; disable interrupts again
					LODSW 				; AX = head, SI = tail ptr
					CMP	AX, [SI] 			; head == tail?
					JE	KB_WAIT_READ 		; if so, buffer is empty
					XCHG	AX, SI 			; SI = tail
					LODSW 				; AX = buffer[tail], SI = next
					CMP	SI, KB_BUF_END_B		; is next >= end of buffer?
					JB	KB_GET_READ 		; if not, get tail value
					MOV	SI, OFFSET KB_BUF 	; otherwise, wrap next to buffer top
				KB_GET_READ:
					MOV	KB_BUF_HD, SI 		; head ptr = next
				INT_16_DONE:
					POP	SI
					POP	DS
 E7EE					IRET
 E7EE  B4 01			KB_WAIT_READ ENDP
 E7F0  33 C9			
 E7F2  8B FA			;----------------------------------------------------------------------------;
				; AH = 2 - Get shift status
				;----------------------------------------------------------------------------;
				; Read Keyboard Flags
				; Output:
 E7F4				;	AL = BIOS keyboard flags (from BDA 0040:0017)
 E7F4  8A CF			;----------------------------------------------------------------------------;
 E7F6  8B D7			KB_SHIFT_STATUS PROC
 E7F8  8A C4				MOV	AL, KB_FLAGS1
 E7FA					JMP	SHORT INT_16_DONE
 E7FA  EE			KB_SHIFT_STATUS ENDP
				
			     1			LOCAL _DONE
			     1				IF ARCH_TYPE NE ARCH_EMU
 E7FB  EB 00		     1		JMP	SHORT ??0016
 E7FD			     1	??0016:
			     1				ENDIF
 E7FD  EE			INT_16 ENDP
 E7FE  42			
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 104 - 1


 E7FF  D0 C0			;----------------------------------------------------------------------------;
 E801  E2 F7			; Repeats LONG_BEEPs then SHORT_BEEPs indefinetly
				;----------------------------------------------------------------------------;
				; Input:
				;	BL low nibble = long beeps
				;	BL high nibble = short beeps
 E803  8A CF			;
 E805  8B D7			; Note: must use LOOP for beep since BEEP could occur if PIT is not working
 E807  8A DC			; Note 2: cannot use stack since HALT_BEEP could occur before stack
 E809				;
 E809  EC			; Size: 60 bytes
 E80A  38 D8			;----------------------------------------------------------------------------;
 E80C  75 0E			HALT_BEEP PROC NEAR
 E80E					MOV	DX, CS 				; SS to CS
 E80E  EC				MOV	SS, DX				; for CALL_NS
 E80F  38 D8				XCHG	AX, BX				; beep pattern to AL
 E811  75 09				DB	0D4H, 10H				; AAM 10H ; split nibbles
 E813  42				XCHG	AX, BP				; BP(H) = short beeps, BP(L) = long beeps
 E814  D0 C3			HALT_BEEP_START:
 E816  E2 F1				MOV	DX, BP 				; restore original beep pattern
 E818  D0 E4				MOV	SI, BEEP_ERR_LOW			; low C5
 E81A  75 D8				XOR	CX, CX				; low beep on 100%
 E81C				HALT_BEEP_START_ODD:
 E81C  C3				MOV	DI, CX				; save counter length
 E81D				HALT_BEEP_REP:
					MOV	AX, SI				; restore beep tone
					CALL_NS  BEEP_ON_P, 1			; turn on speaker / beep
					MOV	CX, DI				; reset counter
					IO_DELAY					; delay for beep
					CALL_NS  BEEP_OFF_P, 1			; turn off speaker
					SUB	CX, DI				; set for remainder of counter
					IO_DELAY					; delay for silence
					DEC	DL					; dec beep repeat count
					JNZ	HALT_BEEP_REP			; jump if more of this length
 E81D					XCHG	DL, DH				; swap beep counts
 E81D  E4 61				TEST	DX, DX				; both cycles done?
 E81F  0C 30				JZ	HALT_BEEP_START			; if so, restart beep pattern
 E821  E6 61				MOV	CH, 100H * 1/3			; else, short beep on 33%
 E823  34 30				MOV	SI, BEEP_ERR_HIGH			; high F5
 E825  E6 61				JMP	SHORT HALT_BEEP_START_ODD	; start short cycle
 E827  C3			HALT_BEEP ENDP
 E828				
				;----------------------------------------------------------------------------;
				; Make a beepin' beep
				;----------------------------------------------------------------------------;
				; Play a (correctly pitched) A6 for 250ms
				;----------------------------------------------------------------------------;
 E828			     1			LOCAL LBL
			     1	
 = 0006			     1	BYTES_HERE_INT_16 = INT_16-$
			     1	
			     1			IFDEF BYTES_HERE_INT_16
			     1			IF2
			     1			IF BYTES_HERE_INT_16 LT 0
			     1			.ERR2
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 105 - 1


			     1		%OUT WARNING: Out of space at: INT_16 (BYTES_HERE_INT_16)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				BEEP PROC
					PUSH	AX
					BEEP_ON
					MOV	AX, 250			; 1/4 second pause
					CALL	IO_DELAY_MS
					BEEP_OFF
					POP	AX
					RET
				BEEP ENDP
				
				;----------------------------------------------------------------------------;
				; Two very short beeps
				; Size: 27 bytes
				; Output: CX = 0
 E82E				;----------------------------------------------------------------------------;
							IF IS_TURBO
 E82E  FB			MEEP_DELAY	EQU	40H
 E82F  FC						ELSE
 E830  1E			MEEP_DELAY	EQU	20H
 E831  56						ENDIF
 E832  BE ---- R		MEEPMEEP PROC
 E835  8E DE				CALL MEEP
 E837  80 FC 02			
 E83A  74 33			;----------------------------------------------------------------------------;
 E83C  77 2E			; One very short beep
 E83E  7B 15			;----------------------------------------------------------------------------;
				MEEP PROC
					PUSH	AX
					BEEP_ON
					MOV	CH, MEEP_DELAY
					IO_DELAY				; delay while beeping
					BEEP_OFF
					MOV	CH, MEEP_DELAY
					IO_DELAY				; delay between beeps
					POP	AX
					RET
				MEEP ENDP
				MEEPMEEP ENDP
				
				;----------------------------------------------------------------------------;
 E840				; Turn on speaker at given tone
 E840  BE 001A R		;----------------------------------------------------------------------------;
 E843  FA			; Input:
 E844  AD			; 	AX = TONE
 E845  3B 04			;
 E847  75 06			; http://www.cs.binghamton.edu/~reckert/220/8254_timer.html
 E849				;
 E849  FB			; Clobbers BL, AL
 E84A  5E			; Cannot use stack since this could be called before it is working.
 E84B  1F			;----------------------------------------------------------------------------;
				BEEP_ON_P PROC
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 106 - 1


 E84C  CA 0002		     1		RETF	2
 E84F					XCHG	AX, BX				; save tone to BX
 E84F  96				MOV	AL, PIT_CW <2, 11B, 3>		; Select Timer 2, LE, Mode 3 (square)
 E850  AD				OUT	PIT_CTRL, AL			; Send to PIT control word (43H)
 E851  EB F6				XCHG	AX, BX				; restore tone
 E853				BEEP_ON_1 PROC
					OUT	PIT_CH2, AL				; send low byte to timer
					MOV	AL, AH 				; select high byte
					OUT	PIT_CH2, AL				; send high byte to timer
					IN	AL, PPI_B				; read current PPI port B status
					OR	AL, MASK PBSP OR MASK PBST	; turn on speaker bits
					OUT	PPI_B, AL				; write back to port B
					RET
				BEEP_ON_1 ENDP
				BEEP_ON_P ENDP
 E853				
 E853  FB			;----------------------------------------------------------------------------;
				; Turn off speaker
 E854  F4			;
				; Clobbers: AL
				;----------------------------------------------------------------------------;
				BEEP_OFF_P PROC
 E855					IN	AL, PPI_B				; read current PPI port B status
 E855  BE 001A R			AND	AL, NOT (MASK PBSP OR MASK PBST)	; turn off speaker bits
 E858  FA				OUT	PPI_B, AL				; write back to port B
 E859  AD				RET
 E85A  3B 04			BEEP_OFF_P ENDP
 E85C  74 F5			
 E85E  96			;----------------------------------------------------------------------------;
 E85F  AD			; Display all POST messages
 E860  83 FE 3E			;----------------------------------------------------------------------------;
 E863  72 03			; See PFLAGS
 E865  BE 001E R		; Output: BP (high byte) = 0
 E868				; Clobbers: AX, CX, SI
 E868  89 36 001A R		; Size: 22 bytes
 E86C				;----------------------------------------------------------------------------;
 E86C  5E			
 E86D  1F			;----------------------------------------------------------------------------;
 E86E  CF			; POST Error Strings
 E86F				;
				POST_ERR		DB	CR, LF, 'POST '	; POST Error
				POST_ERR_ERR	DB	'Error ', 0		; Error
				POST_ERR_PKI	DB	'KB',   0		; Reset returned non-success "301"
								IF ARCH_TYPE EQ ARCH_EHB
				POST_ERR_PKEY	EQU	POST_ERR_PKI	; re-use to save bytes
								ELSE
				POST_ERR_PKEY	DB	'Key',  0		; Reset did not clear KBC
								ENDIF
 E86F				POST_ERR_PFDC	DB	'FDC',  0		; General FD init failure
 E86F  A0 0017 R		POST_ERR_PDMA	DB	'DMA',  0		; DMA TC0 error
 E872  EB F8			
 E874				;----------------------------------------------------------------------------;
				; POST String Vectors - indexed by PFLAGS
 E874				;
				POST_ERRORS LABEL WORD
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 107 - 1


					DW	OFFSET POST_ERR_PKI		; PKI  : Keyboard Interrupt Error
					DW	OFFSET POST_ERR_PKEY		; PKEY : Keyboard Key Stuck
					DW	OFFSET POST_ERR_PFDC		; PFDC : FDC Init Failure
					DW	OFFSET POST_FDD			; PFSK : FDC Seek Test Failure
					DW	OFFSET POST_ERR_PDMA		; PDMA : DMA TC0 Error
					DW	OFFSET POST_MEMORY		; PMEM : RAM Error
				L_POST_ERRORS	EQU	($-POST_ERRORS)/SIZE POST_ERRORS
				
				POST_ERROR_MSG PROC
					MOV	CX, L_POST_ERRORS+1		; # of available POST error messages
					MOV	SI, OFFSET POST_ERRORS-2	; SI = string table pointer
											;  add one LOOP for WARM BOOT flag
 E874				POST_ERROR_MSG_LOOP:
 E874  8C CA				LODS	WORD PTR CS:[SI]			; AX = next message offset
 E876  8E D2				SHL	BP, 1					; CF = POST error flag
 E878  93				JNC	POST_ERROR_MSG_NEXT		; no flag?
 E879  D4 10				PUSHF						; save BP ZF
 E87B  95				XCHG	AX, SI				; SI = error string
 E87C					PRINTLN_SZ  SI				; write string with CRLF
 E87C  8B D5				XCHG	AX, SI				; SI = string table pointer
 E87E  BE 08F1				POPF
 E881  33 C9			POST_ERROR_MSG_NEXT:
 E883					LOOPNZ  POST_ERROR_MSG_LOOP		; loop until end of strings or flags
 E883  8B F9			POST_ERROR_MSG_EXIT:
 E885					RET
 E885  8B C6			POST_ERROR_MSG ENDP
				
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E887  BC E88C R	     1		MOV	SP, OFFSET ??0018
			     1				IFNB <1>
 E88A  EB 4F		     1		JMP	SHORT BEEP_ON_P
			     1				ELSE
			     1		JMP	BEEP_ON_P
			     1				ENDIF
 E88C			     1	??0018:
 E88C  E88E R		     1		DW	OFFSET ??0019
 E88E			     1	??0019:
 E88E  8B CF			;----------------------------------------------------------------------------;
				; Additional INT 9h - Keyboard Code
			     1			LOCAL _DONE
 E890			     1	??001A:
 E890  E2 FE		     1		LOOP	??001A					; long delay for I/O
				;----------------------------------------------------------------------------;
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E892  BC E897 R	     1		MOV	SP, OFFSET ??001B
			     1				IFNB <1>
 E895  EB 57		     1		JMP	SHORT BEEP_OFF_P
			     1				ELSE
			     1		JMP	BEEP_OFF_P
			     1				ENDIF
 E897			     1	??001B:
 E897  E899 R		     1		DW	OFFSET ??001C
 E899			     1	??001C:
 E899  2B CF			
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 108 - 1


			     1			LOCAL _DONE
 E89B			     1	??001D:
 E89B  E2 FE		     1		LOOP	??001D					; long delay for I/O
 E89D  FE CA			; INT 9 - Test keyboard during POST
 E89F  75 E4			; Size: 27 bytes
 E8A1  86 D6			;----------------------------------------------------------------------------;
 E8A3  85 D2			INT_09_POST PROC
 E8A5  74 D5				PUSH	AX
 E8A7  B5 55				POST_FLAG_CLR PKI				; clear POST test int flag
 E8A9  BE 06A5				IN	AL, PPI_A				; read keyboard scan from PPI
 E8AC  EB D5				CMP	AL, 0AAH
 E8AE					JNZ	INT_09_POST_DONE
					POST_FLAG_SET PKI				; POST keyboard test flag
				INT_09_POST_DONE:
					IN	AL, PPI_B				; read keyboard status
					OR	AL, MASK PBKB OR MASK PBKC	; set clear keyboard and enable clock
					OUT	PPI_B, AL				; write to PPI Control Port B
					MOV	AL, EOI				; Send End of Interrupt
 E8AE					OUT	INT_P0, AL
 E8AE  50				POP	AX
					IRET
			     1			IFNB	<>
			     1		MOV	AX,  				; custom tone
			     1			ELSE
 E8AF  B8 054C		     1		MOV	AX, BEEP_DEFAULT
			     1			ENDIF
			     1			IFB	<>
 E8B2  53		     1		PUSH	BX
			     1			ENDIF
 E8B3  E8 0025		     1		CALL	BEEP_ON_P
			     1			IFB	<>
 E8B6  5B		     1		POP	BX
			     1			ENDIF
 E8B7  B8 00FA			INT_09_POST ENDP
 E8BA  E8 0EB7			
				;----------------------------------------------------------------------------;
 E8BD  E8 002E		     1		CALL	BEEP_OFF_P
 E8C0  58			; Clear keyboard circular buffer
 E8C1  C3			;----------------------------------------------------------------------------;
 E8C2				; Clear/init circular buffer at KB_BUF
				; Clobbers AX, DI
				;
				; Size: 17 bytes
				;----------------------------------------------------------------------------;
				KB_BUF_CLEAR PROC
						ASSUME ES:_BDA
					PUSH	ES 					; save ES
 = 0040					MOV	AX, SEG _BDA 			; get BDA segment
					MOV	ES, AX
					MOV	AX, ES:KB_BUF_ST 			; AX = original start of buffer
					MOV	DI, OFFSET KB_BUF_HD 		; DI = buffer head
 E8C2					STOSW 					; write to head pointer
 E8C2  E8 0000				STOSW 					; write to tail pointer
					POP	ES
					RET
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 109 - 1


						ASSUME ES:NOTHING
				KB_BUF_CLEAR ENDP
 E8C5				
 E8C5  50			;----------------------------------------------------------------------------;
				; INT 9 - Keyboard Additional Data Tables
			     1			IFNB	<>
			     1		MOV	AX,  				; custom tone
			     1			ELSE
 E8C6  B8 054C		     1		MOV	AX, BEEP_DEFAULT
			     1			ENDIF
			     1			IFB	<>
 E8C9  53		     1		PUSH	BX
			     1			ENDIF
 E8CA  E8 000E		     1		CALL	BEEP_ON_P
			     1			IFB	<>
 E8CD  5B		     1		POP	BX
			     1			ENDIF
 E8CE  B5 40			;----------------------------------------------------------------------------;
				; When CTRL held, modify ASCII codes for these scan codes (10 bytes)
			     1			LOCAL _DONE
 E8D0			     1	??001E:
 E8D0  E2 FE		     1		LOOP	??001E					; long delay for I/O
				;
 E8D2  E8 0019		     1		CALL	BEEP_OFF_P
 E8D5  B5 40			INT_KB_CTRL_ASC_TBL LABEL BYTE
					DB	00H, 03H				; Ctrl 2	-> ASCII 0
			     1			LOCAL _DONE
 E8D7			     1	??001F:
 E8D7  E2 FE		     1		LOOP	??001F					; long delay for I/O
 E8D9  58				DB	1EH, 07H				; Ctrl 6	-> ASCII 1EH
 E8DA  C3				DB	1FH, 0CH				; Ctrl '-'	-> ASCII 1FH
 E8DB					DB	7FH, 0EH				; Ctrl BS 	-> ASCII 07FH
 E8DB					DB	0AH, 1CH				; Ctrl Enter -> ASCII 0AH
				
				;----------------------------------------------------------------------------;
				; When CTRL held, modify scan codes for these scan codes (14 bytes)
				;
				INT_KB_CTRL_SCAN_TBL LABEL BYTE
					DB	77H, 47H 				; Ctrl Home
					DB	84H, 49H 				; Ctrl PgUp
					DB	73H, 4BH 				; Ctrl Left Arrow
					DB	74H, 4DH 				; Ctrl Right Arrow
					DB	75H, 4FH 				; Ctrl End
					DB	76H, 51H 				; Ctrl PgDn
					DB	72H, 37H				; Keypad * / PrtSc
 E8DB				
 E8DB  93			L_INT_KB_CTRL_ASC_TBL	EQU ($-INT_KB_CTRL_ASC_TBL)/2		; 12 total
 E8DC  B0 B6			L_INT_KB_CTRL_SCAN_TBL	EQU ($-INT_KB_CTRL_SCAN_TBL)/2-1	; 6
 E8DE  E6 43			
 E8E0  93						IF IS_TURBO
 E8E1				;----------------------------------------------------------------------------;
 E8E1  E6 42			; Handle Turbo speed mode toggle from INT 09h keyboard interrupt
 E8E3  8A C4			;----------------------------------------------------------------------------;
 E8E5  E6 42			; Size: 15 bytes
 E8E7  E4 61			;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 110 - 1


 E8E9  0C 03			INT_KB_TOGGLE_TURBO PROC
 E8EB  E6 61						IF ARCH_TYPE EQ ARCH_TD3300
 E8ED  C3				IN	AL, TD_TURBO			; read current state
 E8EE					CMP	AL, MASK TDSS			; turbo on? (NZ = turbo)
 E8EE							ELSE
								IF ARCH_TYPE EQ ARCH_EHB
					MOV	DX, V40_WCR1			; V40 W/S register
					IN	AL, DX				; FF = slow, 0 = Turbo
					NOT	AL					; flip bits
								ELSE
					IN	AL, PPI_B				; read standard PPI register
 E8EE								ENDIF			; /IF ARCH_TYPE EQ ARCH_EHB
 E8EE  E4 61				TEST	AL, MASK PBTB			; is in Turbo mode?
 E8F0  24 FC						ENDIF				; /IF ARCH_TYPE EQ ARCH_TD3300
 E8F2  E6 61				JNZ	INT_KB_TURBO_IS_ON		; if so, only one meep since
 E8F4  C3				CALL	MEEP					;  switching to low speed
 E8F5				INT_KB_TURBO_IS_ON:
					CALL	MEEP
					JMP	TOGGLE_TURBO
				INT_KB_TOGGLE_TURBO ENDP
							ENDIF
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	INT_09
				
				;----------------------------------------------------------------------------;
				; INT 9 - Keyboard Interrupt IRQ1 (Hardware Handler)
				;----------------------------------------------------------------------------;
 E8F5 0D 0A 50 4F 53 54		; Handles hardware Interrupt generated by the KBC connected to IRQ 1. The 
       20
 E8FC 45 72 72 6F 72 20		; scan code that is received is translated to all of the behaviors and key
       00
 E903 4B 42 00			; combinations used by the PC.
				;
				;----------------------------------------------------------------------------;
				; References:
 E906 4B 65 79 00		;  https://stanislavs.org/helppc/scan_codes.html
				;  https://stanislavs.org/helppc/make_codes.html
 E90A 46 44 43 00		;  https://stanislavs.org/helppc/keyboard_commands.html
 E90E 44 4D 41 00		;  https://stanislavs.org/helppc/8042.html
				;  http://www.techhelpmanual.com/106-int_09h__keyboard_interrupt.html
				;  https://www.phatcode.net/res/223/files/html/Chapter_20/CH20-1.html
				;
				; KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1
 E912				; KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1
 E912  E903 R			;----------------------------------------------------------------------------;
 E914  E906 R			; Things you must do:
 E916  E90A R			; - Check for a scan code from the KBC via PPI Port A (60h)
 E918  E4D4 R			; - Clear and Enable the keyboard bit (7) on PPI Port B
 E91A  E90E R			; - Examine the Make or Break system scan code
 E91C  E4BA R			; - If a toggle key (Shift, Alt, Ctrl, Caps Lock, Num Lock or Scroll Lock),
 E91E = 0006			;	update that flag in the BDA (17-18h)
				; - Determine if the scan code is altered by an active shift or toggle state
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 111 - 1


 E91E				; - If Ctrl-Alt-Del is pressed, do a warm reboot of the system
 E91E  B9 0007			; - If Print Screen is pressed, call INT 05h
 E921  BE E910 R		; - If Pause/Ctrl-NumLock is pressed, enter pause/hold state
				; - If Ctrl-Break is pressed, call INT 1Bh
 E924				; - Handle any special, non-standard translations
 E924  2E: AD			; - Translate printable chars to their ASCII/CP-437 value
 E926  D1 E5			;
 E928  73 07			; In short, it needs to do this:
 E92A  9C			;    https://stanislavs.org/helppc/scan_codes.html
 E92B  96			;----------------------------------------------------------------------------;
						ORG 0E987H
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <SI>,<SI>			; if SZ is not SI
			     1		MOV	SI, OFFSET SI
			     1			ENDIF
 E92C  E8 0DE4		     1		CALL	OUTLN_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E92F  96			INT_09 PROC
 E930  9D						ASSUME DS:_BDA
 E931					PUSH	AX						; save AX first
 E931  E0 F1				IN	AL, PPI_A 					; read scan code from PPI Port A
 E933					MOV	AH, AL					; save scan code to AH
 E933  C3				IN	AL, PPI_B 					; read Control Port B
 E934					PUSH	AX						; save status, and I/O delay
					OR	AL, MASK PBKB				; set clear keyboard bit
					OUT	PPI_B, AL 					; write to Control Port B
					POP	AX						; restore status, and I/O delay
					OUT	PPI_B, AL 					; write to Control Port B
				
				;----------------------------------------------------------------------------;
				; Send non-specific EOI to PIC
				;
					MOV	AL, EOI 					; End of Interrupt OCW
 E934					OUT	INT_P0, AL					; write EOI to port 0
 E934  50				STI							; enable interrupts
					CLD							; string functions increment
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		CLR1_BP   PKI				; V20 only: CLR1 BP, PKI
			     1				ELSE
 E935  81 E5 BFFF	     1		AND	BP, NOT MASK PKI			; Clear flag
			     1				ENDIF
 E939  E4 60						IF CPU_TYPE EQ CPU_V20
 E93B  3C AA				PUSHA							; save working registers
 E93D  75 04						ELSE
					PUSHX	BX, CX, DX, DI, SI			; save working registers
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		SET1_BP   PKI				; V20 only: SET1 BP, PKI
			     1				ELSE
 E93F  81 CD 4000	     1		OR	BP, MASK PKI			; Set flag
			     1				ENDIF
 E943							ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 112 - 1


 E943  E4 61				PUSHX	DS, ES					; save segment registers
 E945  0C C0				MOV	DX, SEG _BDA 				; DX = BIOS Data Area
 E947  E6 61				MOV	AL, AH					; AL = original scan code
 E949  B0 20				CMP	AL, 0FFH 					; check for Detection Error/Overrun
 E94B  E6 20				JZ	INT_KB_MEEP_DONE				; if overrun, meep and exit
 E94D  58				MOV	DS, DX					; DS = BIOS Data Area
 E94E  CF				MOV	DX, CS					; ES = BIOS code segment
 E94F					MOV	ES, DX
					MOV	DX, KB_FLAGS				; DL=KB_FLAGS1, DH=KB_FLAGS2
				
				;----------------------------------------------------------------------------;
				; 1. Is a function key?
				; Function keys have different scan codes based on shift, ALT or CTRL state
				;
				KB_INT_CHECK_FN_KEY:
					CMP	AL, 044H					; is above F10 scan code?
					JA	KB_INT_CHECK_FN_KEY_DONE
 E94F					CMP	AL, 03BH					; is below F1 scan code?
					JB	KB_INT_CHECK_FN_KEY_DONE
 E94F  06				MOV	AL, 0						; ASCII always 0 on F-keys
 E950  B8 ---- R		
 E953  8E C0			;----------------------------------------------------------------------------;
 E955  26: A1 0080 R		; Is a Function key. Check if shift, ALT or Ctrl is held?
 E959  BF 001A R		;
 E95C  AB				TEST	DL, MASK K1AL OR MASK K1CT OR MASK K1LS OR MASK K1RS
 E95D  AB				JZ	KB_INT_CHECK_FN_KEY_DONE		; no control keys held
 E95E  07				ADD	AH, 2DH					; adjust to ALT
 E95F  C3				TEST	DL, MASK K1AL				; is it ALT?
					JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer
 E960					SUB	AH, 2DH-23H					; adjust to CTRL
					TEST	DL, MASK K1CT				; is CTRL?
					JNZ	KB_INT_PUT_BUFFER_2			; if so, put in buffer
					SUB	AH, 23H-19H					; adjust to shift
				KB_INT_PUT_BUFFER_2:					; fit short jumps above
					JMP	KB_INT_PUT_BUFFER
				
 E960				KB_INT_CHECK_FN_KEY_DONE:				; not a function key
 E960  00 03			
 E962  1E 07			;----------------------------------------------------------------------------;
 E964  1F 0C			; 2. Handle "early" Ctrl such as Ctrl-Break and Ctrl-NumLock
 E966  7F 0E			;
 E968  0A 1C				TEST	DL, MASK K1CT				; is Ctrl held?
					JZ	KB_INT_IS_NUM				; if not, skip to IS_NUM
				
				;----------------------------------------------------------------------------;
				; Is Ctrl-Break?
 E96A				;
 E96A  77 47				CMP	AL, 46H					; Scroll Lock (Break)
 E96C  84 49				JNZ	INT_KB_CHECK_CTRL_NUM			; jump if not Break
 E96E  73 4B			
 E970  74 4D			INT_KB_CTRL_BREAK:
 E972  75 4F				CALL	KB_BUF_CLEAR				; clear keyboard buffer
 E974  76 51				MOV	BIOS_BREAK, 10000000b			; BIOS break flag
 E976  72 37				INT	1BH						; call BIOS Break handler
					JMP	SHORT INT_KB_DONE_2
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 113 - 1


 E978 = 000C			
 E978 = 0006			;----------------------------------------------------------------------------;
				; Is Ctrl-NumLock (Pause)?
				;
				INT_KB_CHECK_CTRL_NUM:
					CMP	AL, 45H					; is Num Lock key?
					;CMP	AL, 35H					; key pad / (for testing)
					JZ	INT_KB_SET_PAUSE				; if not, put in Pause
				
 E978				;----------------------------------------------------------------------------;
				; 3. Handle numeric keypad entry according to the following:
				;
				;	Num	Shift	ASCII	Scan
				; 	0	0	0	52h	5230 0020
				;	0	1	'0'	52h	5200 80A2
				;	1	0	'0'	52h	5200 8000
				;	1	1	0	52h	5200 8080
				;
				KB_INT_IS_NUM:
 E978  E4 61				TEST	DL, MASK K1NL				; is NUM LOCK on?
					JZ	KB_INT_IS_NUM_DONE			; if not, do nothing
 E97A  A8 04				CMP	AL, 53H					; is higher than Del key?
					JA	KB_INT_IS_NUM_DONE
 E97C  75 03				CMP	AL, 47H					; is lower than Home/7 key?
 E97E  E8 FF44				JB	KB_INT_IS_NUM_DONE
 E981				
 E981  E8 FF41			;----------------------------------------------------------------------------;
 E984  E9 F907			; Keypad number pressed and Num Lock is on, so invert shift behavior.
 E987				;
					SHL	AL, 1						; invert NumLock and Shift
					TEST	DL, MASK K1LS OR MASK K1RS		;  behavior and jump ahead
					JZ	KB_INT_UC					; jump if no shift held
					JMP	SHORT KB_INT_SHIFT
				
				;----------------------------------------------------------------------------;
 E987			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_09 = INT_09-$
			     1	
			     1			IFDEF BYTES_HERE_INT_09
			     1			IF2
			     1			IF BYTES_HERE_INT_09 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_09 (BYTES_HERE_INT_09)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				; KB Ctrl-NumLock Screen Pause
				;----------------------------------------------------------------------------;
				INT_KB_SET_PAUSE:
					MOV	BX, OFFSET KB_FLAGS2		; (-1 byte to use indirect addr)
					OR	BYTE PTR [BX], MASK K2PA	; set PAUSE flag
				
								IF CGA_SNOW_REMOVE GT 0
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 114 - 1


				; Make sure CGA is not currently being blanked
				;
					CALL	INT_10_IS_CGA80			; ZF = 1 if CGA 80 col
					JNZ	INT_KB_PAUSE_LOOP			; jump if not CGA 80 col
					MOV	AL, VID_MODE_REG			; get default CGA control register
					MOV	DX, CGA_CTRL			; DX = CGA control port 03D8h
					OUT	DX, AL				; enable video signal
								ENDIF
				
				;----------------------------------------------------------------------------;
				; Loop until Pause flag is cleared
				;
				INT_KB_PAUSE_LOOP:
					HLT						; be a good neighbor
					NOP						; let another interrupt happen
					TEST	BYTE PTR [BX], MASK K2PA	; check the Pause flag
					JNZ	INT_KB_PAUSE_LOOP			; loop until clear
				INT_KB_DONE_2:
					JMP	SHORT INT_KB_DONE			; exit INT
				
				;----------------------------------------------------------------------------;
				; Emit a feeble meep and exit
				;
				INT_KB_MEEP_DONE:
					CALL	MEEP
					JMP	SHORT INT_KB_DONE			; exit INT
				
				KB_INT_IS_NUM_DONE:
				
				;----------------------------------------------------------------------------;
 E987				; 4. Do scan code to ASCII translation
				;----------------------------------------------------------------------------;
 E987  50			KB_INT_CHAR:						; is a regular key ?
 E988  E4 60				SHL	AL, 1						; align index for table
 E98A  8A E0				TEST	DL, MASK K1LS OR MASK K1RS OR MASK K1AL	; is either shift key or ALT already pressed
				?
 E98C  E4 61				JNZ	KB_INT_UC					; if so, use uppercase table
 E98E  50			KB_INT_SHIFT:
 E98F  0C 80				INC	AX 						; if not shifted, increment
 E991  E6 61			KB_INT_UC:							;  one to use lower case
 E993  58				MOV	BX, OFFSET KEY_SCAN_TBL
 E994  E6 61				XLAT	CS:[BX]					; ASCII key in AL = CS:BX[AL]
					TEST	AL, AL					; a is flag key code?
					JNS	KB_INT_NOT_FLAG
					JMP	INT_KB_IS_FLAG
				KB_INT_NOT_FLAG:
 E996  B0 20				TEST	AH, AH					; test high bit of scan code
 E998  E6 20				JS	INT_KB_DONE					; if set, it is an unhandled break c
				ode
 E99A  FB			KB_INT_IS_CAPS:
 E99B  FC				TEST	DL, MASK K1CL				; is CAPS LOCK on?
					JZ	KB_INT_IS_CAPS_DONE
				IS_ALPHA:							; CF if AL is not [A-Za-z]
					PUSH	AX						; save original AL
					OR	AL, 'a'-'A'					; lowercase it for comparison
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 115 - 1


			     1				IFNB <BX>			; exit if last reg
 E99C  53		     1		PUSH	BX 					; push register and repeat
			     1		PUSHX	CX, DX, DI, SI, , , 
			     2				IFNB <CX>			; exit if last reg
 E99D  51		     2		PUSH	CX 					; push register and repeat
			     2		PUSHX	DX, DI, SI, , , , 
			     3				IFNB <DX>			; exit if last reg
 E99E  52		     3		PUSH	DX 					; push register and repeat
			     3		PUSHX	DI, SI, , , , , 
			     4				IFNB <DI>			; exit if last reg
 E99F  57		     4		PUSH	DI 					; push register and repeat
			     4		PUSHX	SI, , , , , , 
			     5				IFNB <SI>			; exit if last reg
 E9A0  56		     5		PUSH	SI 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		PUSH	 					; push register and repeat
			     6		PUSHX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
					CMP	AL, 'a'					; is less than 'a'?
					JB	IS_ALPHA_DONE				; CF if not alpha
			     1				IFNB <DS>			; exit if last reg
 E9A1  1E		     1		PUSH	DS 					; push register and repeat
			     1		PUSHX	ES, , , , , , 
			     2				IFNB <ES>			; exit if last reg
 E9A2  06		     2		PUSH	ES 					; push register and repeat
			     2		PUSHX	, , , , , , 
			     3				IFNB <>			; exit if last reg
			     3		PUSH	 					; push register and repeat
			     3		PUSHX	, , , , , , 
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 E9A3  BA ---- R			CMP	AL, 'z'+1					; is greater than 'z'?
 E9A6  8A C4				CMC							; CF if not alpha
 E9A8  3C FF			IS_ALPHA_DONE:
 E9AA  74 6D				POP	AX						; restore original AL
 E9AC  8E DA				JC	KB_INT_IS_CAPS_DONE			; jump if not alpha
 E9AE  8C CA				XOR	AL, 'a'-'A'					; otherwise, toggle case
 E9B0  8E C2			
 E9B2  8B 16 0017 R		KB_INT_IS_CAPS_DONE:
				;----------------------------------------------------------------------------;
				; 5. Handle ALT chars that require ASCII translation
				;
				KB_INT_IS_ALT:
					TEST	DL, MASK K1AL				; is ALT currently held?
 E9B6					JNZ	INT_KB_ALT
 E9B6  3C 44			
 E9B8  77 21			;----------------------------------------------------------------------------;
 E9BA  3C 3B			; 6. Handle additional Non-ALT special case chars
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 116 - 1


 E9BC  72 1D			;
 E9BE  B0 00				CMP	AX, 3700H					; is Shift-PrtSc?
					JZ	KB_INT_PRTSC				; jump if so
					CMP	AX, 4C00H					; Numeric 5 key (unshifted)
					JZ	INT_KB_DONE					; discard and exit
				
 E9C0  F6 C2 0F			KB_INT_IS_ALT_DONE:
 E9C3  74 16			
 E9C5  80 C4 2D			;----------------------------------------------------------------------------;
 E9C8  F6 C2 08			; 7. Handle CTRL chars
 E9CB  75 0B			;
 E9CD  80 EC 0A			KB_INT_IS_CTRL:
 E9D0  F6 C2 04				TEST	DL, MASK K1CT				; is CTRL currently held?
 E9D3  75 03				JZ	KB_INT_IS_CTRL_DONE			; jump if not
 E9D5  80 EC 0A				JMP	INT_KB_CTRL					; otherwise, CTRL is held
 E9D8				
 E9D8  E9 0096			;----------------------------------------------------------------------------;
				; Handle Shift-PrtSc
 E9DB				;
				KB_INT_PRTSC:
					INT	5H						; call print screen handler
					JMP	SHORT INT_KB_DONE
				
 E9DB  F6 C2 04			KB_INT_IS_CTRL_DONE:
 E9DE  74 14			;----------------------------------------------------------------------------;
				; Test if in Ctrl-NumLock PAUSE
				; If in Pause, any remaining key will exit and be discarded
				;
				KB_INT_IS_PAUSE:
 E9E0  3C 46				TEST	DH, MASK K2PA				; is in pause?
 E9E2  75 0C				JZ	KB_INT_PUT_BUFFER
					AND	KB_FLAGS2, NOT MASK K2PA		; clear pause flag
 E9E4					JMP	SHORT INT_KB_DONE				; discard key and exit int
 E9E4  E8 FF68			
 E9E7  C6 06 0071 R 80		;----------------------------------------------------------------------------;
 E9EC  CD 1B			; All special cases have been handled
 E9EE  EB 27			; Store AX in keyboard buffer
				;
				KB_INT_PUT_BUFFER:
					MOV	DI, KB_BUF_TL 				; DI = tail ptr
					LEA	SI, [DI][2]					; SI = next (maybe)
 E9F0					CMP	SI, KB_BUF_END_B				; is next >= end of buffer?
 E9F0  3C 45				JB	KB_INT_CHECK_FULL 			; if not, check if buffer is full
					MOV	SI, OFFSET KB_BUF 			; otherwise, wrap to first address
 E9F2  74 16			KB_INT_CHECK_FULL:
					CMP	SI, KB_BUF_HD 				; next == head?
					JE	INT_KB_MEEP_DONE				; Beep if ZF - buffer is full
					MOV	[DI], AX 					; buffer[head] = AX
					MOV	KB_BUF_TL, SI 				; tail = next
				
				;----------------------------------------------------------------------------;
				; Restore registers and exit
				;
				INT_KB_DONE:
					POPX	ES, DS
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 117 - 1


 E9F4							IF CPU_TYPE EQ CPU_V20
 E9F4  F6 C2 20				POPA							; restore used registers
 E9F7  74 25						ELSE
 E9F9  3C 53				POPX	SI, DI, DX, CX, BX			; restore used registers
 E9FB  77 21						ENDIF
 E9FD  3C 47				POP	AX
 E9FF  72 1D				IRET
				
				;----------------------------------------------------------------------------;
				; 6. Only ALT key is held (no CTRL)
				;
 EA01  D0 E0			; Space bar is the only key that returns the same scan code and ASCII code 
 EA03  F6 C2 03			; when ALT is held.
 EA06  74 1E			;
 EA08  EB 1B			INT_KB_ALT PROC
					CMP	AH, 39H					; is space bar?
					JZ	KB_INT_IS_ALT_DONE			; continue
					MOV	BX, AX
					MOV	AL, 0						; AL will be 0 for any others
 EA0A				
 EA0A  BB 0018 R		CHECK_TOP_ROW_NUM:
 EA0D  80 0F 08				CMP	AH, 0DH					; is above '=' scan code?
					JA	CHECK_ALT_ON
					CMP	AH, 2
					JB	CHECK_ALT_ON
					ADD	AH, 76H
					JMP	SHORT KB_INT_PUT_BUFFER
				
				;----------------------------------------------------------------------------;
				; 7. Check for ALT + 000 numeric entry
				; Alt held, and number is valid numeric keypad
				; Note: AH must be preserved
				;
				CHECK_ALT_ON:
					SUB	BL, '0'					; ASCII convert and test
					JB	INT_KB_NOT_ALT_000			; jump if less than 0
					CMP	BL, 9
 EA10					JA	INT_KB_NOT_ALT_000			; jump if above 9
 EA10  F4			
 EA11  90			INT_KB_IS_ALT_000:
 EA12  F6 07 08				XCHG	AX, BX					; AL = input byte, save AX
 EA15  75 F9				MOV	AH, KB_ALT					; AH = partial working byte
 EA17					AAD							; AL = AL + ( AH * 10 )
 EA17  EB 73				MOV	KB_ALT, AL					; save new working byte to BDA
					XCHG	AX, BX					; restore AH, AL = 0
					JMP	SHORT INT_KB_DONE				; interrupt complete
				
				;----------------------------------------------------------------------------;
 EA19				; 8. Check for ALT modified chars that are skipped
 EA19  E8 FEA9			; Uses table INT_KB_ALT_SKIP
 EA1C  EB 6E			;
				INT_KB_NOT_ALT_000:
 EA1E					MOV	DI, OFFSET INT_KB_ALT_SKIP
					MOV	CX, 11					; L_INT_KB_ALT_SKIP
					XCHG	AH, AL
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 118 - 1


					REPNE SCASB						; is in table?
					XCHG	AH, AL
 EA1E					JNZ	KB_INT_IS_ALT_DONE			; if not found, continue
 EA1E  D0 E0				JMP	SHORT INT_KB_DONE				; if found, skip
 EA20  F6 C2 0B			
 EA23  75 01			;ALT_MOD_LEN	EQU $-INT_KB_NOT_ALT_000+L_INT_KB_ALT_SKIP	; 30 bytes
 EA25				
 EA25  40			INT_KB_ALT ENDP
 EA26				
 EA26  BB EB98 R		;----------------------------------------------------------------------------;
 EA29  2E: D7			; 9. Only CTRL key is held (no ALT)
 EA2B  84 C0			;----------------------------------------------------------------------------;
 EA2D  79 03			INT_KB_CTRL_NO_ALT PROC
 EA2F  E9 0103			
 EA32				;----------------------------------------------------------------------------;
 EA32  84 E4			; Handle CTRL exceptions after ASCII or scan code is modified. These require
 EA34  78 56			; a lookup table since they do not follow a predictable pattern.
 EA36				;
 EA36  F6 C2 40				XCHG	AX, BX					; BH = scan code, BL = ASCII
 EA39  74 0F				MOV	CX, 12					; length of table (L_INT_KB_CTRL_ASC_TBL)
 EA3B					MOV	SI, OFFSET INT_KB_CTRL_ASC_TBL
 EA3B  50			INT_KB_CTRL_ASC_TBL_LOOP:
 EA3C  0C 20				LODS	WORD PTR CS:[SI]				; AH = scan code, AL = new ASCII
 EA3E  3C 61				CMP	AH, BH					; scan code match?
 EA40  72 03				LOOPNE INT_KB_CTRL_ASC_TBL_LOOP		; if not keep looping until end
 EA42  3C 7B				JNZ	INT_KB_CTRL_ASC_TBL_DONE		; no matches, restore AX and continue
 EA44  F5				CMP	CL, 6						; was first list segment? (L_INT_KB_
				CTRL_SCAN_TBL)
 EA45					JG	INT_KB_CTRL_NO_DONE			; if so, match found and AX is set, exit
 EA45  58				MOV	AH, 0						; ASCII code 0
 EA46  72 02				XCHG	AL, AH					; AH = scan code, AL = 0
 EA48  34 20			INT_KB_CTRL_NO_DONE:
					JMP	KB_INT_IS_CTRL_DONE			; AX set, exit
 EA4A				INT_KB_CTRL_ASC_TBL_DONE:
					XCHG	AX, BX					; restore AX
				
				;----------------------------------------------------------------------------;
 EA4A				; Skip ; ' `
 EA4A  F6 C2 08			;
 EA4D  75 46				CMP	AH, 27H					; pass < 27
					JB	INT_KB_CTRL_ALPHA
					CMP	AH, 29H					; pass > 29
					JNA	INT_KB_DONE					; skip 27-29
				
 EA4F  3D 3700			;----------------------------------------------------------------------------;
 EA52  74 0D			; For scan codes 10H-32H return only low 5 bits of ASCII code when CTRL is held
 EA54  3D 4C00			;
 EA57  74 33			INT_KB_CTRL_ALPHA:
					CMP	AH, 10H
 EA59					JB	INT_KB_CTRL_NO_ALT_1
					CMP	AH, 32H
					JA	INT_KB_CTRL_NO_ALT_1
					AND	AL, 00011111B				; adjust ASCII value
					JMP	SHORT INT_KB_CTRL_NO_DONE
 EA59				INT_KB_CTRL_NO_ALT_1:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 119 - 1


 EA59  F6 C2 04			
 EA5C  74 07			;----------------------------------------------------------------------------;
 EA5E  E9 00B4			; If scan code between 02H-35H and hasn't been modified yet, return nothing
				;
					CMP	AH, 2
					JB	INT_KB_CTRL_NO_DONE			; pass < 2
					CMP	AH, 35H
 EA61					JA	INT_KB_CTRL_NO_DONE			; pass > 35
 EA61  CD 05				JMP	INT_KB_DONE					; don't return 2-35?
 EA63  EB 27			
				INT_KB_CTRL_NO_ALT ENDP
 EA65				
				;----------------------------------------------------------------------------;
				; 8. Ctrl key is held
				;----------------------------------------------------------------------------;
				INT_KB_CTRL:
 EA65					TEST	DL, MASK K1AL				; is ALT also currently held?
 EA65  F6 C6 08				JZ	INT_KB_CTRL_NO_ALT			; jump if no ALT
 EA68  74 07			
 EA6A  80 26 0018 R F7		;----------------------------------------------------------------------------;
 EA6F  EB 1B			; 9. Ctrl-Alt keys are held
				;----------------------------------------------------------------------------;
				INT_KB_CTRL_ALT:
					CMP	AH, 53H					; is Ctrl-Alt-Del?
							IF IS_TURBO
					JNZ	INT_KB_CTRL_ALT_1				; if not check for turbo hotkey
 EA71							ELSE
 EA71  8B 3E 001C R			JNZ	INT_KB_CTRL_NO_DONE			; put in buffer as-is and exit
 EA75  8D 75 02						ENDIF
 EA78  83 FE 3E			
 EA7B  72 03			;----------------------------------------------------------------------------;
 EA7D  BE 001E R		; Handle Ctrl-Alt-Del (Warm reboot)
 EA80				;
 EA80  3B 36 001A R		INT_KB_CTRL_ALT_DEL:
 EA84  74 93				CALL	BEEP						; BEEP on ctrl-alt-del
 EA86  89 05						IF WARM_ENABLE EQ 1
 EA88  89 36 001C R			MOV	WARM_FLAG, WARM_BOOT			; set warm boot flag
							ELSE
					MOV	WARM_FLAG, COLD_BOOT			; clear warm boot flag
							ENDIF
					JMP	BOOT						; warm reboot
 EA8C				
							IF IS_TURBO
			     1				IFNB <ES>			; exit if last reg
 EA8C  07		     1		POP	ES 					; pop register and repeat
			     1		POPX	DS, , , , , , 
			     2				IFNB <DS>			; exit if last reg
 EA8D  1F		     2		POP	DS 					; pop register and repeat
			     2		POPX	, , , , , , 
			     3				IFNB <>			; exit if last reg
			     3		POP	 					; pop register and repeat
			     3		POPX	, , , , , , 
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 120 - 1


				;----------------------------------------------------------------------------;
				; 10. Handle Ctrl-Alt but not Del (only Turbo hotkey)
				;
				INT_KB_CTRL_ALT_1:
			     1				IFNB <SI>			; exit if last reg
 EA8E  5E		     1		POP	SI 					; pop register and repeat
			     1		POPX	DI, DX, CX, BX, , , 
			     2				IFNB <DI>			; exit if last reg
 EA8F  5F		     2		POP	DI 					; pop register and repeat
			     2		POPX	DX, CX, BX, , , , 
			     3				IFNB <DX>			; exit if last reg
 EA90  5A		     3		POP	DX 					; pop register and repeat
			     3		POPX	CX, BX, , , , , 
			     4				IFNB <CX>			; exit if last reg
 EA91  59		     4		POP	CX 					; pop register and repeat
			     4		POPX	BX, , , , , , 
			     5				IFNB <BX>			; exit if last reg
 EA92  5B		     5		POP	BX 					; pop register and repeat
			     5		POPX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		POP	 					; pop register and repeat
			     6		POPX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
				
 EA93  58			;----------------------------------------------------------------------------;
 EA94  CF			; Is Turbo speed toggle Ctrl-Alt-+ hotkey?
				;
					CMP	AH, 4EH					; numeric pad + key
					JNZ	INT_KB_CTRL_NO_DONE
				
				;	;CMP	AH, 4AH					; numeric pad - key
				;	;JZ	INT_KB_TURBO_MINUS
				
 EA95				;----------------------------------------------------------------------------;
 EA95  80 FC 39			; Handle Turbo speed mode toggle
 EA98  74 BF			;
 EA9A  8B D8				CALL	INT_KB_TOGGLE_TURBO			; meep meep and switch speed
 EA9C  B0 00				JMP	SHORT INT_KB_DONE3
				
 EA9E							ENDIF
 EA9E  80 FC 0D			
 EAA1  77 0A			;----------------------------------------------------------------------------;
 EAA3  80 FC 02			; 5. Is a flag key?
 EAA6  72 05			;----------------------------------------------------------------------------;
 EAA8  80 C4 76			;  40:18	Keyboard Flags Byte 2 (High)
 EAAB  EB C4			; 84218421
				; 7 	    |			- K2IN	insert key is depressed
				;  6 	    |			- K2CL	caps-lock key is depressed
				;   5	    |			- K2NL	num-lock key is depressed
				;    4    |			- K2SL	scroll lock key is depressed
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 121 - 1


				;     3   |			- K2PA	suspend key has been toggled
				;      2  |			- K2SY	system key depressed and held
 EAAD				;       1 |			- K2LA	left ALT key depressed
 EAAD  80 EB 30			;        0|			- K2LC	left CTRL key depressed
 EAB0  72 12			;----------------------------------------------------------------------------;
 EAB2  80 FB 09			_KB_FLAGS2	EQU	BYTE PTR[BX]			; Use index addressing
 EAB5  77 0D			_KB_FLAGS1	EQU	_KB_FLAGS2[-1]			;  for byte savings
				
 EAB7				INT_KB_IS_FLAG PROC
 EAB7  93				MOV	BX, OFFSET KB_FLAGS2			; BX = KB_FLAGS2
 EAB8  8A 26 0019 R			MOV	DI, OFFSET KEY_FLAG_ON_TBL
 EABC  D5 0A				MOV	AL, AH					; AL = original scan code
 EABE  A2 0019 R			AND	AL, 01111111B				; clear high bit for search
 EAC1  93				MOV	CL, 1						; set up bit mask counter
 EAC2  EB C8			INT_KB_FLAG_LOOP:
					SCASB 						; look for scan code
					JZ	INT_KB_FLAG_FOUND
					SHL	CL, 1 					; CL will contain bit mask
					JNZ	INT_KB_FLAG_LOOP				; CF if not found too
					JMP	KB_INT_NOT_FLAG
 EAC4				INT_KB_FLAG_FOUND:
 EAC4  BF EC16 R			CLI
 EAC7  B9 000B				MOV	AL, CL					; move to AL for work
 EACA  86 E0			
 EACC  F2/ AE			;----------------------------------------------------------------------------;
 EACE  86 E0			; Ins, Caps, Num, Scrl send break codes, but state is kept by BIOS so ignore those.
 EAD0  75 87			;
 EAD2  EB B8				TEST	AL, MASK K1IN OR MASK K1CL OR MASK K1NL OR MASK K1SL
					JZ	INT_KB_NOT_ICNS				; don't clear on break code on these
					TEST	AH, AH					; is Ins, Caps, Num, Scrl break code?
					JNS	INT_KB_ICNS_MAKE				; if not, jump to make
 EAD4				
				;----------------------------------------------------------------------------;
				; Handle KB_FLAGS2 for Ins, Caps, Num, Scroll Lock for both make and break
				;
				INT_KB_ICNS_BREAK:
 EAD4					NOT	AL
					AND	_KB_FLAGS2, AL
					JMP	SHORT	INT_KB_DONE3
				INT_KB_ICNS_MAKE:
					OR	_KB_FLAGS2, AL				; set flag in KB_FLAGS2
				
 EAD4  93			;----------------------------------------------------------------------------;
 EAD5  B9 000C			; Otherwise toggle the flag for Ins, Caps, Num, Scrl.
 EAD8  BE E960 R		;
 EADB				; Note: The Ins key is treated as a key press with code 5200H.
 EADB  2E: AD			;
 EADD  38 FC			INT_KB_FLAG_TOGGLE:
 EADF  E0 FA				XOR	_KB_FLAGS1, AL				; toggle flag
 EAE1  75 0C				TEST	AL, MASK K1IN				; is insert key?
 EAE3  80 F9 06				MOV	AL, 0
 EAE6  7F 04				JNZ	INT_KB_PUT_BUFFER_2			; pass through as a key if so
 EAE8  B4 00			INT_KB_DONE3:
 EAEA  86 C4				JMP	INT_KB_DONE
 EAEC				
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 122 - 1


 EAEC  E9 FF76			;----------------------------------------------------------------------------;
 EAEF				; Scan code for Alt, Ctrl, Left or Right Shift
 EAEF  93			; On make code, set flag.  On break code, clear flag.
				;
				INT_KB_NOT_ICNS:
				
				;----------------------------------------------------------------------------;
 EAF0  80 FC 27			; Handle KB_FLAGS2 for Ctrl or Alt
 EAF3  72 05			;
 EAF5  80 FC 29				TEST	AL, MASK K1AL OR MASK K1CT		; is Alt or Ctrl?
 EAF8  76 92				JZ	INT_KB_NOT_ICNS_1				; jump if not
					SHR	AL, 1						; adjust for KB_FLAGS2
					SHR	AL, 1
					XOR	_KB_FLAGS2, AL				; toggle flag
					MOV	AL, CL					; restore AL
 EAFA				
 EAFA  80 FC 10			INT_KB_NOT_ICNS_1:
 EAFD  72 09				DEC	BX						; _KB_FLAGS2 = KB_FLAGS1
 EAFF  80 FC 32				TEST	AH, AH					; is a break code?
 EB02  77 04				JS	INT_KB_FLAG_CLEAR				; if so, clear flag
 EB04  24 1F				OR	_KB_FLAGS2, AL				; set flag
 EB06  EB E4				JMP	SHORT INT_KB_DONE3			; done
 EB08				
				INT_KB_FLAG_CLEAR:
					NOT	AL						; invert mask
					AND	_KB_FLAGS2, AL				; clear flag
					CMP	CL, MASK K1AL				; was it ALT key?
 EB08  80 FC 02				JNZ	INT_KB_DONE3				; if not, done
 EB0B  72 DF			
 EB0D  80 FC 35			INT_KB_IS_FLAG ENDP
 EB10  77 DA			
 EB12  E9 FF77			;----------------------------------------------------------------------------;
				; ALT has just been released
 EB15				;----------------------------------------------------------------------------;
				; Check if there a partial value of ALT+000 (ALT-GR) numpad entry work byte?
				;
				INT_KB_ALT_BREAK:
					MOV	AL, KB_ALT
 EB15					TEST	AL, AL					; is ALT working sum 0?
 EB15  F6 C2 08				JZ	INT_KB_DONE3				; if so, end
 EB18  74 BA				MOV	AH, 0						; Scan code is 0
					MOV	KB_ALT, AH					; clear ALT byte working sum
				INT_KB_PUT_BUFFER_2:
					JMP	KB_INT_PUT_BUFFER				; use value as output char
				
 EB1A				;----------------------------------------------------------------------------;
 EB1A  80 FC 53			; Keyboard scancode mapping tables
				;----------------------------------------------------------------------------;
 EB1D  75 0C			; For each scan code this table contains ASCII characters. The first byte is
				; the shifted (shift held) ASCII char, followed by the non-shifted ASCII char.
				;
				; Flag chars (noted by *) return their scan code with most sig bit set 
				; (also their break code).
				;----------------------------------------------------------------------------;
				KEY_SCAN_TBL	LABEL BYTE
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 123 - 1


					DB	2 DUP(0), 2 DUP(1BH) 		; 00-01H	None, Escape
 EB1F	DB	'!1@2#3$4%5^6' 			; 02-		(Top row keys)
 EB1F  E8 FD8C				DB	'&7*8(9)0_-+='			;   -0DH
					DB	8, 8, 0, 9 				; 0E-0FH	Backspace, Tab
 EB22  C7 06 0072 R 1234		DB	'QqWwEeRrTtYy' 			; 10-		(Second row keys)
					DB	'UuIiOoPp{[}]' 			;    1BH
					DB	2 DUP(0DH) 				; 1C		Enter
					DB	2 DUP(01DH OR 80H) 		; 1D		*Ctrl
 EB28  E9 F530				DB	'AaSsDdFfGgHh'			; 1E-		(Third row keys)
					DB	'JjKkLl:;"', "'", '~`'		;   -29H
					DB	2 DUP(02AH OR 80H)  		; 2A		*Left shift
					DB	'|\ZzXxCcVvBb' 			; 2B-		(Fourth row keys)
					DB	'NnMm<,>.?/' 			;   -35H
					DB	2 DUP(36H OR 80H)			; 36H		*Right Shift
 EB2B					DB	0, '*' 				; 37H		PrtSc/'*'
					DB	2 DUP(38H OR 80H)			; 38H		*Alt
					DB	2 DUP(' ')				; 39H		Space
					DB	2 DUP(3AH OR 80H) 		; 3AH		*Caps Lock
				
 EB2B  80 FC 4E			;----------------------------------------------------------------------------;
 EB2E  75 BC			; IMPORTANT NOTE: these next two tables are placed here to fill the "hole"
				; for the F1-F10 keys, so MUST be exactly 20 bytes to maintain the table
				; index. Left in commented out below for reference:
				
				;	DW	10 DUP(0) 				; 3B-44H	F1-F10
				
				;----------------------------------------------------------------------------;
				; Table for scan codes that are keys that set flags.
 EB30  E8 FE45			; The byte's index corresponds to the flag bit position in BDA's KB_FLAGS1.
 EB33  EB 32			; Length: 8 bytes
				;
				KEY_FLAG_ON_TBL	LABEL BYTE	;                            ICNSATLR
					DB	36H			; Right shift on	0110110 -> 00000001
					DB	2AH			; Left shift on	0101010 -> 00000010
					DB	1DH			; cTrl on		0011101 -> 00000100
					DB	38H			; Alt on		0111000 -> 00001000
					DB	46H			; Scroll lock on 	1000110 -> 00010000
					DB	45H			; Num lock on	1000101 -> 00100000
					DB	3AH			; Caps lock on	0111010 -> 01000000
					DB	52H			; Insert on		1010010 -> 10000000
				L_KEY_FLAG_ON_TBL	EQU $-KEY_FLAG_ON_TBL
				
				;----------------------------------------------------------------------------;
				; Alt keys that are "skipped" and return no scan codes
				; Length: 10 bytes
				;
				INT_KB_ALT_SKIP	LABEL BYTE
 = BYTE PTR[BX]				DB	0FH					; Tab
 = _KB_FLAGS2[-1]			DB	1CH					; Enter
					DB	27H					; ;
 EB35					DB	28H					; '
 EB35  BB 0018 R			DB	29H					; `
 EB38  BF EC0E R			DB	2BH					; \
 EB3B  8A C4				DB	33H					; ,
 EB3D  24 7F				DB	34H					; .
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 124 - 1


 EB3F  B1 01				DB	35H					; /
 EB41					DB	37H					; * PrcSc
 EB41  AE			L_INT_KB_ALT_SKIP	EQU $-INT_KB_ALT_SKIP
 EB42  74 07			
 EB44  D0 E1			;----------------------------------------------------------------------------;
 EB46  75 F9			; Resume scancode table at 45H (word aligned)
 EB48  E9 FEE7			;
 EB4B						ORG	KEY_SCAN_TBL + 45H * 2
 EB4B  FA			KEY_SCAN_TBL_HIGH	LABEL BYTE
 EB4C  8A C1				DB	2 DUP(45H OR 80H)			; 45H		*Num Lock
					DB	2 DUP(46H OR 80H)			; 46H		*Scroll Lock
					DB	'7', 0				; 47H		Home/7
					DB	'8', 0				; 48H		Up/8
					DB	'9', 0				; 49H		PgUp/9
 EB4E  A8 F0				DB	2 DUP('-')				; 4AH		Keypad '-'
 EB50  74 18				DB	'4', 0				; 4BH		Left/4
 EB52  84 E4				DB	'5', 0				; 4CH		Center/5
 EB54  79 06				DB	'6', 0				; 4DH		Right/6
					DB	2 DUP('+')				; 4EH		Keypad '+'
					DB	'1', 0				; 4FH		End/1
					DB	'2', 0				; 50H		Down/2
					DB	'3', 0				; 51H		PgDn/3
 EB56					DB	'0', 52H OR 80H			; 52H		*Ins/0
 EB56  F6 D0				DB	'.', 0				; 53H		Del
 EB58  20 07				DB	2 DUP(0)				; 54H		SysReq
 EB5A  EB 0B			L_KEY_SCAN_TBL EQU $-KEY_SCAN_TBL
 EB5C				
 EB5C  08 07			INT_09 ENDP
				
				;
				; 11 BYTES HERE
				;
				BYTES_HERE	INT_13
				
 EB5E				;----------------------------------------------------------------------------;
 EB5E  30 47 FF			; INT 13H - Diskette BIOS Services
 EB61  A8 80			;----------------------------------------------------------------------------;
 EB63  B0 00			;	INT 13,0  Reset disk system
 EB65  75 2E			;	INT 13,1  Get disk status
 EB67				;	INT 13,2  Read disk sectors
 EB67  E9 FF22			;	INT 13,3  Write disk sectors
				;	INT 13,4  Verify disk sectors
				;	INT 13,5  Format disk track
				;
				;  Typical params:
				;	AH = function request number
 EB6A				;	AL = number of sectors	(1-128)
				;	CH = cylinder number	(0-1023)
				;	CL = sector number	(1-17)
				;	DH = head number		(0-15)
				;	DL = drive number		(0=A:, 1=B:, 80H=C:, 81H=D:) (for AH=2-5)
 EB6A  A8 0C			;	ES:BX = address of user buffer
 EB6C  74 08			;
 EB6E  D0 E8			;  Output:
 EB70  D0 E8			;	CF = 0 if successful
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 125 - 1


 EB72  30 07			;	   = 1 if error
 EB74  8A C1			;	AH = status of operation (https://stanislavs.org/helppc/int_13-1.html)
				;
 EB76				;----------------------------------------------------------------------------;
 EB76  4B			;  All functions:
 EB77  84 E4			;	- return FD_LAST_OP ([41H]) in AH
 EB79  78 04			;	- set CF if error
 EB7B  08 07			;	- reset motor shutoff counter
 EB7D  EB E8			;
				;  Reference:
 EB7F				;	https://stanislavs.org/helppc/int_13.html
 EB7F  F6 D0			;	https://stanislavs.org/helppc/765.html
 EB81  20 07			;	NEC Microcomputers, Inc. PD765C Application Note 8 (Mar 1979)
 EB83  80 F9 08			;
 EB86  75 DF			;  Ports:
				;	3F0-3F7 Floppy disk controller (except PCjr)
 EB88				;	3F0 Diskette controller status A
				;	3F1 Diskette controller status B
				;	3F2 controller control port
				;	3F4 controller status register
				;	3F5 data register (write 1-9 byte command, see INT 13)
				;	3F6 Diskette controller data
				;	3F7 Diskette digital input
 EB88				;
 EB88  A0 0019 R		;----------------------------------------------------------------------------;
 EB8B  84 C0					ORG 0EC59H
 EB8D  74 D8			
 EB8F  B4 00			INT_13 PROC
 EB91  88 26 0019 R				ASSUME DS:_BDA
 EB95				
 EB95  E9 FED9			;----------------------------------------------------------------------------;
				; Use indexed addressing to DI = FD_LAST_OP for byte savings.
				;
				_FD_LAST_OP		EQU	BYTE PTR [DI]				; FD_LAST_OP
				_FD_MOTOR_ST	EQU	_FD_LAST_OP[FD_MOTOR_ST-FD_LAST_OP]	; FD_MOTOR_ST
				_FD_CAL_ST		EQU	_FD_LAST_OP[FD_CAL_ST-FD_LAST_OP]	; FD_CAL_ST
				_FDC_LAST_ST	EQU	[DI][FDC_LAST_ST-FD_LAST_OP]		; FDC_LAST_ST
				
					STI 						; enable interrupts
					CLD
					PUSHX	DS, DI, DX, CX, BX, AX		; save original registers
 EB98					MOV	DI, SEG _BDA			; DS = BDA
 EB98  0002 [				MOV	DS, DI
        00
       ]
       0002 [
        1B
       ]
 EB9C  21 31 40 32 23 33		MOV	DI, OFFSET FD_LAST_OP		; DI = FD_LAST_OP throughout
       24 34 25 35 5E 36
 EBA8  26 37 2A 38 28 39		CMP	AH, 1 				; AH = 1?
       29 30 5F 2D 2B 3D
 EBB4  08 08 00 09			JB	INT_13_0 				; AH = 0, jump to Reset
 EBB8  51 71 57 77 45 65		JZ	INT_13_1 				; AH = 1, jump to Status
       52 72 54 74 59 79
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 126 - 1


 EBC4  55 75 49 69 4F 6F		CMP	DL, 3 				; is drive number > 3?
       50 70 7B 5B 7D 5D
 EBD0  0002 [				JA	INT_13_BAD_CMD 			; if so, exit
        0D
       ]
 EBD2  0002 [				MOV	_FD_LAST_OP, FDC_ST_OK		; clear last operation
        9D
       ]
 EBD4  41 61 53 73 44 64		CMP	AH, 6 				; AH = 2 through 5?
       46 66 47 67 48 68
 EBE0  4A 6A 4B 6B 4C 6C		JB	INT_13_2_5 				; jump to FDC RWVF command
       3A 3B 22 27 7E 60
 EBEC  0002 [			INT_13_BAD_CMD:
        AA
       ]
 EBEE  7C 5C 5A 7A 58 78		MOV	_FD_LAST_OP, FDC_ST_BADCMD	; otherwise return "bad command"
       43 63 56 76 42 62
 EBFA  4E 6E 4D 6D 3C 2C	INT_13_DONE:
       3E 2E 3F 2F
 EC04  0002 [				MOV	AL, DBT.FMCT 			; INT_1E[2] = motor shutoff counter
        B6
       ]
 EC06  00 2A				CALL	INT_1E_PARAM 			; AL = shutoff counter value (37)
 EC08  0002 [				MOV	FD_MOTOR_CT, AL 			; update in BDA
        B8
       ]
 EC0A  0002 [				POP	AX 					; restore original AL
        20
       ]
 EC0C  0002 [				MOV	AH, _FD_LAST_OP 			; AH = last operation status
        BA
       ]
				INT_13_EXIT:
					POPX	BX, CX, DX, DI, DS		; restore original registers
					CMP	AH, FDC_ST_OK+1			; check AH for error (CF = AH < 1)
					CMC   					; invert CF for return (CF = ! CF)
					IRET_F 					; return from int with current flags
				
				;----------------------------------------------------------------------------;
				; INT 13, 0: Reset disk system
				;----------------------------------------------------------------------------;
				; Performs hard reset on FDC controller
				;
				; Input:
				;	AH = 00
 EC0E				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
 EC0E  36			;		(unused - drive is determined by BDA motor status)
 EC0F  2A			;
 EC10  1D			; Output:
 EC11  38			;	AH = disk operation status  (see INT 13,STATUS)
 EC12  46			;	CF = 0 if successful
 EC13  45			;	   = 1 if error
 EC14  3A			;
 EC15  52			; To Convert FD_MOTOR_ST to FDC byte use the following table/formula:
 EC16 = 0008			;	Motors On 	Drive #
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 127 - 1


				;	0 0 0 0	 	0 			AND with 1111, jump if AL = 0
				;	1 x x x		3			TEST bit 1000, if non-zero then AL = 3
				;	0 1 x x		2 			Shift right once and AL will be correct
				;	0 0 1 x		1 			"
				;	0 0 0 x	 	0			"
 EC16				;
 EC16  0F			;----------------------------------------------------------------------------;
 EC17  1C			; Things you must do:
 EC18  27			;
 EC19  28			;	- if a motor flag is on in BDA, turn it on in the FDC also
 EC1A  29			;	- clear reset flag in controller and pull heads to track 0
 EC1B  2B			;	- set ALL disks need recalibration on next seek (Why all drives?)
 EC1C  33			;	- setting the controller reset flag causes the disk to recalibrate
 EC1D  34			;	  	on the next disk operation
 EC1E  35			;	- if bit 7 is set, the diskette drive indicated by the lower 7 bits
 EC1F  37			;		will reset then the hard disk will follow; return code in AH is
 EC20 = 000A			;		for the drive requested (this is done by HD BIOS)
				;----------------------------------------------------------------------------;
				INT_13_0 PROC
					MOV	DX, FDC_CTRL			; port 3F2H, FDC Digital Output
					CLI 						; disable interrupts
					MOV	AL, FD_MOTOR_ST 			; 3FH - Diskette motor status
 EC22					MOV	CH, AL 				; save to CH
 EC22  0002 [				AND	AL, MASK FMOT			; isolate motor status flags
        C5
       ]
 EC24  0002 [				JZ	INT_13_0_2				; jump if no motors are on, default to 0
        C6
       ]
 EC26  37 00			
 EC28  38 00			;----------------------------------------------------------------------------;
 EC2A  39 00			; One motor is on (according to BDA). Convert motor run flags to binary number
 EC2C  0002 [			; since FDC requires a drive index for the reset.
        2D
       ]
 EC2E  34 00			;
 EC30  35 00				SHR	AL, 1					; disregard low bit (will be 0 either way)
 EC32  36 00				TEST	AL, 0100B 				; test for drive 3?
 EC34  0002 [				JZ	INT_13_0_1				; if not drive 3, AL is now correct
        2B
       ]
 EC36  31 00				MOV	AL, 3 				; otherwise set AL to drive 3
 EC38  32 00			INT_13_0_1:
 EC3A  33 00						IF CPU_TYPE	EQ CPU_V20
 EC3C  30 D2				SHL	CH, 4					; move original low nibble into CH
 EC3E  2E 00						ELSE
 EC40  0002 [				MOV	CL, 4 				; move original low nibble
        00
       ]
 EC42 = 00AA				SHL	CH, CL				;  into high nibble of CH
							ENDIF
 EC42					OR	AL, CH 				; combine nibbles with AL
				
				;----------------------------------------------------------------------------;
				; Reset the controller by holding FDC reset (bit 2) at 0.
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 128 - 1


				; Flag all drives for recalibration (not just the drive in DL)
				; Clear last FDC operation status in BDA
 EC42			     1			LOCAL LBL
			     1	
 = 0017			     1	BYTES_HERE_INT_13 = INT_13-$
			     1	
			     1			IFDEF BYTES_HERE_INT_13
			     1			IF2
			     1			IF BYTES_HERE_INT_13 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_13 (BYTES_HERE_INT_13)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				;
				INT_13_0_2:
					OR	AL, MASK FDDMA			; enable DMA & I/O interface, FDC reset
					OUT	DX, AL				; send to FDC
					XOR	CX, CX 				; clear CX, delay for FDC to settle	(3)
					MOV	_FD_CAL_ST, CL 			; flag all drives for recalibration	(22)
					MOV	_FD_LAST_OP, CL 			; clear last operation flags		(22)
				
				;----------------------------------------------------------------------------;
				; Re-enable FDC by setting bit 2 to 1.
				; Wait for Interrupt (WIF) from FDC
				;
					OR	AL, MASK FDCEN			; set FDC enable 				(4)
					OUT	DX, AL				; send to FDC
					STI 						; enable interrupts
					CALL	FDC_WAIT_SENSE			; wait for FDC to signal interrupt
					JC	INT_13_0_RESET_BAD
					CMP	AL, 11000000B			; was successful reset?
					JZ	INT_13_0_RESET_DONE		; jump if success, AH = 0
				INT_13_0_RESET_BAD:
					MOV	AH, FDC_ST_ERR_FDC		; otherwise, controller failure
				INT_13_0_RESET_DONE:
					MOV	_FD_LAST_OP, AH			; set last result
					JNZ	INT_13_DONE				; exit if there was an error
				
				;----------------------------------------------------------------------------;
				; (Re)send Specify bytes to FDC
				;
					MOV	AL, FDC_CMD_SPEC 			; [0] FDC Specify command
					CALL	FDC_SEND 				; send command in AL, CF if error
					JC	INT_13_DONE
					MOV	AL, DBT.SRT				; [1] step rate time, head unload time
					CALL	FDC_SEND_PARAM
					JC	INT_13_DONE
					MOV	AL, DBT.HLT_ND			; [2] head load time (01H), DMA mode (ND)
					CALL	FDC_SEND_PARAM
				INT_13_0_DONE:
					JMP	SHORT INT_13_DONE
				INT_13_0 ENDP
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 129 - 1


				; INT 13, 1: Get disk status
				;----------------------------------------------------------------------------;
				; Output: AL and AH = status of last operation
				;----------------------------------------------------------------------------;
				INT_13_1 PROC
					POP	AX 					; discard original AX
					MOV	AL, _FD_LAST_OP 			; AL = last operation status
					MOV	AH, AL				; AH = last operation status
 EC59					JMP	SHORT INT_13_EXIT
				INT_13_1 ENDP
				
				;----------------------------------------------------------------------------;
				; DMA page boundary overrun
				;
 = BYTE PTR [DI]		FDC_DMA_BOUND:
 = _FD_LAST_OP[FD_MOTOR_ST-		OR	_FD_LAST_OP, FDC_ST_DMA_64K	; DMA boundary error
   FD_LAST_OP]
 = _FD_LAST_OP[FD_CAL_ST-FD		STC						; re-set CF
   _LAST_OP]
 = [DI][FDC_LAST_ST-FD_LAST		JMP	SHORT FDC_INIT_DMA_EXIT		; rebalance stack and exit
   _OP]
				
 EC59  FB			;----------------------------------------------------------------------------;
 EC5A  FC			; INT 13, AH=2-5: FDC read/write operations
				;----------------------------------------------------------------------------;
			     1				IFNB <DS>			; exit if last reg
 EC5B  1E		     1		PUSH	DS 					; push register and repeat
			     1		PUSHX	DI, DX, CX, BX, AX, , 
			     2				IFNB <DI>			; exit if last reg
 EC5C  57		     2		PUSH	DI 					; push register and repeat
			     2		PUSHX	DX, CX, BX, AX, , , 
			     3				IFNB <DX>			; exit if last reg
 EC5D  52		     3		PUSH	DX 					; push register and repeat
			     3		PUSHX	CX, BX, AX, , , , 
			     4				IFNB <CX>			; exit if last reg
 EC5E  51		     4		PUSH	CX 					; push register and repeat
			     4		PUSHX	BX, AX, , , , , 
			     5				IFNB <BX>			; exit if last reg
 EC5F  53		     5		PUSH	BX 					; push register and repeat
			     5		PUSHX	AX, , , , , , 
			     6				IFNB <AX>			; exit if last reg
 EC60  50		     6		PUSH	AX 					; push register and repeat
			     6		PUSHX	, , , , , , 
			     7				IFNB <>			; exit if last reg
			     7		PUSH	 					; push register and repeat
			     7		PUSHX	, , , , , , 
			     7				ENDIF
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 EC61  BF ---- R		; All commands:
 EC64  8E DF			;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 130 - 1


 EC66  BF 0041 R		; 	AL = number of sectors to read  (1-128 dec.)
 EC69  80 FC 01			;	AH = function number
 EC6C  72 29			;	CH = track/cylinder number  (0-1023 dec., see below)
 EC6E  74 74			;	CL = sector number  (1-17 dec.)
 EC70  80 FA 03			;	DH = head number  (0-15 dec.)
 EC73  77 08			;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
 EC75  C6 05 00			;	ES:BX = pointer to buffer
 EC78  80 FC 06			;----------------------------------------------------------------------------;
 EC7B  72 74			; Things you must do:
 EC7D				;
 EC7D  C6 05 01			;	1. Set FD_MOTOR_ST read/write flag for operation
 EC80				;	2. Motor ON (update BDA)
 EC80  B0 02			;		- is motor already on? Skip wait for spin up
 EC82  E8 02A3			;		- wait only for writes?
 EC85  A2 0040 R		;		- check if recalibration is necessary
 EC88  58			;	3. Set up DMA
 EC89  8A 25			;	4. seek drive DL to cylinder CH, head DH
 EC8B				; 	5. send command
				;	6. wait for interrupt
			     1				IFNB <BX>			; exit if last reg
 EC8B  5B		     1		POP	BX 					; pop register and repeat
			     1		POPX	CX, DX, DI, DS, , , 
			     2				IFNB <CX>			; exit if last reg
 EC8C  59		     2		POP	CX 					; pop register and repeat
			     2		POPX	DX, DI, DS, , , , 
			     3				IFNB <DX>			; exit if last reg
 EC8D  5A		     3		POP	DX 					; pop register and repeat
			     3		POPX	DI, DS, , , , , 
			     4				IFNB <DI>			; exit if last reg
 EC8E  5F		     4		POP	DI 					; pop register and repeat
			     4		POPX	DS, , , , , , 
			     5				IFNB <DS>			; exit if last reg
 EC8F  1F		     5		POP	DS 					; pop register and repeat
			     5		POPX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		POP	 					; pop register and repeat
			     6		POPX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 EC90  80 FC 01			;	7. fetch results
 EC93  F5			;	8. Check FDC status bytes for result
				;
 EC94  CA 0002		     1		RETF	2
				; Things you should do:
				;	- Check if drive is valid? Check if exists in BDA and not a hard drive
				;----------------------------------------------------------------------------;
				INT_13_2_5 PROC
					CALL	FDC_SEEK 				; Turn on motor, CH = track, DL = drive
				INT_13_0A_DONE:
					JC	INT_13_DONE				; exit if seek error
					PUSH	AX					; save function / sector count
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 131 - 1


					PUSH	DX					; save head / drive
					XCHG	AX, DX 				; DL = sectors count
					MOV	AL, DH				; AL = function number
					MOV	DH, DMA_MR <1,0,0,2,2> 		; set DMA 8237A write/format mode 2 (AH = 3,5)
					OR	_FD_MOTOR_ST, MASK FWRT		; turn on write flag default
					TEST	AL, 3 AND 5				; is write (3) or format (5)?
					JNZ	INT_13_2_5_SETUP_DMA		; if so, proceed to setup
					AND	_FD_MOTOR_ST, NOT MASK FWRT	; else read or verify (turn off BDA write flag)
					MOV	DH, DMA_MR <1,0,0,0,2> 		; 8237A verify mode 0 (AH = 4)
					CMP	AL, 4 				; is verify?
					JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup
					MOV	DH, DMA_MR <1,0,0,1,2> 		; else set 8237A read mode 1 (AH = 2)
				INT_13_2_5_SETUP_DMA:
					XCHG	AX, DX				; AL = sectors to read, AH = DMA mode
											; fall through to set up DMA
				
				;-------------------------------------------------------------------------
				; FDC_INIT_DMA: Configure DMA channel 2 for FDC operation
				;-------------------------------------------------------------------------
				; Input:
				;  AL = sectors to read
				;  AH = DMA mode:
				;	01000110 (46H) - Read
				;	01000010 (42H) - Verify
				;	01001010 (4AH) - Write
				; 	01 			; Mode: Single mode select
				; 	  0  			; Address increment
				;	   0 			; Auto-initialization disable
 EC97				;	    xx		; 00=verify, 01=write, 10=read, 11=unused
 EC97  BA 03F2			;	      10		; Channel 2 select
 EC9A  FA			;  ES:BX = pointer to buffer
 EC9B  A0 003F R		;
 EC9E  8A E8			; Output:
 ECA0  24 0F			;  CF = 0 success, 1 if error DMA exceeds segment
 ECA2  74 0E			;-------------------------------------------------------------------------
				; Things you must do:
				;	- Calculate # of bytes to transfer by multiplying AL (sectors) by
				;		sector size in INT 1E Disk Base Table.
				;	- Calculate linear memory address from ES:BX and normalize to
				;		Paragraph:Offset (P:FFFFH).
 ECA4  D0 E8			;	- Verify that Offset + Byte Count does not exceed the remaining
 ECA6  A8 04			;		space in that paragraph. The DMA controller can only select one
 ECA8  74 02			;		paragraph bank at a time, so writes will NOT wrap to next para.
 ECAA  B0 03			;		Exit with DMA Boundary error if segment is exceeded.
 ECAC				;	- Reset the high/low byte flip-flop (send any value to I/O port 0CH)
				;	- Set DMA mode for Channel 2 to either Verify, Read or Write/Format
				;	- Disable interrupts while programming DMA
				;	- Set the DMA Page (memory paragraph) for DMA channel 2 (I/O port 81H)
 ECAC  B1 04			;	- Set the DMA Byte Counter to size of transfer minus 1 (since
 ECAE  D2 E5			;		DMA's counter is 0-indexed)
				;	- Set the DMA Address register to beginning of DMA buffer from ES:BX
 ECB0  0A C5			;	- Enable interrupts and unmask DMA Channel 2
				;
				;-------------------------------------------------------------------------
				; References:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 132 - 1


				;  https://pdf1.alldatasheet.com/datasheet-pdf/view/127822/AMD/8237A.html
				;  https://wiki.osdev.org/ISA_DMA#Floppy_Disk_DMA_Initialization
				;  https://stackoverflow.com/questions/52396915/how-to-write-assembly-language-to-make-dma-works
 ECB2				;  https://userpages.umbc.edu/~squire/intel_book.pdf
 ECB2  0C 08			;-------------------------------------------------------------------------
 ECB4  EE			FDC_INIT_DMA:
 ECB5  33 C9				PUSH	CX					; save track / sector
 ECB7  88 4D FD				OUT	DMA_FF, AL				; DMA clear flip-flop (port 0CH) (any value)
 ECBA  88 0D				MOV	DX, ES 				; get and shift ES by one nibble
							IF CPU_TYPE EQ CPU_V20
					ROL	DX, 4					; V20 only
							ELSE
					MOV	CL, 4					; DL = highest and lowest nibble of ES
					ROL	DX, CL				; DH = middle nibbles
 ECBC  0C 04						ENDIF
 ECBE  EE				XCHG	AL, AH				; AL = DMA mode, AH = sectors to read
 ECBF  FB				OUT	DMA_MODE, AL			; write to DMA mode reg (port 0BH)
 ECC0  E8 01FF				XOR	AL, AL				; AX = sectors to read << 8
 ECC3  72 04				XCHG	AX, CX				; CX = sectors, AX = scratch
 ECC5  3C C0				MOV	AL, DBT.FBPS			; get bytes/sector param (0=128, 1=256, 2=512, 3=102
				4)
 ECC7  74 02				CALL	INT_1E_PARAM			; AL = shift count (default 2 => 512)
 ECC9					XCHG	AX, CX				; AX = sectors, CL = bytes per sector shifts
 ECC9  B4 20				SHR	AX, 1					; adjust shift for bytes/sector * 128
 ECCB					SHL	AX, CL				; AX = bytes to transfer (AX * 2^CL)
 ECCB  88 25				DEC	AX					; AX = bytes to transfer - 1
 ECCD  75 B1				XCHG	AX, CX				; CX = bytes to transfer - 1
					MOV	AL, DL				; AL = highest and lowest nibble of ES
					AND	AL, 0FH				; AL = only high nibble of ES
					AND	DL, 0F0H				; DX = low three nibbles of ES (shifted left
				 1 nibble)
					ADD	DX, BX				; DX = DMA start offset for transfer
 ECCF  B0 03				ADC	AL, 0					; AL = DMA page
 ECD1  E8 01AD				MOV	BX, DX				; check that buffer offset + length does not exceed 
				segment
 ECD4  72 AA				ADD	BX, CX				; BX = DMA end offset, test for boundary overflow
 ECD6  B0 00				JC	FDC_DMA_BOUND			; error if DMA access across 64k boundary
 ECD8  E8 01A3				CLI						; Disable interrupts
 ECDB  72 A3				OUT	DMA_P_C2, AL 			; set DMA Channel 2 Page Address Register (port 81H)
 ECDD  B0 01				XCHG	AX, DX				; AL = address low byte, AH = high byte (4)
 ECDF  E8 019C				OUT	DMA_2_A, AL				;
 ECE2					XCHG	AL, AH 				; AH = address low byte, AL = high byte (4)
 ECE2  EB 9C				OUT	DMA_2_A, AL				;
 ECE4					XCHG	AX, CX				; AL = byte/count low byte, AH = high byte (4)
					OUT	DMA_2_C, AL				;
					XCHG	AL, AH				; AH = byte/count low byte, AL = high byte (4)
					OUT	DMA_2_C, AL
					STI						; Enable interrupts
					MOV	AL, DMA_SMR <0, 2>		; DMA clear single channel 2 mask bit
					OUT	DMA_MASK, AL			; Unmask DMA Channel 2 (port 0AH)
 ECE4				FDC_INIT_DMA_EXIT:
 ECE4  58				POP	CX					; restore track / sector
 ECE5  8A 05				POP	DX 					; restore drive number DL
 ECE7  8A E0				POP	AX					; restore function number AH
 ECE9  EB A0				JC	INT_13_0_DONE			; exit if DMA error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 133 - 1


 ECEB				
				;-------------------------------------------------------------------------
				; Set FDC command byte
				;
					MOV	AL, FDC_CB <1,1,,FDC_CMD_WR>	; FDC Write Data - Multi-Track, MFM
 ECEB					CMP	AH, 3 				; is write?
 ECEB  80 0D 09				JE	FDC_RWVF				; jump if write
 ECEE  F9				MOV	AL, FDC_CB <0,1,,FDC_CMD_FMT>	; FDC Format Track - Single Track, MFM
 ECEF  EB 64				CMP	AH, 5 				; is format command?
					JE	FDC_RWVF 				; jump if format
					MOV	AL, FDC_CB <1,1,1,FDC_CMD_RD>	; FDC Read Data - MT, MFM, Skip deleted
				
				;-------------------------------------------------------------------------
				; FDC_RWVF: read, write, verify or format sectors
				;-------------------------------------------------------------------------
				; Input:
				;	AL = FDC command
				;	AH = function
				;	DL = drive
				;	DH = head
				;-------------------------------------------------------------------------
				FDC_RWVF:
					PUSH	AX					; preserve AH function number
					CALL	FDC_SEND 				; [0] send command in AL, CF if error
					POP	AX
					JC	FDC_RWV_ERR
					MOV	AL, DH				; AL = head
					XCHG	AX, DX				; AL = drive, AH = head, DL = head, DH = function
					AND	AX, 103H				;  xxxxx     ; unused
					SHL	AH, 1					;       h    ; head number (bit 3)
					SHL	AH, 1					;        dd  ; drive number (bit 1,2)
					OR	AL, AH 				; [1] head / drive
					CALL	FDC_SEND 				; send command in AL, CF if error
					JC	FDC_RWV_ERR
					CMP	DH, 5					; is format?
					JE	FDC_FORMAT
				
				;-------------------------------------------------------------------------
				; FDC_RWV: read, write or verify sectors
				;-------------------------------------------------------------------------
 ECF1				; Input:
 ECF1  E8 010B			;	CH = track/cylinder number (0-39)
 ECF4				;	CL = sector number (1-17)
 ECF4  72 8A			;	DL = head number (0-1)
 ECF6  50			; 	(All registers clobbered)
 ECF7  52			;
 ECF8  92			; Output:
 ECF9  8A C6			;	AL = number of sectors read, written or verified
 ECFB  B6 4A			;-------------------------------------------------------------------------
 ECFD  80 4D FE 80		FDC_RWV PROC
 ED01  A8 01				MOV	AL, CH 				; [2] cylinder number
 ED03  75 0C				CALL	FDC_SEND 				; send command in AL, CF if error
 ED05  80 65 FE 7F			JC	FDC_RWV_ERR
 ED09  B6 42				MOV	AL, DL 				; [3] head number
 ED0B  3C 04				CALL	FDC_SEND 				; send command in AL, CF if error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 134 - 1


 ED0D  74 02				JC	FDC_RWV_ERR
 ED0F  B6 46				MOV	AL, CL 				; [4] sector number
 ED11					CALL	FDC_SEND 				; send command in AL, CF if error
 ED11  92				JC	FDC_RWV_ERR
					MOV	AL, DBT.FBPS			; [5] bytes per sector
					CALL	FDC_SEND_PARAM			; 2 = 512 bytes
					JC	FDC_RWV_ERR
					MOV	AL, DBT.SPT				; [6] end of track (last sector in track)
					CALL	FDC_SEND_PARAM
					JC	FDC_RWV_ERR
					MOV	AL, DBT.SGAP			; [7] sector gap length
					CALL	FDC_SEND_PARAM
					JC	FDC_RWV_ERR
					MOV	AL, DBT.LSEC			; [8] data length (if cmd byte 5==0)
				
				;-------------------------------------------------------------------------
				; Send last param and wait for status
				;
				FDC_RWV_SEND_WAIT:
					CALL	FDC_SEND_PARAM
					JC	FDC_RWV_ERR
					CALL	FDC_WAIT_STATUS			; wait for WIF and get status
					JC	FDC_RWV_ERR				; check for timeout error
											; fall through for FDC SEC COUNT
				
				;-------------------------------------------------------------------------
				; FDC_SEC_COUNT: get the number of sectors read/verified/written
				;-------------------------------------------------------------------------
				; Input:
				;	CH = start track/cylinder number (0-39)
				;	CL = start sector number (1-17)
				;	DL = head number (0-1)
				; Ouput:
				;	AL = sectors transferred
				;
				; Note: If the operation finishes at the last head/sector of a track, 
				;	FDC will report the head/track/sector position to be the beginning 
				;	of the next track.
				;-------------------------------------------------------------------------
				FDC_SEC_COUNT PROC
					MOV	AH, _FDC_LAST_ST.SEC		; AL = FDC reported end sector
					MOV	DH, DL				; DH = start head
					MOV	DL, CH				; DL = start track
					CMP	DX, WORD PTR _FDC_LAST_ST.CYL	; end on the same head and track?
					JE	FDC_SEC_COUNT_SAME		; if not, rolled to next head or track
				
				;----------------------------------------------------------------------------;
				; FDC has ended on a different head or track. Calculate the correct number of
				; sectors spanned.
				;
 ED12					MOV	AL, DBT.SPT				; get INT 1E sectors per track
 ED12  51				CALL	INT_1E_PARAM			; AL = last sector (# of SPT)
 ED13  E6 0C				CMP	DH, _FDC_LAST_ST.HEAD		; end on same head but different track?
 ED15  8C C2				JNE	FDC_SEC_COUNT_SAME_CYL		; if so, has spanned a full head
					SHL	AL, 1					; two tracks worth of sectors
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 135 - 1


				FDC_SEC_COUNT_SAME_CYL:
					ADD	AH, AL				; add ending sector
 ED17  B1 04			FDC_SEC_COUNT_SAME:
 ED19  D3 C2				MOV	AL, AH				; AL = last_sector - starting_sector
					SUB	AL, CL				;   returns AL = sectors read
 ED1B  86 C4			FDC_SEC_COUNT ENDP
 ED1D  E6 0B			
 ED1F  32 C0			FDC_RWV ENDP					; fall through for exit
 ED21  91			
 ED22  B0 03			;----------------------------------------------------------------------------;
 ED24  E8 0201			; Done with all disk operations and return AL
 ED27  91			;
 ED28  D1 E8			INT_13_2_5_DONE:
 ED2A  D3 E0				POP	CX					; discard original AX from INT_13 PROC
 ED2C  48				PUSH	AX					; replace with AL = sectors read
 ED2D  91			INT_13_2_5_EXIT:
 ED2E  8A C2				JMP	INT_13_DONE
 ED30  24 0F			
 ED32  80 E2 F0			;----------------------------------------------------------------------------;
 ED35  03 D3			; Clear AL and exit on any read/write error
 ED37  14 00			;
 ED39  8B DA			FDC_RWV_ERR:
 ED3B  03 D9			FDC_FORMAT_ERR:
 ED3D  72 AC				MOV	AL, 0					; on error: sectors read = 0
 ED3F  FA				JMP	SHORT INT_13_2_5_DONE
 ED40  E6 81			
 ED42  92			;----------------------------------------------------------------------------;
 ED43  E6 04			; INT 13, 5: Format Track
 ED45  86 C4			;----------------------------------------------------------------------------;
 ED47  E6 04			; Input:
 ED49  91			;	AH = 05
 ED4A  E6 05			;	AL = interleave value (XT only) / sectors per track
 ED4C  86 C4			;	CX = track/cylinder number (see below for format)
 ED4E  E6 05			;	DL = head number  (0-15 dec.)
 ED50  FB			;	ES:BX = pointer to block of "track address fields" (provided by DOS)
 ED51  B0 02			;----------------------------------------------------------------------------;
 ED53  E6 0A			FDC_FORMAT PROC
 ED55					MOV	AL, DBT.FBPS			; [2] bytes per sector
 ED55  59				CALL	FDC_SEND_PARAM
 ED56  5A				JC	FDC_FORMAT_ERR
 ED57  58				MOV	AL, DBT.SPT				; [3] sectors per track
 ED58  72 88				CALL	FDC_SEND_PARAM
					JC	FDC_FORMAT_ERR
					MOV	AL, DBT.FGAP			; [4] format gap length
					CALL	FDC_SEND_PARAM
					JC	FDC_FORMAT_ERR
 ED5A  B0 C5				MOV	AL, DBT.FFILL			; [5] format fill byte
 ED5C  80 FC 03				MOV	CL, 1					; format always starts at sector 1
 ED5F  74 09				JMP	SHORT FDC_RWV_SEND_WAIT		; send, wait for WIF and get status
 ED61  B0 4D			FDC_FORMAT ENDP
 ED63  80 FC 05			
 ED66  74 02			INT_13_2_5 ENDP
 ED68  B0 E6			
				;-------------------------------------------------------------------------
				; FDC_SEEK: Seek to track
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 136 - 1


				;-------------------------------------------------------------------------
				; Input:
				;	CH = track
				;	DL = drive
				;-------------------------------------------------------------------------
				FDC_SEEK PROC
					PUSH	AX
					CALL	FDC_RECAL 				; recalibrate if needed
 ED6A					JC	FDC_SEEK_RECAL_ERR
 ED6A  50				MOV	AL, FDC_CMD_SEEK			; seek command (0FH)
 ED6B  E8 0113				CALL	FDC_SEND 				; send command, CF if error
 ED6E  58				JC	FDC_SEEK_ERR
 ED6F  72 6F				MOV	AL, DL 				; AL = drive number
 ED71  8A C6				CALL	FDC_SEND 				; send command, CF if error
 ED73  92				JC	FDC_SEEK_ERR			; necessary?
 ED74  25 0103				MOV	AL, CH 				; AL = track number
 ED77  D0 E4				CALL	FDC_SEND 				; send command, CF if error
 ED79  D0 E4				JC	FDC_SEEK_ERR
 ED7B  0A C4				CALL	FDC_WAIT_SENSE			; wait for WIF, sense and get status
 ED7D  E8 0101				JC	FDC_SEEK_ERR
 ED80  72 5E				XOR	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete
 ED82  80 FE 05				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete
 ED85  74 5D				JZ	FDC_SEEK_ERR
							IF ARCH_TYPE NE ARCH_EMU
					MOV	AX, DBT.HDST
					CALL	INT_1E_PARAM			; AL = head settle time (ms)
					CALL	IO_DELAY_MS				; delay AX ms
							ENDIF
					CLC
				FDC_SEEK_DONE:
					POP	AX
					RET
				FDC_SEEK_ERR:
					OR	_FD_LAST_OP, FDC_ST_ERR_SEEK
				FDC_SEEK_RECAL_ERR:
					STC
 ED87					JMP	SHORT FDC_SEEK_DONE
 ED87  8A C5			FDC_SEEK ENDP
 ED89  E8 00F5			
 ED8C  72 52			;-------------------------------------------------------------------------
 ED8E  8A C2			; FDC_MOTOR_ON: Turn on motor
 ED90  E8 00EE			;-------------------------------------------------------------------------
 ED93  72 4B			; Input:
 ED95  8A C1			; 	DL = drive number
 ED97  E8 00E7			; Clobbers: CX
 ED9A  72 44			;-------------------------------------------------------------------------
 ED9C  B0 03			; Things you must do:
 ED9E  E8 00DD			;	- is motor already on? Skip wait for spin up
 EDA1  72 3D			;	- wait only for writes?
 EDA3  B0 04			;	- check if recalibration is necessary
 EDA5  E8 00D6			;
 EDA8  72 36			; Things you should do:
 EDAA  B0 05			;	- check if drive is valid in BDA?
 EDAC  E8 00CF			;-------------------------------------------------------------------------
 EDAF  72 2F			FDC_MOTOR_ON PROC
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 137 - 1


 EDB1  B0 06				PUSH	AX
					PUSH	DX
				
				;-------------------------------------------------------------------------
				; Convert drive number to motor run format
 EDB3				;
 EDB3  E8 00C8				MOV	CL, DL 				; move to CL for shift
 EDB6  72 28				AND	CL, MASK FDSEL			; isolate selected drive number in CL
 EDB8  E8 013F				MOV	AX, 110H 				; AH -> RUN_ST, AL -> FDC byte
 EDBB  72 23				SHL	AX, CL 				; shift drive flags
					CLI 						; disable interrupts
					MOV	CH, _FD_MOTOR_ST			; get current RUN_ST
					TEST	CH, AH 				; is drive already running?
					JNZ	FDC_DRV_ALREADY_ON		; skip startup if so
					OR	AL, CL 				; combine drive number to FDC byte
					OR	AL, MASK FDDMA OR MASK FDCEN	; set DMA and controller enable flags
					MOV	DX, FDC_CTRL			; turn on motor
					OUT	DX, AL				; port 3F2H, FDC Digital Output
					MOV	AL, CH 				; AL = FD_MOTOR_ST
					AND	AL, NOT MASK FMOT 		; clear motor status of FD_MOTOR_ST
					OR	AL, AH				; combine nibbles
					MOV	AH, 255				; restart timer to max for motor spinup
					MOV	WORD PTR FD_MOTOR_ST, AX	; write to motor status and timer
					STI 						; enable interrupts
					TEST	AL, MASK FWRT			; Delay for motor spinup if write operation
					JZ	FDC_DRIVE_STARTED 		; if not, bypass delay
 EDBD				
 EDBD  8A 65 06			;-------------------------------------------------------------------------
 EDC0  8A F2			; Delay using timer tick counter
 EDC2  8A D5			;
 EDC4  3B 55 04				MOV	AL, DBT.FMST			; AL = INT_1E[10]
 EDC7  74 0E				CALL	INT_1E_PARAM 			; AL = motor startup time (in 125ms)
					CALL	IO_WAIT_MS_125			; wait AL * 125ms
				
				FDC_DRV_ALREADY_ON:
					MOV	AL, DBT.FMCT 			; AL = INT_1E[2]
					CALL	INT_1E_PARAM			; AL = reset motor counter
 EDC9  B0 04				MOV	FD_MOTOR_CT, AL
 EDCB  E8 015A				STI
 EDCE  3A 75 05			FDC_DRIVE_STARTED:
 EDD1  75 02				POP	DX
 EDD3  D0 E0				POP	AX
 EDD5					RET
 EDD5  02 E0			FDC_MOTOR_ON ENDP
 EDD7				
 EDD7  8A C4			;----------------------------------------------------------------------------;
 EDD9  2A C1			; FDC_RECV: Wait for FDC ready to send and read next FDC Status byte into AL
 EDDB				;----------------------------------------------------------------------------;
				; Timeout is 5 timer ticks = ~275ms.
 EDDB				;
				; Input: None
				; Output:
				;	AL = top of FDC status stack
				;	AH = 80H if error, 0 if success
 EDDB				;	CF if timeout or error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 138 - 1


 EDDB  59			;----------------------------------------------------------------------------;
 EDDC  50			FDC_RECV PROC
 EDDD					PUSH	BX
 EDDD  E9 FEA0				XOR	BX, BX				; flag is 0 if RECV operation
					MOV	BH, AL				; save byte to send
					JMP	SHORT FDC_SEND_RECV
				
				;----------------------------------------------------------------------------;
 EDE0				; FDC_SEND_PARAM: Wait for FDC ready and send a floppy param in AL
 EDE0				;----------------------------------------------------------------------------;
 EDE0  B0 00			; Same as below except AL input is INT_1E param index
 EDE2  EB F7			;----------------------------------------------------------------------------;
				FDC_SEND_PARAM PROC
					CALL	INT_1E_PARAM 			; AL = INT_1E[AL] param
				
				;----------------------------------------------------------------------------;
				; FDC_SEND: Wait for FDC ready to receive and send a single command
				;----------------------------------------------------------------------------;
				; Timeout is 5 timer ticks = ~275ms.
				;
				; Input:
				;	AL = byte to send to FDC
				;
 EDE4				; Output:
 EDE4  B0 03			;	AL = status register
 EDE6  E8 0095			;	AH = 80H if error, 0 if success
 EDE9  72 F5			;	CF and ZF if error
 EDEB  B0 04			;----------------------------------------------------------------------------;
 EDED  E8 008E			FDC_SEND PROC
 EDF0  72 EE				PUSH	BX
 EDF2  B0 07				MOV	BH, AL				; save byte to send
 EDF4  E8 0087				MOV	BL, 1					; flag is 1 if SEND operation
 EDF7  72 E7			
 EDF9  B0 08			FDC_SEND_RECV:
 EDFB  B1 01				PUSH	CX
 EDFD  EB B4				PUSH	DX 					; call-preserve used registers
 EDFF				
				;----------------------------------------------------------------------------;
 EDFF				; Wait for FDC I/O direction = CPU to FDC and Data Reg Ready
				;
					MOV	DX, FDC_STAT 			; port 3F4H - FDC Main Status Register
					MOV	CX, 5					; CX = # of ticks to wait
					MOV	AH, BYTE PTR TIMER.LW		; get starting tick counter low byte
				
				FDC_SEND_WAIT_POLL:
					IN	AL, DX				; AL = FDC status register
					TEST	AL, AL				; is DRR = I/O to/from CPU?
 EDFF					JNS	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
 EDFF  50			
 EE00  E8 018F			;----------------------------------------------------------------------------;
 EE03  72 2F			; FDC is ready for I/O
 EE05  B0 0F			;
 EE07  E8 0077				INC	DX 					; port 3F5H - FDC Command Status Register
 EE0A  72 25				TEST	BL, BL				; is send or receive?
 EE0C  8A C2				JZ	FDC_RECV_WAIT_POLL		; jump if receive
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 139 - 1


 EE0E  E8 0070			
 EE11  72 1E			;----------------------------------------------------------------------------;
 EE13  8A C5			; SEND operation
 EE15  E8 0069			;----------------------------------------------------------------------------;
 EE18  72 17			FDC_SEND_WAIT_POLL_1:
 EE1A  E8 00A5				TEST	AL, MASK FIOD			; is I/O direction = CPU to FDC (0)?
 EE1D  72 12				JNZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
 EE1F  34 60			
 EE21  24 60			;----------------------------------------------------------------------------;
 EE23  74 0C			; Status is ready to send
				;
 EE25  B8 0009			FDC_SEND_READY:
 EE28  E8 00FD				MOV	AL, BH				; restore AL byte to send
 EE2B  E8 0946				OUT	DX, AL				; send command
					JMP	SHORT FDC_WAIT_DONE		; status = success (0), CF = 0 and done
 EE2E  F8			
 EE2F				;----------------------------------------------------------------------------;
 EE2F  58			; RECEIVE operation
 EE30  C3			;----------------------------------------------------------------------------;
 EE31				FDC_RECV_WAIT_POLL:
 EE31  80 0D 40				TEST	AL, MASK FIOD			; is I/O direction = FDC to CPU (1)?
 EE34					JZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
 EE34  F9			
 EE35  EB F8			;----------------------------------------------------------------------------;
 EE37				; Data is ready to read
				;
				FDC_RECV_READY:
					IN	AL, DX				; read from FDC
				
				;----------------------------------------------------------------------------;
				; Completed with success
				;
				FDC_WAIT_DONE:
					XOR	AH, AH 				; status = success (0), CF = 0
				
				FDC_WAIT_EXIT:
					POP	DX
					POP	CX
					POP	BX
					RET
				
 EE37				;----------------------------------------------------------------------------;
 EE37  50			; Check if timeout has expired
 EE38  52			;
				FDC_SEND_WAIT_TIMER:
					MOV	AL, BYTE PTR TIMER.LW		; get current tick counter
					CMP	AL, AH				; still the same?
					JZ	FDC_SEND_WAIT_POLL		; loop if the same
 EE39  8A CA				MOV	AH, AL				; otherwise, save new tick value to AH
 EE3B  80 E1 03				LOOPNZ FDC_SEND_WAIT_POLL		; loop until # of ticks (CX) has elapsed
 EE3E  B8 0110			
 EE41  D3 E0			FDC_WAIT_TIMEOUT:
 EE43  FA				MOV	AH, FDC_ST_TIMEOUT 		; time out, drive not ready error
 EE44  8A 6D FE				OR	_FD_LAST_OP, AH			; set flag in BDA
 EE47  84 EC				STC						; set error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 140 - 1


 EE49  75 20				JMP	SHORT	FDC_WAIT_EXIT
 EE4B  0A C1			
 EE4D  0C 0C			FDC_SEND ENDP
 EE4F  BA 03F2			FDC_SEND_PARAM ENDP
 EE52  EE			FDC_RECV ENDP
 EE53  8A C5			
 EE55  24 F0			;-------------------------------------------------------------------------
 EE57  0A C4			; FDC_WAIT_SENSE: wait for WIF, sense status and get status bytes
 EE59  B4 FF			;-------------------------------------------------------------------------
 EE5B  A3 003F R		; Output:
 EE5E  FB			;	CF if error
 EE5F  A8 80			;	AL = FDC_LAST_ST (BDA Floppy drive status)
 EE61  74 11			;	AH clobbered
				;-------------------------------------------------------------------------
				FDC_WAIT_SENSE PROC
					CALL	FDC_WAIT_INT 			; wait for WIF
					JC	FDC_WAIT_SENSE_EXIT
 EE63  B0 0A				MOV	AL, FDC_CMD_SENSE			; sense Interrupt status
 EE65  E8 00C0				CALL	FDC_SEND
 EE68  E8 0905			
				;----------------------------------------------------------------------------;
 EE6B				; FDC_RECV_STATUS:
 EE6B  B0 02			;----------------------------------------------------------------------------;
 EE6D  E8 00B8			; Output:
 EE70  A2 0040 R		;	CF if FDC read/timeout error
 EE73  FB			;	NZ if result status error
 EE74				;
 EE74  5A			;	AL = FDC_LAST_ST (BDA Floppy drive status), if success
 EE75  58			;	AH clobbered
 EE76  C3			;----------------------------------------------------------------------------;
 EE77				FDC_RECV_STATUS PROC
					JC	FDC_WAIT_SENSE_EXIT		; return if timeout error
											; fall through to FDC_RECV_ALL
				
				;----------------------------------------------------------------------------;
				; FDC_RECV_ALL: Pop all status bytes from FDC to BDA
				;----------------------------------------------------------------------------;
				; Check for FDC errors and set FD_LAST_OP if necessary
				;----------------------------------------------------------------------------;
				FDC_RECV_ALL PROC
					PUSH	ES
					PUSH	CX
					PUSH	DI					; preserve DI (FD_LAST_OP)
 EE77					PUSH	DX
 EE77  53				MOV	DX, FDC_STAT
 EE78  33 DB				MOV	AX, SEG _BDA
 EE7A  8A F8				MOV	ES, AX
 EE7C  EB 08				INC	DI					; DI = FDC_LAST_ST (FDC Last Result)
					MOV	CX, 7					; loop up to 7 FDC bytes
				FDC_RECV_ALL_LOOP:
					CALL	FDC_RECV				; AL = next byte, AH = 0 if success
					JC	FDC_RECV_ALL_DONE			; CF if failure
					STOSB						; write to BDA
				
 EE7E				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 141 - 1


 EE7E  E8 00A7			; Additional delay for FDC to settle
				;
						IF IS_TURBO
					MOV	AL, 20				; delay 372 clocks (~31us at 12MHz,
						ELSE					;  ~37us at 10MHz, ~46us at 8MHz)
					MOV	AL, 10				; delay 182 clocks (~38us at 4.77)
						ENDIF
				FDC_RECV_DELAY:					; [7+19(AX-1)] clocks
					DEC	AX					; [3]
					JNZ	FDC_RECV_DELAY			; [4+16(AX-1)]
				
				;----------------------------------------------------------------------------;
				; Check for additional bytes to be read from FDC registers
				;
					IN	AL, DX				; DX = 03F4H
 EE81					AND	AL, MASK FDRW 			; is FDC R/W command in progress flag?
 EE81  53				LOOPNZ FDC_RECV_ALL_LOOP		; loop until no flag or 7 bytes read
 EE82  8A F8										; AL = 0 (no command in progress) or CX = 0
 EE84  B3 01				REP	STOSB 				; zero out rest of results in BDA
				FDC_RECV_CHECK_ERR:
 EE86					MOV	AL, FDC_LAST_ST.SB0 		; AL = last FDC status byte 0
 EE86  51				TEST	AL, MASK ST0CS			; check Last Command Status
 EE87  52			FDC_RECV_ALL_DONE:
					POP	DX
					POP	DI					; DI = FD_LAST_OP
					POP	CX
					POP	ES
 EE88  BA 03F4			FDC_WAIT_SENSE_EXIT:
 EE8B  B9 0005				RET
 EE8E  8A 26 006C R		FDC_RECV_ALL ENDP
				FDC_RECV_STATUS ENDP
 EE92				FDC_WAIT_SENSE ENDP
 EE92  EC			
 EE93  84 C0			;-------------------------------------------------------------------------
 EE95  79 19			; FDC_WAIT_STATUS: Wait for WIF, get status bytes and check for error
				;-------------------------------------------------------------------------
				FDC_WAIT_STATUS PROC
					CALL	FDC_WAIT_INT 			; wait for WIF
					CALL	FDC_RECV_STATUS			; read FDC status into BDA
 EE97  42										; CF if FDC error, NZ if status error
 EE98  84 DB				JBE	FDC_WAIT_ERR_EXIT_OK		; exit if ZF or CF error
 EE9A  74 09			
				;-------------------------------------------------------------------------
				; FDC_WAIT_STATUS_ERR: Map FDC Command Status Register 1 to BDA error codes
				;-------------------------------------------------------------------------
				; Input:
 EE9C				;	AL = Last result from FDC_LAST_ST
 EE9C  A8 40			; Output:
 EE9E  75 10			;	CF if error
				;	AH/AL = BDA Floppy drive status
				;-------------------------------------------------------------------------
				FDC_WAIT_STATUS_ERR PROC
					PUSH	SI
 EEA0					TEST	AL, 01000000B			; command terminated abnormally?
 EEA0  8A C7				MOV	AL, FDC_ST_ERR_FDC		; if not, FDC error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 142 - 1


 EEA2  EE				JZ	FDC_WAIT_STATUS_ERR_DONE
 EEA3  EB 05				MOV	AH, _FDC_LAST_ST.SB1		; AH = last status byte 1
					TEST	AH, AH
					JZ	FDC_WAIT_STATUS_ERR_DONE	; skip if AH = 0
					MOV	SI, OFFSET FDC_ERR1_MAP
				FDC_ERR_MAP_LOOP:
 EEA5					LODS	BYTE PTR CS:[SI]			; fetch next error byte
 EEA5  A8 40				SHL	AH, 1					; CF if this status flag
 EEA7  74 07				JA	FDC_ERR_MAP_LOOP			; loop if NC (not this flag)
											;  and NZ (more flags to check)
				FDC_WAIT_STATUS_ERR_DONE:
					MOV	AH, AL				; AH = last result
				FDC_WAIT_ERR_EXIT:
 EEA9					POP	SI
 EEA9  EC				OR	_FD_LAST_OP, AH			; BDA 40:41H
					STC
				FDC_WAIT_ERR_EXIT_OK:
					RET
				
 EEAA				;-------------------------------------------------------------------------
 EEAA  32 E4			; Note: Must check from most sig bit to lowest since higher
				; bits are more meaningful.
 EEAC				;
 EEAC  5A			FDC_ERR1_MAP LABEL BYTE
 EEAD  59				DB	FDC_ST_ERR_SEC			; 80 end of cylinder
 EEAE  5B				DB	FDC_ST_ERR_FDC			; 40 unused (always zero)
 EEAF  C3				DB	FDC_ST_ERR_CRC			; 20 data error CRC
					DB	FDC_ST_DMA_OVR			; 10 DMA timeout/overrun
					DB	FDC_ST_ERR_FDC			; 08 unused (always zero)
					DB	FDC_ST_ERR_SEC			; 04 Sector Not Found
					DB	FDC_ST_ERR_WP			; 02 Write Protect
 EEB0					DB	FDC_ST_ERR_MARK			; 01 Address mark not found or bad sector
 EEB0  A0 006C R		
 EEB3  38 E0			FDC_WAIT_STATUS_ERR ENDP
 EEB5  74 DB			FDC_WAIT_STATUS ENDP
 EEB7  8A E0			
 EEB9  E0 D7			;----------------------------------------------------------------------------;
				; Retrieve a parameter value from the DBT by index
 EEBB				;----------------------------------------------------------------------------;
 EEBB  B4 80			; Input:
 EEBD  08 25			;	AL = parameter index (bounds not checked)
 EEBF  F9			; Output:
 EEC0  EB EA			;	AL = byte
				;
 EEC2				; Size: 14 bytes
 EEC2				;----------------------------------------------------------------------------;
 EEC2				INT_1E_PARAM PROC
					PUSH	DS
					PUSH	BX
					XOR	BX, BX 				; BX = IVT
					MOV	DS, BX 				; DS = IVT
							ASSUME DS:_IVT
					LDS	BX, IVT_1E				; DS:BX = INT 1EH in IVT
					XLAT 						; AL = byte
					POP	BX
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 143 - 1


					POP	DS
 EEC2							ASSUME DS:NOTHING
 EEC2  E8 00A6				RET
 EEC5  72 32			INT_1E_PARAM ENDP
 EEC7  B0 08			
 EEC9  E8 FFB5			;
				; 33 BYTES HERE
				;
				BYTES_HERE	INT_0E
				
				;----------------------------------------------------------------------------;
				; INT 0EH - Floppy Disk Interrupt IRQ6
				;----------------------------------------------------------------------------;
				; This interrupt is issued upon floppy disk I/O completion and sets the
				; floppy disk working interrupt flag at 40:3E, bit 7.
				;----------------------------------------------------------------------------;
						ORG 0EF57H
 EECC				INT_0E PROC
 EECC  72 2B					ASSUME DS:_BDA
					STI						; necessary?
					PUSH	AX
					PUSH	DS
					MOV	AX, SEG _BDA 			; DS = BDA segment
					MOV	DS, AX
					OR	FD_CAL_ST, MASK FWIF		; turn on working interrupt flag
					MOV	AL, EOI 				; End of Interrupt OCW
 EECE					OUT	INT_P0, AL				; write EOI to port 0
 EECE  06				POP	DS
 EECF  51				POP	AX
 EED0  57				IRET
 EED1  52			INT_0E ENDP
 EED2  BA 03F4			
 EED5  B8 ---- R		;----------------------------------------------------------------------------;
 EED8  8E C0			; FDC_WAIT_INT: Wait for BDA Working Interrupt Flag from FDC
 EEDA  47			;----------------------------------------------------------------------------;
 EEDB  B9 0007			; Input: DS = BDA
 EEDE				; Output: CF if timeout
 EEDE  E8 FF96			;----------------------------------------------------------------------------;
 EEE1  72 12			FDC_WAIT_INT PROC
 EEE3  AA				STI						; ensure interrupts are on
					PUSH	AX 					; call preserve regs
					PUSH	CX
					MOV	CX, 2 * (1000/55) + 1		; timeout ~2 sec (37 ticks)
				FDC_WAIT_INT_LOOP1:
					MOV	AX, TIMER.LW			; AX = time ticks
 EEE4  B0 14			FDC_WAIT_INT_LOOP2:
					TEST	FD_CAL_ST, MASK FWIF 		; check for WIF in FD_CAL_ST (3EH)
					JNZ	FDC_WAIT_INT_OK			; if so, exit
							IF FDC_HLT_WAIT GT 0
 EEE6					HLT						; wait for any INT
 EEE6  48						ELSE
 EEE7  75 FD				NOP						; allow extra time for INTs
							ENDIF
					CMP	AX, TIMER.LW			; has timer tick changed?
					JZ	FDC_WAIT_INT_LOOP2		; if not, wait for next INT
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 144 - 1


					LOOP	FDC_WAIT_INT_LOOP1		; decrement tick counter and resume loop
 EEE9  EC				OR	_FD_LAST_OP, FDC_ST_TIMEOUT 	; FDC result set time out, drive not ready
 EEEA  24 10				STC
 EEEC  E0 F0				JMP	SHORT FDC_WAIT_INT_DONE
				FDC_WAIT_INT_OK:
 EEEE  F3/ AA				AND	FD_CAL_ST, NOT MASK FWIF 	; clear working interrupt flag
 EEF0				FDC_WAIT_INT_DONE:
 EEF0  A0 0042 R			POP	CX
 EEF3  A8 C0				POP	AX
 EEF5					RET
 EEF5  5A			FDC_WAIT_INT ENDP
 EEF6  5F			
 EEF7  59			;-------------------------------------------------------------------------
 EEF8  07			; FDC_RECAL: recalibrate drive, if necessary
 EEF9				;-------------------------------------------------------------------------
 EEF9  C3			; Input:
 EEFA				;	DL = drive to recalibrate
 EEFA				; Output:
 EEFA				;	CF if error
				;
				; AX clobbered
				;-------------------------------------------------------------------------
				FDC_RECAL PROC
 EEFA					PUSH	CX
 EEFA  E8 006E				CALL	FDC_MOTOR_ON			; ensure motor is on
 EEFD  E8 FFCC				MOV	CL, DL 				; move to CL for shift
					AND	CL, 0011B 				; mask just drive number in CL
 EF00  76 1D				MOV	AL, 0001B 				; AL shift to FDC drive # bit
					SHL	AL, CL 				; shift drive flags
					TEST	AL, FD_CAL_ST 			; 0 means drive is uncalibrated
					JNZ	FDC_RECAL_DONE 			; if drive is calibrated, exit
					MOV	CH, AL 				; CH = drive bits
					MOV	AL, FDC_CMD_RECAL 		; recalibrate command (07H)
					CALL	FDC_SEND 				; send command, CF if error
					JC	FDC_RECAL_ERR
					MOV	AL, CL 				; AL = drive number
					CALL	FDC_SEND 				; send command, CF if error
					;JC	FDC_RECAL_ERR			; (necessary?)
 EF02					CALL	FDC_WAIT_SENSE 			; wait for WIF, sense and get status in AL
 EF02  56				JC	FDC_RECAL_ERR
 EF03  A8 40				XOR 	AL, FDC_ST0 <01B, 1>		; select abnormal term, seek complete
 EF05  B0 20				AND	AL, FDC_ST0 <01B, 1>		; ZF = abnormal term AND seek complete
 EF07  74 10				STC						; presume failure
 EF09  8A 65 02				JZ	FDC_RECAL_ERR			; jump if error
 EF0C  84 E4				OR	FD_CAL_ST, CH 			; mark drive as calibrated and CLC
 EF0E  74 09			FDC_RECAL_ERR:
 EF10  BE EF20 R		FDC_RECAL_DONE:
 EF13					POP	CX
 EF13  2E: AC				RET
 EF15  D0 E4			FDC_RECAL ENDP
 EF17  77 FA			
				INT_13 ENDP
 EF19				
 EF19  8A E0			;
 EF1B				; 2 BYTES HERE
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 145 - 1


 EF1B  5E			;
 EF1C  08 25			BYTES_HERE	INT_1E
 EF1E  F9			
 EF1F				;----------------------------------------------------------------------------;
 EF1F  C3			; INT 1E - Disk Initialization Parameter Table Vector
				;----------------------------------------------------------------------------;
				; Provides a "pluggable" method to allow additional disk ROMs or DOS to 
				; replace this table.
				;
				;  00  Head Step Rate (SRT) = 0CH = 12ms
 EF20				;      Head Unload Time (HUT) = 0FH (16ms increments) = 240ms(?)
 EF20  04			;  01  Head Load Time = 01H (2ms increments) = 2ms
 EF21  20			;  02  timer ticks to wait before disk motor shutoff = 37
 EF22  10			;  03  512 bytes per sector (0=128, 1=256, 2=512, 3=1024) = 2
 EF23  08			;  04  sectors per track (last sector number) = 8
 EF24  20			;  05  inter-block gap length/gap between sectors = 02AH
 EF25  04			;  06  data length, if sector length not specified = 0FFH
 EF26  03			;  07  gap length between sectors for format = 50H
 EF27  02			;  08  fill byte for formatted sectors = 0F6H
				;  09  head settle time in milliseconds = 25
 EF28				;  0A  motor startup time in eighths of a second = 4
 EF28				;  MFM = 2
				;
				; https://stanislavs.org/helppc/dbt.html
				; https://stanislavs.org/helppc/765.html
				; https://stanislavs.org/helppc/int_1e.html
				;----------------------------------------------------------------------------;
						ORG 	0EFC7H
				INT_1E	DBT 	<0CFH, 0010B, 37, 2, 8, 2AH, 0FFH, 50H, 0F6H, 25, 4>
				
				;----------------------------------------------------------------------------;
				; INT 17 - Printer BIOS Services
				;----------------------------------------------------------------------------;
 EF28				;	INT 17,0   Print character
 EF28  1E			;	INT 17,1   Initialize printer port
 EF29  53			;	INT 17,2   Read printer port status
 EF2A  33 DB			;
 EF2C  8E DB			; https://www.stanislavs.org/helppc/ports.html
				; https://en.wikipedia.org/wiki/Parallel_port#IBM_PC_implementation
 EF2E  C5 1E 0078 R		; http://www.techhelpmanual.com/907-parallel_printer_adapter_ports.html
 EF32  D7			;----------------------------------------------------------------------------;
 EF33  5B			; Things you must do (on all calls):
 EF34  1F			; - Verify printer is within range 0-2.
				; - Verify printer index is detected and get I/O address.
 EF35  C3			; - Return AH = 0 if any of the above are not met.
 EF36				; - Do the function call
				; - Get port status and return in AH for any valid calls.
				;
				; Things you should do:
				; - Get installed printer count via INT 11H
				;
 EF36			     1			LOCAL LBL
			     1	
 = 0021			     1	BYTES_HERE_INT_0E = INT_0E-$
			     1	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 146 - 1


			     1			IFDEF BYTES_HERE_INT_0E
			     1			IF2
			     1			IF BYTES_HERE_INT_0E LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_0E (BYTES_HERE_INT_0E)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				;----------------------------------------------------------------------------;
						ORG 0EFD2H
				INT_17 PROC
						ASSUME DS:_BDA
					STI 						; enable interrupts
					CMP	DX, 2					; is greater than 2?
					JA	INT_17_IRET 			; if so, exit
					PUSHX	DX, DI, CX, AX, DS		; call-preserve working regs
 EF57					MOV	CX, SEG _BDA 			; CH = 0, CL = 40H
					MOV	DS, CX				; DS = BDA
 EF57  FB				MOV	DI, DX 				; DI = LPT port index (0-2)
 EF58  50				MOV	CL, LPT_TIME_B[DI]		; CX = port timeout
 EF59  1E				SHL	DI, 1 				; convert to word-aligned index
 EF5A  B8 ---- R			MOV	DX, LPT_ADDR_B[DI]		; DX = data port address
 EF5D  8E D8				POP	DS 					; restore DS
 EF5F  80 0E 003E R 80			TEST	DX, DX 				; is port index valid (detected)?
 EF64  B0 20				JZ	INT_17_DONE 			; if not, exit
 EF66  E6 20				DEC	AH
 EF68  1F				JZ	INT_17_1				; AH = 1 then init
 EF69  58				JG	INT_17_2	 			; AH = 2 then status
 EF6A  CF										; AH = 0 fall through to print
 EF6B				
				;----------------------------------------------------------------------------;
				; AH = 0 - Print Character
				;----------------------------------------------------------------------------;
				; Write character and returns status
				;
				; Input:
				;	AH = -1 (not 0)
 EF6B				;	AL = character to print
 EF6B  FB			;	CX = timeout "value" (the number of 64k loops)
 EF6C  50			;	DX = LPT data port (278, 378, 3BC)
 EF6D  51			;
 EF6E  B9 0025			; Output:
 EF71				;	AH = printer status, see AH = 2
 EF71  A1 006C R		;
 EF74				;----------------------------------------------------------------------------;
 EF74  F6 06 003E R 80		; 765	    |			- LCX		unused
 EF79  75 0F			;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK
				;     3   |			- LCDR	1 = printer reads output,  (pin 17)
 EF7B  F4			;      2  |			- LCINI	0 = initialize printer,  (pin 16)
				;       1 |			- LCLF	1 = auto line feed,  (pin 14)
				;        0|			- LCOUT	1 = output data to printer,  (pin 1)
				; PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1
 EF7C  3B 06 006C R		;----------------------------------------------------------------------------;
 EF80  74 F2			INT_17_0:
 EF82  E2 ED				OUT	DX, AL			; write the character to data port
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 147 - 1


 EF84  80 0D 80				INC	DX				; DX to status port
 EF87  F9			INT_17_0_TIMEOUT_LOOP:
 EF88  EB 05				XOR	DI, DI			; set abitrary timeout counter
 EF8A				INT_17_0_BUSY_LOOP:
 EF8A  80 26 003E R 7F			IN	AL, DX			; read status port
 EF8F					TEST	AL, MASK LPBZ 		; printer busy?
 EF8F  59				JNZ	INT_17_0_OK			; if not, toggle strobe pin and exit
 EF90  58				DEC	DI
 EF91  C3				JNZ	INT_17_0_BUSY_LOOP
 EF92					LOOP	INT_17_0_TIMEOUT_LOOP 	; loop BDA/LPT timeout value
					OR	AL, MASK LPTO		; printer timed out - set flag
					JMP	SHORT INT_17_2_STATUS_2	; exit with status in AL
				INT_17_0_OK:
					MOV	AL, MASK LCDR OR MASK LCINI OR MASK LCOUT ; /strobe pin HIGH
					INC	DX 				; DX = control port
					PUSH	DX				; I/O delay
					OUT	DX, AL
					POP	DX				; I/O delay
					MOV	AL, MASK LCDR OR MASK LCINI	; /strobe pin LOW
					OUT	DX, AL
					DEC	DX 				; reset to data port
 EF92					DEC	DX				; and fall through to status
 EF92  51			
 EF93  E8 FEA1			;----------------------------------------------------------------------------;
 EF96  8A CA			; AH = 2 - Read printer port status
 EF98  80 E1 03			;----------------------------------------------------------------------------;
 EF9B  B0 01			; Return status of specified printer port
 EF9D  D2 E0			;
 EF9F  84 06 003E R		; Input:
 EFA3  75 1E			;	AH = 1 (not 2)
 EFA5  8A E8			;	DX = LPT data port (278, 378, 3BC)
 EFA7  B0 07			;
 EFA9  E8 FED5			; Output:
 EFAC  72 15			;	AH = status:
 EFAE  8A C1			;
 EFB0  E8 FECE			;		|7|6|5|4|3|2|1|0|  Printer status bits
				;		 | | | | | | | `---- time out		(always 0)
 EFB3  E8 FF0C			;		 | | | | | `------- unused
 EFB6  72 0B			;		 | | | | `-------- I/O error		Pin 15
 EFB8  34 60			;		 | | | `--------- selected		Pin 13
 EFBA  24 60			;		 | | `---------- out of paper		Pin 12
 EFBC  F9			;		 | `----------- acknowledge		Pin 10
 EFBD  74 04			;		 `------------ not busy			/Pin 11
 EFBF  08 2E 003E R		;
 EFC3				; PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1
 EFC3				;----------------------------------------------------------------------------;
 EFC3  59			INT_17_2:
 EFC4  C3				INC	DX 				; DX to status port
 EFC5				INT_17_2_STATUS:
					IN	AL, DX			; AL = status
 EFC5					AND	AL, NOT (MASK LPX OR MASK LPTO)	; mask time-out pins
				INT_17_2_STATUS_2:
					XOR	AL, MASK LPACK OR MASK LPIO ; acknowledge and error are active low
					MOV	CH, AL			; save status to CH so AL can be restored
				INT_17_DONE:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 148 - 1


					POP	AX				; restore AL
 EFC5			     1			LOCAL LBL
			     1	
 = 0002			     1	BYTES_HERE_INT_1E = INT_1E-$
			     1	
			     1			IFDEF BYTES_HERE_INT_1E
			     1			IF2
			     1			IF BYTES_HERE_INT_1E LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_1E (BYTES_HERE_INT_1E)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					MOV	AH, CH			; AH = status
					POP	CX
					POP	DI
					POP	DX
				INT_17_IRET:
					IRET
				
				;----------------------------------------------------------------------------;
				; AH = 1 - Initialize printer port
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0 (not 1)
				;	DX = LPT data port (278, 378, 3BC)
				;
				; Output:
				;	AH = status, see AH = 2
				;----------------------------------------------------------------------------;
				INT_17_1:
					MOV	AL, MASK LCDR		; printer reads output = 1
					INC	DX
					INC	DX				; DX = control port
					OUT	DX, AL			; send to control port
					MOV	CH, HIGH 800H		; delay 800H-ish loops
					IO_DELAY 				; wait, then CX = 0
					OR	AL, MASK LCINI		; initialize printer = 1
					OUT	DX, AL			; send to control port
 EFC7 CF 02 25 02 08 2A			DEC	DX				; DX = status port
       FF 50 F6 19 04
					JMP	SHORT INT_17_2_STATUS	; small delay, read status and return
				INT_17 ENDP
				
				CRLF_SHOW_CURSOR PROC
				;----------------------------------------------------------------------------;
				; CRLF then show cursor display (this exists to utilize the free bytes here)
				;----------------------------------------------------------------------------;
					CALL	CRLF
				
				;----------------------------------------------------------------------------;
				; Show cursor display - restores saved cursor in CURSOR_DEFAULT
				;----------------------------------------------------------------------------;
				; Input:
				; 	DS = BDA
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 149 - 1


				; Clobbers CX
				;----------------------------------------------------------------------------;
				SHOW_CURSOR PROC
						ASSUME DS:_BDA
					MOV	CX, CURSOR_DEFAULT	; reset to original
					JMP	SHORT SET_CURSOR
				
				;----------------------------------------------------------------------------;
				; Hide cursor display
				;----------------------------------------------------------------------------;
 EFD2				; Clobbers CX
				;----------------------------------------------------------------------------;
 EFD2  FB			HIDE_CURSOR PROC
 EFD3  83 FA 02				MOV	CX, 2000H			; hide cursor
 EFD6  77 4A			
				;----------------------------------------------------------------------------;
			     1				IFNB <DX>			; exit if last reg
 EFD8  52		     1		PUSH	DX 					; push register and repeat
			     1		PUSHX	DI, CX, AX, DS, , , 
			     2				IFNB <DI>			; exit if last reg
 EFD9  57		     2		PUSH	DI 					; push register and repeat
			     2		PUSHX	CX, AX, DS, , , , 
			     3				IFNB <CX>			; exit if last reg
 EFDA  51		     3		PUSH	CX 					; push register and repeat
			     3		PUSHX	AX, DS, , , , , 
			     4				IFNB <AX>			; exit if last reg
 EFDB  50		     4		PUSH	AX 					; push register and repeat
			     4		PUSHX	DS, , , , , , 
			     5				IFNB <DS>			; exit if last reg
 EFDC  1E		     5		PUSH	DS 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		PUSH	 					; push register and repeat
			     6		PUSHX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 EFDD  B9 ---- R		; Set Video Cursor
 EFE0  8E D9			;----------------------------------------------------------------------------;
 EFE2  8B FA			SET_CURSOR PROC
 EFE4  8A 4D 78				PUSH	AX
 EFE7  D1 E7				MOV	AH, 1
 EFE9  8B 55 08				INT	10H
 EFEC  1F				POP	AX
 EFED  85 D2				RET
 EFEF  74 2B			SET_CURSOR ENDP
 EFF1  FE CC			
 EFF3  74 2E			HIDE_CURSOR ENDP
 EFF5  7F 1D			SHOW_CURSOR ENDP
				CRLF_SHOW_CURSOR ENDP
				
				;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 150 - 1


				; 0 BYTES HERE
				;
				BYTES_HERE	INT_10_JMP
				
				;----------------------------------------------------------------------------;
				; INT 10h - Function Jump Table
				;----------------------------------------------------------------------------;
						ORG 0F045H
				INT_10_JMP LABEL WORD
					DW	OFFSET INT_10_0		; AH = 0 - Set video mode
					DW	OFFSET INT_10_1		; AH = 1 - Set cursor type
					DW	OFFSET INT_10_2		; AH = 2 - Set cursor position
					DW	OFFSET INT_10_3		; AH = 3 - Read cursor position
					DW	OFFSET INT_10_RET		; AH = 4 - Read light pen (not supported)
					DW	OFFSET INT_10_5		; AH = 5 - Select active display page
					DW	OFFSET INT_10_6		; AH = 6 - Scroll active page up
					DW	OFFSET INT_10_7		; AH = 7 - Scroll active page down
					DW	OFFSET INT_10_8		; AH = 8 - Read character and attribute at cursor
					DW	OFFSET INT_10_9		; AH = 9 - Write character and attribute at cursor
					DW	OFFSET INT_10_A		; AH = A - Write character at current cursor
					DW	OFFSET INT_10_B		; AH = B - Set color palette
					DW	OFFSET INT_10_C		; AH = C - Write graphics pixel at coordinate
 EFF7					DW	OFFSET INT_10_D		; AH = D - Read graphics pixel at coordinate
 EFF7  EE				DW	OFFSET INT_10_E		; AH = E - Write text in teletype mode
 EFF8  42				DW	OFFSET INT_10_F		; AH = F - Get current video state
 EFF9				
 EFF9  33 FF			;----------------------------------------------------------------------------;
 EFFB				; INT 10h - Video BIOS Services
 EFFB  EC			;----------------------------------------------------------------------------;
 EFFC  A8 80			; BIOS Interface to CGA/MDA display adapters.
 EFFE  75 09			;----------------------------------------------------------------------------;
 F000  4F			; References and Info Sources:
 F001  75 F8			;  "PC System Programming", Tischer
 F003  E2 F4			;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton
 F005  0C 01			;  https://github.com/joncampbell123/dosbox-x/blob/master/src/ints/int10_char.cpp
 F007  EB 0F			;  https://github.com/joncampbell123/dosbox-x/issues/256
 F009				;  https://www.seasip.info/VintagePC/cga.html
 F009  B0 0D			;  https://www.reenigne.org/blog/crtc-emulation-for-mess/
 F00B  42			;  (many other posts and articles...)
 F00C  52			;
 F00D  EE			; Thx to @Raffzahn for "clean room" specs for various display routines.
 F00E  5A			;----------------------------------------------------------------------------;
 F00F  B0 0C					ORG 0F065H
 F011  EE			INT_10 PROC
 F012  4A				STI					; enable interrupts
 F013  4A				CMP	AH, 0FH			; function > 15?
					JA	INT_10_IRET			; exit if function not valid
					PUSHX	ES, DS, DI			; always preserve these registers
					CLD					; string instructions forward direction
					MOV	DI, SEG _BDA		; DS = BDA segment
					MOV	DS, DI
					MOV	DI, AX			; save AX
					XCHG	AH, AL			; AL = function, AH = video mode
					SHL	AL, 1				; word align index
					CBW					; AX = jump index
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 151 - 1


					XCHG	AX, DI			; restore AX, DI = jump offset
					CALL	CS:INT_10_JMP[DI]
				INT_10_DONE:
					POPX	DI, DS, ES
				INT_10_IRET:
					IRET
				
				;----------------------------------------------------------------------------;
				; Is Current video mode text or GFX?
				;----------------------------------------------------------------------------;
				; Input:
				; 	DS = BDA (040h)
				; Output:
				;	AL = current video mode
				; 	ZF = 0 if CGA GFX (modes 4-6)
 F014				;	ZF = 1 if CGA/MDA Text (modes 0-3 and 7)
 F014  42			;	CF = 1 if MDA
 F015				;----------------------------------------------------------------------------;
 F015  EC			INT_10_IS_TXT PROC
 F016  24 F8				MOV	AL, VID_MODE
 F018					CMP	AL, 7				; ZF if mode MDA
 F018  34 48				CMC					; CF if MDA
 F01A  8A E8				JZ	INT_10_IS_TXT_DONE
 F01C					TEST	AL, 4 AND 5 AND 6		; NZ if GFX modes 4,5,6?
 F01C  58			INT_10_IS_TXT_DONE:
 F01D  8A E5				RET
 F01F  59			INT_10_IS_TXT ENDP
 F020  5F			
 F021  5A			;----------------------------------------------------------------------------;
 F022				; Is Current video CGA 80 col?
 F022  CF			;----------------------------------------------------------------------------;
				; Output:
				;	ZF = 1 if mode is 2 or 3
				;	ZF = 0 all others
				;----------------------------------------------------------------------------;
				INT_10_IS_CGA80 PROC
					PUSH	AX
					PUSH	DS
					MOV	AX, SEG _BDA
					MOV	DS, AX
					MOV	AL, VID_MODE
					CMP	AL, 2				; is mode 2?
 F023					JZ	INT_10_IS_CGA80_DONE
 F023  B0 08				CMP	AL, 3				; is mode 3?
 F025  42			INT_10_IS_CGA80_DONE:
 F026  42				POP	DS
 F027  EE				POP	AX
 F028  B5 08				RET
				INT_10_IS_CGA80 ENDP
			     1			LOCAL _DONE
 F02A			     1	??0024:
 F02A  E2 FE		     1		LOOP	??0024					; long delay for I/O
 F02C  0C 04			
 F02E  EE			;
 F02F  4A			; 1 BYTE HERE
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 152 - 1


 F030  EB E3			;
 F032				BYTES_HERE	INT_1D
				
 F032				;----------------------------------------------------------------------------;
				; INT 1D - Video mode register value table 
				;----------------------------------------------------------------------------;
				; https://stanislavs.org/helppc/6845.html
 F032  E8 06E1			;----------------------------------------------------------------------------;
						ORG 0F0A4H					; 116 bytes
				INT_1D PROC
				
				; 40x25 CGA text
				INT_1D_40		CRTC	<38H,28H,2DH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H>
				O_INT_1D_40		EQU	INT_1D_40-INT_1D		; 40x25 mode data offset
				
				; 80x25 CGA text
 F035				INT_1D_80		CRTC	<71H,50H,5AH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H>
				O_INT_1D_80		EQU	INT_1D_80-INT_1D		; 80x25 mode data offset
 F035  8B 0E 00E8 R		
 F039  EB 03			; 320x200 CGA graphics
				INT_1D_GFX		CRTC	<38H,28H,2DH,0AH,7FH,06H,64H,70H,02H,01H,06H,07H>
				O_INT_1D_GFX	EQU	INT_1D_GFX-INT_1D		; 320x200 mode data offset
				
				; MDA text
				INT_1D_MDA		CRTC	<61H,50H,52H,0FH,19H,06H,19H,19H,02H,0DH,0BH,0CH>
				O_INT_1D_MDA	EQU	INT_1D_MDA-INT_1D		; MDA mode data offset
 F03B				
 F03B  B9 2000			INT_1D ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,0 - Set video mode
				;----------------------------------------------------------------------------;
 F03E				; AL = video mode:
 F03E  50			;   0000  00  M 40x25 B/W text (CGA)
 F03F  B4 01			;   0001  01  C 40x25 16 color text (CGA)
 F041  CD 10			;   0010  02  M 80x25 16 shades of gray text (CGA)
 F043  58			;   0011  03  C 80x25 16 color text (CGA)
 F044  C3			;   0100  04  C 320x200 4 color graphics (CGA)
 F045				;   0101  05  C 320x200 4 color graphics (CGA)
				;   0110  06  M 640x200 B/W graphics (CGA)
 F045				;   0111  07  M 80x25 Monochrome text (MDA,HERC)
 F045				;
 F045				; AX clobbered
				;----------------------------------------------------------------------------;
				; Things you must do:
				; 	1. Check that the new video mode is valid: 0-7. For MDA, the mode
				;		will always be 7. If CGA mode > 6, reset in current mode.
				;	2. Clear the video BDA block data
 F045			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_10_JMP = INT_10_JMP-$
			     1	
			     1			IFDEF BYTES_HERE_INT_10_JMP
			     1			IF2
			     1			IF BYTES_HERE_INT_10_JMP LT 0
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 153 - 1


			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_10_JMP (BYTES_HERE_INT_10_JMP)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				;	3. Determine the type of adapter from motherboard switches
				;	4. Disable the adapter to reprogram it.
				;	5. Based on new input mode and MB switches, determine:
				;		- Adapter base I/O port (03B4H for MDA, 03D4H for CGA)
				;		- RAM base segment (0B000H for MDA, 0B800H for CGA)
 F045				;		- RAM size (16K for CGA gfx, 4K for 80x25 text, 2K for 40x25 text)
 F045  F0E4 R			;		- RAM fill data (0 for gfx, space char with attribute 7 for text)
 F047  F19F R			;		- Corresponding entry from INT 1DH CRTD table for new video mode
 F049  F1B5 R			;		- Corresponding mode byte from CRT_MODE table
 F04B  F1FB R			;	6. Clear regen RAM by filling with data from above
 F04D  F19E R			;	7. Write data from CRTD table to adapter registers to set mode
 F04F  F20C R			;	8. Write CGA palette register
 F051  F234 R			;	9. Enable adapter with new mode byte
 F053  F233 R			;
 F055  F347 R			;----------------------------------------------------------------------------;
 F057  F3E8 R			INT_10_0 PROC
 F059  F3E8 R				PUSHX	BX, DX, BP, CX, SI
 F05B  F4D2 R				MOV	DI, OFFSET VID_MODE		; start with VID_MODE (49H)
 F05D  F4FD R				CMP	AL, 7					; is new video mode > 7?
 F05F  F524 R				JB	INT_10_0_1				; if not, is valid mode
 F061  F576 R				MOV	AL, [DI]				; otherwise use current mode
 F063  F5E5 R			INT_10_0_1:
					XCHG	AX, BX				; BL = new video mode
				
				;----------------------------------------------------------------------------;
				; Clear all video data in BDA
				;
					XOR	AX, AX
					MOV	CX, L_VID_BDA / 2			; Video data in BDA (in WORDs)
					PUSH	DS
					POP	ES					; ES = BDA
					REP	STOSW					; clear data, set CX = 0
				
				;----------------------------------------------------------------------------;
				; Determine video adapter type and new mode and re-program 6845
				;
					MOV	AL, BYTE PTR EQUIP_FLAGS	; get BDA equipment flags
					XOR	AL, MASK VIDM			; isolate video switches
					AND	AL, 11B SHL VIDM			; is switch MDA (ON-ON)?
					MOV	AL, 0					; 0 = CGA disable video signal
 F065					MOV	SI, O_INT_1D_80			; SI = CGA 80 CRTD offset
 F065  FB				MOV	BH, VID_DEF_COLS			; default 80 columns
 F066  80 FC 0F				MOV	CH, HIGH OFFSET MDA_MEM		; Total MDA video memory = 1000H (4K)
 F069  77 19				MOV	AH, CH				; MDA/CGA 80x25 page size = 1000H (4K)
					MOV	DI, DBW <VID_ATTR, VID_SP>	; fill memory with attr 7 and space
			     1				IFNB <ES>			; exit if last reg
 F06B  06		     1		PUSH	ES 					; push register and repeat
			     1		PUSHX	DS, DI, , , , , 
			     2				IFNB <DS>			; exit if last reg
 F06C  1E		     2		PUSH	DS 					; push register and repeat
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 154 - 1


			     2		PUSHX	DI, , , , , , 
			     3				IFNB <DI>			; exit if last reg
 F06D  57		     3		PUSH	DI 					; push register and repeat
			     3		PUSHX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		PUSH	 					; push register and repeat
			     4		PUSHX	, , , , , , 
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F06E  FC				JNZ	INT_10_0_IS_CGA
 F06F  BF ---- R			INC	AX					; 1 = MDA disable video signal value
 F072  8E DF				MOV	BP, SEG _MDA_MEM			; BP = MDA memory segment (0B000H)
 F074  8B F8				MOV	DX, MDA_CTRL			; MDA Mode Select Register (03B8H)
 F076  86 E0				MOV	BL, 7					; only valid MDA display mode is 7
 F078  D0 E0				MOV	SI, O_INT_1D_MDA			; SI = MDA CRTD offset
 F07A  98				JMP	SHORT INT_10_0_DETECT_DONE	; MDA mode selected, continue
 F07B  97			INT_10_0_IS_CGA:
 F07C  2E: FF 95 F045 R			MOV	CH, HIGH OFFSET CGA_MEM		; Total CGA video memory = 4000H (16K)
 F081					MOV	DX, CGA_CTRL			; CGA Mode Select Register (03D8H)
					MOV	BP, SEG _CGA_MEM			; BP = CGA memory segment (0B800H)
			     1				IFNB <DI>			; exit if last reg
 F081  5F		     1		POP	DI 					; pop register and repeat
			     1		POPX	DS, ES, , , , , 
			     2				IFNB <DS>			; exit if last reg
 F082  1F		     2		POP	DS 					; pop register and repeat
			     2		POPX	ES, , , , , , 
			     3				IFNB <ES>			; exit if last reg
 F083  07		     3		POP	ES 					; pop register and repeat
			     3		POPX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		POP	 					; pop register and repeat
			     4		POPX	, , , , , , 
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F084					TEST	BL, 0100B				; text or gfx mode?
 F084  CF				JZ	INT_10_0_IS_CGA_TEXT		; jump if text
				INT_10_0_IS_CGA_GFX:
					MOV	SI, O_INT_1D_GFX			; SI = CGA GFX CRTD offset
					MOV	AH, HIGH OFFSET CGA_MEM		; CGA gfx page size = 4000H (16K)
					XOR	DI, DI				; DI = memory fill 0's
					TEST	BL, 0010B				; is 80 or 40 col text?
					JNZ	INT_10_0_DETECT_DONE		; jump if 80
					JMP	SHORT INT_10_0_IS_40_COL	; else set 40 columns
				INT_10_0_IS_CGA_TEXT:
					TEST	BL, 0010B				; is 80 or 40 col text?
					JNZ	INT_10_0_DETECT_DONE		; jump if 80
					MOV	AH, HIGH OFFSET CGA_MEM_40	; CGA 40x25 page size = 800H (2K)
					XOR	SI, SI				; SI = CGA 40 CRTD offset (00H)
 F085				INT_10_0_IS_40_COL:
 F085  A0 0049 R			SHR	BH, 1					; BH = 40 columns
 F088  3C 07			INT_10_0_DETECT_DONE:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 155 - 1


 F08A  F5				MOV	WORD PTR VID_MODE, BX		; write BDA video mode and columns
 F08B  74 02				MOV	ES, BP				; ES = video memory segment
 F08D  A8 04				MOV	VID_MEM_SEG, BP			; write video segment for later
 F08F					OUT	DX, AL				; disable video
 F08F  C3				MOV	BYTE PTR VID_BUF_SZ[1], AH	; write BDA video page size
 F090					SUB	DL, 4					; DX = 6845 index register port
					MOV	VID_PORT, DX			; write BDA video I/O port
					MOV	BP, BX				; save video mode to BP
				
				;----------------------------------------------------------------------------;
				; Fill video regen/memory
				;
					XCHG	AX, DI				; AX = fill byte
					XOR	DI, DI				; start at offset 0
 F090					SHR	CX, 1					; WORD size counter
 F090  50				REP	STOSW
 F091  1E			
 F092  B8 ---- R		;----------------------------------------------------------------------------;
 F095  8E D8			; Write CRTC data to 6845 registers
 F097  A0 0049 R		;
 F09A  3C 02				PUSH	DS					; save DS = BDA
 F09C  74 02				MOV	AX, CX				; AX = 0
 F09E  3C 03				MOV	VID_PAGE, AL			; video page 1 = 0
 F0A0					MOV	DS, AX				; DS = IVT
 F0A0  1F						ASSUME DS:_IVT
 F0A1  58				LDS	BX, IVT_1D				; DS:BX = BIOS:INT_1D
 F0A2  C3				MOV	DI, WORD PTR [BX][SI].CSL	; DI = cursor type (start and end)
 F0A3					MOV	CL, SIZE CRTC			; size of CRTC data
				INT_10_0_CRTC_LOOP:
					MOV	AH, [BX][SI]			; AH = next byte from table
					OUT	DX, AX				; write AH to register index AL
					INC	AX					; next register index
					INC	SI					; next byte in table
 F0A3			     1			LOCAL LBL
			     1	
 = 0001			     1	BYTES_HERE_INT_1D = INT_1D-$
			     1	
			     1			IFDEF BYTES_HERE_INT_1D
			     1			IF2
			     1			IF BYTES_HERE_INT_1D LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_1D (BYTES_HERE_INT_1D)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					LOOP	INT_10_0_CRTC_LOOP
				
				;----------------------------------------------------------------------------;
				; Send mode and color bytes to 6845
				;
					XCHG	AX, BP				; AL = new video mode
					CMP	AL, 6					; is CGA color gfx mode?
 F0A4					MOV	AH, VID_CSGFX <>			; use for 640x200 mode 6
					JE	INT_10_0_COLOR_BYTE		; jump if so
					MOV	AH, VID_CSTXT <>			; otherwise use for text/low gfx
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 156 - 1


 F0A4 38 28 2D 0A 1F 06		INT_10_0_COLOR_BYTE:
       19 1C 02 07 06 07
       00 00 00 00
 = 0000					MOV	BX, OFFSET CRT_MODE
					XLAT						; AL = control byte data
							ASSUME DS:_BDA
 F0B4 71 50 5A 0A 1F 06			POP	DS					; DS = BDA
       19 1C 02 07 06 07
       00 00 00 00
 = 0010					ADD	DL, 4					; DX = control reg
					MOV	WORD PTR VID_MODE_REG, AX	; write mode and color to BDA
					OUT	DX, AX				; write mode and color to 6845
 F0C4 38 28 2D 0A 7F 06			XCHG	AX, DI				; AX = cursor bytes from CRTC table
       64 70 02 01 06 07
       00 00 00 00
 = 0020					XCHG	AH, AL				; convert endian for cursor bytes
					MOV	VID_CURS_TYPE, AX			; write cursor type to BDA
					POPX	SI, CX, BP, DX, BX
 F0D4 61 50 52 0F 19 06		INT_10_RET:
       19 19 02 0D 0B 0C
       00 00 00 00
 = 0030					RET
				INT_10_0 ENDP
 F0E4				
				;----------------------------------------------------------------------------;
				; INT 10,1 - Set cursor type
				;----------------------------------------------------------------------------;
				; Input:
				;	CH = cursor starting scan line (cursor top) (low order 5 bits)
				;	CL = cursor ending scan line (cursor bottom) (low order 5 bits)
				;----------------------------------------------------------------------------;
				INT_10_1 PROC
					PUSH	DX
					XCHG	AX, DI			; save AX
					MOV	VID_CURS_TYPE, CX		; write new cursor to BDA
					MOV	AL, CRTC.CSL		; AL = cursor start index (scan line)
					MOV	AH, CH			; CH = cursor starting scan line (top)
					MOV	DX, VID_PORT		; DX = 6845 index register port
					OUT	DX, AX			; write AH to 6845 reg index in AL
					INC	AX				; AL = cursor end index (scan line)
					MOV	AH, CL			; CL = cursor ending scan line (bottom)
					OUT	DX, AX			; write AH to 6845 reg index in AL
					XCHG	AX, DI			; restore AX
					POP	DX
					RET
				INT_10_1 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,2 - Set cursor position
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 02
				;	BH = page number (0 for graphics modes)
				;	DH = row
				;	DL = column
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 157 - 1


				;----------------------------------------------------------------------------;	
				; Things you must do:
				;	1. Update the BDA Cursor position (50H-5FH) with the new video page
				;		with the new cursor position
 F0E4				;	2. Calculate the memory address of the cursor's position, and set it
				;		to the 6845 Cursor address register
			     1				IFNB <BX>			; exit if last reg
 F0E4  53		     1		PUSH	BX 					; push register and repeat
			     1		PUSHX	DX, BP, CX, SI, , , 
			     2				IFNB <DX>			; exit if last reg
 F0E5  52		     2		PUSH	DX 					; push register and repeat
			     2		PUSHX	BP, CX, SI, , , , 
			     3				IFNB <BP>			; exit if last reg
 F0E6  55		     3		PUSH	BP 					; push register and repeat
			     3		PUSHX	CX, SI, , , , , 
			     4				IFNB <CX>			; exit if last reg
 F0E7  51		     4		PUSH	CX 					; push register and repeat
			     4		PUSHX	SI, , , , , , 
			     5				IFNB <SI>			; exit if last reg
 F0E8  56		     5		PUSH	SI 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		PUSH	 					; push register and repeat
			     6		PUSHX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F0E9  BF 0049 R		;
 F0EC  3C 07			; Things you should do:
 F0EE  72 02			;	- Make sure page number is valid for adapter type and current mode
 F0F0  8A 05			;
 F0F2				;----------------------------------------------------------------------------;	
 F0F2  93			INT_10_2 PROC
					PUSH	AX
					MOV	AL, BH			; AL = new video page
					CMP	AL, 7				; is new video page > 7?
					JA	INT_10_2_DONE		; if so, not valid, return
 F0F3  33 C0			
 F0F5  B9 000F			;----------------------------------------------------------------------------;
 F0F8  1E			; 1. Set cursor position in BDA
 F0F9  07			;
 F0FA  F3/ AB				CBW					; AX = page number
					XCHG	AX, DI			; DI = page number
					SHL	DI, 1				; word align index
					MOV	VID_CURS_POS[DI], DX	; write to page cursor position in BDA
					CMP	VID_PAGE, BH		; is this the current page?
 F0FC  A0 0010 R			JNZ	INT_10_2_DONE		; if not, do nothing and exit
 F0FF  34 30				PUSH	BX
 F101  24 30				PUSH	DX
 F103  B0 00			
 F105  BE 0010			;----------------------------------------------------------------------------;
 F108  B7 50			; 2. Set cursor position in 6845 Cursor address register
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 158 - 1


 F10A  B5 34 R			;
 F10C  8A E5			INT_10_SET_CUR_OFFSET:
 F10E  BF 0720				MOV	AL, BYTE PTR VID_COLS	; AL = screen cols
 F111  75 0E				MUL	DH				; AX = row * screen cols
 F113  40				XOR	DH, DH			; DX = col
 F114  BD ---- R			ADD	AX, DX			; AX = ( row * screen cols ) + col
 F117  BA 03B8									; AX = byte offset for cursor position to page memor
				y
 F11A  B3 07				MOV	BX, VID_SEG
 F11C  BE 0030				SHR	BX, 1				; byte align
 F11F  EB 26				ADD	BX, AX
 F121					MOV	AL, CA_H			; 6845 Cursor address high reg (0EH)
 F121  B5 64 R				MOV	AH, BH			; Cursor address (MSB)
 F123  BA 03D8				MOV	DX, VID_PORT
 F126  BD ---- R			OUT	DX, AX			; write AH to index AL
 F129  F6 C3 04				INC	AX				; AL = CA_L (0FH)
 F12C  74 0E				MOV	AH, BL			; Cursor address (LSB)
 F12E					OUT	DX, AX			; write AH to index AL
 F12E  BE 0020				POP	DX
 F131  B4 64 R				POP	BX
 F133  33 FF			INT_10_2_DONE:
 F135  F6 C3 02				POP	AX
 F138  75 0D				RET
 F13A  EB 09			INT_10_2 ENDP
 F13C				
 F13C  F6 C3 02			;----------------------------------------------------------------------------;
 F13F  75 06			; INT 10,3 - Read cursor position and Size for current page
 F141  B4 2C R			;----------------------------------------------------------------------------;
 F143  33 F6			; Output:
 F145				;	ZF = 0 and BH = 0 if MDA/CGA GFX
 F145  D0 EF			;  	ZF = 1 and BH = VID_PAGE if CGA text
 F147				;----------------------------------------------------------------------------;
 F147  89 1E 0049 R		INT_10_3_CUR_PAGE PROC
 F14B  8E C5				XOR	BH, BH			; BH = 0
 F14D  89 2E 00EA R			TEST	VID_MODE, 0100B		; is >= 4?
 F151  EE				JNZ	INT_10_3			; jump if not MDA or GFX
 F152  88 26 004D R			MOV	BH, VID_PAGE		; otherwise BH = VID_PAGE
 F156  80 EA 04			
 F159  89 16 0063 R		;----------------------------------------------------------------------------;
 F15D  8B EB			; INT 10,3 - Read cursor position and Size
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 03
				;	BH = video page
 F15F  97			; Output:
 F160  33 FF			;	CH = cursor starting scan line (low order 5 bits)
 F162  D1 E9			;	CL = cursor ending scan line (low order 5 bits)
 F164  F3/ AB			;	DH = row
				;	DL = column
				;----------------------------------------------------------------------------;
				INT_10_3 PROC
					PUSH	AX
 F166  1E				MOV	AL, BH			; AL = video page
 F167  8B C1				CBW					; AX = video page
 F169  A2 0062 R			XCHG	AX, DI			; DI = video page
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 159 - 1


 F16C  8E D8				SHL	DI, 1				; word align index
					MOV	DX, VID_CURS_POS[DI]
 F16E  C5 1E 0074 R			MOV	CX, VID_CURS_TYPE
 F172  8B 78 0A				POP	AX
 F175  B1 10				RET
 F177				INT_10_3 ENDP
 F177  8A 20			INT_10_3_CUR_PAGE ENDP
 F179  EF			
 F17A  40			;----------------------------------------------------------------------------;
 F17B  46			; INT 10,5 - Select active display page
 F17C  E2 F9			;----------------------------------------------------------------------------;
				; Input:
				;	AH = 05
				;	AL = new page number
				;----------------------------------------------------------------------------;
 F17E  95			; Things you must do:
 F17F  3C 06			;	1. Write the new page number to BDA (40:62H)
 F181  B4 3F			;	2. Calculate new regen buffer page offset and update BDA and
 F183  74 02			;		6845 Start address register
 F185  B4 30			;	3. Calculate the memory address of the cursor's position, and set it
 F187				;		to the 6845 Cursor address register
 F187  BB F60F R		;
 F18A  D7			; Things you should do:
				;	- Bounds check that page number is valid for adapter and current mode?
 F18B  1F			;----------------------------------------------------------------------------;
 F18C  80 C2 04			INT_10_5 PROC
 F18F  A3 0065 R			PUSH	AX
 F192  EF				PUSH	BX
 F193  97				PUSH	DX
 F194  86 E0			
 F196  A3 0060 R		;----------------------------------------------------------------------------;
				; 1. Write the new page number to BDA (40:62H).
			     1				IFNB <SI>			; exit if last reg
 F199  5E		     1		POP	SI 					; pop register and repeat
			     1		POPX	CX, BP, DX, BX, , , 
			     2				IFNB <CX>			; exit if last reg
 F19A  59		     2		POP	CX 					; pop register and repeat
			     2		POPX	BP, DX, BX, , , , 
			     3				IFNB <BP>			; exit if last reg
 F19B  5D		     3		POP	BP 					; pop register and repeat
			     3		POPX	DX, BX, , , , , 
			     4				IFNB <DX>			; exit if last reg
 F19C  5A		     4		POP	DX 					; pop register and repeat
			     4		POPX	BX, , , , , , 
			     5				IFNB <BX>			; exit if last reg
 F19D  5B		     5		POP	BX 					; pop register and repeat
			     5		POPX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		POP	 					; pop register and repeat
			     6		POPX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 160 - 1


			     1				ENDIF
 F19E				;
 F19E  C3				MOV	VID_PAGE, AL
 F19F					CBW					; AX = video page
					XCHG	AX, DI			; DI = page number (save for later)
				
				;----------------------------------------------------------------------------;
				; 2. Calculate new regen buffer page offset and update BDA and 
				;	6845 Start address register
				;
					MOV	AX, VID_BUF_SZ		; AX = Size of video regen buffer (bytes)
					MUL	DI				; AX = offset of start of page regen buffer
 F19F					MOV	VID_SEG, AX			; write to BDA
 F19F  52				SHR	AX, 1				; video segment byte-indexed
 F1A0  97				MOV	BL, AL			; AH = Start address (MSB), BL = (LSB)
 F1A1  89 0E 0060 R			MOV	AL, CRTC.SA_H		; 6845 Start address register
 F1A5  B0 0A				MOV	DX, VID_PORT		; 6845 I/O port address
 F1A7  8A E5				OUT	DX, AX			; write AH (MSB) to index AL
 F1A9  8B 16 0063 R			INC	AX				; AL = 0DH
 F1AD  EF				MOV	AH, BL			; AH = Start address (LSB)
 F1AE  40				OUT	DX, AX			; write AH (LSB) to index AL
 F1AF  8A E1			
 F1B1  EF			;----------------------------------------------------------------------------;
 F1B2  97			; 3. Set cursor position in 6845 Cursor address register
 F1B3  5A			;
 F1B4  C3				SHL	DI, 1				; get the current cursor position
 F1B5					MOV	DX, VID_CURS_POS[DI]	; DH/DL = cursor position on current page
					JMP	INT_10_SET_CUR_OFFSET	; write it to the new page's offset on 6845
				
				INT_10_5 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,7 - Scroll active page down
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = number of lines to scroll, previous lines are
				;	     blanked, if 0 or AL > screen size, window is blanked
				;	BH = attribute to be used on blank line
				;	CH = row of upper left corner of scroll window
				;	CL = column of upper left corner of scroll window
				;	DH = row of lower right corner of scroll window
				;	DL = column of lower right corner of scroll window
				;----------------------------------------------------------------------------;
				;
				;   0000  00  M 40x25 B/W text (CGA)
				;   0001  01  C 40x25 16 color text (CGA)
				;   0010  02  M 80x25 16 shades of gray text (CGA)
 F1B5				;   0011  03  C 80x25 16 color text (CGA)
 F1B5  50			;   0100  04  C 320x200 4 color graphics (CGA)
 F1B6  8A C7			;   0101  05  C 320x200 4 color graphics (CGA)
 F1B8  3C 07			;   0110  06  M 640x200 B/W graphics (CGA)
 F1BA  77 30			;   0111  07  M 80x25 Monochrome text (MDA)
				;----------------------------------------------------------------------------;
				; Things you must do:
				; 	1. Calculate coordinates of existing rectangle and new rectangle.
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 161 - 1


				;	2. Convert to memory video RAM addresses
 F1BC  98			;	3. If CGA 80 col, disable video during video RAM operations
 F1BD  97			;	4. If rows to scroll > 0, copy each row, starting at the left column.
 F1BE  D1 E7			;	   If scroll up, start from the top of the overlapping area and copy
 F1C0  89 95 0050 R		;	   downward. If scroll down, start at the bottom and copy upward.
 F1C4  38 3E 0062 R		;	5. If rows to scroll > height of rectangle, fill the remaining rows
 F1C8  75 22			;	   with spaces.
 F1CA  53			;
 F1CB  52			;----------------------------------------------------------------------------;
				; NOTE: The original XT BIOS (and maybe clones) appear to have a bug where
				; if the lines to scroll (AL) is greater than the height of the rectangle
				; it will scroll incorrectly. This behavior has been preserved.
				;----------------------------------------------------------------------------;
 F1CC				INT_10_7 PROC
 F1CC  A0 004A R			STD					; Set direction flag
 F1CF  F6 E6			
 F1D1  32 F6			;----------------------------------------------------------------------------;
 F1D3  03 C2			; INT 10,6 - Scroll active page up
				;----------------------------------------------------------------------------;
 F1D5  8B 1E 004E R		; Input: same as INT 10,7 above
 F1D9  D1 EB			;----------------------------------------------------------------------------;
 F1DB  03 D8			INT_10_6 PROC
 F1DD  B0 0E				PUSHX	AX, BX, SI, BP		; call-preserve these registers
 F1DF  8A E7				MOV	SI, VID_MEM_SEG		; video/regen RAM segment (B800 or B000)
 F1E1  8B 16 0063 R			MOV	ES, SI
 F1E5  EF			
 F1E6  40			;----------------------------------------------------------------------------;
 F1E7  8A E3			; Register Check:
 F1E9  EF			;	AH = saved flags - ZF if scroll up
 F1EA  5A			;	AL = number of rows to scroll
 F1EB  5B			;	BH = attribute to be used on blank line
 F1EC				;	BL = scratch
 F1EC  58			;	CH = row of upper left corner of scroll window
 F1ED  C3			;	CL = column of upper left corner of scroll window
 F1EE				;	DH = row of lower right corner of scroll window
				;	DL = column of lower right corner of scroll window
				;
					CMP	AH, 6				; is scroll up?
					LAHF					; save ZF if scroll up
					MOV	BP, AX			; save original AL / AH flags
					MOV	DI, DX			; save original DX
					JNZ	INT_10_CHECK_BOUNDS	; jump if scroll down
				
 F1EE				;----------------------------------------------------------------------------;
 F1EE  32 FF			; On scroll up, the new rectangle to scroll is above the old one so start the
 F1F0  F6 06 0049 R 04		; bottom left of the new rectangle at the top left of the old one. This 
 F1F5  75 04			; will be later adjusted by the number of rows to scroll.
 F1F7  8A 3E 0062 R		;
					MOV	DX, CX			; if scroll up, DX becomes "top"
				
				;----------------------------------------------------------------------------;
				; Make sure lower right column does not exceed screen width
				;
				INT_10_CHECK_BOUNDS:
					MOV	AL, BYTE PTR VID_COLS	; AL = video mode columns
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 162 - 1


					CMP	DL, AL			; is rect right column > screen columns?
					JB	INT_10_BOUNDS_OK
					MOV	DL, AL			; number of screen columns (80 or 40)
					DEC	DX				; fixup for 0-based column index (0-79, etc)
				INT_10_BOUNDS_OK:
					MUL	DH				; AX = memory offset of col 0 of new bottom row
 F1FB					MOV	DH, AL			; save AL
 F1FB  50			
 F1FC  8A C7			;----------------------------------------------------------------------------;
 F1FE  98			; Is graphics mode?
 F1FF  97			;
 F200  D1 E7				CALL	INT_10_IS_TXT		; NZ if CGA GFX, ZR if CGA/MDA Text
 F202  8B 95 0050 R			MOV	AL, DH			; restore AL
 F206  8B 0E 0060 R			MOV	DH, 0				; DX = lower right column position
 F20A  58				PUSH	DS				; save BDA data SEG
 F20B  C3				JNZ	INT_10_SCR_GFX
 F20C				
 F20C				;----------------------------------------------------------------------------;
				; Scroll in text mode
				;----------------------------------------------------------------------------;
				; To calculate scroll memory offsets:
				;
				;  rect_height = rect_height + 1
				;  next_row = screen_cols - rect_width
				;
				;  if scroll down:
				; 	rect_height = - rect_height
				;	next_row = - next_row
				;
				;  new_top = old_top - rect_height
				;  new_bottom = old_bottom - rect_height
				;
				INT_10_SCR_TXT:
					ADD	DX, AX			; DX = byte offset of new bottom row and col
					SHL	DX, 1				; WORD-align memory offset
					ADD	DX, VID_SEG			; DX = memory offset bottom row/col in video page
 F20C					MOV	SI, DX			; SI = memory offset of new rect bottom (midpoint)
 F20C  50				XCHG	DI, DX			; DI = new rect bottom, DX = row/col pos.
 F20D  53				SUB	DX, CX			; DH = rect height (rows), DL = rect width (cols)
 F20E  52				MOV	CX, VID_COLS		; CL = current video mode cols (80 or 40), CH = 0
					MOV	AX, ES			; source and destination is video/regen RAM
					MOV	DS, AX
					MOV	AX, BP			; AL = # of rows to scroll
					SHL	CL, 1				; WORD-align bytes per full row (now 160 or 80)
 F20F  A2 0062 R			MUL	CL				; AX = size in WORDs of full rows to scroll
 F212  98				XCHG	AX, BP			; AL = # rows, AH = func, BP = WORD size of rect. rows
 F213  97				ADD	DX, 101H			; convert 0-based indexes to 1-based loop counters
					SAHF					; set ZF if scroll up
					MOV	AH, BH			; AH = fill attribute byte
					PUSHF					; save scroll direction flag (out of registers!)
					MOV	BX, CX			; BX = WORD size of one screen row (80 or 160)
					MOV	CL, DL			; CX = BYTE size of one rectangle row
 F214  A1 004C R			SUB	BX, CX			; BX = WORD offset btwn end of rect. col and start col
 F217  F7 E7				SUB	BX, CX			;  on next row (subtract twice to WORD align)
 F219  A3 004E R			POPF					; set ZF if scroll up
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 163 - 1


 F21C  D1 E8				JZ	INT_10_CGA_CHECK		; jump if scroll up
 F21E  8A D8			
 F220  B0 0C			;----------------------------------------------------------------------------;
 F222  8B 16 0063 R		; On scroll down, subtract (instead of add) the difference between the end 
 F226  EF			; of the current rectangle and the next row start.
 F227  40			;
 F228  8A E3			; The start address of source rectangle will also be above (instead of below)
 F22A  EF			; the destination rectangle.
				;
				; These offsets are then added the top/bottom of current rectangle to get the
				; new rectangle coords, either above or below depending on scroll direction.
				;
 F22B  D1 E7				NEG	BX				; BX = - WORD size offset to start of next row
 F22D  8B 95 0050 R			NEG	BP				; BP = - WORD size of region of rows to scroll
 F231  EB 99			
				INT_10_CGA_CHECK:
 F233								IF CGA_SNOW_REMOVE GT 0
				;----------------------------------------------------------------------------;
				; If CGA, blank video during memory writes to avoid "CGA snow" effect
				;
					CALL	INT_10_IS_CGA80		; ZF if CGA 80, NZ if not
					PUSHF					; save flags to use same result at end
					JNZ	INT_10_6_CHECK_CLS	; jump if not mode 2 or 3 CGA 80 col text
				
				;----------------------------------------------------------------------------;
				; Blank CRTC video during memory writes to avoid "CGA snow" effect.
				;
				INT_10_CGA_DISABLE:
					PUSH	AX
					PUSH	DX
					MOV	DX, CGA_STAT		; CGA Status (3DAH)
				INT_10_CGA_WAIT:
					IN	AL, DX			; get CRTC status register
								IF CGA_SNOW_REMOVE EQ 3
					TEST	AL, MASK VSVS OR MASK VSHS	; in HSYNC or VSYNC?
								ELSE
					TEST	AL, MASK VSVS 		; is in VSYNC?
								ENDIF
					JZ	INT_10_CGA_WAIT		; loop until it is
					MOV	DL, LOW CGA_CTRL		; CGA Control (3D8H)
					MOV	AL, 00100101B		; Mode 80x25 text, BW, disable video, blink
					OUT	DX, AL			; disable video
					POP	DX
					POP	AX
								ENDIF
				
				INT_10_6_CHECK_CLS:
					TEST	AL, AL			; is number of lines to scroll 0?
					JZ	INT_10_6_TXT_CLR		; if so, skip move and only clear
				
				;----------------------------------------------------------------------------;
				; Move scrolled window rectangle to new location in video memory 
				;
					SUB	DH, AL			; DH = rect height - lines to scroll
					JZ	INT_10_6_TXT_CLR_1	; is number of lines to move 0?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 164 - 1


 F233					ADD	SI, BP			; SI = source row starting address
 F233  FD			INT_10_6_TXT_MOVE_LOOP:
					MOV	CL, DL			; CX = number of columns (chars) to move
					REP	MOVSW				; copy row from [DS:SI] to [ES:DI]
					ADD	DI, BX			; move to start of next row
					ADD	SI, BX
					DEC	DH
					JNZ	INT_10_6_TXT_MOVE_LOOP	; loop through all rows
 F234				INT_10_6_TXT_CLR_1:
					MOV	DH, AL			; DH = remaining lines to clear
			     1				IFNB <AX>			; exit if last reg
 F234  50		     1		PUSH	AX 					; push register and repeat
			     1		PUSHX	BX, SI, BP, , , , 
			     2				IFNB <BX>			; exit if last reg
 F235  53		     2		PUSH	BX 					; push register and repeat
			     2		PUSHX	SI, BP, , , , , 
			     3				IFNB <SI>			; exit if last reg
 F236  56		     3		PUSH	SI 					; push register and repeat
			     3		PUSHX	BP, , , , , , 
			     4				IFNB <BP>			; exit if last reg
 F237  55		     4		PUSH	BP 					; push register and repeat
			     4		PUSHX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		PUSH	 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F238  8B 36 00EA R		
 F23C  8E C6			;----------------------------------------------------------------------------;
				; Clear (fill with spaces) the newly cleared area
				;
				INT_10_6_TXT_CLR:
					MOV	AL, VID_SP			; fill blank lines with spaces
				INT_10_6_TXT_CLR_LOOP:
					MOV	CL, DL			; write rect width number of blank chars
					REP	STOSW				; write attribute and space to col
					ADD	DI, BX			; move to start of next row
					DEC	DH
					JNZ	INT_10_6_TXT_CLR_LOOP	; loop through all rows
								IF CGA_SNOW_REMOVE GT 0
					POPF					; ZF if CGA/80, NZ if not
 F23E  80 FC 06							ENDIF
 F241  9F				POP	DS				; restore BDA SEG
 F242  8B E8			
 F244  8B FA							IF CGA_SNOW_REMOVE GT 0
 F246  75 02				JNZ	INT_10_6_DONE		; jump if not CGA/80
				;----------------------------------------------------------------------------;
				; If is CGA 80 column, re-enable the video signal
				;
				INT_10_6_ENABLE_CGA:
					MOV	AL, VID_MODE_REG		; reload the current control register
					MOV	DX, CGA_CTRL
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 165 - 1


 F248  8B D1				OUT	DX, AL			; write to CGA Control Register
								ENDIF
				
				INT_10_6_DONE:
					POPX	BP, SI, BX, AX
 F24A					RET
 F24A  A0 004A R		
 F24D  38 C2			;----------------------------------------------------------------------------;
 F24F  72 03			; INT 10,6/7 - Scroll up or down in graphics mode
 F251  8A D0			;----------------------------------------------------------------------------;
 F253  4A			; Input:
 F254				;	AX = memory offset of col 0 of new bottom row
 F254  F6 E6			;	BH = attribute to be used on blank line
 F256  8A F0			;	BL = (scratch)
				;	BP (high) = flags (ZF if scroll up, NZ if scroll down)
				;	CH = row/Y of upper left corner of scroll window
				;	CL = column/X of upper left corner of scroll window
				;	DX = lower right column/X position
 F258  E8 FE2A			;	DI = original row/column parameter
 F25B  8A C6			;
 F25D  B6 00			; Perform BitBlt operation within video RAM.
 F25F  1E			;----------------------------------------------------------------------------;
 F260  75 5E			INT_10_SCR_GFX PROC
					SHL	AX, 1				; BYTE (char) align memory offset for line
					SHL	AX, 1				;  (default for 640x200)
					ADD	DX, AX
					XCHG	DX, DI			; DI = memory offset of new rect bottom
										; DX = original row/col
					ADD	DX, 101H			; use 0-based indexes for 1-based counters
					SUB	DX, CX			; DH = rect height, DL = rect width
					XCHG	AX, BP			; restore original AL / AH = func flag
					MOV	BL, AL			; BL = lines to scroll
					MOV	BP, 80			; 1 scanline = 80 bytes
					MOV	CX, 2				; CL = 2, CH = 0 (needed later for counters)
					SHL	DH, CL			; rect height * char (row) height / 2 fields
					SHL	BL, CL			; lines to scroll * char height / 2 fields
					CMP	VID_MODE, 6			; is 640x200 mode?
					JZ	INT_10_SCR_GFX_2		; jump if so
				
 F262				;----------------------------------------------------------------------------;
 F262  03 D0			; is 320x200/4 color - adjust to 2 bits per pixel (16 bits per glyph)
 F264  D1 E2			;
 F266  03 16 004E R			SHL	DI, 1				; WORD (char) align mem offset
 F26A  8B F2				SHL	DL, 1				; WORD (char) align rect width
 F26C  87 FA				SAHF					; set ZF if scroll up
 F26E  2B D1				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up
 F270  8B 0E 004A R		
 F274  8C C0			;----------------------------------------------------------------------------;
 F276  8E D8			; is 320x200 AND scroll down
 F278  8B C5			;
 F27A  D0 E1				INC	DI				; fixup start address for last pixel
 F27C  F6 E1			
 F27E  95			INT_10_SCR_GFX_2:
 F27F  81 C2 0101			SAHF					; set ZF if scroll up
 F283  9E				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 166 - 1


 F284  8A E7			
 F286  9C			;----------------------------------------------------------------------------;
 F287  8B D9			; is scroll down
 F289  8A CA			;
 F28B  2B D9				ADD	DI, 240			; fixup bottom row of new rect.
 F28D  2B D9				NEG	BP				; if scroll down, subtract offset instead
 F28F  9D			
 F290  74 04			;----------------------------------------------------------------------------;
				; ready to begin
				;
				INT_10_SCR_GFX_RDY:
					TEST	AL, AL			; is number of lines to scroll 0?
					JZ	INT_10_SCR_GFX_CLR	; if so, skip move and only clear
				
				;----------------------------------------------------------------------------;
				; Bit block transfer pixel data in video memory
				;
					MOV	SI, DI			; SI = mem offset of new rectangle
					MOV	AX, BP			; AL = 1 scanline (80 if up, -80 if down)
 F292  F7 DB				IMUL	BL				; AX = offset of lines to scroll * +/- 80
 F294  F7 DD				ADD	SI, AX			; SI = mem offset of old rectangle
					MOV	AX, ES			; set DS to video regen segment
 F296					MOV	DS, AX			;  for source (old) rectangle
					PUSH	BX				; save lines to clear and attribute
					SUB	DH, BL			; DH = # of lines to write
					;JZ	INT_10_SCR_GFX_CLR_1	; check that loop > 1 (necessary?)
					MOV	AX, SI			; save source
					MOV	BX, DI			; save destination
				INT_10_SCR_GFX_MOVE_LOOP:
					MOV	CL, DL			; # of pixels to copy
					REP	MOVSB				; copy odd field
					MOV	SI, CGA_MEM_FLD		; vid mem offset for interlaced field
					MOV	DI, SI
					ADD	SI, AX			; add to line offset
					ADD	DI, BX
					MOV	CL, DL			; # of pixels to copy
					REP	MOVSB				; copy even field
					ADD	AX, BP			; move to next line
					ADD	BX, BP
					MOV	SI, AX			; reset source
					MOV	DI, BX			; reset dest
					DEC	DH
					JNZ	INT_10_SCR_GFX_MOVE_LOOP
					POP	BX
				
				;----------------------------------------------------------------------------;
				; Clear old window rectangle
				;
				INT_10_SCR_GFX_CLR_1:
					MOV	DH, BL			; # of lines to clear
				INT_10_SCR_GFX_CLR:
					MOV	AL, BH			; AL = attribute/color byte to write
					MOV	SI, DI			; save destination
 F296				INT_10_SCR_GFX_CLR_LOOP:
 F296  84 C0				MOV	CL, DL			; # of pixels to clear
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 167 - 1


 F298  74 14				REP	STOSB				; clear odd field
					MOV	DI, CGA_MEM_FLD		; vid mem offset for interlaced field
					ADD	DI, SI
					MOV	CL, DL			; # of pixels to clear
					REP	STOSB				; clear even field
 F29A  2A F0				ADD	SI, BP			; move to next line
 F29C  74 0E				MOV	DI, SI			; reset dest
 F29E  03 F5				DEC	DH
 F2A0					JNZ	INT_10_SCR_GFX_CLR_LOOP
 F2A0  8A CA				POP	DS
 F2A2  F3/ A5				JMP	INT_10_6_DONE
 F2A4  03 FB			
 F2A6  03 F3			INT_10_SCR_GFX ENDP
 F2A8  FE CE			
 F2AA  75 F4			INT_10_6 ENDP
 F2AC				INT_10_7 ENDP
 F2AC  8A F0			
				;----------------------------------------------------------------------------;
				; INT 10,8 - Read character and attribute at cursor
				;----------------------------------------------------------------------------;
				; Input:
 F2AE				;	BH = display page
 F2AE  B0 20			; Output:
 F2B0				;	AH = attribute of character (alpha modes only)
 F2B0  8A CA			;	AL = character at cursor position
 F2B2  F3/ AB			;
 F2B4  03 FB			; http://www.techhelpmanual.com/92-cga_video_snow_and_cls_flash.html
 F2B6  FE CE;----------------------------------------------------------------------------;
 F2B8  75 F6			INT_10_8 PROC
					MOV	DI, VID_MEM_SEG		; ES = video RAM segment
					MOV	ES, DI
					CALL	INT_10_GET_CUR_ADDR	; DI = video RAM offset of cursor
 F2BA  1F				MOV	AL, VID_MODE		; AL = current video mode (0-7)
					CMP	AL, 7				; is MDA mode 7?
					JNZ	INT_10_8_CHK_CGA		; if not, jump to check CGA or gfx
				
				;----------------------------------------------------------------------------;
				; Standard, fast routine
				;
				INT_10_8_FAST:
					MOV	AX, ES:[DI]			; just read from memory and return
					RET
				
				INT_10_8_CHK_CGA:
					SHR	AL, 1				; Video modes: 0=40,1=80,2=low-gfx,3=hi-gfx
 F2BB					CMP	AL, 1				; is CGA modes 2,3?
							IF CGA_SNOW_REMOVE GT 0
			     1				IFNB <BP>			; exit if last reg
 F2BB  5D		     1		POP	BP 					; pop register and repeat
			     1		POPX	SI, BX, AX, , , , 
			     2				IFNB <SI>			; exit if last reg
 F2BC  5E		     2		POP	SI 					; pop register and repeat
			     2		POPX	BX, AX, , , , , 
			     3				IFNB <BX>			; exit if last reg
 F2BD  5B		     3		POP	BX 					; pop register and repeat
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 168 - 1


			     3		POPX	AX, , , , , , 
			     4				IFNB <AX>			; exit if last reg
 F2BE  58		     4		POP	AX 					; pop register and repeat
			     4		POPX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		POP	 					; pop register and repeat
			     5		POPX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F2BF  C3				JNE	INT_10_8_NOT_CGA		; jump if not
				
				;----------------------------------------------------------------------------;
				; CGA snow-removal routine. Wait for a blanking interval before read.
				;
					PUSH	DX
					MOV	DX, CGA_STAT
					CGA_WAIT_SYNC
					MOV	AX, ES:[DI]
					STI
					POP	DX
					JMP	SHORT INT_10_8_FAST
				
				INT_10_8_NOT_CGA:
							ENDIF
				
					JBE	INT_10_8_FAST		; if not GFX modes 4,5,6 jump to fast text
 F2C0										; fall through to graphics
 F2C0  D1 E0			
 F2C2  D1 E0			;----------------------------------------------------------------------------;
 F2C4  03 D0			; INT 10,8 - Read character and attribute at cursor in CGA graphic mode
 F2C6  87 D7			;----------------------------------------------------------------------------;
				; Input:
 F2C8  81 C2 0101		;	AL = 3 if high res, 2 if low-res
 F2CC  2B D1			;	ES = video mem segment
 F2CE  95			; Output:
 F2CF  8A D8			;	AH = 0
 F2D1  BD 0050			;	AL = character at cursor position, 0 if not found
 F2D4  B9 0002			;----------------------------------------------------------------------------;
 F2D7  D2 E6			INT_10_8_MODE_GFX PROC
 F2D9  D2 E3				PUSHX	BX, CX, DX, SI
 F2DB  80 3E 0049 R 06			SUB	SP, 8				; reserve 8 bytes for target bitmap
 F2E0  74 08			
				;----------------------------------------------------------------------------;
				; Lookup page, calculate charpos and set up data segments
				;
					CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor
 F2E2  D1 E7				MOV	SI, DI			; SI = memory offset of curr. cursor
 F2E4  D0 E2				MOV	DI, SP			; DI = start of temp space
 F2E6  9E				PUSH	ES				; DS = ES
 F2E7  74 0A				POP	DS
					PUSH	SS				; ES = SS
					POP	ES
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 169 - 1


					MOV	CX, 4				; loop counter for high and low res
					MOV	DX, CGA_MEM_FLD		; CGA memory interlace field offset
 F2E9  47				CMP	AL, 3				; is high-res graphics mode?
					JZ	INT_10_8_GFX_HIGH		; jump to handle high-res 1 bpp spacing
 F2EA				
 F2EA  9E			;----------------------------------------------------------------------------;
 F2EB  74 06			; Low-res - Load and pack 8 character bytes from video mem into [DS:BP]
				;----------------------------------------------------------------------------;
				INT_10_8_MODE_GFX_LOW:
					SHL	SI, 1				; align for two bytes/char in 320x200
				
 F2ED  81 C7 00F0		INT_10_8_GFX_LOW_1:
 F2F1  F7 DD				MOV	AX, [SI]			; AX = next two chars from video mem
					XCHG	AL, AH			; convert endian from WORD read
				
				;----------------------------------------------------------------------------;
				; Shift and OR the color bits together so that non-zero value will produce 1
 F2F3				;
 F2F3  84 C0				MOV	BX, AX			; copy bit pattern
 F2F5  74 33				SHL	AX, 1				; shift low bit into high bit
					OR	BX, AX			; make high bit a 1 if either bit is 1
				
				;----------------------------------------------------------------------------;
				; Copy the only odd bits from the WORD value into a BYTE value.
 F2F7  8B F7			;
 F2F9  8B C5				MOV	AH, 8				; loop through the eight 2 bpp values
 F2FB  F6 EB			INT_10_8_GFX_LOW_2:
 F2FD  03 F0				SHL	BX, 1				; even bit into CF
 F2FF  8C C0				ADC	AL, AL			; shift CF onto low order bit
 F301  8E D8				SHL	BX, 1				; discard pixel odd bit
 F303  53				DEC	AH				; dec loop counter
 F304  2A F3				JNZ	INT_10_8_GFX_LOW_2
					STOSB					; save byte to local storage
 F306  8B C6				XOR	SI, DX			; toggle video field memory offset
 F308  8B DF				TEST	SI, DX			; is next field even?
 F30A					JNZ	INT_10_8_GFX_LOW_1	; jump if next field is even
 F30A  8A CA				ADD	SI, 80			; if next field is odd, move to next line
 F30C  F3/ A4				LOOP	INT_10_8_GFX_LOW_1	; loop all 8 bitmap bytes and fall through
 F30E  BE 2000			
 F311  8B FE			;----------------------------------------------------------------------------;
 F313  03 F0			; Do a linear search (uh, time complexity anyone?) of ROM BIOS and INT 1Fh 
 F315  03 FB			; for the 8x8 1 bpp bitmap at the cursor position.
 F317  8A CA			;
 F319  F3/ A4			INT_10_8_GFX_SEARCH:
 F31B  03 C5				MOV	DI, SP			; DI = char bitmap from video mem
 F31D  03 DD				MOV	SI, OFFSET GFX_CHARSET	; SI = BIOS ROM table
 F31F  8B F0				MOV	BX, CS			; DS = CS
 F321  8B FB				MOV	DS, BX
 F323  FE CE				XOR	AX, AX			; start codepoint counter at 0
 F325  75 E3			INT_10_8_GFX_SEARCH_TBL:
 F327  5B				MOV	BX, 128			; loop counter for each charset table
				INT_10_8_GFX_SEARCH_CHR:
					PUSH	SI				; save target bitmap and ROM table offsets
					PUSH	DI
					MOV	CL, 4				; compare [CS:SI] (ROM table) to
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 170 - 1


 F328					REPE	CMPSW				;  [ES:DI] (char bitmap from vid mem)
 F328  8A F3				POP	DI				; restart target bitmap at beginning 
 F32A					POP	SI				; ROM table always advanced by 8 
 F32A  8A C7				JE	INT_10_8_GFX_DONE		; end search if match found
 F32C  8B F7				ADD	SI, 8				; next char in table
 F32E					INC	AL				; next codepoint to try
 F32E  8A CA				JZ	INT_10_8_GFX_DONE		; if AL > 255, char not found
 F330  F3/ AA				DEC	BX				; dec charset loop counter
 F332  BF 2000				JNZ	INT_10_8_GFX_SEARCH_CHR	; loop until end of table set
 F335  03 FE			
 F337  8A CA			;----------------------------------------------------------------------------;
 F339  F3/ AA			; Search again in user charset at 0000:007C (INT 1Fh).
 F33B  03 F5			;
 F33D  8B FE				CWD					; DX = 0000h
 F33F  FE CE				MOV	DS, DX			; DS = IVT
 F341  75 EB						ASSUME DS:_IVT
 F343  1F				LDS	SI, IVT_1F			; DS:SI = user charset
 F344  E9 FF74						ASSUME DS:_BDA
					MOV	DX, DS			; see if custom table has been vectored
 F347					OR	DX, SI			;  and not the default of 0000:0000
					JNZ	INT_10_8_GFX_SEARCH_TBL	; if so, continue search
 F347					XOR	AX, AX			; otherwise return not found (0)
 F347				INT_10_8_GFX_DONE:
					ADD	SP, 8				; restore stack pointer
					POPX	SI, DX, CX, BX
					RET
				
				;----------------------------------------------------------------------------;
				; High-res - Load 8 character bytes from video mem into [DS:BP]
				;----------------------------------------------------------------------------;
				INT_10_8_GFX_HIGH:
					MOVSB					; copy odd field
					DEC	SI				; undo MOVSB source inc
					XOR	SI, DX			; toggle video field memory offset
					MOVSB					; copy even field
 F347					XOR	SI, DX			; toggle video field memory offset back
 F347  8B 3E 00EA R			ADD	SI, 80-1			; move to next line (undo MOVSB inc of SI)
 F34B  8E C7				LOOP	INT_10_8_GFX_HIGH		; loop 8 times
 F34D  E8 029D				JMP	INT_10_8_GFX_SEARCH	; rejoin the search
 F350  A0 0049 R		
 F353  3C 07			INT_10_8_MODE_GFX ENDP
 F355  75 04			
				INT_10_8 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,9 - Write character and attribute at cursor
 F357				;----------------------------------------------------------------------------;
 F357  26: 8B 05		; INT 10,A - Write character at current cursor
 F35A  C3			;----------------------------------------------------------------------------;
				; Input:
 F35B				;	AH = 09 or 0A
 F35B  D0 E8			;	AL = ASCII character to write
 F35D  3C 01			;	BH = display page  (or mode 13h, background pixel value)
				;	BL = foreground color (graphics mode only)
				;	CX = count of characters to write (CX >= 1)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 171 - 1


				;
				; This code is performance sensitive, so jumps are prioritizied
				; and some code is duplicated to avoid jumps. For example, AH=0AH is used 
				; far more frequently than 09H so it gets the fall through cases.
				;----------------------------------------------------------------------------;
				INT_10_9 PROC
				INT_10_A PROC
					PUSH	CX
					PUSH	AX				; save AX
					MOV	DI, VID_MEM_SEG
					MOV	ES, DI			; ES = video regen memory segment
					CALL	INT_10_GET_CUR_ADDR	; DI = video RAM offset of cursor
					MOV	AL, VID_MODE		; AL = current video mode (0-7)
					CMP	AL, 7				; is MDA mode 7?
					JNZ	INT_10_CHK_CGA		; if not, jump to check CGA
 F35F  76 F6			
				;----------------------------------------------------------------------------;
				; Use standard, fast routine for direct video memory writes
				;
				INT_10_9A_FAST:
					POP	AX				; restore AX
					CMP	AH, 9				; is function 9 (char + attribute)?
					JZ	INT_10_9_FAST		; if so, jump
				
				;----------------------------------------------------------------------------;
				; AH = 0AH: Write Character
				;
				INT_10_A_FAST:
 F361					STOSB					; write char, skip attribute
					INC	DI
			     1				IFNB <BX>			; exit if last reg
 F361  53		     1		PUSH	BX 					; push register and repeat
			     1		PUSHX	CX, DX, SI, , , , 
			     2				IFNB <CX>			; exit if last reg
 F362  51		     2		PUSH	CX 					; push register and repeat
			     2		PUSHX	DX, SI, , , , , 
			     3				IFNB <DX>			; exit if last reg
 F363  52		     3		PUSH	DX 					; push register and repeat
			     3		PUSHX	SI, , , , , , 
			     4				IFNB <SI>			; exit if last reg
 F364  56		     4		PUSH	SI 					; push register and repeat
			     4		PUSHX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		PUSH	 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F365  83 EC 08				LOOP	INT_10_A_FAST
					POP	CX
					RET
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 172 - 1


 F368  E8 0152			; AH = 09H: Write Character and Attribute
 F36B  8B F7			;
 F36D  8B FC			INT_10_9_FAST:
 F36F  06				MOV	AH, BL			; char attribute into high byte
 F370  1F				REP	STOSW				; write with attribute
 F371  16				POP	CX
 F372  07				RET
 F373  B9 0004			
 F376  BA 2000			INT_10_CHK_CGA:
 F379  3C 03				SHR	AL, 1				; group remaining video modes
 F37B  74 5D				CMP	AL, 1				; is CGA modes 2,3?
							IF CGA_SNOW_REMOVE GT 0
					JNE	INT_10_A_NOT_CGA		; jump if not
				
				;----------------------------------------------------------------------------;
 F37D				; Use slower CGA-specific snow-removal routines for memory writes during
 F37D  D1 E6			; screen blanking.
				;
 F37F				INT_10_9A_CGA:
 F37F  8B 04				POP	AX				; restore AX
 F381  86 C4				PUSH	BX				; save BX
					PUSH	DX
					MOV	DX, CGA_STAT
					CMP	AH, 9				; is function 9 (char + attribute)?
					JZ	INT_10_9_CGA
 F383  8B D8			
 F385  D1 E0			;----------------------------------------------------------------------------;
 F387  0B D8			; AH = 0AH: Write Character (CGA Text)
				;
				INT_10_A_CGA:
					XCHG	AX, BX			; save AX
					CGA_WAIT_SYNC			; wait for blanking to write memory
 F389  B4 08				XCHG	AX, BX			; restore AX
 F38B					STOSB					; write char, skip attribute
 F38B  D1 E3				STI
 F38D  12 C0				INC	DI
 F38F  D1 E3				LOOP	INT_10_A_CGA
 F391  FE CC			INT_10_A_CGA_DONE:
 F393  75 F6				POP	DX
 F395  AA				POP	BX
 F396  33 F2				POP	CX
 F398  85 F2				RET
 F39A  75 E3			
 F39C  83 C6 50			;----------------------------------------------------------------------------;
 F39F  E2 DE			; AH = 09H: Write Character and Attribute (CGA Text)
				;
				INT_10_9_CGA:
					MOV	AH, BL			; char attribute into high byte
				INT_10_9_CGA_LOOP:
					XCHG	AX, BX			; save AX
 F3A1					CGA_WAIT_SYNC			; wait for blanking to write memory
 F3A1  8B FC				XCHG	AX, BX			; restore AX
 F3A3  BE FA6E R			STOSW
 F3A6  8C CB				STI
 F3A8  8E DB				LOOP	INT_10_9_CGA_LOOP
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 173 - 1


 F3AA  33 C0				JMP	SHORT INT_10_A_CGA_DONE
 F3AC				INT_10_A_NOT_CGA:
 F3AC  BB 0080						ENDIF
 F3AF				
 F3AF  56				JBE	INT_10_9A_FAST		; is not GFX modes 4,5,6 jump to fast text
 F3B0  57				POP	AX				; restore AX and fall through to graphics
 F3B1  B1 04			
 F3B3  F3/ A7			;----------------------------------------------------------------------------;
 F3B5  5F			; INT 10, 9 and A - Write character in CGA graphics mode
 F3B6  5E			;----------------------------------------------------------------------------;
 F3B7  74 19			INT_10_9A_MODE_GFX PROC
 F3B9  83 C6 08				PUSHX	AX, BX, DX, SI, DS
 F3BC  FE C0				MOV	BH, VID_MODE		; BH = current video mode
 F3BE  74 12				CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor
 F3C0  4B			
 F3C1  75 EC			;----------------------------------------------------------------------------;
				; If extended ASCII, use custom table revectored at 1Fh
				;
					MOV	SI, OFFSET GFX_CHARSET	; default to lower set using BIOS table
					MOV	DX, CS			;  located in CS
 F3C3  99				MOV	DS, DX			; DS = CS
 F3C4  8E DA				TEST	AL, AL			; is extended (AL > 127)?
					JNS	INT_10_9A_GFX_2		; Jump if not
 F3C6  C5 36 007C R			AND	AL, 01111111b		; AL = low 7 bits of CP
					XOR	DX, DX			; Set DS to IVT to load DS and SI from
 F3CA  8C DA				MOV	DS, DX			; INT 1Fh
 F3CC  0B D6						ASSUME DS:_IVT
 F3CE  75 DC				LDS	SI, IVT_1F			; use custom font table
 F3D0  33 C0						ASSUME DS:_BDA
 F3D2				
 F3D2  83 C4 08			INT_10_9A_GFX_2:
					CBW					; AH = 0
			     1				IFNB <SI>			; exit if last reg
 F3D5  5E		     1		POP	SI 					; pop register and repeat
			     1		POPX	DX, CX, BX, , , , 
			     2				IFNB <DX>			; exit if last reg
 F3D6  5A		     2		POP	DX 					; pop register and repeat
			     2		POPX	CX, BX, , , , , 
			     3				IFNB <CX>			; exit if last reg
 F3D7  59		     3		POP	CX 					; pop register and repeat
			     3		POPX	BX, , , , , , 
			     4				IFNB <BX>			; exit if last reg
 F3D8  5B		     4		POP	BX 					; pop register and repeat
			     4		POPX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		POP	 					; pop register and repeat
			     5		POPX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F3D9  C3				SHL	AX, 1				; AX = char * 8
					SHL	AX, 1
					SHL	AX, 1
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 174 - 1


					ADD	SI, AX			; SI = offset in char table
					CMP	BH, 6
 F3DA					JE	INT_10_9A_GFX_HIGH	; jump if high res
 F3DA  A4			
 F3DB  4E			;----------------------------------------------------------------------------;
 F3DC  33 F2			; Low-res (320x200) graphics modes 4-5
 F3DE  A4			;----------------------------------------------------------------------------;
 F3DF  33 F2			; Input:
 F3E1  83 C6 4F			;	AX = ASCII character to write * 8 bytes
 F3E4  E2 F4			;	BH = video mode
 F3E6  EB B9			;	BL = foreground color
				;	CX = number of times to repeat character
 F3E8				;	DS:SI = start of character offset in font bitmap table
				;	ES:DI = cursor location in video RAM
 F3E8				;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. Transform each BYTE of 1 bit glyph into 2 bpp color WORD
				;	2. If BL has high bit set, XOR new char with current char
				;	3. Write new bitmap to CGA interlaced video memory
				;----------------------------------------------------------------------------;
				INT_10_9A_GFX_LOW:
					MOV	DL, BL			; DL = foreground color bits
					AND	DX, 0011b			; zero extend 2 bit color
				
				;----------------------------------------------------------------------------;
				; Repeat/expand 2 color bits in DL into into DX
				;
				INT_10_9A_GFX_FG:
					OR	DH, DL			; copy 2 bits
					SHL	DL, 1				; move color bits to next position
					SHL	DL, 1
					JNZ	INT_10_9A_GFX_FG		; loop until DL = 0
 F3E8					MOV	DL, DH			; copy to both bytes of DX
 F3E8				
 F3E8  51			;----------------------------------------------------------------------------;
 F3E9  50			; Repeat for number of chars to write in CX to create color mask
 F3EA  8B 3E 00EA R		;
 F3EE  8E C7				SHL	DI, 1				; align for two bytes/char in 320x200
 F3F0  E8 01FA			INT_10_9A_GFX_LOW_CHAR:
 F3F3  A0 0049 R			PUSH	SI				; save char glyph start offset for each loop
 F3F6  3C 07				PUSH	DI				; start each char at first row of vid mem
 F3F8  75 12			
				;----------------------------------------------------------------------------;
				; Transform glyph bitmap to 2 bit color and move into video memory
				;
					PUSH	CX				; save repeat counter
 F3FA					MOV	CX, 8				; loop 8 bytes
 F3FA  58			INT_10_9A_GFX_LOW_BYTE:
 F3FB  80 FC 09				LODSB					; Load next byte
 F3FE  74 06			
				;----------------------------------------------------------------------------;
				; Parallel-deposit bits of input char and transform 1 bit pixel into 2 bpp
				;
					PUSH	BX
 F400					PUSH	CX				; save bitmap counter
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 175 - 1


 F400  AA				XOR	BX, BX			; clear output
 F401  47				MOV	CL, 8				; loop 8 bits of input char
 F402  E2 FC			INT_10_9A_GFX_LOW_PDEP:
 F404  59				SHL	AL, 1				; CF = source pixel bit
 F405  C3				LAHF					; save CF
					RCL	BX, 1				; shift CF into next bit
					SAHF					; restore CF
					RCL	BX, 1				; shift CF into next bit again
					LOOP	INT_10_9A_GFX_LOW_PDEP
 F406					XCHG	AX, BX			; AX = result
 F406  8A E3				XCHG	AL, AH			; convert endian
 F408  F3/ AB				POP	CX
 F40A  59				POP	BX
 F40B  C3				AND	AX, DX			; combine with color mask
				
 F40C				;----------------------------------------------------------------------------;
 F40C  D0 E8			; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color
 F40E  3C 01			;
					TEST	BL, BL			; high bit set?
					JNS	INT_10_9A_GFX_LOW_WR	; jump if not
					XOR	AX, ES:[DI]			; XOR byte for current field
				INT_10_9A_GFX_LOW_WR:
					MOV	ES:[DI], AX			; write 2 bytes to video memory
					XOR	DI, CGA_MEM_FLD		; alternate video fields
					TEST	DI, CGA_MEM_FLD		; is an even field next?
					JNZ	INT_10_9A_GFX_LOW_NEXT	; jump if even (use same offset for even)
					ADD	DI, 80			; if next is odd, move to next bitmap row
				INT_10_9A_GFX_LOW_NEXT:
					LOOP	INT_10_9A_GFX_LOW_BYTE	; loop 8 glyph bytes/lines
				
					POP	CX				; restore repeat counter
					POP	DI
					POP	SI
					INC	DI				; move to next video mem WORD offset
					INC	DI
					LOOP	INT_10_9A_GFX_LOW_CHAR	; repeat for CX number of chars
				
				INT_10_9A_MODE_GFX_DONE:
					POPX	DS, SI, DX, BX, AX
				
				INT_10_9A_MODE_GFX_EXIT:
					POP	CX				; restore CX and rebalance stack
					RET
				
				;----------------------------------------------------------------------------;
				; High-res (640x200) graphics mode 6
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = ASCII character to write * 8 bytes
				;	BH = current video mode
				;	BL = foreground color
				;	CX = number of times to repeat character
				;	DS:SI = start of character offset in font bitmap table
				;	ES:DI = cursor location in video RAM
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 176 - 1


				; Things you must do:
				;	1. If BL has high bit set, XOR new char with current char
				;	2. Write new bitmap to CGA interlaced video memory
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Repeat for number of chars to write in CX
				;
				INT_10_9A_GFX_HIGH:
					PUSH	SI				; save char glyph start offset for each loop
					PUSH	DI				; start each char at first row of vid mem
 F410  76 E8			
 F412  58			;----------------------------------------------------------------------------;
				; Copy glyph bitmap to interlaced video memory
				;
					MOV	BH, 4				; loop 4 words (8 bytes)
				INT_10_9A_GFX_HIGH_WORD:
 F413					LODSW					; load next two glyph rows
				
			     1				IFNB <AX>			; exit if last reg
 F413  50		     1		PUSH	AX 					; push register and repeat
			     1		PUSHX	BX, DX, SI, DS, , , 
			     2				IFNB <BX>			; exit if last reg
 F414  53		     2		PUSH	BX 					; push register and repeat
			     2		PUSHX	DX, SI, DS, , , , 
			     3				IFNB <DX>			; exit if last reg
 F415  52		     3		PUSH	DX 					; push register and repeat
			     3		PUSHX	SI, DS, , , , , 
			     4				IFNB <SI>			; exit if last reg
 F416  56		     4		PUSH	SI 					; push register and repeat
			     4		PUSHX	DS, , , , , , 
			     5				IFNB <DS>			; exit if last reg
 F417  1E		     5		PUSH	DS 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		PUSH	 					; push register and repeat
			     6		PUSHX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F418  8A 3E 0049 R		;----------------------------------------------------------------------------;
 F41C  E8 009E			; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color
				;
					TEST	BL, BL			; high bit set?
					JNS	INT_10_9A_GFX_HIGH_WR	; jump if not
					XOR	AL, ES:[DI]			; XOR byte on odd field
 F41F  BE FA6E R			XOR	AH, ES:CGA_MEM_FLD[DI]	; and even field
 F422  8C CA			
 F424  8E DA			;----------------------------------------------------------------------------;
 F426  84 C0			; Write next two bytes to each field
 F428  79 0A			;
 F42A  24 7F			INT_10_9A_GFX_HIGH_WR:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 177 - 1


 F42C  33 D2				STOSB					; write odd field in AL
 F42E  8E DA				MOV	ES:CGA_MEM_FLD[DI][-1], AH	; write even field in AH
					ADD	DI, 80-1			; move to next bitmap row
 F430  C5 36 007C R			DEC	BH
					JNZ	INT_10_9A_GFX_HIGH_WORD	; loop 4 words
					POP	DI				; restore video mem cursor offset
 F434					POP	SI				; restore start of glyph
 F434  98				INC	DI				; move to next video mem BYTE offset 
 F435  D1 E0				LOOP	INT_10_9A_GFX_HIGH	; repeat for CX number of chars
 F437  D1 E0			
 F439  D1 E0				JMP	INT_10_9A_MODE_GFX_DONE	; exit
 F43B  03 F0			
 F43D  80 FF 06			;----------------------------------------------------------------------------;
 F440  74 56			; Calculate graphics memory address for current current position
				;----------------------------------------------------------------------------;
				; Input: DS = BDA
				; Output:
				;	DI = Current cursor vid mem offset
				;
				; Clobbers DX
				;----------------------------------------------------------------------------;
				INT_10_GFX_CHARPOS PROC
					MOV	DI, AX			; save original AX
					MOV	AL, BYTE PTR VID_COLS	; AL = screen mode cols (40 or 80)
					MOV	DX, VID_CURS_POS		; DH = cursor row pos, DL = column
					MUL	DH				; AX = screen cols * current row
					SHL	AX, 1				; AX = AX * 4
					SHL	AX, 1				; (8 rows / 2 fields)
					XCHG	AX, DX			; AL = current column, DX = row offset
					CBW					; AX = current column
					ADD	AX, DX			; AX = current row/column vid mem offset
 F442					XCHG	AX, DI			; AX = original, DI = row/col vid mem offset
 F442  8A D3				RET
 F444  83 E2 03			INT_10_GFX_CHARPOS ENDP
				
				INT_10_9A_MODE_GFX ENDP
				
				INT_10_A ENDP
 F447				INT_10_9 ENDP
 F447  0A F2			
 F449  D0 E2			;----------------------------------------------------------------------------;
 F44B  D0 E2			; INT 10,B - Set color palette
 F44D  75 F8			;----------------------------------------------------------------------------;
 F44F  8A D6			; Input:
				;	AH = 0B
				;	BH = palette color ID
				;	   = 0 to set background and border color
				;	   = 1 to select 4 color palette
 F451  D1 E7			;	BL = color value (when BH = 0)
 F453				;	   = palette value (when BH = 1)
 F453  56			;----------------------------------------------------------------------------;
 F454  57			;	|7|6|5|4|3|2|1|0|  3D9 Color Select Register (Graphics)
				;	 | | | | | `-------- RGB for background
				;	 | | | | `--------- intensity
				;	 | | | `---------- unused
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 178 - 1


				;	 | | `----------- 1 = palette 1, 0=palette 0 (see below)
 F455  51			;	 `-------------- unused
 F456  B9 0008			;	  Palette 0 = green, red, brown
 F459				;	  Palette 1 = cyan, magenta, white
 F459  AC			;
				; VID_CSGFX	RECORD	CGPH:2=11B,CGPL:1,CGX:1,CGIN:1,CGBG:3
				;----------------------------------------------------------------------------;
				INT_10_B PROC
					PUSH	AX
 F45A  53				MOV	AL, VID_COLOR			; get current color byte
 F45B  51				TEST	BH, BH				; set BG/border or palette?
 F45C  33 DB				JNZ	INT_10_B_SET_PAL			; jump if set palette
 F45E  B1 08			INT_10_B_SET_COL:
 F460					AND	AL, MASK CGPH OR MASK CGPL	; isolate current palette
 F460  D0 E0				AND	BL, 00011111B			; isolate color bits
 F462  9F				JMP	SHORT INT_10_B_DONE
 F463  D1 D3			INT_10_B_SET_PAL:
 F465  9E				AND	AL, NOT MASK CGPL			; clear palette bit
 F466  D1 D3				AND	BL, 00000001B			; isolate palette selector bit
 F468  E2 F6						IF CPU_TYPE	EQ CPU_V20
 F46A  93				ROR	BL, 3					; move low bit into bit 5
 F46B  86 C4						ELSE
 F46D  59					REPT	3
 F46E  5B				ROR	BL, 1					; move low bit into bit 5		ENDM
 F46F  23 C2						ENDIF
				INT_10_B_DONE:
					OR	AL, BL				; combine bytes
					MOV	VID_COLOR, AL			; save to BDA
					PUSH	DX
 F471  84 DB				MOV	DX, VID_PORT
 F473  79 03				ADD	DL, 5					; DX = 03D9H
 F475  26: 33 05			OUT	DX, AL				; send to CGA Color Select Register
 F478					POP	DX
 F478  26: 89 05			POP	AX
 F47B  81 F7 2000			RET
 F47F  F7 C7 2000		INT_10_B ENDP
 F483  75 03			
 F485  83 C7 50			;----------------------------------------------------------------------------;
 F488				; INT 10,C - Write graphics pixel at coordinate
 F488  E2 CF			;----------------------------------------------------------------------------;
				; Input:
 F48A  59			;	AL = color value (XOR'ed with current pixel if bit 7=1)
 F48B  5F			;	BH = page number, see VIDEO PAGES
 F48C  5E			;	CX = column number (zero based)
 F48D  47			;	DX = row number (zero based)
 F48E  47			;----------------------------------------------------------------------------;
 F48F  E2 C2			INT_10_C PROC
					PUSH	AX
 F491					PUSH	CX
					MOV	DI, VID_MEM_SEG		; ES to video memory
			     1				IFNB <DS>			; exit if last reg
 F491  1F		     1		POP	DS 					; pop register and repeat
			     1		POPX	SI, DX, BX, AX, , , 
			     2				IFNB <SI>			; exit if last reg
 F492  5E		     2		POP	SI 					; pop register and repeat
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 179 - 1


			     2		POPX	DX, BX, AX, , , , 
			     3				IFNB <DX>			; exit if last reg
 F493  5A		     3		POP	DX 					; pop register and repeat
			     3		POPX	BX, AX, , , , , 
			     4				IFNB <BX>			; exit if last reg
 F494  5B		     4		POP	BX 					; pop register and repeat
			     4		POPX	AX, , , , , , 
			     5				IFNB <AX>			; exit if last reg
 F495  58		     5		POP	AX 					; pop register and repeat
			     5		POPX	, , , , , , 
			     6				IFNB <>			; exit if last reg
			     6		POP	 					; pop register and repeat
			     6		POPX	, , , , , , 
			     6				ENDIF
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
					MOV	ES, DI
 F496					CALL	INT_10_GFX_PIXEL		; DI = memory offset, AH/CL mask/counter
 F496  59				MOV	CH, AL			; save original AL
 F497  C3				AND	AL, AH			; mask only selected pixel
					SHL	AL, CL			; shift into correct bit position
					TEST	CH, CH			; is high bit of color value set?
					JS	INT_10_C_XOR		; if so, XOR byte in memory
					SHL	AH, CL			; shift mask for pixel position
					NOT	AH				; invert mask to clear current pixel
					AND	AH, ES:[DI]			; clear pixel bits
					OR	AL, AH			; replace with new pixel value
					STOSB					; write to video buffer
				INT_10_C_DONE:
					POP	CX
					POP	AX
					RET
				INT_10_C_XOR:
					XOR	ES:[DI], AL			; just XOR and 'XIT
					JMP	SHORT INT_10_C_DONE
				INT_10_C ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,D - Read graphics pixel at coordinate
				;----------------------------------------------------------------------------;
 F498				; Input:
 F498  56			;	BH = page number
 F499  57			;	CX = X / column (zero based)
				;	DX = Y / row (zero based)
				; Output:
				;	AL = color of pixel read
				;	AH clobbered
 F49A  B7 04			;----------------------------------------------------------------------------;
 F49C				INT_10_D PROC
 F49C  AD				PUSH	CX
					MOV	DI, VID_MEM_SEG		; ES to video memory
					MOV	ES, DI
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 180 - 1


					CALL	INT_10_GFX_PIXEL		; DI = memory offset, AH/CL mask/counter
					MOV	AL, ES:[DI]			; read packed pixel byte
 F49D  84 DB				SHR	AL, CL			; shift into low order bit(s)
 F49F  79 08				AND	AL, AH			; mask only selected pixel
 F4A1  26: 32 05			POP	CX
 F4A4  26: 32 A5 2000			RET
				INT_10_D ENDP
				
				;----------------------------------------------------------------------------;
				; Get Video Memory Pixel Offset and Pixel Byte Mask
 F4A9				;----------------------------------------------------------------------------;
 F4A9  AA			; Input:
 F4AA  26: 88 A5 1FFF		;	CX = X / column (zero based)
 F4AF  83 C7 4F			;	DX = Y / row (zero based)
 F4B2  FE CF			;
 F4B4  75 E6			; Output
 F4B6  5F			;	DI = pixel byte offset
 F4B7  5E			;	AH = pixel data mask
 F4B8  47			;	CL = pixel right shift counter
 F4B9  E2 DD;	CH = pixel index (big endian)
				;
 F4BB  EB D4			; Example of read:
				;	MOV	AL, PIXEL_DAT
				;	SHR	AL, CL
				;	AND	AL, AH
				;
				; http://www.techhelpmanual.com/89-video_memory_layouts.html
				;----------------------------------------------------------------------------;
				INT_10_GFX_PIXEL PROC
					PUSH	BX
					PUSH	DX
				
 F4BD				;----------------------------------------------------------------------------;
 F4BD  8B F8			; Calculate X offset
 F4BF  A0 004A R		;
 F4C2  8B 16 0050 R			MOV	DI, CX		; DI = X position (zero based)
 F4C6  F6 E6				SHR	DI, 1
 F4C8  D1 E0				SHR	DI, 1			; DI = DI / 4 (two bit alignment)
 F4CA  D1 E0			
 F4CC  92			;----------------------------------------------------------------------------;
 F4CD  98			; Unpack pixel bit(s)
 F4CE  03 C2			;
 F4D0  97				MOV	AH, 0011B		; pixel mask = 0011B
 F4D1  C3				MOV	BL, AH		; index mask = 0011B (bits 0-3)
 F4D2					MOV	CH, CL		; save CH = CL
					MOV	CL, 1			; ROL multiplier = 1
 F4D2					CMP	VID_MODE, 6		; is 640x200 gfx mode?
					JB	NOT_HI_RES		; if low-res, skip
 F4D2				
 F4D2				;----------------------------------------------------------------------------;
				; Is "high res" (640x200)
				;
					SHR	AH, 1			; pixel mask = 0001B
					RCL	BL, 1			; index mask = 0111B (bits 0-7)
					DEC	CX			; ROL multiplier = 0
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 181 - 1


					SHR	DI, 1			; DI = DI / 8 (one bit alignment)
				NOT_HI_RES:
				
				;----------------------------------------------------------------------------;
				; Calculate right-shift counter:
				; - 640x200: CL = (7 - i) * 1
				; - 320x200: CL = (3 - i) * 2
				;
					AND	CH, BL		; CH = packed pixel index
					SUB	BL, CH		; calculate right-shift counter
					SHL	BL, CL		; multiply by 1 (high res) or 2 (low res)
					MOV	CL, BL		; CL = shift count
				
				;----------------------------------------------------------------------------;
				; Calculate Y offset
				;
				; Y offset = (DX / 2) * 80 + 2000H[DX is odd]
				;
 F4D2					SHR	DX, 1			; DX = DX / 2
 F4D2  50				XCHG	DL, DH		; DX = DX << 8
 F4D3  A0 0066 R			JNC	FIELD_EVEN		; is odd or even field?
 F4D6  84 FF				ADD	DI, CGA_MEM_FLD	; odd field address offset
 F4D8  75 07			FIELD_EVEN:
 F4DA					SHR	DX, 1
 F4DA  24 E0				SHR	DX, 1
 F4DC  80 E3 1F				ADD	DI, DX		; DI += (DX / 2) * 16
 F4DF  EB 0B				SHR	DX, 1
 F4E1					SHR	DX, 1
 F4E1  24 DF				ADD	DI, DX		; DI += (DX / 2) * 64
 F4E3  80 E3 01				POP	DX
					POP	BX
					RET
				INT_10_GFX_PIXEL ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,E - Write text in teletype mode
 F4E6  D0 CB		     1		ROR	BL, 1					; move low bit into bit 5
 F4E8  D0 CB		     1		ROR	BL, 1					; move low bit into bit 5
 F4EA  D0 CB		     1		ROR	BL, 1					; move low bit into bit 5
				;----------------------------------------------------------------------------;
 F4EC				; Input:
 F4EC  0A C3			;	AH = 0E
 F4EE  A2 0066 R		;	AL = ASCII character to write
 F4F1  52			;	BH = page number (text modes) - override it with BDA value though
 F4F2  8B 16 0063 R		;	BL = foreground pixel color (graphics modes)
 F4F6  80 C2 05			;
 F4F9  EE			; Output:
 F4FA  5A			;	Character to console
 F4FB  58			;	All registers preserved
 F4FC  C3			;----------------------------------------------------------------------------;
 F4FD				; Things you must do:
				;	1. Get video page from BDA - ignore what was passed in BH (why?)
				;	2. Get cursor location (INT 10,3) and keep it handy.
				;	3. Check for the four special control codes: BELL(7), BS(8), LF(A), CR(D)
				;		- BELL: beep and exit
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 182 - 1


				;		- Backspace: if cursor column is 0, exit else DEC col and go to 6
				;		- CR: set cursor to column 0 and go to step 6
				;		- LF: increment row and go to step 5 to check if scroll is needed
				;	4. Write the char to the current position (INT 10,A)
				;	5. If new row > last row, scroll up 1 row (INT 10,8).
				;	6. Update cursor position (INT 10,6)
 F4FD				;
 F4FD  50			;----------------------------------------------------------------------------;
 F4FE  51			INT_10_E PROC
 F4FF  8B 3E 00EA R			PUSHX	AX, BX, CX, DX
 F503  8E C7				CALL	INT_10_3_CUR_PAGE		; Get cursor pos: DH = row, DL = column
 F505  E8 002F				CMP	AL, CR			; is maybe a control code?
 F508  8A E8				JBE	INT_10_E_CTRL		; if so, jump to handle it
 F50A  22 C4			
 F50C  D2 E0			;----------------------------------------------------------------------------;
 F50E  84 ED			; Handle a regular char
 F510  78 0D			;
 F512  D2 E4			INT_10_E_CHAR:
 F514  F6 D4				MOV	CX, 1				; repeat only once
 F516  26: 22 25			CALL	INT_10_A			; write char in AL at current row/col
 F519  0A C4			
 F51B  AA			;----------------------------------------------------------------------------;
 F51C				; Handle line wrap
 F51C  59			;
 F51D  58				MOV	CL, BYTE PTR VID_COLS	; get screen cols
 F51E  C3				DEC	CX				; fix 0 index
 F51F					CMP	DL, CL			; reached end of screen cols?
 F51F  26: 30 05			JB	NEXT_COL			; jump if not
 F522  EB F8				MOV	DL, -1			; else move to first col and next row 
 F524				NEXT_COL:
					INC	DX				; move to next column (and maybe row)
				
				;----------------------------------------------------------------------------;
				; Scroll if necessary
				;
				INT_10_E_SCROLL:
					CMP	DH, VID_DEF_ROWS		; moved past last row?
					JBE	INT_10_E_CURS		; if not, no scroll necessary
					XOR	AH, AH			; attribute = 0 if gfx mode
					DEC	DH				; undo row scroll
					CALL	INT_10_IS_TXT		; ZF = 1 if CGA/MDA Text, ZF = 0 if gfx
					JNZ	INT_10_E_SCROLL_UP	; jump if graphics
 F524					CALL	INT_10_8			; Read character: AH = attribute, AL = char
 F524  51			
 F525  8B 3E 00EA R		;----------------------------------------------------------------------------;
 F529  8E C7			; Scroll up one line
 F52B  E8 0009			;
 F52E  26: 8A 05		INT_10_E_SCROLL_UP:
 F531  D2 E8				PUSH	BX				; save video page (BH)
 F533  22 C4				XCHG	AX, BX			; BH = attribute
 F535  59				MOV	AX, DBW <6, 1>		; AH = 06H Scroll Window Up, AL = 1 line
 F536  C3				XOR	CX, CX			; scroll top left: CH = row 0, CL = col 0
 F537					PUSH	DX				; save cursor bottom
					MOV	DL, BYTE PTR VID_COLS	; DL = right-most column
					MOV	DH, VID_DEF_ROWS		; DH = bottom row (always 24)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 183 - 1


					DEC	DX				; fixup 0-indexed column
					CLD
					CALL	INT_10_6			; INT 10H, 06H Scroll Window Up
					POP	DX				; restore cursor bottom
					POP	BX				; restore video page (BH)
				
				;----------------------------------------------------------------------------;
				; Set new cursor position
				;
				INT_10_E_CURS:
					CALL	INT_10_2			; set cursor pos: BH = page, row = DH, col = DL
				
				INT_10_E_DONE:
					POPX	DX, CX, BX, AX		; restore caller registers
					RET
				
				;----------------------------------------------------------------------------;
				; Handle control codes
				;
 F537				INT_10_E_CTRL:
 F537  53				JZ	INT_10_E_CR			; ZF = CR (from above)
 F538  52				CMP	AL, LF			; is an LF?
					JZ	INT_10_E_LF
					CMP	AL, BS			; is a backspace?
					JZ	INT_10_E_BS
					CMP	AL, BELL			; Isabelle?
 F539  8B F9				JNZ	INT_10_E_CHAR		; otherwise, handle as a normal char
 F53B  D1 EF			INT_10_E_BELL:
 F53D  D1 EF				POPX	DX, CX, BX, AX		; clear stack, beep and exit
					JMP	BEEP				; standard BEEP and RET
				INT_10_E_CR:
					XOR	DL, DL			; move to column 0
					JMP	INT_10_E_CURS		; update cursor
 F53F  B4 03			INT_10_E_LF:
 F541  8A DC				INC	DH				; move to next row
 F543  8A E9				JMP	INT_10_E_SCROLL		; maybe scroll
 F545  B1 01			INT_10_E_BS:
 F547  80 3E 0049 R 06			TEST	DL, DL			; is first column? (can't backspace further)
 F54C  72 07				JZ	INT_10_E_DONE		; if so, do nothing and exit
					DEC	DX				; back space one column
					JMP	INT_10_E_SCROLL		; maybe scroll
				
				INT_10_E ENDP
 F54E  D0 EC			
 F550  D0 D3			;----------------------------------------------------------------------------;
 F552  49			; INT 10,F - Get current video state
 F553  D1 EF			;----------------------------------------------------------------------------;
 F555				; Input:
				;	AH = 0F
				; Output
				;	AH = number of screen columns
				;	AL = mode currently set
				;	BH = current display page
				;----------------------------------------------------------------------------;
 F555  22 EB			INT_10_F PROC
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 184 - 1


 F557  2A DD				MOV	AX, WORD PTR VID_MODE
 F559  D2 E3				MOV	BH, VID_PAGE
 F55B  8A CB				RET
				INT_10_F ENDP
				
				;----------------------------------------------------------------------------;
				; Get video memory offset for current cursor position
				;----------------------------------------------------------------------------;
				; Input:
 F55D  D1 EA			;	BH = current video page
 F55F  86 D6			; Output
 F561  73 04			;	DI = memory offset of current cursor in memory
 F563  81 C7 2000		;----------------------------------------------------------------------------;
 F567				INT_10_GET_CUR_ADDR PROC
 F567  D1 EA				PUSH	AX
 F569  D1 EA				PUSH	DX
 F56B  03 FA				MOV	AL, BH			; AL = display page
 F56D  D1 EA				CBW					; AX = page number
 F56F  D1 EA				XCHG	AX, DI			; DI = page number
 F571  03 FA				MOV	AX, VID_BUF_SZ		; AX = VID_BUF_SZ
 F573  5A				MUL	DI				; AX = page size * page (base offset)
 F574  5B				SHL	DI, 1				; word align index
 F575  C3				MOV	DX, VID_CURS_POS[DI]	; DX = cursor position on page
 F576					XCHG	AX, DI			; DI = page base offset
					MOV	AL, BYTE PTR VID_COLS
					MUL	DH				; AX = screen cols * current row
					XCHG	AX, DX			; DX = rows offset, AL = current col
					CBW					; AX = current col
					ADD	AX, DX			; AX = page relative cursor offset
					SHL	AX, 1				; word align
					ADD	DI, AX			; DI = memory offset of cursor
					POP	DX
					POP	AX
					RET
				INT_10_GET_CUR_ADDR ENDP
				
				;----------------------------------------------------------------------------;
				; 6845 CRT mode control register values
				;----------------------------------------------------------------------------;
				; CGA:
				;	|7|6|5|4|3|2|1|0|  3D8H Mode Select Register
				;	     | | | | | `---- 1 = 80x25 text, 0 = 40x25 text
				;	     | | | | `----- 1 = 320x200 graphics, 0 = text (unused on MDA)
				;	     | | | `------ 1 = B/W, 0 = color (unused on MDA)
				;	     | | `------- 1 = enable video signal
				;	     | `-------- 1 = 640x200 B/W graphics (unused on MDA)
				;	     `--------- 1 = blink, 0 = no blink
				; MDA:
				;	|7|6|5|4|3|2|1|0|  3B8 CRT Control Port
				;	     | | | | | `---- 1 = 80x25 text
				;	     | | | `------- unused
 F576				;	     | | `-------- 1 = enable video signal
				;	     | `--------- unused
			     1				IFNB <AX>			; exit if last reg
 F576  50		     1		PUSH	AX 					; push register and repeat
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 185 - 1


			     1		PUSHX	BX, CX, DX, , , , 
			     2				IFNB <BX>			; exit if last reg
 F577  53		     2		PUSH	BX 					; push register and repeat
			     2		PUSHX	CX, DX, , , , , 
			     3				IFNB <CX>			; exit if last reg
 F578  51		     3		PUSH	CX 					; push register and repeat
			     3		PUSHX	DX, , , , , , 
			     4				IFNB <DX>			; exit if last reg
 F579  52		     4		PUSH	DX 					; push register and repeat
			     4		PUSHX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		PUSH	 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F57A  E8 FC71			;	     `---------- 1 = blinking on
 F57D  3C 0D			;
 F57F  76 40			; source: https://stanislavs.org/helppc/6845.html
				;----------------------------------------------------------------------------;
				CRT_MODE	DB	101100B	; 00: 40x25 B/W text (CGA)
						DB	101000B	; 01: 40x25 16 color text (CGA)
						DB 	101101B	; 02: 80x25 16 shades of gray text (CGA)
 F581						DB	101001B	; 03: 80x25 16 color text (CGA)
 F581  B9 0001					DB	101010B	; 04: 320x200 4 color graphics (CGA)
 F584  E8 FE61					DB	101110B	; 05: 320x200 4 color graphics (CGA)
						DB	011110B	; 06: 640x200 B/W graphics (CGA)
						DB	101001B	; 07: 80x25 Monochrome text (MDA, HERC)
				
				INT_10 ENDP
 F587  8A 0E 004A R		
 F58B  49			;----------------------------------------------------------------------------;
 F58C  38 CA			; Display system hardware config
 F58E  72 02			;----------------------------------------------------------------------------;
 F590  B2 FF			; Input:
 F592				;	DS = BDA (0040)
 F592  42			;
				; Clobbers: AX, BX, CX, SI
				; Size: 133 bytes
				;----------------------------------------------------------------------------;
				POST_SYS_CONFIG PROC
 F593						ASSUME DS:_BDA
 F593  80 FE 18			
 F596  76 21						IF POST_VIDEO_TYPE EQ 1
 F598  32 E4				CALL	POST_SYS_VIDEO			; display Video type
 F59A  FE CE						ENDIF
 F59C  E8 FAE6			
 F59F  75 03			;----------------------------------------------------------------------------;
 F5A1  E8 FDA3			; Display CPU type
				;
					POST_COL_1	POST_CPU, POST_CLR_VAL1	; display 'CPU' left column
											;  SI default to 8088
				CPU_CHECK_TYPE_2:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 186 - 1


 F5A4					TEST_GFLAG  V20				; ZF = 0 if V20, ZF = 1 if 8088
 F5A4  53				JZ	CPU_CHECK_TYPE_2_DONE		; jump if 8088
 F5A5  93				MOV	SI, OFFSET POST_V20		; if not, is V20
 F5A6  B8 0601			CPU_CHECK_TYPE_2_DONE:
 F5A9  33 C9				CALL	OUT_SZ				; write CPU type
 F5AB  52				POST_COL_END				; end first column
 F5AC  8A 16 004A R		
 F5B0  B6 18			;----------------------------------------------------------------------------;
 F5B2  4A			; Display FPU/math co-processor
 F5B3  FC			;
 F5B4  E8 FC7D			FPU_CHECK:
 F5B7  5A				POST_COL_2  POST_FPU, POST_CLR_VAL1	; SI default to '8087'
 F5B8  5B				TEST_EFLAG  FPU				; was FPU detected?
					JNZ	FPU_DISP_DONE			; jump to output if FPU
					MOV	SI, OFFSET POST_NONE		; otherwise 'None'
				FPU_DISP_DONE:
					CALL	OUT_SZ				; display string
 F5B9					POST_COL_END_NL				; end second column, move to NL
 F5B9  E8 FBF9			
				;----------------------------------------------------------------------------;
 F5BC				; Display LPT ports
				;
			     1				IFNB <DX>			; exit if last reg
 F5BC  5A		     1		POP	DX 					; pop register and repeat
			     1		POPX	CX, BX, AX, , , , 
			     2				IFNB <CX>			; exit if last reg
 F5BD  59		     2		POP	CX 					; pop register and repeat
			     2		POPX	BX, AX, , , , , 
			     3				IFNB <BX>			; exit if last reg
 F5BE  5B		     3		POP	BX 					; pop register and repeat
			     3		POPX	AX, , , , , , 
			     4				IFNB <AX>			; exit if last reg
 F5BF  58		     4		POP	AX 					; pop register and repeat
			     4		POPX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		POP	 					; pop register and repeat
			     5		POPX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F5C0  C3				POST_COL_1	POST_LPT, POST_CLR_VAL2
					GET_EFLAG   LPT				; AX = number of LPT ports
					XCHG	AX, CX				; CX = number of ports
					MOV	SI, OFFSET LPT_ADDR
					CALL	SHOW_PORT_COUNT
 F5C1				
 F5C1  74 13			;----------------------------------------------------------------------------;
 F5C3  3C 0A			; Display COM ports
 F5C5  74 13			;
 F5C7  3C 08				POST_COL_2	POST_COM, POST_CLR_VAL2
 F5C9  74 13				GET_EFLAG   COM				; AX = number of COM ports
 F5CB  3C 07				XCHG	AX, CX				; CX = number of ports
 F5CD  75 B2				XOR	SI, SI				; OFFSET COM_ADDR = 0000H
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 187 - 1


 F5CF				
				;----------------------------------------------------------------------------;
			     1				IFNB <DX>			; exit if last reg
 F5CF  5A		     1		POP	DX 					; pop register and repeat
			     1		POPX	CX, BX, AX, , , , 
			     2				IFNB <CX>			; exit if last reg
 F5D0  59		     2		POP	CX 					; pop register and repeat
			     2		POPX	BX, AX, , , , , 
			     3				IFNB <BX>			; exit if last reg
 F5D1  5B		     3		POP	BX 					; pop register and repeat
			     3		POPX	AX, , , , , , 
			     4				IFNB <AX>			; exit if last reg
 F5D2  58		     4		POP	AX 					; pop register and repeat
			     4		POPX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		POP	 					; pop register and repeat
			     5		POPX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F5D3  E9 F2D8			; Display I/O addresses of COM or LPT ports on POST
 F5D6				;----------------------------------------------------------------------------;
 F5D6  32 D2			; Input:
 F5D8  EB DF			;	SI = WORD array of ports
 F5DA				;	CX = number of ports to show
 F5DA  FE C6			;----------------------------------------------------------------------------;
 F5DC  EB B5			SHOW_PORT_COUNT PROC
 F5DE					JCXZ	PORT_COUNT_NONE			; if no ports, display 'None'
 F5DE  84 D2			PORT_COUNT_LOOP:
 F5E0  74 DA				LODSW	
 F5E2  4A				CALL	WORD_HEX				; display I/O address in hex
 F5E3  EB AE				CALL	SPACE					; separate ports with space
					LOOP	PORT_COUNT_LOOP
 F5E5					MOV	SI, OFFSET POST_RSEP[1]		; skip leading space in right sep.
					JMP	SHORT POST_END_COL_STR		; display end with sep. in SI and RET
				PORT_COUNT_NONE:
					PRINT_SZ  POST_NONE			; display 'None'
					JMP	SHORT POST_END_COL		; display end sep and RET
				SHOW_PORT_COUNT ENDP
				
				POST_SYS_CONFIG ENDP
				
				;----------------------------------------------------------------------------;
				; Write POST column label and start separator 
				;----------------------------------------------------------------------------;
 F5E5				; - Start new line
 F5E5  A1 0049 R		; - display column name in color 1
 F5E8  8A 3E 0062 R		; - display left separator in color 1
 F5EC  C3			; - set color for inner text to be color 2
 F5ED				;----------------------------------------------------------------------------;
				; Input:
				; - SI: column name string
				; - BL: inner text color/attribute
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 188 - 1


				;
				; Output:
				; - SI: beginning of next adjacent string
				; - CX: inner text color length = POST_TAB_COL_I
				;----------------------------------------------------------------------------;
				POST_COL PROC
 F5ED				
 F5ED  50			;----------------------------------------------------------------------------;
 F5EE  52; Handle 40 column mode - move to next line and fall through to col 1
 F5EF  8A C7			;
 F5F1  98			POST_START_COL_2_40:
 F5F2  97				CALL	CRLF				; move to next line
 F5F3  A1 004C R			POP	AX				; rebalance stack
 F5F6  F7 E7			POST_START_COL_1 PROC
 F5F8  D1 E7				PUSH	AX
 F5FA  8B 95 0050 R			MOV	AL, POST_COL_W		; column 1 tab width
 F5FE  97			POST_START_COL_START:
 F5FF  A0 004A R			PUSH	BX				; save inner text color
 F602  F6 E6				MOV	AH, BL			; save text color
 F604  92				MOV	CX, POST_COL_VT		; set attribute on next CX # of chars
 F605  98				MOV	BX, LOW POST_CLR_TXT	; set outer text color
 F606  03 C2				CALL	OUT_SZ_ATTR			; write SI string with attribute
 F608  D1 E0				CALL	MOVE_COL			; move cursor to separator column
 F60A  03 F8				PUSH	SI				; save end of string
 F60C  5A				MOV	SI, OFFSET POST_LSEP	; write separator string with
 F60D  58				CALL	OUT_SZ			;  existing attributes
 F60E  C3				MOV	BL, AH			; restore text color
 F60F					DEC	SI				; [SI] = previous null char
					MOV	CL, POST_TAB_COL_I	; CX = repeat times
					PUSH	CX				; save for return
					CALL	OUT_SZ_ATTR			; set attributes, skip null string
					POP	CX				; CX = inner text color length
					POP	SI				; restore string position
					POP	BX				; BL = attribute for next CX chars
					POP	AX
					RET
				POST_START_COL_1 ENDP
				
				;----------------------------------------------------------------------------;
				; Same as POST_START_COL_1 except starts at column 2
				;----------------------------------------------------------------------------;
				POST_START_COL_2 PROC
							ASSUME DS:_BDA
					PUSH	AX
					MOV	AH, 0FH			; get video mode
					INT	10H				; AL = video mode
					CMP	AL, 1				; is 40 column mode?
					JLE	POST_START_COL_2_40
					MOV	AL, POST_TAB_COL		; move to start of column 2
					CALL	MOVE_COL
 F60F 2C				MOV	AL, POST_TAB_COL+POST_COL_W	; set abs. position for column 2 tab
 F610  28				JMP	POST_START_COL_START
 F611  2D			POST_START_COL_2 ENDP
 F612  29			
 F613  2A			;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 189 - 1


 F614  2E			; Same as POST_END_COL and displays a CRLF
 F615  1E			;----------------------------------------------------------------------------;
 F616  29			POST_END_COL_NL PROC
					CALL	POST_END_COL
 F617					JMP	SHORT CRLF			; write CRLF and RET
				POST_END_COL_NL ENDP
				
				;----------------------------------------------------------------------------;
				; Write POST column end separator 
				;----------------------------------------------------------------------------;
				; Display right separator in color POST_CLR_TXT
				; Clobbers: BX
				;----------------------------------------------------------------------------;
				POST_END_COL PROC NEAR
					MOV	SI, OFFSET POST_RSEP
 F617				
				;----------------------------------------------------------------------------;
				; POST_END_COL_STR: Write POST column end separator
				;----------------------------------------------------------------------------;
 F617  E8 F02F			; Input: CS:SI
				;----------------------------------------------------------------------------;
				POST_END_COL_STR PROC NEAR
					MOV	CX, 2
					MOV	BX, LOW POST_CLR_TXT	; Fall through to OUT_SZ_ATTR and RET
				
				;----------------------------------------------------------------------------;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 F61A  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 F61C  BE E4A2 R	     1		MOV	SI, OFFSET POST_CPU
 F61F  E8 0072		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
				; Write a zero-terminated string to console with attributes, no cursor move
 F622				;----------------------------------------------------------------------------;
				; Sets attribute in BL for the next CX number of characters, past end of string.
 F622  F6 06 0012 R 04	     1		TEST	GB_FLAGS, MASK V20
 F627  74 03			;
 F629  BE E4C8 R		; Input: CS:SI = String, CX = length, BL = attribute, BH = video page
 F62C				; Output: SI = end of string
 F62C  E8 00BE			;----------------------------------------------------------------------------;
				OUT_SZ_ATTR PROC
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 F62F  E8 00A0		     1		CALL	POST_END_COL
			     1			IFNB	<>
			     1		POP	BX
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 190 - 1


			     1			ENDIF
					PUSH	AX
				
				;----------------------------------------------------------------------------;
				; Filter MDA attributes - display with intensity attribute only
 F632				;
				MDA_COLOR_FIX:
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 F632  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 F634  BE E4AB R	     1		MOV	SI, OFFSET POST_FPU
 F637  E8 0081		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
					CALL	INT_10_IS_TXT		; CF if MDA
			     1				IF FPU LT 8
 F63A  F6 06 0010 R 02	     1		TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FPU
			     1				ELSE
			     1		TEST	BYTE PTR EQUIP_FLAGS[1], HIGH MASK FPU
			     1				ENDIF
 F63F  75 03				JNC	OUT_SZ_ATTR_SET		; skip if not MDA
 F641  BE FF4D R					IF MDA_ATTR LT 2	; preserve all attributes
 F644							IF MDA_ATTR EQ 1	; only intensity
 F644  E8 00A6				AND	BL, MASK MDIN OR MASK MDFG ; remove MDA blink and background attr
					OR	BL, MASK MDFG		; remove MDA underline attr
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 F647  E8 0083		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
							ELSE			; filter all
					MOV	BL, MDA_CH_ATTR <>	; default normal
							ENDIF
							ENDIF
				OUT_SZ_ATTR_SET:
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL2		; BH = 0, BL = attribute
			     1			ELSE
 F64A  B3 0E		     1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute
			     1			ENDIF
 F64C  BE E4CC R	     1		MOV	SI, OFFSET POST_LPT
 F64F  E8 0042		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 191 - 1


			     1			ENDIF
			     1	
					MOV	AX, DBW <9, VID_SP>	; write empty char with attr CX # of times
			     1			LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
			     1				IFNB <>
			     1		PUSH	CX					; save CX
			     1		PUSH	DS
			     1		MOV	CX, SEG _BDA			; DS = BDA
			     1		MOV	DS, CX
			     1				ENDIF
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Shift if flag is in high byte to low for byte operations
			     1	;
			     1				IF LPT LT 8		; is in low byte?
			     1	??0027	= MASK LPT
			     1	??0028	= LPT AND 0111B
			     1	??0029	= EQUIP_FLAGS[0]			; low BDA flags byte
			     1				ELSE				; is in high byte
 = 00C0			     1	??0027	= HIGH MASK LPT
 = 0006			     1	??0028	= (LPT - 8) AND 0111B
 = 0011			     1	??0029	= EQUIP_FLAGS[1]			; high BDA flags byte
			     1				ENDIF
			     1	
 F652  A0 0011 R	     1		MOV	AL, BYTE PTR ??0029
 F655  25 00C0		     1		AND	AX, ??0027			; clear AH
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Determine optimal number of shifts based on bit position and shift
			     1	; right or left depending on fewest.
			     1	;
			     1				IF CPU_TYPE	EQ CPU_V20
			     1					IF ??0028 GT 4
			     1		ROL	AL, 8-??0028			; shift value into position
			     1					ELSE
			     1		ROR	AL, ??0028			; shift value into position
			     1					ENDIF
			     1				ELSE
			     1					IF ??0028 GT 4
 F658  B1 02		     1		MOV	CL, 8-??0028			; CL = bit(s) position of record
 F65A  D2 C0		     1		ROL	AL, CL				; shift value into position
			     1					ELSE
			     1		MOV	CL, ??0028			; CL = bit(s) position of record
			     1		ROR	AL, CL				; shift value into position
			     1					ENDIF
			     1				ENDIF
			     1				IFNB <>
			     1		POP	DS
			     1		POP	CX
			     1				ENDIF
 F65C  91				INT	10H
 F65D  BE 0008 R			POP	AX				; Fall through to OUT_SZ and RET
 F660  E8 0015			
				;----------------------------------------------------------------------------;
				; Display a zero-terminated string in BIOS at CS:[SI]
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 192 - 1


				;----------------------------------------------------------------------------;
				; Input: CS:SI = String, BH = video page
				; Size: 24 bytes
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL2		; BH = 0, BL = attribute
			     1			ELSE
 F663  B3 0E		     1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute
			     1			ENDIF
 F665  BE E4D0 R	     1		MOV	SI, OFFSET POST_COM
 F668  E8 0050		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				;----------------------------------------------------------------------------;
			     1			LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
			     1				IFNB <>
			     1		PUSH	CX					; save CX
			     1		PUSH	DS
			     1		MOV	CX, SEG _BDA			; DS = BDA
			     1		MOV	DS, CX
			     1				ENDIF
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Shift if flag is in high byte to low for byte operations
			     1	;
			     1				IF COM LT 8		; is in low byte?
			     1	??002A	= MASK COM
			     1	??002B	= COM AND 0111B
			     1	??002C	= EQUIP_FLAGS[0]			; low BDA flags byte
			     1				ELSE				; is in high byte
 = 000E			     1	??002A	= HIGH MASK COM
 = 0001			     1	??002B	= (COM - 8) AND 0111B
 = 0011			     1	??002C	= EQUIP_FLAGS[1]			; high BDA flags byte
			     1				ENDIF
			     1	
 F66B  A0 0011 R	     1		MOV	AL, BYTE PTR ??002C
 F66E  83 E0 0E		     1		AND	AX, ??002A			; clear AH
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Determine optimal number of shifts based on bit position and shift
			     1	; right or left depending on fewest.
			     1	;
			     1				IF CPU_TYPE	EQ CPU_V20
			     1					IF ??002B GT 4
			     1		ROL	AL, 8-??002B			; shift value into position
			     1					ELSE
			     1		ROR	AL, ??002B			; shift value into position
			     1					ENDIF
			     1				ELSE
			     1					IF ??002B GT 4
			     1		MOV	CL, 8-??002B			; CL = bit(s) position of record
			     1		ROL	AL, CL				; shift value into position
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 193 - 1


			     1					ELSE
 F671  B1 01		     1		MOV	CL, ??002B			; CL = bit(s) position of record
 F673  D2 C8		     1		ROR	AL, CL				; shift value into position
			     1					ENDIF
			     1				ENDIF
			     1				IFNB <>
			     1		POP	DS
			     1		POP	CX
			     1				ENDIF
 F675  91			OUT_SZ PROC
 F676  33 F6				PUSH	AX
					MOV	AH, 0EH			; TTY output
				OUT_SZ_LOOP:
					LODS	BYTE PTR CS:[SI]		; AL = CS:[SI++]
					TEST	AL, AL			; is zero terminator?
					JZ	OUT_SZ_DONE			; if so, exit
					INT	10H
					JMP	SHORT OUT_SZ_LOOP
				OUT_SZ_DONE:
 F678					POP	AX
 F678  E3 0E				RET
 F67A				OUT_SZ ENDP
 F67A  AD			OUT_SZ_ATTR ENDP
 F67B  E8 00CC			POST_END_COL_STR ENDP
 F67E  E8 009E			POST_END_COL ENDP
 F681  E2 F7			
 F683  BE E4E1 R		;----------------------------------------------------------------------------;
 F686  EB 4D			; Locate cursor to column on current line
 F688				;----------------------------------------------------------------------------;
				; Input:
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <POST_NONE>,<SI>			; if SZ is not SI
 F688  BE FF4D R	     1		MOV	SI, OFFSET POST_NONE
			     1			ENDIF
 F68B  E8 005F		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 F68E  EB 42			; - AL = new col
 F690				;
				; Size: 23 bytes
 F690				;----------------------------------------------------------------------------;
				MOVE_COL PROC
							IF CPU_TYPE	EQ CPU_V20
					PUSHA					; preserve all registers
							ELSE
					PUSHX	AX, BX, CX, DX		; must preserve all of these
							ENDIF
					PUSH	AX				; preserve AL on INT 10H call
					XOR	BH, BH 			; video page 0
					MOV	AH, 3 			; get cursor position
					INT	10H 				; DH = row, DL = column
					POP	AX
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 194 - 1


				MOVE_COL_SET:
					MOV	DL, AL			; set new column
					MOV	AH, 2 			; set cursor position
					INT	10H 				; row = DH, column = DL
							IF CPU_TYPE	EQ CPU_V20
					POPA					; restore all registers
 F690							ELSE
					POPX	DX, CX, BX, AX
							ENDIF
					RET
				MOVE_COL ENDP
 F690				POST_COL ENDP
 F690  E8 0083			
 F693  58			;----------------------------------------------------------------------------;
 F694				; Display a zero-terminated string in BIOS at CS:[SI] with ending NL
 F694  50			;----------------------------------------------------------------------------;
 F695  B0 06			; Input: CS:SI = String
 F697				; Size: 12 bytes
 F697  53			;----------------------------------------------------------------------------;
 F698  8A E3			OUTLN_SZ PROC
 F69A  B9 0009				CALL	OUT_SZ			; write original string in SI
 F69D  BB 0003									; fall through to CRLF
 F6A0  E8 0038			
 F6A3  E8 0056			;----------------------------------------------------------------------------;
 F6A6  56			; Write a CRLF string to console
 F6A7  BE E4DC R		;----------------------------------------------------------------------------;
 F6AA  E8 0040			CRLF PROC
 F6AD  8A DC				PRINT_SZ  NL_Z, 1
 F6AF  4E				RET
 F6B0  B1 13			CRLF ENDP
 F6B2  51			
 F6B3  E8 0025			OUTLN_SZ ENDP
 F6B6  59			
 F6B7  5E			;----------------------------------------------------------------------------;
 F6B8  5B			; Write a space char to console (8 bytes)
 F6B9  58			;----------------------------------------------------------------------------;
 F6BA  C3			SPACE PROC
 F6BB					PUSH	AX				; no clobbery AX
					MOV	AX, DBW <0EH, ' '>	; AH = 0Eh, AL = space char
					INT	10H				; send to console
					POP	AX
					RET
 F6BB				SPACE ENDP
				
 F6BB  50			;----------------------------------------------------------------------------;
 F6BC  B4 0F			; Write Unsigned word as decimal to console
 F6BE  CD 10			;----------------------------------------------------------------------------;
 F6C0  3C 01			; Input: AX value
 F6C2  7E CC			; Clobbers: AX, BX
 F6C4  B0 20			;----------------------------------------------------------------------------;
 F6C6  E8 0033			OUT_DECU PROC
 F6C9  B0 26				MOV	BX, 10			; decimal divisor = 10
 F6CB  EB CA			OUT_DECU_R:
 F6CD					PUSH	DX				; save remainder digit / caller DX
					XOR	DX, DX 			; clear high word of dividend
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 195 - 1


					DIV	BX				; AX = DX:AX / 10, DX = DX:AX % 10
					TEST	AX, AX			; is zero?
					JZ	OUT_DECU_DONE		; loop while AX > 0
 F6CD					CALL	OUT_DECU_R			; recursive call to next division
 F6CD  E8 0002			OUT_DECU_DONE:
 F6D0  EB 44				XCHG	AX, DX			; AL = digit, AH = 0
 F6D2					XOR	AX, DBW <0EH, '0'>	; ASCII convert digit, AH = 0EH
					INT	10H				; write to console
					POP	DX				; restore digit
					RET
				OUT_DECU ENDP
				
				;----------------------------------------------------------------------------;
				; Write DWORD BX:AX as HEX to console
 F6D2				;----------------------------------------------------------------------------;
 F6D2  BE E4E0 R		; Input: BX:AX - 32 bit value to write
				; WORDS are separated by a colon ex: 1234:ABCD
				;
				; AX clobbered
				; Size: 50 bytes
				;----------------------------------------------------------------------------;
				DWORD_HEX PROC
 F6D5					PUSH	AX 				; save AX
 F6D5  B9 0002				MOV	AX, BX
 F6D8  BB 0003				CALL	WORD_HEX 			; write AX to console as HEX
					MOV	AL, ':'
					CALL	OUT_CHAR			; Write char in AL to console
					POP	AX 				; restore AX
				
				;--------------------------------------------------------------------------
				; Write WORD AX as HEX to console
				;--------------------------------------------------------------------------
				WORD_HEX PROC
					PUSH	AX 				; save AX
 F6DB					MOV	AL, AH 			; move high byte into low byte
 F6DB  50				CALL	BYTE_HEX 			; write byte as HEX to console
					POP	AX 				; restore AX
				
				;--------------------------------------------------------------------------
				; Write BYTE AL as HEX to console
 F6DC				;--------------------------------------------------------------------------
 F6DC  E8 F9A6			BYTE_HEX PROC
 F6DF  73 06				PUSH	AX 				; save AL
							IF CPU_TYPE	EQ CPU_V20
					DB	0FH, 28H, 0C0H		; ROL4 AL ; swap nibbles (V20 only)
 F6E1  80 E3 0F						ELSE
 F6E4  80 CB 07					REPT	4
					SHR	AL, 1				; move high nibble to low nibble		ENDM
							ENDIF
					CALL	NIB_HEX 			; write low nibble of AL as HEX to console
					POP	AX 				; restore AL
 F6E7				
 F6E7  B8 0920			;--------------------------------------------------------------------------
 F6EA  CD 10			; Write low nibble of AL as HEX to console
 F6EC  58			;--------------------------------------------------------------------------
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 196 - 1


				NIB_HEX PROC
					AND	AL, 0FH 			; isolate low nibble
					CMP	AL, 0AH 			; if < 0Ah, CF=1 and setup a -1 for ASCII
										;  adjust since 'A'-'9' is 7 (not 6)
					SBB	AL, -('0'+66H+1) 		; BCD bias for ASCII (30h + 66h + CF)
										;  AF = AL < 0Ah, CF = 1
										;  if > 9, high_nibble = 0Ah
 F6ED										;  if <=9, high_nibble = 09h
 F6ED  50				DAS					; BCD adjust to ASCII
 F6EE  B4 0E									;  if low_nibble < 0Ah, low_nibble -= 6
 F6F0										;  high_nibble -= 6
 F6F0  2E: AC			
 F6F2  84 C0			;--------------------------------------------------------------------------
 F6F4  74 04			; Write char in AL to console
 F6F6  CD 10			;--------------------------------------------------------------------------
 F6F8  EB F6			OUT_CHAR PROC
 F6FA					PUSH	AX
 F6FA  58				PUSH	BX
 F6FB  C3				XOR	BX, BX			; video page = 0
 F6FC					MOV	AH, 0EH			; Write AL to screen tty mode
 F6FC					INT	10H				; send to console
 F6FC					POP	BX
 F6FC					POP	AX
					RET
				
				OUT_CHAR ENDP
				NIB_HEX ENDP
				BYTE_HEX ENDP
				WORD_HEX ENDP
				DWORD_HEX ENDP
				
				;----------------------------------------------------------------------------;
 F6FC				; Delay using PIT counter increments of 125 ms
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = wait in 125 ms increments
				;
			     1				IFNB <AX>			; exit if last reg
 F6FC  50		     1		PUSH	AX 					; push register and repeat
			     1		PUSHX	BX, CX, DX, , , , 
			     2				IFNB <BX>			; exit if last reg
 F6FD  53		     2		PUSH	BX 					; push register and repeat
			     2		PUSHX	CX, DX, , , , , 
			     3				IFNB <CX>			; exit if last reg
 F6FE  51		     3		PUSH	CX 					; push register and repeat
			     3		PUSHX	DX, , , , , , 
			     4				IFNB <DX>			; exit if last reg
 F6FF  52		     4		PUSH	DX 					; push register and repeat
			     4		PUSHX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		PUSH	 					; push register and repeat
			     5		PUSHX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 197 - 1


			     2				ENDIF
			     1				ENDIF
				; AX clobbered
 F700  50			; Size: 53 bytes
 F701  32 FF			;----------------------------------------------------------------------------;
 F703  B4 03			IO_WAIT_MS_125 PROC
 F705  CD 10				MOV	AH, 125
 F707  58				MUL	AH				; AX = wait in 1 ms
 F708				
 F708  8A D0			;----------------------------------------------------------------------------;
 F70A  B4 02			; Delay using PIT counter increments of 1 ms
 F70C  CD 10			;----------------------------------------------------------------------------;
				; - Calculate the total number of PIT ticks necessary (where 1,193,000 = 1s)
				; - Latch the PIT and draw down the countdown total on each read.
				; - Exit when countdown underflows.
				;
			     1				IFNB <DX>			; exit if last reg
 F70E  5A		     1		POP	DX 					; pop register and repeat
			     1		POPX	CX, BX, AX, , , , 
			     2				IFNB <CX>			; exit if last reg
 F70F  59		     2		POP	CX 					; pop register and repeat
			     2		POPX	BX, AX, , , , , 
			     3				IFNB <BX>			; exit if last reg
 F710  5B		     3		POP	BX 					; pop register and repeat
			     3		POPX	AX, , , , , , 
			     4				IFNB <AX>			; exit if last reg
 F711  58		     4		POP	AX 					; pop register and repeat
			     4		POPX	, , , , , , 
			     5				IFNB <>			; exit if last reg
			     5		POP	 					; pop register and repeat
			     5		POPX	, , , , , , 
			     5				ENDIF
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
				; Note: Mode 3 (Square Wave) decements the readable counter by 2, so the
 F712  C3			; effective frequency of the counter is actually 2,386,360 Hz.
 F713				;
 F713				; Input:
				;	AX = wait in number of ms (clobbered)
				;
				; Based on contribution by @Raffzahn (under CC BY-SA 4.0):
				; https://retrocomputing.stackexchange.com/a/24874/21323
				;
				; https://stanislavs.org/helppc/8253.html
				;----------------------------------------------------------------------------;
 F713				IO_DELAY_MS PROC
 F713  E8 FFD7				PUSH	BX
					MOV	BX, 1193 * 2		; 1,193,180 / 1000 ms * 2 = 2,386 ticks/ms
				IO_DELAY_TICK PROC
					XCHG	AX, BX			; BX = wait ms
					PUSH	CX
					PUSH	DX
 F716					MUL	BX				; DX:AX = countdown of PIT ticks to wait
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 198 - 1


					XCHG	AX, BX			; DX:BX = countdown ticks
			     1			IFNB	<1>
 F716  56		     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <NL_Z>,<SI>			; if SZ is not SI
 F717  BE E46B R	     1		MOV	SI, OFFSET NL_Z
			     1			ENDIF
 F71A  E8 FFD0		     1		CALL	OUT_SZ
			     1			IFNB	<1>
 F71D  5E		     1		POP	SI
			     1			ENDIF
 F71E  C3				CALL	IO_WAIT_LATCH		; AX = start read
 F71F					MOV	CX, AX			; CX = last read
				IO_WAIT_MS_LOOP:
 F71F					CALL	IO_WAIT_LATCH		; AX = current counter reading
					SUB	CX, AX			; CX = # of ticks elapsed since last reading
					SUB	BX, CX			; subtract change in ticks from countdown
					MOV	CX, AX			; CX = save the last read
					SBB	DX, 0				; borrow out of high word (if necessary)
 F71F					JAE	IO_WAIT_MS_LOOP		; loop while countdown >= 0
 F71F  50				POP	DX
 F720  B8 0E20				POP	CX
 F723  CD 10				POP	BX
 F725  58			IO_WAIT_MS_DONE:
 F726  C3				RET
 F727				
				;----------------------------------------------------------------------------;
				; Latch PIT 0 and read counter to AX
				;----------------------------------------------------------------------------;
				; Output: AX = current counter
				; Time: 123 clock cycles (including CALL)
				;----------------------------------------------------------------------------;
				IO_WAIT_LATCH PROC
 F727					MOV	AL, PIT_CW <0, 0>		; Counter 0, Latch (00b)
 F727  BB 000A				PUSHF					; save current IF
 F72A					CLI					; disable interrupts
 F72A  52				OUT	PIT_CTRL, AL		; Write command to CTC
 F72B  33 D2				IN	AL, PIT_CH0			; Read low byte of Counter 0 latch
 F72D  F7 F3				MOV	AH, AL			; Save it
 F72F  85 C0				IN	AL, PIT_CH0			; Read high byte of Counter 0 latch
 F731  74 03				POPF					; restore IF state
 F733  E8 FFF4				XCHG	AL, AH			; convert endian
 F736					RET
 F736  92			IO_WAIT_LATCH ENDP
 F737  35 0E30			IO_DELAY_TICK ENDP
 F73A  CD 10			IO_DELAY_MS ENDP
 F73C  5A			IO_WAIT_MS_125 ENDP
 F73D  C3			
 F73E							IF POST_VIDEO_TYPE EQ 1
				;----------------------------------------------------------------------------;
				; POST Video Adapter Type Strings
				; 17 bytes
				;
				POST_VGA		DB	'VGA', 0
				POST_EGA		DB	'EGA', 0
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 199 - 1


				POST_CGA		DB	'CGA', 0
				POST_MDA		DB	'Mono', 0
							ENDIF
				
 F73E				;
 F73E  50			; 8 BYTES HERE
 F73F  8B C3			;
 F741  E8 0006			BYTES_HERE	INT_12
 F744  B0 3A			
 F746  E8 001C			;----------------------------------------------------------------------------;
 F749  58			; INT 12H - Memory Size Determination
				;----------------------------------------------------------------------------;
				; Output
				;	AX = number of contiguous 1k memory blocks found at startup
				;----------------------------------------------------------------------------;
 F74A						ORG 0F841H
 F74A  50			INT_12 PROC
 F74B  8A C4					ASSUME DS:_BDA
 F74D  E8 0001				STI 					; Interrupts on
 F750  58				PUSH	DS 				; save DS
					MOV	AX, SEG _BDA
					MOV	DS, AX 			; DS = BDA
					MOV	AX, MEM_SZ_KB 		; AX = DS:[MEM_SZ_KB]
					POP	DS
 F751					IRET
 F751  50			INT_12 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 11H - BIOS Equipment Determination / BIOS Equipment Flags
				;----------------------------------------------------------------------------;
				; Output
				;	AX = data stored at BIOS Data Area location 0040:0010
 F752  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
 F754  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
 F756  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
 F758  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
				;----------------------------------------------------------------------------;
 F75A  E8 0001					ORG 0F84DH
 F75D  58			INT_11 PROC
						ASSUME DS:_BDA
					STI 					; Interrupts on
					PUSH	DS 				; save DS
					MOV	AX, SEG _BDA
 F75E					MOV	DS, AX 			; DS = BDA
 F75E  24 0F				MOV	AX, EQUIP_FLAGS
 F760  3C 0A				POP	DS
					IRET
 F762  1C 69			INT_11 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 15 - System BIOS Services / Cassette
 F764  2F			;----------------------------------------------------------------------------;
				;	INT 15,0  Turn cassette motor on
				;	INT 15,1  Turn cassette motor off
				;	INT 15,2  Read blocks from cassette
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 200 - 1


				;	INT 15,3  Write blocks to cassette
				;
				; Output:
 F765				;	CF = 1, AH = 86H (unsupported/no cassette present)
 F765  50			;
 F766  53			; https://stanislavs.org/helppc/int_15.html
 F767  33 DB			; http://www.ctyme.com/intr/int-15.htm
 F769  B4 0E			; http://www.techhelpmanual.com/212-int_15h__at_extended_services___apm.html
 F76B  CD 10			;----------------------------------------------------------------------------;
 F76D  5B					ORG 0F859H
 F76E  58			INT_15 PROC
 F76F  C3				STI					; return with interrupts enabled
							IF CASSETTE EQ 1
 F770					CMP	AH, 3				; cassette function 0-3?
 F770					JBE	INT_15_CASS
 F770							ENDIF
 F770				
 F770					MOV	AH, 86H 			; return with unsupported function
				INT_15_EXIT:
					CMP	AH, 1				; set CF if error (AH > 0)
					CMC
					IRET_F				; IRET with current flags
				
							IF CASSETTE EQ 1
				;----------------------------------------------------------------------------;
				; INT 15H - 5150 Cassette
				;----------------------------------------------------------------------------;
				; Input:
 F770				;	ZF if AH = 3 (result of 'CMP AH, 3')
 F770  B4 7D			;
 F772  F6 E4			;----------------------------------------------------------------------------;
				; Huge thx to @Raffzahn for clean room specs!
				;
				; Further reading:
				;  https://nerdlypleasures.blogspot.com/2014/04/tape-cassettes-storage-with-ibm-pc-and.html
				;  http://fileformats.archiveteam.org/wiki/IBM_PC_data_cassette
				;  http://brutmanlabs.org/Cassette_Waveforms/Cassette_Waveforms.html
				;----------------------------------------------------------------------------;
				INT_15_CASS PROC
							ASSUME DS:_BDA
					PUSH	DS
					PUSH	DX				; scratch register
					MOV	DX, SEG _BDA		; DS = BDA
					MOV	DS, DX
					MOV	BIOS_BREAK, DH		; clear BIOS break key flag
					MOV	AL, AH			; AL = function
					LAHF					; save 'CMP AH, 3' flags
					DEC	AL				; is motor off function?
					JZ	CAS_MOTOR_OFF_DONE	; turn motor off and exit
										; otherwise fall through, turn on motor
 F774										; and do read/write operation or exit
 F774  53			
 F775  BB 0952			;----------------------------------------------------------------------------;
 F778				; INT 15,0 - Turn Cassette Motor On
 F778  93			;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 201 - 1


 F779  51			; Input:
 F77A  52			;	AH = 00
 F77B  F7 E3			;
 F77D  93			; - all programs using the cassette must actually turn on
 F77E  E8 0014			;	the device before use
 F781  8B C8			; - there is a noticeable delay between turn-on and device ready
 F783				; - a noticeable clicking noise can be heard by switching the
 F783  E8 000F			;	cassette on and off
 F786  2B C8			;----------------------------------------------------------------------------;
 F788  2B D9			
 F78A  8B C8			CAS_MOTOR_ON:
 F78C  83 DA 00			;----------------------------------------------------------------------------;
 F78F  73 F2			; - Disable Speaker
 F791  5A			; - Switch on Motor
 F792  59			; - Wait ca 0.5s
 F793  5B			;
 F794					IN	AL, PPI_B			; read current PPI B
 F794  C3				AND	AL, NOT MASK PBSP	AND NOT MASK PBCM	; Disable Speaker and
										; turn on (clear) motor bit
					OUT	PPI_B, AL			; send to PPI B
					SAHF					; restore 'CMP AH, 3' flags
					JPE	CAS_MOTOR_WAIT		; jump if read/write
										; otherwise fall through to exit
				
				;----------------------------------------------------------------------------;
 F795				; Return with success
 F795  B0 00			;
 F797  9C			INT_15_DONE_OK:
 F798  FA				MOV	AH, 0				; return with success
 F799  E6 43			
 F79B  E4 40			;----------------------------------------------------------------------------;
 F79D  8A E0			; Return with status in AH 
 F79F  E4 40			;
 F7A1  9D			INT_15_DONE:
 F7A2  86 C4				POP	DX				; restore working registers
 F7A4  C3			
 F7A5				INT_15_DONE_NO_DX:			; return without restoring DX
 F7A5					POP	DS
 F7A5					JMP	SHORT INT_15_EXIT
 F7A5				
				;----------------------------------------------------------------------------;
				; Turn off motor and return success (only read operation returns non-success)
				;
				CAS_MOTOR_OFF_DONE:
					CALL	CAS_TIMER_ON_MOTOR_OFF		
					JMP	SHORT INT_15_DONE_OK	; return with success
 F7A5 56 47 41 00		
 F7A9 45 47 41 00		;----------------------------------------------------------------------------;
 F7AD 43 47 41 00		; Re-enable timer and turn off motor
 F7B1 4D 6F 6E 6F 00		;
				CAS_TIMER_ON_MOTOR_OFF PROC
					IN	AL, INT_IMR			; Re-enable timer interrupt
					AND	AL, NOT MASK IRQ0		; unmask IRQ 0 (INT 8 Timer)
					OUT	INT_IMR, AL
				CAS_TIMER_ON_MOTOR_OFF ENDP
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 202 - 1


				
 F7B6			     1			LOCAL LBL
			     1	
 = 008B			     1	BYTES_HERE_INT_12 = INT_12-$
			     1	
			     1			IFDEF BYTES_HERE_INT_12
			     1			IF2
			     1			IF BYTES_HERE_INT_12 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_12 (BYTES_HERE_INT_12)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				;----------------------------------------------------------------------------;
				; INT 15,1 - Turn Cassette Motor Off
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 01
				;
				; - all programs using the cassette should turn off
				;	the device after use
 F841				; - a noticeable clicking noise can be heard by switching the
				;	cassette on and off
 F841  FB			;----------------------------------------------------------------------------;
 F842  1E			CAS_MOTOR_OFF PROC
 F843  B8 ---- R			IN	AL, PPI_B			; read current PPI port B status
 F846  8E D8				OR	AL, MASK PBCM 		; turn off (SET) motor bit
 F848  A1 0013 R			OUT	PPI_B, AL			; write back to port B	
 F84B  1F				RET
 F84C  CF			CAS_MOTOR_OFF ENDP
 F84D				
				;----------------------------------------------------------------------------;
				; Is Read/Write operation: Wait 0.5 sec for motor spinup
				;
				CAS_MOTOR_WAIT:
					PUSHF					; save flags
					MOV	AX, 500			; delay for 500ms
					CALL	IO_DELAY_MS
				
 F84D				;----------------------------------------------------------------------------;
				; Disable "noisy" INT 08h timer interrupt (could affect timing)
 F84D  FB			;
 F84E  1E				IN	AL, INT_IMR			; read IMR register
 F84F  B8 ---- R			OR	AL, MASK IRQ0		; mask IRQ 0 (INT 8 Timer)
 F852  8E D8				OUT	INT_IMR, AL			; write IMR
 F854  A1 0010 R		
 F857  1F				POPF					; ZF if write, NZ if read
 F858  CF				JZ	CAS_WRITE			; AH = 3 write
 F859					JMP	NEAR PTR CAS_READ		; near jump to read
				
				;----------------------------------------------------------------------------;
				; INT 15,3 - Write Blocks to Cassette
				;----------------------------------------------------------------------------;
				; Write a "chunk" of blocks to tape:
				;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 203 - 1


				; Input:
				;	AH = 03
				;	CX = count of bytes to write
				;	ES:BX = pointer to data buffer
				;
				; Output:
				;	AX clobbered
				;	CX = zero
				;	ES:BX = pointer to byte following last byte written
				;	Flags preserved
				;----------------------------------------------------------------------------;
 F859				; Format:
 F859  FB			; - One bit zero  (to start at defined timing)
				; - 256 bytes FFh (=2048 bits of 1) (Leader)
				; - One bit zero  (for sync)
				; - One byte 16h  (sync byte - MSB first)
				; - 1..n Data Blocks
				; - 4 bytes FFh   (=32 bits of 1)
 F85A  B4 86			;
 F85C				; Notes:
 F85C  80 FC 01			; - data is actually written in 256 byte blocks
 F85F  F5			; - if CX is less than 256, then the block is padded
				; - no error detection/correction is available for writing
 F860  CA 0002		     1		RETF	2
				;----------------------------------------------------------------------------;
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				;----------------------------------------------------------------------------;
				CAS_WRITE PROC
				
				;----------------------------------------------------------------------------;
				; Set Timer 2 to mode square and enable
				;
					MOV	AL, PIT_CW <2, 11B, 3>	; Select Timer 2, LE, Mode 3 (square), Binary
					OUT	PIT_CTRL, AL		; (10 11 011 0) Send to PIT control word (43H)
					IN	AL, PPI_B			; read PPI B
					OR	AL, MASK PBST		; turn on timer 2
					OUT	PPI_B, AL			; send to PPI B
				
				;----------------------------------------------------------------------------;
				; One bit zero (to start at defined timing)
				;
					CALL	CAS_WRITE_BIT		; start output bit is 0 (already NC from OR)
				
				;----------------------------------------------------------------------------;
				; 256 bytes FFh (=2048 bits of 1) (Leader)
				;
					PUSH	CX				; save outer byte loop counter
				CAS_WRITE_LEADER:
					STC					; leader output bit is 1
					MOV	CX, 256 * 8			; leader is 2048 bits
				CAS_WRITE_LEADER_LOOP:
					CALL	CAS_WRITE_BIT		; set timer to correct bit, wait for full cycle
					LOOP	CAS_WRITE_LEADER_LOOP
					POP	CX				; restore outer byte loop counter
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 204 - 1


				
				;----------------------------------------------------------------------------;
				; One bit zero (for sync)
				;
					CLC					; sync output bit is 0
					CALL	CAS_WRITE_BIT
				
				;----------------------------------------------------------------------------;
				; One byte 16h (sync byte - MSB first)
				;
					MOV	AL, SYN			; SYN C0 control char
					CALL	CAS_WRITE_BYTE		; write sync byte
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BLOCKS: Output 1..n Data Blocks
				;----------------------------------------------------------------------------;
				;- Output loop (BLOCK)
				;  - Init CRC
				;  - Block loop (BYTE)
				;
				; Input: CX = blocks to write
				;----------------------------------------------------------------------------;
				CAS_WRITE_BLOCKS PROC
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BLOCK: loop until 256 bytes transfered
				;----------------------------------------------------------------------------;
				; - Fetch byte if not exhausted
				; - Byte loop (BIT)
				;
				CAS_WRITE_BLOCK PROC
					MOV	CAS_CRC, CAS_CRC_PRE	; Init CRC preset
					XOR	DX, DX			; block counter DX = 0
				CAS_WRITE_BLOCK_LOOP:
					MOV	AL, ES:[BX]			; AL = next byte
					INC	BX
					CALL	CAS_WRITE_BYTE		; write to cassette
					DEC	DL				; loop until 00
					LOOPNZ CAS_WRITE_BLOCK_LOOP	; loop while DX > 0 and CX > 0
					JZ	CAS_WRITE_CRC		; if DX = 0, current block is done
				
				;----------------------------------------------------------------------------;
				; CX is 0, DX > 0 - done writing bytes, fill the remaining space in the
				; 256 byte block with same char.
				;
				CAS_WRITE_BLOCK_PAD:
					XCHG	CX, DX			; otherwise write out the rest
				CAS_WRITE_PAD_LOOP:
					CALL	CAS_WRITE_BYTE
					LOOP	CAS_WRITE_PAD_LOOP
					XCHG	CX, DX			; restore CX
				
				;----------------------------------------------------------------------------;
				; Done writing block and DX = 0
				; - Write One's complement of CRC to cassette
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 205 - 1


				;
				CAS_WRITE_CRC:
					MOV	AX, CAS_CRC			; get working CRC
					NOT	AX				; one's complement it
					CALL	CAS_WRITE_WORD		; write to cassette
				
				CAS_WRITE_BLOCK ENDP
				
				;----------------------------------------------------------------------------;
				;- Do output loop while still input bytes
				;
					INC	CX				; any more bytes left to write?
					LOOP	CAS_WRITE_BLOCK		; write another block if so
				
				CAS_WRITE_BLOCKS ENDP
				
				;----------------------------------------------------------------------------;
				; Finish transfer
				;----------------------------------------------------------------------------;
				; Write 4 Byte FF trailer (32 bits of 1) / 4 bytes FFh   (=32 bits of 1)
				;
				CAS_WRITE_TRAILER:
					STC					; trailer output bit is 1
					MOV	CL, 4 * 8			; trailer is 4 bytes
				CAS_WRITE_TRAILER_LOOP:
					CALL	CAS_WRITE_BIT		; set timer to CF bit, wait for full cycle
					LOOP	CAS_WRITE_TRAILER_LOOP
				
				;----------------------------------------------------------------------------;
				;- Turn off timer 2
				;- Set Timer 2 to 1
				;
					MOV	AL, PIT_CW <2, 11B, 0>	; Select Timer 2, LE, Mode off, Binary
					OUT	PIT_CTRL, AL		; (10 11 000 0) Send to PIT control word
				
				;----------------------------------------------------------------------------;
				;- Re-enable INT 8 timer interrupt
				;- Switch Motor off and exit
				;
					JMP	 SHORT CAS_MOTOR_OFF_DONE
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BIT: Write a single bit to tape
				;----------------------------------------------------------------------------;
				; Input:
				; 	CF bit: 1 or 0 (preserved)
				;
				; AL preserved, AH clobbered
				;----------------------------------------------------------------------------;
				; Things you must do:
				;
				; - Extract MSB (RCL)
				; - Write 0 or 1
				; 	- 0 = 2.015 KHz (592 timer cycles)
				;	- 1 = 1.007 KHz (1184 timer cycles)
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 206 - 1


				; - Add to CRC message
				;----------------------------------------------------------------------------;
				CAS_WRITE_BIT PROC
					LAHF					; preserve CF flag
					PUSH	AX				; preserve AX
					MOV	AX, BEEP_1K7		; set for 1 = ~1 ms  (1.007 KHz = 1,193,180/1184)
					JC	CAS_START_TIMER		; if input bit is a 1, AX already set
					SHR	AX, 1				; set for 0 = ~0.5ms (2.015 KHz = 1,193,180/592)
				CAS_START_TIMER:
					OUT	PIT_CH2, AL			; send low byte to timer
				 	XCHG	AL, AH 			; select high byte
				 	OUT	PIT_CH2, AL			; send high byte to timer
				
				;----------------------------------------------------------------------------;
				; Read Timer 2 and wait a full rising and falling flank
				;
				CAS_WRITE_RISE:
					IN	AL, PPI_C			; read PPI C
					TEST	AL, MASK PCT2		; is cassette output low?
					JZ	CAS_WRITE_RISE		; loop until rise
				CAS_WRITE_FALL:
					IN	AL, PPI_C			; read PPI C
					TEST	AL, MASK PCT2		; is cassette output high?
					JNZ	CAS_WRITE_FALL		; loop until fall
				 	POP	AX				; restore AL for next call
				 	SAHF					; restore CF flag for next call
					RET
				CAS_WRITE_BIT ENDP
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_WORD: Write a little endian word to tape
				;----------------------------------------------------------------------------;
				; Input:
				; 	AX: word to write (preserved)
				;----------------------------------------------------------------------------;
				CAS_WRITE_WORD PROC
					XCHG	AH, AL			; MSB first
					CALL	CAS_WRITE_BYTE		; write MSB
					XCHG	AH, AL			; LSB
										; fall through to write LSB
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BYTE: Write a single byte to tape
				;----------------------------------------------------------------------------;
				; Input:
				; 	AL: byte to write (preserved)
				;----------------------------------------------------------------------------;
				CAS_WRITE_BYTE PROC
					PUSH	AX
					PUSH	CX
					MOV	CX, 8				; loop 8 bits
				CAS_WRITE_BYTE_LOOP:
					SHL	AL, 1				; CF = next bit to write
					CALL	CAS_WRITE_BIT		; write bit in CF
					CALL	CAS_CRC_ADD			; add to working CRC
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 207 - 1


					LOOP	CAS_WRITE_BYTE_LOOP
					POP	CX
					POP	AX
					RET
				CAS_WRITE_BYTE ENDP
				CAS_WRITE_WORD ENDP
				
				CAS_WRITE ENDP
				
				;----------------------------------------------------------------------------;
				; CAS_CRC_ADD: Add current bit to CRC message
				;----------------------------------------------------------------------------;
				; Input:
				;	CF = bit to add
				;----------------------------------------------------------------------------;
				; This is (effectively) CRC16-CCITT as used by IBM for SDLC/HDLC. It uses a
				; 0FFFFh initial/preset value, 1021h polynomial and has an expected residue
				; value of 01D0Fh.
				;
				; cf = ( ( crc & 0x8000 ) >> 15 ) ^ CF;
				; if ( cf ) {
				;	crc = crc ^ 0x0810;
				; }
				; crc = crc << 1 | cf;
				; return crc;
				;
				; https://stackoverflow.com/questions/62771192/crc16-ccitt-calculation
				; http://bitsavers.trailing-edge.com/pdf/ibm/datacomm/GA27-3093-3_SDLC_Concepts_Jun86.pdf
				;----------------------------------------------------------------------------;
				CAS_CRC_PRE		EQU	0FFFFh	; Cassette CRC16-CCITT preset value
				CAS_CRC_RES		EQU	01D0Fh	; Cassette CRC16-CCITT residue value
				CAS_CRC_POLY 	EQU 	01021h	; Cassette CRC16-CCITT polynomial
				
				CAS_CRC_ADD PROC
					XCHG	AX, CAS_CRC			; get working CRC, save AX
					RCR	AX, 1				; set up for RCL
					RCL	AX, 1				; OF = MSB(AX) XOR CF
					CLC					; CF = OF
					JNO	CAS_CRC_SHIFT		; if OF: AX = AX XOR 0810h
					XOR	AX, CAS_CRC_POLY SHR 1	; divide by polynomial (already shifted)
					STC					; CF = OF
				CAS_CRC_SHIFT:
					ADC	AX, AX			; shift and add bit to working CRC value
					XCHG	CAS_CRC, AX			; store working CRC, restore AX
					RET
				CAS_CRC_ADD ENDP
				
				;----------------------------------------------------------------------------; 
				; INT 15,2 - Read Blocks from Cassette 
				;----------------------------------------------------------------------------; 
				; Input:
				;	AH = 02
				;	CX = count of bytes to read
				;	ES:BX = pointer to data buffer
				;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 208 - 1


				; Output:
				;	CF = 1 if error
				;	AH = result:
				;	  00h = successful
				;	  01h = CRC error
				;	  02h = bad tape signals / data transition lost
				;	  04h = no data / timeout / general failure
				;
				;	DX = count of bytes actually read
				;	ES:BX = pointer to byte following last byte read
				;----------------------------------------------------------------------------;
				; Notes:
				;
				; - Data is transferred in 256 byte blocks, though only the
				;	number of bytes requested are actually stored
				; - Mask INT 8 Timer interrupts (IRQ 0) during actual read 
				;	(could affect timing)
				;
				; Data Format:
				;
				; - One bit zero  (to start at defined timing)
				; - 256 bytes FFh (2048 bits of 1) (Leader)
				; - One bit zero  (for sync)
				; - One byte 16h  (sync byte - MSB first)
				; - 1..n Data Blocks
				; - 4 bytes FFh   (=32 bits of 1)
				;----------------------------------------------------------------------------;
				CAS_READ PROC NEAR
					PUSH	SI				; call-preserve SI
					MOV	SI, 5				; set timeout/retry counter
					PUSH	DI
					MOV	DI, BX			; DI = output buffer
					PUSH	CX				; save bytes to read
				
				;----------------------------------------------------------------------------;
				; CAS_READ_HEADER_START: Search for leader
				;----------------------------------------------------------------------------;
				; - Must read at least 32 bytes of FFh
				; - Timeout/Error if > 1000 invalid bytes are read
				; - Must check for Ctrl-Break in all loops
				; - Retry reading header 5 times
				;----------------------------------------------------------------------------;
				CAS_READ_HEADER_START:
					IN	AL, PPI_C			; read PPI C
					AND	AL, MASK PCCI		; mask only cassette input
					MOV	CAS_PREV, AL		; save initial value
				
				;----------------------------------------------------------------------------;
				; Continue reading until a valid cycle detected or timeout
				;
					MOV	CX, 1000 * 8 * 2		; timeout is 1000 bytes
				CAS_READ_HEADER_LOOP:
					TEST	BIOS_BREAK, 10000000b	; Test BIOS break flag
					JNZ	CAS_READ_ERR_1		; Break key was hit
					CALL	CAS_READ_CYCLE		; loop until bit detected or timeout
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 209 - 1


					LOOPZ	CAS_READ_HEADER_LOOP
					JCXZ	CAS_READ_ERR		; return with general error
				
				;----------------------------------------------------------------------------;
				; Read Leader up to sync bit:
				; - If read error, start over from beginning
				; - Read at least 32 consecutive FFh bytes
				;	- if >= 32 bytes
				;		- if 0, read corresponding high cycle and continue
				;		- if 1, continue reading until sync bit (0) detected
				;	- if < 32 bytes and 0 read, start over from beginning
				;
					MOV	CX, 32 * 8 * 2		; leader must be at least 32 bytes
				CAS_READ_HEADER_LOOP_1:
					TEST	BIOS_BREAK, 10000000b	; Test BIOS break flag
				CAS_READ_ERR_1:				; (short jump hack)
					JNZ	CAS_READ_ERR		; exit if break key was hit
				
				;----------------------------------------------------------------------------;
				; Read cycle transition, start over if error
				;
					CALL	CAS_READ_CYCLE		; read (ZF if failure, NZ if success)
					JZ	CAS_READ_HEADER_START	; if error, start over 32 byte count
				
				;----------------------------------------------------------------------------;
				; Calculate cycle length - is a 1 or 0?
				;
					CMP	DX, (BEEP_1K7+BEEP_2K)/2; is cycle > 1 length + 33%?
					JCXZ	CAS_READ_HEADER_SYNC	; if at least 32 FFh bytes, check for sync bit
					JB	CAS_READ_HEADER_START	; if a 0 and not 32 FFh's, start over
					LOOP	CAS_READ_HEADER_LOOP_1	; otherwise decrement counter of 1's.
				
				;----------------------------------------------------------------------------;
				; At least 32 x 1's have been found (CX = 0):
				; - if bit is 0, it is the sync bit
				; - if bit is 1, keep reading out the remaining 1's
				;
				CAS_READ_HEADER_SYNC:
					JAE	CAS_READ_HEADER_LOOP_1	; jump if 1 is read (keep reading for 1's)
					CALL	CAS_READ_CYCLE		; wait for sync bit high cycle to complete
				
				;----------------------------------------------------------------------------;
				; Read and verify sync byte
				;
					CALL	CAS_READ_BYTE		; read first byte
					CMP	AL, SYN			; is sync byte?
					JNE	CAS_READ_ERR		; error if not
				
				;----------------------------------------------------------------------------;
				; CAS_READ_BLOCKS
				;----------------------------------------------------------------------------;
				; - Reset CRC to initial preset
				; - Always loop 256 times (bytes)
				; - Check for Ctrl-Break
				; - If successful read, write to ES:[DI]
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 210 - 1


				; - If failed read, exit with data error (04h)
				; - If requested bytes < 256, read (and discard) remaining bytes
				; - Read and verify CRC. If bad CRC exit with CRC error (01h)
				; - If CX > 0, restart block loop
				;----------------------------------------------------------------------------;
					POP	CX				; restore counter
					PUSH	CX				; rebalance stack
				CAS_READ_BLOCKS PROC
					MOV	CAS_CRC, CAS_CRC_PRE	; set CRC to initial preset
					MOV	BH, 0				; loop 256 bytes
				CAS_READ_BLOCK_LOOP:
					TEST	BIOS_BREAK, 10000000b	; Test BIOS break flag
					JNZ	CAS_READ_ERR		; exit if break key was hit
					CALL	CAS_READ_BYTE		; read next full byte
					MOV	AH, 2				; data error
					JC	CAS_READ_EXIT		; exit if error
					STOSB					; write to output buffer
					DEC	BH				; dec block counter
					LOOPNZ CAS_READ_BLOCK_LOOP	; loop if block and byte counters > 0
					JZ	CAS_READ_VERIFY_CRC	; if end of requested bytes, jump to CRC
				
				;----------------------------------------------------------------------------;
				; CX is 0, DX > 0 - done reading bytes, skip the remaining padding bytes
				;
					MOV	CL, BH			; CX = remaining bytes to read
				CAS_READ_BLOCK_PAD:
					CALL	CAS_READ_BYTE		; read next full byte
					JC	CAS_READ_ERR		; exit if error
					LOOP	CAS_READ_BLOCK_PAD
				
				;----------------------------------------------------------------------------;
				; Verify CRC - read CRC bytes and compare to known residue
				;
				; https://stackoverflow.com/questions/241605/crc-preset-and-residue
				;
				CAS_READ_VERIFY_CRC:
					CALL	CAS_READ_WORD		; read final two CRC bytes, adding to CRC
					JC	CAS_READ_ERR		; 
					CMP	CAS_CRC, CAS_CRC_RES	; is expected CRC-CCITT residue (01D0Fh)?
					MOV	AH, 1				; CRC error
					JNE	CAS_READ_EXIT
					INC	CX				; any more bytes left to read?
					LOOP	CAS_READ_BLOCKS		; if so, read another block
					MOV	AH, 0				; no error
					JMP	SHORT CAS_READ_EXIT
				
				CAS_READ_BLOCKS ENDP
				
				;----------------------------------------------------------------------------;
				; General / timeout error
				;
				CAS_READ_ERR PROC
					DEC	SI				; dec retry counter
					JNZ	CAS_READ_HEADER_START	; if not 0, retry header read
					MOV	AH, 4				; general/timeout error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 211 - 1


				CAS_READ_ERR ENDP
				
				;----------------------------------------------------------------------------;
				; Re-enable interrupts, set return values
				;
				CAS_READ_EXIT:
					POP	DX				; DX = original bytes to read
					SUB	DX, CX			; DX = actual bytes read (subtract bytes remaining)
					MOV	BX, DI			; BX = pointer to end of output buffer
					POP	DI				; restore original DI
					POP	SI
					POP	DS				; discard original DX
					CALL	CAS_TIMER_ON_MOTOR_OFF	; Re-enable timer and motor off
					JMP	INT_15_DONE_NO_DX		; exit without restoring DX
				
				;----------------------------------------------------------------------------;
				; CAS_READ_WORD: read 16 bits, add to working CRC
				;----------------------------------------------------------------------------;
				; Output:
				;	AX = word read (little endian)
				;	CF if error
				;----------------------------------------------------------------------------;
				CAS_READ_WORD PROC
					CALL	CAS_READ_BYTE
					JC	CAS_READ_BYTE_RET
				
				;----------------------------------------------------------------------------;
				; CAS_READ_BYTE: read 8 bits, add to working CRC
				;----------------------------------------------------------------------------;
				; Output:
				;	AL = byte read
				;	CF if error
				;
				; Clobbers: AH, BL, DX
				;----------------------------------------------------------------------------;
				CAS_READ_BYTE PROC
					PUSH	CX				; save CX
					MOV	CX, 8				; loop 8 bits
				
				;----------------------------------------------------------------------------;
				; CAS_READ_BIT: read 1 bit (2 cycles)
				;----------------------------------------------------------------------------;
				CAS_READ_BIT PROC
				CAS_READ_BIT_LOOP:
					CALL	CAS_READ_CYCLE		; DX = read low cycle length
					STC					; presume failure
					JZ	CAS_READ_BYTE_EXIT	; exit if unable to read
					PUSH	DX				; save low length
					CALL	CAS_READ_CYCLE		; DX = read high cycle length
					POP	AX				; AX = low length
					STC					; presume failure
					JZ	CAS_READ_BYTE_EXIT
					ADD	AX, DX			; AX = full cycle length
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 212 - 1


				; Determine bit value based on full cycle duration with 33% tolerance.
				;
				; 1: 2t * 1193180 (Hz) / 1007 Hz = ~ 2368 ticks
				; 0: 2t * 1193180 (Hz) / 2014 Hz = ~ 1184 ticks
				; (Note: raw timer counter readings are doubled, so must be adjusted by 2x)
				;
				; BEEP_1K7 = 1184 ticks = ~1007 Hz
				; BEEP_2K  = 592 ticks  = ~2014 Hz
				;
				; Use median of values to determine maximum length of a '1' bit cycle:
				; 1184 + 592 -> 1776 / 2 = ~ 1344 Hz = ~ 33% tolerance
				;
					MOV	DX, BEEP_1K7 + BEEP_2K	; DX = median cycle length
					CMP	DX, AX			; above or below median freq?
					CALL	CAS_CRC_ADD			; add bit to working CRC
					CMP	DX, AX			; above or below median freq?
					ADC	BL, BL			; add bit to result
					LOOP	CAS_READ_BIT_LOOP
					MOV	AL, BL			; AL = result
				CAS_READ_BIT ENDP
					CLC					; no error
				CAS_READ_BYTE_EXIT:
					POP	CX
				CAS_READ_BYTE_RET:
					RET
				
				CAS_READ_BYTE ENDP
				CAS_READ_WORD ENDP
				
				;----------------------------------------------------------------------------;
				; CAS_READ_CYCLE: read 1 cycle
				;----------------------------------------------------------------------------;
				; Time a single cycle of a bit 
				; Output:
				;	AX = counter reading
				;	DX = lendth of cycle in counter ticks
				;	NZ if success
				;	ZF if failure (cycle exceeded maximum possible length)
				;----------------------------------------------------------------------------;
				CAS_READ_CYCLE PROC
					PUSH	CX				; call-preserve CX
					MOV	CX, 100			; timeout value
					MOV	AH, CAS_PREV		; AH last input register value
				CAS_READ_CYCLE_LOOP:
					IN	AL, PPI_C			; read PPI C
					AND	AL, MASK PCCI		; mask only cassette input
					CMP	AL, AH			; ZF if reading is same as last
					LOOPZ	CAS_READ_CYCLE_LOOP	; loop until change or timeout
					MOV	CAS_PREV, AL		; save new input value
					CALL	IO_WAIT_LATCH		; latch and read PIT counter into AX
					MOV	DX, CAS_TIME_CNT		; DX = last counter reading
					SUB	DX, AX			; DX = difference of last and current
					MOV	CAS_TIME_CNT, AX		; update counter read
					TEST	CX, CX			; ZF if timeout, NZ if success
					POP	CX
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 213 - 1


					RET
				CAS_READ_CYCLE ENDP
				CAS_READ ENDP
				
				INT_15_CASS ENDP
							ENDIF			; ENDIF CASSETTE EQ 1
				INT_15 ENDP
				
				;----------------------------------------------------------------------------;
				;
				; Features not included in 5150/Cassette build go below:
				;
				;----------------------------------------------------------------------------;
				
							IF POST_HD_PARMS EQ 1
				;----------------------------------------------------------------------------;
				; Display Hard Drive Parameters
				;----------------------------------------------------------------------------;
				; Display info for POST in drive DL
				;
				; Input:
				;	DL = drive #
				;
				; Clobbers: AX, BX
				;
				; Size: 100 bytes
				;----------------------------------------------------------------------------;
				SHOW_DISK_PARAMS PROC
					PUSHX	CX, DX				; call preserve working registers
					PUSH	DX					; save drive ID
					CALL	GET_DISK_PARAMS			; AL=heads, BX=cyl, CL=sec, DL=#drives
					POP	DX					; restore drive ID
					JC	SHOW_DISK_PARAMS_DONE		; exit if error getting drive
					PUSH	CX					; save sectors/track for CHS display
					PUSH	AX					; save heads
					PUSH	BX					; save cylinders
				
				;----------------------------------------------------------------------------;
				; Display Drive letter
				;
					SET_SZ_ATTR	 POST_CLR_TXT, 1, 1	; set next char to be text color
					XCHG	AX, DX				; AL = drive ID, DX = # of heads
					AND	AL, 0011B				; only drives 0-3
					ADD	AL, 'C'				; convert to drive letter
					CALL	OUT_CHAR
				
				;----------------------------------------------------------------------------;
				; Display HD size: MiB = C*H*S*512/1024/1024 = C*H*S/2048
				;
					XCHG	AX, DX				; AX = # of heads
					MUL	CL					; AX = heads * sectors
					MUL	BX					; DX:AX = heads * sectors * cyl
					MOV	CX, 1024 * (1024 / 512)		; AX = DX:AX / 2048
					DIV	CX					; (size in MB)
					POST_COL_1	POST_HD, POST_CLR_VAL1	; start column 1, SI = POST_MB
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 214 - 1


					CALL	OUT_DECU				; print size in MB
					CALL	OUT_SZ				; 'MB' (SI = POST_MB from above)
					POP	AX					; AX = cylinders
					POST_COL_END				; end column 1
				
				;----------------------------------------------------------------------------;
				; Display HD geometry: Cylinders Heads Sectors
				;
					POST_COL_2	POST_CHS, POST_CLR_VAL1 ; start column 2
					CALL	OUT_DECU				; print # cylinders
					CALL	SPACE
					POP	AX					; AX = heads
					CALL	OUT_DECU_R				; print # heads
					CALL	SPACE
					POP	AX					; AX = sectors/track
					CALL	OUT_DECU_R				; print sec/track
					POST_COL_END_NL				; end column 2
				
				SHOW_DISK_PARAMS_DONE:
					POPX	DX, CX				; restore working registers
					RET
				
				POST_CHS	DB	'CHS', 0			; CHS column 2 label
				
				SHOW_DISK_PARAMS ENDP
				
							ENDIF
				
							IF POST_TEST_SEEK EQ 1
				;-------------------------------------------------------------------------
				; FDC_RECAL_SEEK_TEST: Reset, Recalibrate and Seek test a floppy drive at POST
				;-------------------------------------------------------------------------
				; Input:
				;	DL = drive # to test (0 = A:, 1 = B:, etc)
				; Output:
				;	CF if error
				;	Clobbers SI, AX
				;
				; Size: 38 bytes
				;-------------------------------------------------------------------------
				FDC_RECAL_SEEK_TEST PROC
					PUSH	CX
					CALL	FDC_RECAL				; Motor on, recal, DL = drive
					JC	FDC_TEST_DRIVE_EXIT		; exit if error
					JWB	FDC_TEST_DRIVE_DONE		; skip seek tests on warm boot
					IO_DELAY					; short pause before seek, CX=0
					MOV	SI, OFFSET FDC_SEEK_TRACKS
				FDC_TEST_DRIVE_SEEK:
					LODS	BYTE PTR CS:[SI]			; next track to seek
					MOV	CH, AL				; CH = track
					PUSH	CX					; CX clobbered by FDC_SEEK
					CALL	FDC_SEEK				; CH = track, DL = drive
					POP	CX					; restore CX
					JCXZ	FDC_TEST_DRIVE_DONE		; exit if track = 0
					JNC	FDC_TEST_DRIVE_SEEK		; loop unless error
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 215 - 1


				FDC_TEST_DRIVE_DONE:
							IF IS_TURBO
					MOV	CH, 80H				; longer delay for faster PCs
							ELSE
					MOV	CH, 40H
							ENDIF
					IO_DELAY					; delay between drives
				FDC_TEST_DRIVE_EXIT:
					POP	CX
					RET
				
				;----------------------------------------------------------------------------;
				; Track seek pattern for POST seek test
				;
				FDC_SEEK_TRACKS	DB	38, 2, 19, 0		; tracks (0 is end)
				
				FDC_RECAL_SEEK_TEST ENDP
							ENDIF
				
						IF RANDOM_TAGLINE EQ 1
				;----------------------------------------------------------------------------;
				; Display BIOS name and random tagline
				;----------------------------------------------------------------------------;
				; String is chosen from low two bits of BP
				; Clobbers: AX
				;----------------------------------------------------------------------------;
				HELLO_RAND_TAGLINE PROC
					PRINT_SZ  TOP_BANNER		; display main banner
					MOV	AX, BP			; get random bits from BP
					POST_FLAG_CLR  GRND		; clear random bits from BP
					AND	AX, MASK GRND		; mask only low 2 bits
					XCHG	AX, SI			; SI = string offset table
					SHL	SI, 1				; word align
					MOV	SI, CS:TAGS[SI]		; SI = chosen tagline offset
					PRINT_SZ  SI			; display tagline
					PRINTLN_SZ  COPYRIGHT		; display copyright message
					RET
				
				;----------------------------------------------------------------------------;
				; Three additional random taglines
				;
				TAG1		DB	'An Energy Star Foe', 0
				TAG2		DB	'Abort, Retry, Succeed', 0
				TAG3		DB	'When life gives you lemonade', 0
				;		DB	'Smoke Edition'
				;		DB	'Reimagined without Ray Tracing', 0
				;		DB	'Now 97% asbestos-free', 0
				;		DB	'Ought to be enough for anybody', 0
				
				;----------------------------------------------------------------------------;
 F863				; Offset table for taglines
				;
				TAGS		DW	OFFSET TAG0, OFFSET TAG1, OFFSET TAG2, OFFSET TAG3
				
				HELLO_RAND_TAGLINE ENDP
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 216 - 1


						ENDIF
				
						IF POST_OPT_ROM EQ 1
				;----------------------------------------------------------------------------;
				; ROM scan loading - display segment, size and checksum error
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = BIOS size in bytes
				;	DI = Option ROM scan end segment
				;	DL = ROM checksum value
				; Clobbers: BX, DX
				;----------------------------------------------------------------------------;
				ROM_SCAN_POST PROC
					PUSH	AX						; must call-preserve these
					PUSH	SI
					PUSHF
 F863				
				;----------------------------------------------------------------------------;
			     1				IFNB <CX>			; exit if last reg
 F863  51		     1		PUSH	CX 					; push register and repeat
			     1		PUSHX	DX, , , , , , 
			     2				IFNB <DX>			; exit if last reg
 F864  52		     2		PUSH	DX 					; push register and repeat
			     2		PUSHX	, , , , , , 
			     3				IFNB <>			; exit if last reg
			     3		PUSH	 					; push register and repeat
			     3		PUSHX	, , , , , , 
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F865  52			; Ensure this is not scanning a display option ROM - could crash if ISR not
 F866  E8 EEB5			; installed
 F869  5A			;
 F86A  72 54				CMP	DI, 0C800H					; is video ROM scan?
 F86C  51				JBE	ROM_SCAN_POST_EXIT			; exit if so
 F86D  50			
 F86E  53			;----------------------------------------------------------------------------;
				; Display ROM column
				;
					PUSH	AX						; save ROM size
					POST_COL_1  S_OPT_ROM, POST_CLR_VAL2	; start ROM column label
					MOV	AX, DS					; AX = ROM segment
			     1			IFNB	<1>
 F86F  50		     1		PUSH	AX
 F870  53		     1		PUSH	BX
 F871  51		     1		PUSH	CX
			     1			ENDIF ; IFNB
 F872  B8 0920		     1		MOV	AX, DBW <9, VID_SP>	; AH = write char w/attr, AL = space
			     1			IFDIFI <POST_CLR_TXT>,<BL>	; if ATTR is not BL
 F875  BB 0003		     1		MOV	BX, LOW POST_CLR_TXT		; BH = video page 0, BL = attribute
			     1			ENDIF	; IFDIFI
 F878  B9 0001		     1		MOV	CX, 1			; CX = repeat times
 F87B  CD 10		     1		INT	10H
			     1			IFNB	<1>
 F87D  59		     1		POP	CX
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 217 - 1


 F87E  5B		     1		POP	BX
 F87F  58		     1		POP	AX
			     1			ENDIF	; IFNB
 F880  92				CALL	WORD_HEX					; display as hex
 F881  24 03				POST_COL_END					; end column 1
 F883  04 43				POP	AX
 F885  E8 FEDD			
				;----------------------------------------------------------------------------;
				; Display Size or Checksum column
				;
					POPF							; restore checksum flag
 F888  92				PUSHF							; re-save flag
 F889  F6 E1				JNZ	ROM_SCAN_POST_CHK				; jump if checksum error
 F88B  F7 E3				PUSH	AX						; save ROM size again
 F88D  B9 0800				POST_COL_2  S_OPT_SIZE, POST_CLR_VAL2	; start Size column 2
 F890  F7 F1				POP	AX
					XCHG	AH, AL					; convert bytes to KB
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 F892  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 F894  BE E4B4 R	     1		MOV	SI, OFFSET POST_HD
 F897  E8 FDFA		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
 F89A  E8 FE8A				SHR	AL, 1
 F89D  E8 FE4D				SHR	AL, 1
 F8A0  58				CALL	OUT_DECU					; write size as decimal
					PRINT_SZ	S_OPT_K				; display KB unit
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 F8A1  E8 FE2E		     1		CALL	POST_END_COL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				
				ROM_SCAN_POST_DONE:
					POST_COL_END_NL					; end column
				
				ROM_SCAN_POST_EXIT:
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 F8A4  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 218 - 1


 F8A6  BE F8C3 R	     1		MOV	SI, OFFSET POST_CHS
 F8A9  E8 FE0F		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 F8AC  E8 FE78				POPF
 F8AF  E8 FE6D				POP	SI
 F8B2  58				POP	AX
 F8B3  E8 FE74				RET
 F8B6  E8 FE66			
 F8B9  58			;----------------------------------------------------------------------------;
 F8BA  E8 FE6D			; Display checksum error
				;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 F8BD  E8 FE0D		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				ROM_SCAN_POST_CHK:
 F8C0					POST_COL_2  POST_ERR_ERR, RED			; 'Error' with red text
					PRINT_SZ	S_OPT_CHK				; display 'Checksum' message
			     1				IFNB <DX>			; exit if last reg
 F8C0  5A		     1		POP	DX 					; pop register and repeat
			     1		POPX	CX, , , , , , 
			     2				IFNB <CX>			; exit if last reg
 F8C1  59		     2		POP	CX 					; pop register and repeat
			     2		POPX	, , , , , , 
			     3				IFNB <>			; exit if last reg
			     3		POP	 					; pop register and repeat
			     3		POPX	, , , , , , 
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 F8C2  C3				MOV	AL, DL					; AL = computed checksum
					CALL	BYTE_HEX					; write as hex byte
 F8C3 43 48 53 00			JMP	ROM_SCAN_POST_DONE			; end column and return
				
 F8C7				S_OPT_ROM	DB	'ROM', 0
				S_OPT_SIZE	DB	'Size', 0
				S_OPT_CHK	DB	'Chk ', 0				; Checksum
				S_OPT_K	DB	' ', POST_K_UNIT, 0
				
				ROM_SCAN_POST ENDP
						ENDIF
				
				;
				; 274 BYTES HERE / (16 BYTES HERE 5150)
				;
				BYTES_HERE	GFX_CHARSET
				
				;----------------------------------------------------------------------------;
				; INT 1F - 8x8 Font bitmaps
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 219 - 1


				; Font bitmaps from "VileR", (CC BY-SA 4.0)
				; https://int10h.org/oldschool-pc-fonts/
				;----------------------------------------------------------------------------;
						ORG 0FA6EH
				GFX_CHARSET LABEL BYTE
					DB   000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 00H
					DB   07EH, 081H, 0A5H, 081H, 0BDH, 099H, 081H, 07EH	; 01H
					DB   07EH, 0DBH, 0FFH, 0FFH, 0C3H, 0E7H, 07EH, 000H	; 02H
					DB   036H, 07FH, 07FH, 07FH, 03EH, 01CH, 008H, 000H	; 03H
					DB   008H, 01CH, 03EH, 07FH, 03EH, 01CH, 008H, 000H	; 04H
					DB   018H, 03CH, 018H, 066H, 0FFH, 066H, 018H, 03CH	; 05H
					DB   008H, 01CH, 03EH, 07FH, 07FH, 03EH, 008H, 01CH	; 06H
					DB   000H, 000H, 018H, 03CH, 03CH, 018H, 000H, 000H	; 07H
					DB   0FFH, 0FFH, 0E7H, 0C3H, 0C3H, 0E7H, 0FFH, 0FFH	; 08H
					DB   000H, 03CH, 066H, 042H, 042H, 066H, 03CH, 000H	; 09H
					DB   0FFH, 0C3H, 099H, 0BDH, 0BDH, 099H, 0C3H, 0FFH	; 0AH
					DB   03FH, 00DH, 01CH, 03EH, 063H, 063H, 03EH, 000H	; 0BH
					DB   03EH, 063H, 063H, 03EH, 01CH, 07FH, 01CH, 000H	; 0CH
					DB   00EH, 00FH, 00DH, 00DH, 01CH, 07FH, 01CH, 000H	; 0DH
					DB   00FH, 03BH, 037H, 03BH, 033H, 037H, 077H, 070H	; 0EH
					DB   018H, 0DBH, 03CH, 0E7H, 03CH, 0DBH, 018H, 000H	; 0FH
					DB   060H, 078H, 07EH, 07FH, 07EH, 078H, 060H, 000H	; 10H
					DB   003H, 00FH, 03FH, 07FH, 03FH, 00FH, 003H, 000H	; 11H
					DB   018H, 03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H	; 12H
					DB   066H, 066H, 066H, 066H, 066H, 000H, 066H, 000H	; 13H
					DB   03FH, 06DH, 06DH, 03DH, 00DH, 00DH, 00DH, 000H	; 14H
					DB   03FH, 070H, 03EH, 063H, 063H, 03EH, 007H, 07EH	; 15H
					DB   000H, 000H, 000H, 000H, 0FFH, 0FFH, 0FFH, 000H	; 16H
					DB   03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H, 07EH	; 17H
					DB   018H, 03CH, 07EH, 018H, 018H, 018H, 018H, 000H	; 18H
					DB   018H, 018H, 018H, 018H, 07EH, 03CH, 018H, 000H	; 19H
					DB   018H, 00CH, 006H, 07FH, 006H, 00CH, 018H, 000H	; 1AH
					DB   00CH, 018H, 030H, 07FH, 030H, 018H, 00CH, 000H	; 1BH
					DB   000H, 000H, 000H, 060H, 060H, 07FH, 000H, 000H	; 1CH
					DB   000H, 024H, 066H, 0FFH, 066H, 024H, 000H, 000H	; 1DH
					DB   008H, 01CH, 01CH, 03EH, 03EH, 07FH, 07FH, 000H	; 1EH
					DB   07FH, 07FH, 03EH, 03EH, 01CH, 01CH, 008H, 000H	; 1FH
					DB   000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 20H  
					DB   018H, 018H, 018H, 018H, 018H, 000H, 018H, 000H	; 21H !
					DB   033H, 066H, 0CCH, 000H, 000H, 000H, 000H, 000H	; 22H "
					DB   036H, 036H, 07FH, 036H, 036H, 07FH, 036H, 036H	; 23H #
 F8C7					DB   018H, 07EH, 058H, 038H, 01CH, 01AH, 07EH, 018H	; 24H $
					DB   0E3H, 0A6H, 0ECH, 018H, 037H, 065H, 0C7H, 000H	; 25H %
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <TOP_BANNER>,<SI>			; if SZ is not SI
 F8C7  BE E000 R	     1		MOV	SI, OFFSET TOP_BANNER
			     1			ENDIF
 F8CA  E8 FE20		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 F8CD  8B C5				DB   03CH, 066H, 03CH, 038H, 06DH, 066H, 03DH, 000H	; 26H &
					DB   006H, 00CH, 018H, 000H, 000H, 000H, 000H, 000H	; 27H '
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 220 - 1


			     1				IF CPU_TYPE	EQ CPU_V20
			     1		CLR1_BP   GRND				; V20 only: CLR1 BP, GRND
			     1				ELSE
 F8CF  83 E5 FC		     1		AND	BP, NOT MASK GRND			; Clear flag
			     1				ENDIF
 F8D2  83 E0 03				DB   01CH, 030H, 060H, 060H, 060H, 030H, 01CH, 000H	; 28H (
 F8D5  96				DB   038H, 00CH, 006H, 006H, 006H, 00CH, 038H, 000H	; 29H )
 F8D6  D1 E6				DB   063H, 036H, 01CH, 07FH, 01CH, 036H, 063H, 000H	; 2AH *
 F8D8  2E: 8B B4 F92D R			DB   018H, 018H, 018H, 07EH, 018H, 018H, 018H, 000H	; 2BH +
					DB   000H, 000H, 000H, 000H, 000H, 018H, 018H, 030H	; 2CH ,
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <SI>,<SI>			; if SZ is not SI
			     1		MOV	SI, OFFSET SI
			     1			ENDIF
 F8DD  E8 FE0D		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
					DB   000H, 000H, 000H, 07EH, 000H, 000H, 000H, 000H	; 2DH -
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <COPYRIGHT>,<SI>			; if SZ is not SI
 F8E0  BE E031 R	     1		MOV	SI, OFFSET COPYRIGHT
			     1			ENDIF
 F8E3  E8 FE2D		     1		CALL	OUTLN_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 F8E6  C3				DB   000H, 000H, 000H, 000H, 000H, 018H, 018H, 000H	; 2EH .
					DB   002H, 006H, 00CH, 018H, 030H, 060H, 040H, 000H	; 2FH /
					DB   03EH, 063H, 063H, 06BH, 063H, 063H, 03EH, 000H	; 30H 0
					DB   01CH, 03CH, 00CH, 00CH, 00CH, 00CH, 00CH, 000H	; 31H 1
					DB   03EH, 063H, 003H, 00EH, 038H, 060H, 07FH, 000H	; 32H 2
 F8E7 41 6E 20 45 6E 65			DB   07CH, 006H, 006H, 03CH, 006H, 006H, 07CH, 000H	; 33H 3
       72 67 79 20 53 74
       61 72 20 46 6F 65
       00
 F8FA 41 62 6F 72 74 2C			DB   00EH, 01EH, 036H, 066H, 07FH, 006H, 006H, 000H	; 34H 4
       20 52 65 74 72 79
       2C 20 53 75 63 63
       65 65 64 00
 F910 57 68 65 6E 20 6C			DB   07EH, 060H, 07CH, 006H, 006H, 006H, 07CH, 000H	; 35H 5
       69 66 65 20 67 69
       76 65 73 20 79 6F
       75 20 6C 65 6D 6F
       6E 61 64 65 00
					DB   01EH, 030H, 060H, 07EH, 063H, 063H, 03EH, 000H	; 36H 6
					DB   07EH, 066H, 00CH, 018H, 030H, 030H, 030H, 000H	; 37H 7
					DB   03EH, 063H, 036H, 01CH, 036H, 063H, 03EH, 000H	; 38H 8
					DB   03EH, 063H, 063H, 03FH, 003H, 006H, 07CH, 000H	; 39H 9
					DB   000H, 000H, 018H, 018H, 000H, 018H, 018H, 000H	; 3AH :
					DB   000H, 000H, 018H, 018H, 000H, 018H, 018H, 030H	; 3BH ;
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 221 - 1


					DB   00CH, 018H, 030H, 060H, 030H, 018H, 00CH, 000H	; 3CH <
					DB   000H, 000H, 07EH, 000H, 07EH, 000H, 000H, 000H	; 3DH =
 F92D E00E R F8E7 R F8FA R		DB   030H, 018H, 00CH, 006H, 00CH, 018H, 030H, 000H	; 3EH >
       F910 R
					DB   03EH, 063H, 006H, 00CH, 00CH, 000H, 00CH, 000H	; 3FH ?
 F935					DB   03EH, 063H, 06FH, 069H, 06FH, 060H, 03FH, 000H	; 40H @
					DB   03CH, 066H, 066H, 07EH, 066H, 066H, 066H, 000H	; 41H A
					DB   07EH, 063H, 063H, 07EH, 063H, 063H, 07EH, 000H	; 42H B
					DB   01EH, 033H, 060H, 060H, 060H, 033H, 01EH, 000H	; 43H C
					DB   07CH, 066H, 063H, 063H, 063H, 066H, 07CH, 000H	; 44H D
					DB   07EH, 060H, 060H, 07CH, 060H, 060H, 07EH, 000H	; 45H E
					DB   07EH, 060H, 060H, 07CH, 060H, 060H, 060H, 000H	; 46H F
					DB   01EH, 033H, 063H, 060H, 067H, 033H, 01EH, 000H	; 47H G
					DB   063H, 063H, 063H, 07FH, 063H, 063H, 063H, 000H	; 48H H
					DB   03CH, 018H, 018H, 018H, 018H, 018H, 03CH, 000H	; 49H I
					DB   006H, 006H, 006H, 006H, 066H, 066H, 03CH, 000H	; 4AH J
					DB   063H, 066H, 06CH, 078H, 06CH, 066H, 063H, 000H	; 4BH K
					DB   030H, 030H, 030H, 030H, 030H, 030H, 03FH, 000H	; 4CH L
					DB   063H, 077H, 07FH, 06BH, 063H, 063H, 063H, 000H	; 4DH M
					DB   063H, 073H, 07BH, 06FH, 067H, 063H, 063H, 000H	; 4EH N
					DB   03EH, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 4FH O
					DB   07EH, 063H, 063H, 07EH, 060H, 060H, 060H, 000H	; 50H P
					DB   03EH, 063H, 063H, 063H, 07BH, 06EH, 03CH, 007H	; 51H Q
					DB   07EH, 063H, 063H, 07EH, 06CH, 066H, 063H, 000H	; 52H R
					DB   03EH, 063H, 030H, 01CH, 006H, 063H, 03EH, 000H	; 53H S
					DB   07EH, 018H, 018H, 018H, 018H, 018H, 018H, 000H	; 54H T
					DB   063H, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 55H U
					DB   063H, 063H, 063H, 063H, 036H, 01CH, 008H, 000H	; 56H V
					DB   063H, 063H, 063H, 06BH, 06BH, 07FH, 036H, 000H	; 57H W
					DB   063H, 063H, 036H, 01CH, 036H, 063H, 063H, 000H	; 58H X
					DB   063H, 063H, 063H, 03EH, 00CH, 00CH, 00CH, 000H	; 59H Y
					DB   07FH, 006H, 00CH, 018H, 030H, 060H, 07FH, 000H	; 5AH Z
					DB   03EH, 030H, 030H, 030H, 030H, 030H, 03EH, 000H	; 5BH [
					DB   040H, 060H, 030H, 018H, 00CH, 006H, 002H, 000H	; 5CH \
					DB   03EH, 006H, 006H, 006H, 006H, 006H, 03EH, 000H	; 5DH ]
					DB   01CH, 036H, 063H, 000H, 000H, 000H, 000H, 000H	; 5EH ^
					DB   000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH	; 5FH _
					DB   030H, 018H, 00CH, 000H, 000H, 000H, 000H, 000H	; 60H `
					DB   000H, 000H, 03CH, 006H, 03EH, 066H, 03FH, 000H	; 61H a
					DB   060H, 060H, 07CH, 066H, 066H, 066H, 07CH, 000H	; 62H b
					DB   000H, 000H, 03EH, 063H, 060H, 060H, 03FH, 000H	; 63H c
					DB   006H, 006H, 03EH, 066H, 066H, 066H, 03EH, 000H	; 64H d
					DB   000H, 000H, 03CH, 066H, 07CH, 060H, 03EH, 000H	; 65H e
					DB   01EH, 030H, 030H, 07CH, 030H, 030H, 030H, 000H	; 66H f
					DB   000H, 000H, 03FH, 063H, 063H, 03FH, 003H, 07EH	; 67H g
					DB   060H, 060H, 06CH, 076H, 066H, 066H, 066H, 000H	; 68H h
					DB   018H, 000H, 038H, 018H, 018H, 018H, 018H, 000H	; 69H i
					DB   006H, 000H, 006H, 006H, 006H, 006H, 066H, 03CH	; 6AH j
					DB   060H, 060H, 066H, 06CH, 078H, 06CH, 066H, 000H	; 6BH k
					DB   018H, 018H, 018H, 018H, 018H, 018H, 00CH, 000H	; 6CH l
					DB   000H, 000H, 076H, 07FH, 06BH, 06BH, 063H, 000H	; 6DH m
					DB   000H, 000H, 06CH, 076H, 066H, 066H, 066H, 000H	; 6EH n
					DB   000H, 000H, 03EH, 063H, 063H, 063H, 03EH, 000H	; 6FH o
					DB   000H, 000H, 07CH, 066H, 066H, 07CH, 060H, 060H	; 70H p
					DB   000H, 000H, 03EH, 066H, 066H, 03EH, 006H, 006H	; 71H q
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 222 - 1


					DB   000H, 000H, 036H, 03BH, 030H, 030H, 030H, 000H	; 72H r
					DB   000H, 000H, 03EH, 070H, 03CH, 00EH, 07CH, 000H	; 73H s
					DB   018H, 018H, 07EH, 018H, 018H, 018H, 00EH, 000H	; 74H t
					DB   000H, 000H, 066H, 066H, 066H, 066H, 03BH, 000H	; 75H u
					DB   000H, 000H, 066H, 066H, 066H, 03CH, 018H, 000H	; 76H v
					DB   000H, 000H, 063H, 063H, 06BH, 07FH, 036H, 000H	; 77H w
					DB   000H, 000H, 063H, 036H, 01CH, 036H, 063H, 000H	; 78H x
					DB   000H, 000H, 066H, 066H, 066H, 03EH, 006H, 07CH	; 79H y
					DB   000H, 000H, 07EH, 00CH, 018H, 030H, 07EH, 000H	; 7AH z
					DB   00EH, 018H, 018H, 078H, 018H, 018H, 00EH, 000H	; 7BH {
					DB   018H, 018H, 018H, 000H, 018H, 018H, 018H, 000H	; 7CH |
					DB   070H, 018H, 018H, 00EH, 018H, 018H, 070H, 000H	; 7DH }
					DB   03BH, 06EH, 000H, 000H, 000H, 000H, 000H, 000H	; 7EH ~
					DB   018H, 03CH, 066H, 0C3H, 0C3H, 0FFH, 000H, 000H	; 7FH
				
				;----------------------------------------------------------------------------;
				; INT 1A - System and "Real Time" Clock BIOS Services
				;----------------------------------------------------------------------------;
				; INT 1A,0   Read system clock counter
				; INT 1A,1   Set system clock counter
				;----------------------------------------------------------------------------;
						ORG 0FE6EH
				INT_1A PROC
						ASSUME DS:_BDA
					STI
					SUB	AH, 1 				; is function 0 or 1?
					JA	INT_1A_EXIT 			; if not, exit
					PUSH	DS
					PUSH	SI
					MOV	SI, SEG _BDA 			; get BDA segment
					MOV	DS, SI 				; DS = BDA
 F935			     1			LOCAL LBL
			     1	
 = 0139			     1	BYTES_HERE_GFX_CHARSET = GFX_CHARSET-$
			     1	
			     1			IFDEF BYTES_HERE_GFX_CHARSET
			     1			IF2
			     1			IF BYTES_HERE_GFX_CHARSET LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: GFX_CHARSET (BYTES_HERE_GFX_CHARSET)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					MOV	SI, OFFSET TIMER			; SI = BIOS Timer
					CLI 						; disable interrupts
					JZ	INT_1A_SET 				; AH = 1, jump to Set clock
											; AH = 0, fall through to Read
				
				;----------------------------------------------------------------------------;
				; INT 1A,0   Read system clock counter
				;----------------------------------------------------------------------------;
 FA6E				; Output:
 FA6E  00 00 00 00 00 00	;	AL = midnight flag, 1 if 24 hours passed since reset
       00 00
 FA76  7E 81 A5 81 BD 99	;	CX = high order word of tick count
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 223 - 1


       81 7E
 FA7E  7E DB FF FF C3 E7	;	DX = low order word of tick count
       7E 00
 FA86  36 7F 7F 7F 3E 1C	;----------------------------------------------------------------------------;
       08 00
 FA8E  08 1C 3E 7F 3E 1C	INT_1A_READ PROC
       08 00
 FA96  18 3C 18 66 FF 66		LODSW 					; AX = low word of timer
       18 3C
 FA9E  08 1C 3E 7F 7F 3E		XCHG	AX, DX
       08 1C
 FAA6  00 00 18 3C 3C 18		LODSW 					; AX = high word of timer
       00 00
 FAAE  FF FF E7 C3 C3 E7		XCHG	AX, CX
       FF FF
 FAB6  00 3C 66 42 42 66		XOR	AX, AX				; reset midnight flag to 0
       3C 00
 FABE  FF C3 99 BD BD 99		XCHG	AL, [SI]				; AL = BDA flag, BDA = 0
       C3 FF
 FAC6  3F 0D 1C 3E 63 63	INT_1A_DONE:
       3E 00
 FACE  3E 63 63 3E 1C 7F		STI 						; re-enable interrupts
       1C 00
 FAD6  0E 0F 0D 0D 1C 7F		POP	SI
       1C 00
 FADE  0F 3B 37 3B 33 37		POP	DS
       77 70
 FAE6  18 DB 3C E7 3C DB	INT_1A_EXIT:
       18 00
 FAEE  60 78 7E 7F 7E 78		IRET
       60 00
 FAF6  03 0F 3F 7F 3F 0F	INT_1A_READ ENDP
       03 00
 FAFE  18 3C 7E 18 18 7E	
       3C 18
 FB06  66 66 66 66 66 00	;----------------------------------------------------------------------------;
       66 00
 FB0E  3F 6D 6D 3D 0D 0D	; INT 1A,1   Set system clock counter
       0D 00
 FB16  3F 70 3E 63 63 3E	;----------------------------------------------------------------------------;
       07 7E
 FB1E  00 00 00 00 FF FF	; Input:
       FF 00
 FB26  3C 7E 18 18 7E 3C	;	AH = 0
       18 7E
 FB2E  18 3C 7E 18 18 18	;	CX = high order word of tick count
       18 00
 FB36  18 18 18 18 7E 3C	;	DX = low order word of tick count
       18 00
 FB3E  18 0C 06 7F 06 0C	;----------------------------------------------------------------------------;
       18 00
 FB46  0C 18 30 7F 30 18	INT_1A_SET PROC
       0C 00
 FB4E  00 00 00 60 60 7F		MOV	[SI].LW, DX				; set low word ticks (seconds)
       00 00
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 224 - 1


 FB56  00 24 66 FF 66 24		MOV	[SI].HW, CX				; set high word ticks (hours)
       00 00
 FB5E  08 1C 1C 3E 3E 7F		MOV	[SI].OF, AH				; reset midnight counter (0)
       7F 00
 FB66  7F 7F 3E 3E 1C 1C		JMP	SHORT INT_1A_DONE
       08 00
 FB6E  00 00 00 00 00 00	INT_1A_SET ENDP
       00 00
 FB76  18 18 18 18 18 00	
       18 00
 FB7E  33 66 CC 00 00 00	INT_1A ENDP
       00 00
 FB86  36 36 7F 36 36 7F	
       36 36
 FB8E  18 7E 58 38 1C 1A	INT_08_PROC PROC
       7E 18
 FB96  E3 A6 EC 18 37 65	;----------------------------------------------------------------------------;
       C7 00
 FB9E  3C 66 3C 38 6D 66	; INT 8 - Floppy Motor shutoff has elapsed - shut off motor
       3D 00
 FBA6  06 0C 18 00 00 00	;----------------------------------------------------------------------------;
       00 00
 FBAE  1C 30 60 60 60 30	INT_08_MOTOR_OFF:
       1C 00
 FBB6  38 0C 06 06 06 0C		MOV	AL, NOT MASK FMOT			; BDA motor off on all drives
       38 00
 FBBE  63 36 1C 7F 1C 36		AND	FD_MOTOR_ST, AL			; write to BDA
       63 00
 FBC6  18 18 18 7E 18 18		XOR	AL, NOT MASK FDSEL		; FDC motor off on all drives
       18 00
 FBCE  00 00 00 00 00 18		MOV	DX, FDC_CTRL 			; FD control port
       18 30
 FBD6  00 00 00 7E 00 00		OUT	DX, AL 				; write to controller
       00 00
 FBDE  00 00 00 00 00 18		JMP	SHORT INT_08_INT_1C
       18 00
 FBE6  02 06 0C 18 30 60	
       40 00
 FBEE  3E 63 63 6B 63 63	;
       3E 00
 FBF6  1C 3C 0C 0C 0C 0C	; 0 BYTES HERE
       0C 00
 FBFE  3E 63 03 0E 38 60	;
       7F 00
 FC06  7C 06 06 3C 06 06	BYTES_HERE	INT_08
       7C 00
 FC0E  0E 1E 36 66 7F 06	
       06 00
 FC16  7E 60 7C 06 06 06	;----------------------------------------------------------------------------;
       7C 00
 FC1E  1E 30 60 7E 63 63	; INT 8 - Timer
       3E 00
 FC26  7E 66 0C 18 30 30	;----------------------------------------------------------------------------;
       30 00
 FC2E  3E 63 36 1C 36 63	; - Run 18.2 times per second by PIT Timer
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 225 - 1


       3E 00
 FC36  3E 63 63 3F 03 06	; - f = 1193180 / 10000H
       7C 00
 FC3E  00 00 18 18 00 18	; - Increment 32 bit counter, overflows at 24 hours + 9.67 sec
       18 00
 FC46  00 00 18 18 00 18	;	( 3600s/h - 65,536t / ( 1,193,180t/s / 65,536t ) ) * 24h = ~9.67s
       18 30
 FC4E  0C 18 30 60 30 18	; - Decrement floppy disk motor timeout counter
       0C 00
 FC56  00 00 7E 00 7E 00	;  	  if reaches 0, turns off motor
       00 00
 FC5E  30 18 0C 06 0C 18	; - only take jumps on special cases
       30 00
 FC66  3E 63 06 0C 0C 00	;
       0C 00
 FC6E  3E 63 6F 69 6F 60	; IMPORTANT NOTE: ROM BASIC's INT 1CH handler clobbers DX, so DX
       3F 00
 FC76  3C 66 66 7E 66 66	; MUST be call-preserved here.
       66 00
 FC7E  7E 63 63 7E 63 63	;----------------------------------------------------------------------------;
       7E 00
 FC86  1E 33 60 60 60 33			ORG 0FEA5H
       1E 00
 FC8E  7C 66 63 63 63 66	INT_08 PROC
       7C 00
 FC96  7E 60 60 7C 60 60			ASSUME DS:_BDA
       7E 00
 FC9E  7E 60 60 7C 60 60		PUSH	AX 					; save AX, DX, DS and DI
       60 00
 FCA6  1E 33 63 60 67 33		PUSH	DX					; workaround ROM BASIC INT 1Ch bug
       1E 00
 FCAE  63 63 63 7F 63 63		PUSH	DS
       63 00
 FCB6  3C 18 18 18 18 18		PUSH	DI
       3C 00
 FCBE  06 06 06 06 66 66		MOV	AX, SEG _BDA 			; DS = BIOS Data Area
       3C 00
 FCC6  63 66 6C 78 6C 66		MOV	DS, AX
       63 00
 FCCE  30 30 30 30 30 30		CWD						; DX = 0
       3F 00
 FCD6  63 77 7F 6B 63 63	
       63 00
 FCDE  63 73 7B 6F 67 63	;----------------------------------------------------------------------------;
       63 00
 FCE6  3E 63 63 63 63 63	; Increment Timer
       3E 00
 FCEE  7E 63 63 7E 60 60	;
       60 00
 FCF6  3E 63 63 63 7B 6E	INT_08_TICK_TIMER:				; Advance the time ticker
       3C 07
 FCFE  7E 63 63 7E 6C 66		MOV	DI, OFFSET TIMER 			; Low timer at BDA 0040:006C
       63 00
 FD06  3E 63 30 1C 06 63		ADD	[DI].LW, 1				; increment low word
       3E 00
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 226 - 1


 FD0E  7E 18 18 18 18 18		ADC	[DI].HW, DX				; maybe increment high word
       18 00
 FD16  63 63 63 63 63 63		CMP	[DI].HW, 24 			; rolled over to next day?
       3E 00
 FD1E  63 63 63 63 36 1C		JAE	INT_08_TICK_DAY			; if so, check for day rollover
       08 00
 FD26  63 63 63 6B 6B 7F	
       36 00
 FD2E  63 63 36 1C 36 63	;----------------------------------------------------------------------------;
       63 00
 FD36  63 63 63 3E 0C 0C	; Decrement Floppy Motor shutoff counter
       0C 00
 FD3E  7F 06 0C 18 30 60	;
       7F 00
 FD46  3E 30 30 30 30 30	INT_08_FD_MOTOR: 					; Check if there is a motor timeout
       3E 00
 FD4E  40 60 30 18 0C 06		STI						; interrupts back on
       02 00
 FD56  3E 06 06 06 06 06		DEC	FD_MOTOR_CT 			; increment counter, has reached 0?
       3E 00
 FD5E  1C 36 63 00 00 00		JZ	INT_08_MOTOR_OFF			; if so, turn off motor
       00 00
 FD66  00 00 00 00 00 00	
       00 FF
 FD6E  30 18 0C 00 00 00	;----------------------------------------------------------------------------;
       00 00
 FD76  00 00 3C 06 3E 66	; Call INT 1CH user vector
       3F 00
 FD7E  60 60 7C 66 66 66	;
       7C 00
 FD86  00 00 3E 63 60 60	INT_08_INT_1C:
       3F 00
 FD8E  06 06 3E 66 66 66		INT	1CH					; call user timer hook
       3E 00
 FD96  00 00 3C 66 7C 60	
       3E 00
 FD9E  1E 30 30 7C 30 30	;----------------------------------------------------------------------------;
       30 00
 FDA6  00 00 3F 63 63 3F	; Interrupt Complete - send EOI and return
       03 7E
 FDAE  60 60 6C 76 66 66	;
       66 00
 FDB6  18 00 38 18 18 18	INT_08_EOI:
       18 00
 FDBE  06 00 06 06 06 06		CLI						; disable interrupts for EOI
       66 3C
 FDC6  60 60 66 6C 78 6C		MOV	AL, EOI 				; End of Interrupt OCW
       66 00
 FDCE  18 18 18 18 18 18		OUT	INT_P0, AL				; write EOI to port 0
       0C 00
 FDD6  00 00 76 7F 6B 6B		POP	DI
       63 00
 FDDE  00 00 6C 76 66 66		POP	DS
       66 00
 FDE6  00 00 3E 63 63 63		POP	DX					; restore DX
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 227 - 1


       3E 00
 FDEE  00 00 7C 66 66 7C		POP	AX
       60 60
 FDF6  00 00 3E 66 66 3E		IRET
       06 06
 FDFE  00 00 36 3B 30 30	
       30 00
 FE06  00 00 3E 70 3C 0E	;----------------------------------------------------------------------------;
       7C 00
 FE0E  18 18 7E 18 18 18	; Check if day has rolled over (24H + 9.67s) and reset 32 bit ticker if so
       0E 00
 FE16  00 00 66 66 66 66	;
       3B 00
 FE1E  00 00 66 66 66 3C	INT_08_TICK_DAY:
       18 00
 FE26  00 00 63 63 6B 7F		CMP	BYTE PTR [DI].LW, 176 		; has day rolled over?
       36 00
 FE2E  00 00 63 36 1C 36		JB	INT_08_FD_MOTOR			; if not, handle FD motor timeout
       63 00
 FE36  00 00 66 66 66 3E	
       06 7C
 FE3E  00 00 7E 0C 18 30	;----------------------------------------------------------------------------;
       7E 00
 FE46  0E 18 18 78 18 18	; Timer has rolled over 24 hours - reset counters and increment midnight
       0E 00
 FE4E  18 18 18 00 18 18	; http://www.ctyme.com/intr/rb-2271.htm
       18 00
 FE56  70 18 18 0E 18 18	; http://www.phatcode.net/res/246/files/pctim003.txt
       70 00
 FE5E  3B 6E 00 00 00 00	;
       00 00
 FE66  18 3C 66 C3 C3 FF	INT_08_RESET:
       00 00
					MOV	[DI].LW, DX				; TIMER low word = 0
					MOV	[DI].HW, DX				; TIMER high word = 0
					INC	[DI].OF				; increment TIMER midnight counter
					JMP	INT_08_FD_MOTOR			; continue and check motor
				
				INT_08 ENDP
				INT_08_PROC ENDP
				
 FE6E				;
				; 3 BYTES HERE
 FE6E  FB			;
 FE6F  80 EC 01			BYTES_HERE	VECTOR_TABLE
 FE72  77 18			
 FE74  1E			;----------------------------------------------------------------------------;
 FE75  56			; Interrupt Vector Table - These fill the IVT prior to bootstrap
 FE76  BE ---- R		;----------------------------------------------------------------------------;
 FE79  8E DE			; Each ISR is found at the compatibility offset described here:
 FE7B  BE 006C R		; https://www.intel.com/content/dam/doc/reference-guide/efi-compatibility-support-module-specificati
				on-v097.pdf
 FE7E  FA			;----------------------------------------------------------------------------;
 FE7F  74 0C					ORG 0FEE3H
				VECTOR_TABLE PROC
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 228 - 1


					DW  OFFSET INT_IRQ 		; INT 00
					DW  OFFSET INT_IRQ 		; INT 01
					DW  OFFSET INT_02 		; INT 02	NMI
					DW  OFFSET INT_IRQ 		; INT 03
					DW  OFFSET INT_IRQ 		; INT 04
					DW  OFFSET INT_05 		; INT 05	Print Screen
					DW  OFFSET INT_IRQ 		; INT 06
					DW  OFFSET INT_IRQ 		; INT 07
				
 FE81				;----------------------------------------------------------------------------;
 FE81  AD			; Compatibility fixed ORG for INT 08 - 1Eh
 FE82  92			;
 FE83  AD					ORG 0FEF3H
 FE84  91				DW  OFFSET INT_08 		; INT 08	IRQ0 System timer
 FE85  33 C0				DW  OFFSET INT_09_POST		; INT 09	IRQ1 Keyboard IRQ (during POST)
 FE87  86 04				DW  OFFSET INT_IRQ		; INT 0A	IRQ2 Reserved
 FE89					DW  OFFSET INT_IRQ		; INT 0B	IRQ3 COM2
 FE89  FB				DW  OFFSET INT_IRQ		; INT 0C	IRQ4 COM1
 FE8A  5E				DW  OFFSET INT_IRQ		; INT 0D	IRQ5 XT FDC
 FE8B  1F				DW  OFFSET INT_0E			; INT 0E	IRQ6 Floppy Controller
 FE8C					DW  OFFSET INT_IRQ		; INT 0F	IRQ7 LPT
 FE8C  CF				DW  OFFSET INT_10			; INT 10	Video
 FE8D					DW  OFFSET INT_11			; INT 11	Equipment Check
					DW  OFFSET INT_12			; INT 12	Memory Size
					DW  OFFSET INT_13			; INT 13	Floppy Disk
					DW  OFFSET INT_14			; INT 14	Serial Port
					DW  OFFSET INT_15			; INT 15	System Services
					DW  OFFSET INT_16			; INT 16	Keyboard Services
					DW  OFFSET INT_17			; INT 17	Printer
					DW  OFFSET INT_18 		; INT 18	Unbootable/ROM BASIC
					DW  OFFSET INT_19			; INT 19	Bootstrap
					DW  OFFSET INT_1A			; INT 1A	Time of day
 FE8D					DW  OFFSET INT_RET 		; INT 1B	Ctrl Brk
 FE8D  89 14				DW  OFFSET INT_RET 		; INT 1C	Timer Tick
 FE8F  89 4C 02				DW  OFFSET INT_1D 		; INT 1D	CRTC param table
 FE92  88 64 04				DW  OFFSET INT_1E 		; INT 1E	Floppy param table
 FE95  EB F2			L_VECTOR_TABLE = ($-VECTOR_TABLE)/2	; number of vectors 1Fh (31)
 FE97					DW  0 				; INT 1F	8x8 (CP 128-255) custom
										;		 video font table (0000:0000)
 FE97				VECTOR_TABLE ENDP
				
 FE97				;----------------------------------------------------------------------------;
				; INT_IRQ - Handle placeholder hardware interrupts
				;----------------------------------------------------------------------------;
				; ISR for any hardware interrupts that have yet to be vectored.
 FE97				; Acknowledge interrupt, mask the active one and write last HW interrupt to BDA.
 FE97  B0 F0			;
 FE99  20 06 003F R		; Output:
 FE9D  34 FC			;	INT_LAST = last interrupt or 0FFh if non-hardware/unknown interrupt
 FE9F  BA 03F2			;----------------------------------------------------------------------------;
 FEA2  EE					ORG 0FF23H
 FEA3  EB 20			INT_IRQ PROC
							ASSUME DS:_BDA
					PUSH	AX
					PUSH	DS				; save DS
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 229 - 1


					MOV	AL, OCW3 <,,,,11b> 	; AL = OCW3 Read ISR reg on next pulse
					OUT	INT_P0, AL			; write to PIC A0 (20h)
 FEA5			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_08 = INT_08-$
			     1	
			     1			IFDEF BYTES_HERE_INT_08
			     1			IF2
			     1			IF BYTES_HERE_INT_08 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_08 (BYTES_HERE_INT_08)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					MOV	AX, SEG _BDA 		; AH = 0, delay for PIC at least 1 clock pulse
					MOV	DS, AX			; set DS to BDA
					IN	AL, INT_P0			; get current In-Service Register (ISR)
					DEC	AX				; if ISR is zero there is no active hardware int
					JL	INT_IRQ_DONE		; if no active int, exit with INT_LAST = FFh
					INC	AX				; otherwise INT_LAST = active interrupt level
					MOV	AH, AL 			; restore ISR and save to AH
					IN	AL, INT_IMR			; get current Interrupt Mask Register (IMR)
					OR	AL, AH 			; mask active interrupt
					OUT	INT_IMR, AL			; write new IMR to PIC A1 (21h)
					MOV	AL, EOI 			; AL = OCW2 End of Interrupt
					OUT	INT_P0, AL			; write EOI to PIC A0 (20h)
				INT_IRQ_DONE:
					MOV	INT_LAST, AH	 	; save last interrupt to BDA
					POP	DS
					POP	AX
 FEA5					IRET
				
 FEA5  50			INT_IRQ ENDP
 FEA6  52			
 FEA7  1E			;----------------------------------------------------------------------------;
 FEA8  57			; POST Video Adapter Type Strings (2 of 2)
 FEA9  B8 ---- R		; 11 bytes
 FEAC  8E D8			;
 FEAE  99							IF POST_VIDEO_TYPE EQ 1
				POST_VIDEO		DB	'Video', 0
								ENDIF
				POST_NONE		DB	'None', 0	; must be after POST_VIDEO
				
 FEAF				; 1 BYTE HERE
 FEAF  BF 006C R		
 FEB2  83 05 01			BYTES_HERE	INT_RET
 FEB5  11 55 02			
 FEB8  83 7D 02 18		;----------------------------------------------------------------------------;
 FEBC  73 13			; INT_RET - Handle placeholder software interrupts
				;----------------------------------------------------------------------------;
						ORG 0FF53H
				INT_RET PROC
					IRET
 FEBE				INT_RET ENDP
 FEBE  FB			
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 230 - 1


 FEBF  FE 0E 0040 R		;----------------------------------------------------------------------------;
 FEC3  74 D2			; INT 5 - Print Screen
				;----------------------------------------------------------------------------;
				; Print the contents of the current screen/page.
				;
				; Output:
 FEC5				; - Screen contents to PRN (BIOS printer 0)
 FEC5  CD 1C			; - Status to BDA 50:0H:
				;	00	Print screen has not been called, or upon return
				;			from a call there were no errors
				;	01	Print screen is already in progress
				;	FF	Error encountered during printing
 FEC7				;----------------------------------------------------------------------------;
 FEC7  FA			; Things you must do:
 FEC8  B0 20			; 	1. Check status (BDA 50:0H) to ensure PrtScn is not already in progress.
 FECA  E6 20			;	2. Set working status to 1.
 FECC  5F			;	3. Get the current screen size (columns) and video page.
 FECD  1F			;	4. Save the current cursor position, then move to the top.
 FECE  5A			;	5. Read the char at that position and send to printer.
 FECF  58			;	6. If last column reached, move screen cursor to start of next line
 FED0  CF			;		and send CR and LF to printer to start new line.
				;	7. Keep looping until past the last row (always 25)
				;	8. Restore screen cursor position
				;	9. Set BDA status to either success (0) or error (-1)
				;----------------------------------------------------------------------------;
 FED1						ORG 0FF54H
 FED1  80 3D B0			INT_05 PROC
 FED4  72 E8						ASSUME DS:_BDA
					CLD						; string direction forward
					PUSHX	AX, DI, ES				; preserve caller registers
					MOV	DI, SEG _DOS_DAT
					MOV	ES, DI				; ES = seg 50H
					XOR	DI, DI				; DI = PTRSCN_ST (offset 00H)
					MOV	AL, 1					; print status = 1 (in progress)
 FED6					SCASB						; is in progress already?
 FED6  89 15				JZ	INT_05_EXIT				; if so, exit
 FED8  89 55 02				STI						; Interrupts should be okay now
 FEDB  FE 45 04				DEC	DI					; undo earlier SCASB increment
 FEDE  EB DE				STOSB						; update status to 1
					PUSHX	BX, CX, DX				; preserve working registers
 FEE0					MOV	AH, 0FH				; get video state (columns)
 FEE0					INT	10H					; AH = screen columns, BH = page
					MOV	BL, AH				; BL = screen columns
					DEC	BX					; fix 0 index
					MOV	AH, 3					; get cursor position
					INT	10H					; DH = cursor row, DL = cursor column
					PUSH	DX					; save starting cursor position
 FEE0			     1			LOCAL LBL
			     1	
 = 0003			     1	BYTES_HERE_VECTOR_TABLE = VECTOR_TABLE-$
			     1	
			     1			IFDEF BYTES_HERE_VECTOR_TABLE
			     1			IF2
			     1			IF BYTES_HERE_VECTOR_TABLE LT 0
			     1			.ERR2
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 231 - 1


			     1		%OUT WARNING: Out of space at: VECTOR_TABLE (BYTES_HERE_VECTOR_TABLE)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					CALL	LPT_CRLF				; start print head on new line
					JC	INT_05_DONE				; exit if print error
					CWD						; start position at row 0, col 0
				INT_05_LOOP_1:
					MOV	AH, 2					; set cursor position
					INT	10H					; set cursor to DH=row, DL=col
					MOV	AH, 8					; get char/attr at current position
					INT	10H					; AL = char at current position
 FEE3					CALL	LPT_CHAR				; print char in AL
 FEE3  FF23 R				JC	INT_05_DONE				; exit if print error
 FEE5  FF23 R				CMP	BL, DL				; end of screen cols?
 FEE7  E2C3 R				JNE	INT_05_NEXT_COL			; jump if not
 FEE9  FF23 R				MOV	DL, -1				; else move to first col and next row
 FEEB  FF23 R				CALL	LPT_CRLF				; CR and LF to PRN
 FEED  FF54 R				JC	INT_05_DONE				; exit if print error
 FEEF  FF23 R			INT_05_NEXT_COL:
 FEF1  FF23 R				INC	DX					; move to next column (and maybe row)
					CMP	DH, VID_DEF_ROWS+1		; end of screen rows?
					JNE	INT_05_LOOP_1			; loop while not last row, CF=0 when done
				INT_05_DONE:
					SBB	AL, AL				; print status: AL = 0 if NC, AL = -1 if CF
					DEC	DI					; undo earlier STOSB increment
 FEF3  FEA5 R				STOSB						; update BDA status
 FEF5  E934 R				POP	DX					; restore starting cursor position
 FEF7  FF23 R				MOV	AH, 2					; set cursor position in DH/DL
 FEF9  FF23 R				INT	10H
 FEFB  FF23 R				POPX	DX, CX, BX
 FEFD  FF23 R			INT_05_EXIT:
 FEFF  EF57 R				POPX	ES, DI, AX
 FF01  FF23 R				IRET
 FF03  F065 R			
 FF05  F84D R			;----------------------------------------------------------------------------;
 FF07  F841 R			; LPT_CRLF - Write CR and LF to PRN
 FF09  EC59 R			;----------------------------------------------------------------------------;
 FF0B  E739 R			LPT_CRLF PROC
 FF0D  F859 R				MOV	AL, CR
 FF0F  E82E R				CALL	LPT_CHAR
 FF11  EFD2 R				JC	LPT_CHAR_EXIT			; exit if print error
 FF13  E459 R			
 FF15  E6F2 R			;----------------------------------------------------------------------------;
 FF17  FE6E R			; LPT_LF - Write LF to PRN
 FF19  FF53 R			;----------------------------------------------------------------------------;
 FF1B  FF53 R			LPT_LF PROC
 FF1D  F0A4 R				MOV	AL, LF
 FF1F  EFC7 R			
 FF21 = 001F			;----------------------------------------------------------------------------;
 FF21  0000			; LPT_CHAR - Write a char to PRN
				;----------------------------------------------------------------------------;
 FF23				; Input:
				;	AL = char to print
				; Output:
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 232 - 1


				;	CF = 1 (CY) if timeout
				;
				; AL clobbered if null
				;----------------------------------------------------------------------------;
				LPT_CHAR PROC
					PUSH	DX
					MOV	AH, 0					; Print Character function
					CWD						; DX = printer 0 (PRN)
					TEST	AL, AL				; was input char a null?
 FF23					JNZ	LPT_CHAR_OUT			; jump if not
					MOV	AL, ' '				; if so, use a space
 FF23  50			LPT_CHAR_OUT:
 FF24  1E				INT	17H					; Print AL to PRN0
 FF25  B0 0B				SHR	AH, 1					; CF if timeout
 FF27  E6 20				POP	DX
 FF29  B8 ---- R		LPT_CHAR_EXIT:
 FF2C  8E D8				RET
 FF2E  E4 20			LPT_CHAR ENDP
 FF30  48			LPT_LF ENDP
 FF31  7C 0D			LPT_CRLF ENDP
 FF33  40			
 FF34  8A E0			INT_05 ENDP
 FF36  E4 21			
 FF38  0A C4			;----------------------------------------------------------------------------;
 FF3A  E6 21			; Check if a 8087 FPU is present and perform quick tests
 FF3C  B0 20			;----------------------------------------------------------------------------;
 FF3E  E6 20			; Input:
 FF40				;	DI = any non-zero value
 FF40  88 26 006B R		; Output:
 FF44  1F			;	ZF = 0 if no FPU, ZF = 1 if present
 FF45  58			;
 FF46  CF			; Clobbers: BX, DI
				;
 FF47				; Sources:
				;   https://retrocomputing.stackexchange.com/questions/16529/detecting-the-external-x87-fpu
				;   Intel(R) App Note AP-485 "Intel(R) Processor Identification and the CPUID Instruction"
				;----------------------------------------------------------------------------;
				HAS_FPU PROC
					XCHG	AX, DI			; save AX
					FNINIT 				; reset FPU, no wait
 FF47 56 69 64 65 6F 00		
				;----------------------------------------------------------------------------;
 FF4D 4E 6F 6E 65 00		; Test Status Word
				;
				FPU_TEST_SW:
					PUSH	AX 				; init temp word to non-zero
					MOV	BX, SP	 		; use stack memory
 FF52			     1			LOCAL LBL
			     1	
 = 0001			     1	BYTES_HERE_INT_RET = INT_RET-$
			     1	
			     1			IFDEF BYTES_HERE_INT_RET
			     1			IF2
			     1			IF BYTES_HERE_INT_RET LT 0
			     1			.ERR2
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 233 - 1


			     1		%OUT WARNING: Out of space at: INT_RET (BYTES_HERE_INT_RET)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					FNSTSW WORD PTR SS:[BX]		; store status word
					NOP					; delay to allow FPU to complete
					POP	AX 				; AX = control word if FNSTCW executed
					TEST	AL, AL 			; check exception flags
					JNZ	FPU_TEST_DONE		; if flags = 00, FPU is present
 FF53				
 FF53  CF			;----------------------------------------------------------------------------;
 FF54				; Test Control Word
				;
				FPU_TEST_CW:
					PUSH	AX
					FNSTCW WORD PTR SS:[BX]		; store control word
					NOP					; delay to allow FPU to complete
					POP	AX 				; AX = control word
					XOR	AX, 0103FH 			; isolate interesting status flags
					AND	AX, 03FH 			; check for 8087 "signature"
										; ZF = 0 if no FPU
				FPU_TEST_DONE:
					XCHG	AX, DI			; restore AX
					RET
				HAS_FPU ENDP
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	VER
				
				;-------------------------------------------------------------------------
				; Version and Build Strings
				;-------------------------------------------------------------------------
						ORG	0FFE0H
				VER 	DB	'Ver: '
					DB	VER_NUM
					DB	'-'				; Show CPU type and
					DB	CPU_TYPE			; architecture target
 FF54					DB	ARCH_TYPE
							IF ARCH_SUB_TYPE NE 0
 FF54  FC				DB	ARCH_SUB_TYPE		; add optional ARCH sub-identifier
							ENDIF
			     1				IFNB <AX>			; exit if last reg
 FF55  50		     1		PUSH	AX 					; push register and repeat
			     1		PUSHX	DI, ES, , , , , 
			     2				IFNB <DI>			; exit if last reg
 FF56  57		     2		PUSH	DI 					; push register and repeat
			     2		PUSHX	ES, , , , , , 
			     3				IFNB <ES>			; exit if last reg
 FF57  06		     3		PUSH	ES 					; push register and repeat
			     3		PUSHX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		PUSH	 					; push register and repeat
			     4		PUSHX	, , , , , , 
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 234 - 1


			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 FF58  BF ---- R			DB	' '				; space before date
 FF5B  8E C7				DB	0
 FF5D  33 FF			
 FF5F  B0 01			;
 FF61  AE			; 0 BYTES HERE
 FF62  74 42			;
 FF64  FB			BYTES_HERE	POWER_ON
 FF65  4F			
 FF66  AA			BIOS		ENDS
				
			     1				IFNB <BX>			; exit if last reg
 FF67  53		     1		PUSH	BX 					; push register and repeat
			     1		PUSHX	CX, DX, , , , , 
			     2				IFNB <CX>			; exit if last reg
 FF68  51		     2		PUSH	CX 					; push register and repeat
			     2		PUSHX	DX, , , , , , 
			     3				IFNB <DX>			; exit if last reg
 FF69  52		     3		PUSH	DX 					; push register and repeat
			     3		PUSHX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		PUSH	 					; push register and repeat
			     4		PUSHX	, , , , , , 
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 FF6A  B4 0F			;============================================================================;
 FF6C  CD 10			;
 FF6E  8A DC			;				* * *    END OF BIOS   * * *
 FF70  4B			;
 FF71  B4 03			;============================================================================;
 FF73  CD 10			
 FF75  52			END
 FF76  E8 0031			
 FF79  72 1F			;----------------------------------------------------------------------------;
 FF7B  99			; Text Auto-Formatting:
 FF7C				;----------------------------------------------------------------------------;
 FF7C  B4 02			; Sublime Text syntax:
 FF7E  CD 10			; {
 FF80  B4 08			; 	"tab_completion": false,
 FF82  CD 10			;	"auto_complete": false,
 FF84  E8 002C			;	"tab_size": 6,
 FF87  72 11			; }
 FF89  38 D3			;----------------------------------------------------------------------------;
 FF8B  75 07			;
 FF8D  B2 FF			; Modeline magic for various editors
 FF8F  E8 0018			;
 FF92  72 06			; /* vim: set tabstop=6:softtabstop=6:shiftwidth=6:noexpandtab */
 FF94				; # sublime: tab_completion false; auto_complete false; tab_size 6
 FF94  42
 FF95  80 FE 19
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 235 - 1


 FF98  75 E2
 FF9A
 FF9A  1A C0
 FF9C  4F
 FF9D  AA
 FF9E  5A
 FF9F  B4 02
 FFA1  CD 10
			     1				IFNB <DX>			; exit if last reg
 FFA3  5A		     1		POP	DX 					; pop register and repeat
			     1		POPX	CX, BX, , , , , 
			     2				IFNB <CX>			; exit if last reg
 FFA4  59		     2		POP	CX 					; pop register and repeat
			     2		POPX	BX, , , , , , 
			     3				IFNB <BX>			; exit if last reg
 FFA5  5B		     3		POP	BX 					; pop register and repeat
			     3		POPX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		POP	 					; pop register and repeat
			     4		POPX	, , , , , , 
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 FFA6
			     1				IFNB <ES>			; exit if last reg
 FFA6  07		     1		POP	ES 					; pop register and repeat
			     1		POPX	DI, AX, , , , , 
			     2				IFNB <DI>			; exit if last reg
 FFA7  5F		     2		POP	DI 					; pop register and repeat
			     2		POPX	AX, , , , , , 
			     3				IFNB <AX>			; exit if last reg
 FFA8  58		     3		POP	AX 					; pop register and repeat
			     3		POPX	, , , , , , 
			     4				IFNB <>			; exit if last reg
			     4		POP	 					; pop register and repeat
			     4		POPX	, , , , , , 
			     4				ENDIF
			     3				ENDIF
			     2				ENDIF
			     1				ENDIF
 FFA9  CF
 FFAA
 FFAA  B0 0D
 FFAC  E8 0004
 FFAF  72 11
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 236 - 1


 FFB1
 FFB1  B0 0A
 FFB3
 FFB3  52
 FFB4  B4 00
 FFB6  99
 FFB7  84 C0
 FFB9  75 02
 FFBB  B0 20
 FFBD
 FFBD  CD 17
 FFBF  D0 EC
 FFC1  5A
 FFC2
 FFC2  C3
 FFC3
 FFC3
 FFC3
 FFC3
 FFC3
 FFC3  97
 FFC4  DB E3
 FFC6
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 237 - 1


 FFC6  50
 FFC7  8B DC
 FFC9  36: DD 3F
 FFCC  90
 FFCD  58
 FFCE  84 C0
 FFD0  75 0C
 FFD2
 FFD2  50
 FFD3  36: D9 3F
 FFD6  90
 FFD7  58
 FFD8  35 103F
 FFDB  83 E0 3F
 FFDE
 FFDE  97
 FFDF  C3
 FFE0
 FFE0			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_VER = VER-$
			     1	
			     1			IFDEF BYTES_HERE_VER
			     1			IF2
			     1			IF BYTES_HERE_VER LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: VER (BYTES_HERE_VER)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
 FFE0 56 65 72 3A 20
 FFE5  30 2E 32 2E 35
 FFEA  2D
 FFEB  38
 FFEC  54
 FFED  20
 FFEE  00
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Page 238 - 1


 FFEF			     1			LOCAL LBL
			     1	
 = 0001			     1	BYTES_HERE_POWER_ON = POWER_ON-$
			     1	
			     1			IFDEF BYTES_HERE_POWER_ON
			     1			IF2
			     1			IF BYTES_HERE_POWER_ON LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: POWER_ON (BYTES_HERE_POWER_ON)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
 FFEF
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 239 - 1




Macros:

                N a m e                 Type

BEEP_OFF . . . . . . . . . . . .	Proc
BEEP_ON  . . . . . . . . . . . .	Proc
BYTES_HERE . . . . . . . . . . .	Proc
CALL_NS  . . . . . . . . . . . .	Proc
CGA_WAIT_SYNC  . . . . . . . . .	Proc
CLR1_BP  . . . . . . . . . . . .	Proc
GET_EFLAG  . . . . . . . . . . .	Proc
IO_DELAY_LONG  . . . . . . . . .	Proc
IO_DELAY_SHORT . . . . . . . . .	Proc
IO_DELAY_TURBO . . . . . . . . .	Proc
IO_DELAY . . . . . . . . . . . .	Proc
IRET_F . . . . . . . . . . . . .	Proc
JNWB . . . . . . . . . . . . . .	Proc
JWB  . . . . . . . . . . . . . .	Proc
NOT1_BP  . . . . . . . . . . . .	Proc
POPX . . . . . . . . . . . . . .	Proc
POST_COL_1 . . . . . . . . . . .	Proc
POST_COL_2 . . . . . . . . . . .	Proc
POST_COL_END_NL  . . . . . . . .	Proc
POST_COL_END . . . . . . . . . .	Proc
POST_FLAG_CLR  . . . . . . . . .	Proc
POST_FLAG_FLIP . . . . . . . . .	Proc
POST_FLAG_SET  . . . . . . . . .	Proc
POST_FLAG_TEST . . . . . . . . .	Proc
PRINTLN_SZ . . . . . . . . . . .	Proc
PRINT_SZ . . . . . . . . . . . .	Proc
PUSHX  . . . . . . . . . . . . .	Proc
SET1_BP  . . . . . . . . . . . .	Proc
SET_EFLAG  . . . . . . . . . . .	Proc
SET_GFLAG  . . . . . . . . . . .	Proc
SET_SZ_ATTR  . . . . . . . . . .	Proc
TEST1_BP . . . . . . . . . . . .	Proc
TEST_EFLAG . . . . . . . . . . .	Proc
TEST_GFLAG . . . . . . . . . . .	Proc
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 240 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CRTC . . . . . . . . . . . . . .	 0010
  H_TC . . . . . . . . . . . . .	 0000	     Byte
  H_CL . . . . . . . . . . . . .	 0001	     Byte
  H_SP . . . . . . . . . . . . .	 0002	     Byte
  H_SW . . . . . . . . . . . . .	 0003	     Byte
  V_TL . . . . . . . . . . . . .	 0004	     Byte
  V_SL . . . . . . . . . . . . .	 0005	     Byte
  V_DR . . . . . . . . . . . . .	 0006	     Byte
  V_SP . . . . . . . . . . . . .	 0007	     Byte
  IL . . . . . . . . . . . . . .	 0008	     Byte
  MSL  . . . . . . . . . . . . .	 0009	     Byte
  CSL  . . . . . . . . . . . . .	 000A	     Byte
  CEL  . . . . . . . . . . . . .	 000B	     Byte
  SA_H . . . . . . . . . . . . .	 000C	     Byte
  SA_L . . . . . . . . . . . . .	 000D	     Byte
  CA_H . . . . . . . . . . . . .	 000E	     Byte
  CA_L . . . . . . . . . . . . .	 000F	     Byte
DBT  . . . . . . . . . . . . . .	 000B
  SRT  . . . . . . . . . . . . .	 0000	     Byte
  HLT_ND . . . . . . . . . . . .	 0001	     Byte
  FMCT . . . . . . . . . . . . .	 0002	     Byte
  FBPS . . . . . . . . . . . . .	 0003	     Byte
  SPT  . . . . . . . . . . . . .	 0004	     Byte
  SGAP . . . . . . . . . . . . .	 0005	     Byte
  LSEC . . . . . . . . . . . . .	 0006	     Byte
  FGAP . . . . . . . . . . . . .	 0007	     Byte
  FFILL  . . . . . . . . . . . .	 0008	     Byte
  HDST . . . . . . . . . . . . .	 0009	     Byte
  FMST . . . . . . . . . . . . .	 000A	     Byte
FDC_CSB  . . . . . . . . . . . .	 0007
  SB0  . . . . . . . . . . . . .	 0000	     Byte
  SB1  . . . . . . . . . . . . .	 0001	     Byte
  SB2  . . . . . . . . . . . . .	 0002	     Byte
  CYL  . . . . . . . . . . . . .	 0003	     Byte
  HEAD . . . . . . . . . . . . .	 0004	     Byte
  SEC  . . . . . . . . . . . . .	 0005	     Byte
  BPS  . . . . . . . . . . . . .	 0006	     Byte
TIMER_C  . . . . . . . . . . . .	 0005
  LW . . . . . . . . . . . . . .	 0000	     Word
  HW . . . . . . . . . . . . . .	 0002	     Word
  OF . . . . . . . . . . . . . .	 0004	     Byte
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 241 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

BEEP_SL  . . . . . . . . . . . .	 0008	   0002
  BEEP_S . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  BEEP_L . . . . . . . . . . . .	 0000	   0004	     000F     ?
COM_LCR  . . . . . . . . . . . .	 0008	   0007
  DLAB . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  LCBK . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  LCPD . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  LCEPS  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LCPEN  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LCSB . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  LCWLS  . . . . . . . . . . . .	 0000	   0002	     0003     ?
COM_LSR  . . . . . . . . . . . .	 0008	   0008
  LSX  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  TSRE . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  THRE . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  LBI  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LFE  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LPE  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  LOE  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  LDR  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
COM_MCR  . . . . . . . . . . . .	 0008	   0006
  MCRX . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  MCLB . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  MCO2 . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  MCO1 . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  RTS  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DTR  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
COM_MSR  . . . . . . . . . . . .	 0008	   0008
  MLSD . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  MRI  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  MDSR . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  MCTS . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  DDCD . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DRI  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DDSR . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DCTS . . . . . . . . . . . . .	 0000	   0001	     0001     ?
DBW  . . . . . . . . . . . . . .	 0010	   0002
  HWB  . . . . . . . . . . . . .	 0008	   0008	     FF00     ?
  LWB  . . . . . . . . . . . . .	 0000	   0008	     00FF     ?
DMA_CR . . . . . . . . . . . . .	 0008	   0008
  DACK . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  DREQ . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  DWS  . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  DPRI . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  DTIM . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DDIS . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DHLD . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DM2M . . . . . . . . . . . . .	 0000	   0001	     0001     ?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 242 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

DMA_MR . . . . . . . . . . . . .	 0008	   0005
  DMM  . . . . . . . . . . . . .	 0006	   0002	     00C0      0001
  DMINC  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  DMAI . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  DMOP . . . . . . . . . . . . .	 0002	   0002	     000C     ?
  DMCH . . . . . . . . . . . . .	 0000	   0002	     0003     ?
DMA_SMR  . . . . . . . . . . . .	 0008	   0002
  SMCLR  . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  SMCH . . . . . . . . . . . . .	 0000	   0002	     0003     ?
DMA_SR . . . . . . . . . . . . .	 0008	   0008
  CR3  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  CR2  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  CR1  . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  CR0  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  TC3  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  TC2  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  TC1  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  TC0  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
DNB  . . . . . . . . . . . . . .	 0008	   0002
  HBN  . . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  LBN  . . . . . . . . . . . . .	 0000	   0004	     000F     ?
EFLAGS86 . . . . . . . . . . . .	 0008	   0008
  FSF  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FZF  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FR1  . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FAF  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FR2  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FPF  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FR3  . . . . . . . . . . . . .	 0001	   0001	     0002      0001
  FCF  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
EQFLAGS  . . . . . . . . . . . .	 0010	   000A
  LPT  . . . . . . . . . . . . .	 000E	   0002	     C000     ?
  X1 . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  GAM  . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  COM  . . . . . . . . . . . . .	 0009	   0003	     0E00     ?
  DMA  . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  FLP  . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  VIDM . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  MBRAM  . . . . . . . . . . . .	 0002	   0002	     000C      0003
  FPU  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  IPL  . . . . . . . . . . . . .	 0000	   0001	     0001      0000
FDC_CB . . . . . . . . . . . . .	 0008	   0004
  FC0MT  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FC0MF  . . . . . . . . . . . .	 0006	   0001	     0040      0001
  FC0SK  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FC0CMD . . . . . . . . . . . .	 0000	   0005	     001F     ?
FDC_DOR  . . . . . . . . . . . .	 0008	   0007
  FDMD . . . . . . . . . . . . .	 0007	   0001	     0080     ?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 243 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  FDMC . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FDMB . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FDMA . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FDDMA  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FDCEN  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FDSEL  . . . . . . . . . . . .	 0000	   0002	     0003     ?
FDC_MF . . . . . . . . . . . . .	 0008	   0003
  FWRT . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FMTBD  . . . . . . . . . . . .	 0004	   0003	     0070     ?
  FMOT . . . . . . . . . . . . .	 0000	   0004	     000F     ?
FDC_MODE . . . . . . . . . . . .	 0008	   0008
  FM1X . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FM1D . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FM1M . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FM18 . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FM0X . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FM0D . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FM0M . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  FM08 . . . . . . . . . . . . .	 0000	   0001	     0001     ?
FDC_MSR  . . . . . . . . . . . .	 0008	   0008
  FDRR . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FIOD . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FDND . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FDRW . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  F3SK . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  F2SK . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  F1SK . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  F0SK . . . . . . . . . . . . .	 0000	   0001	     0001     ?
FDC_SF . . . . . . . . . . . . .	 0008	   0006
  FWIF . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FSTBD  . . . . . . . . . . . .	 0004	   0003	     0070     ?
  FCAL3  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FCAL2  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FCAL1  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  FCAL0  . . . . . . . . . . . .	 0000	   0001	     0001     ?
FDC_ST0  . . . . . . . . . . . .	 0008	   0006
  ST0CS  . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  ST0SK  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  ST0CHK . . . . . . . . . . . .	 0004	   0001	     0010     ?
  ST0NR  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  ST0HD  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  ST0DRV . . . . . . . . . . . .	 0000	   0002	     0003     ?
FDC_STATE  . . . . . . . . . . .	 0008	   0005
  FSR  . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  FDDS . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FSE  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FDX  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FSD  . . . . . . . . . . . . .	 0000	   0003	     0007     ?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 244 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

GFLAGS . . . . . . . . . . . . .	 0008	   0004
  GTBD1  . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  TURBO  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  V20  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  GTBD2  . . . . . . . . . . . .	 0000	   0002	     0003     ?
ICW1 . . . . . . . . . . . . . .	 0008	   0005
  D4 . . . . . . . . . . . . . .	 0004	   0004	     00F0      0001
  LTIM . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  ADI  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  SNGL . . . . . . . . . . . . .	 0001	   0001	     0002      0001
  IC4  . . . . . . . . . . . . .	 0000	   0001	     0001      0001
ICW2 . . . . . . . . . . . . . .	 0008	   0002
  ICW2IVA  . . . . . . . . . . .	 0003	   0005	     00F8     ?
  ICW2X  . . . . . . . . . . . .	 0000	   0003	     0007      0000
ICW4 . . . . . . . . . . . . . .	 0008	   0004
  SFNM . . . . . . . . . . . . .	 0004	   0004	     00F0      0000
  ICWBUF . . . . . . . . . . . .	 0002	   0002	     000C     ?
  AEOI . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  uPM  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
KBFLAGS1 . . . . . . . . . . . .	 0008	   0008
  K1IN . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  K1CL . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  K1NL . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  K1SL . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  K1AL . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  K1CT . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  K1LS . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  K1RS . . . . . . . . . . . . .	 0000	   0001	     0001     ?
KBFLAGS2 . . . . . . . . . . . .	 0008	   0008
  K2IN . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  K2CL . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  K2NL . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  K2SL . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  K2PA . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  K2SY . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  K2LA . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  K2LC . . . . . . . . . . . . .	 0000	   0001	     0001     ?
KBFLAGS3 . . . . . . . . . . . .	 0008	   0008
  KERD . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  KEFI . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  KENL . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  KEEN . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  KERA . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  KERC . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  KEE0 . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  KEE1 . . . . . . . . . . . . .	 0000	   0001	     0001     ?
KBFLAGS4 . . . . . . . . . . . .	 0008	   0008
  KLTE . . . . . . . . . . . . .	 0007	   0001	     0080     ?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 245 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  KLMU . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  KLRF . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  KLAK . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  KLCI . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  KLCL . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  KLNL . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  KLSL . . . . . . . . . . . . .	 0000	   0001	     0001     ?
MDA_CH_ATTR  . . . . . . . . . .	 0008	   0004
  MDBK . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  MDBG . . . . . . . . . . . . .	 0004	   0003	     0070     ?
  MDIN . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  MDFG . . . . . . . . . . . . .	 0000	   0003	     0007      0007
NMI  . . . . . . . . . . . . . .	 0008	   0002
  NMIE . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  NMIX . . . . . . . . . . . . .	 0000	   0007	     007F     ?
OCW1 . . . . . . . . . . . . . .	 0008	   0008
  IRQ7 . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  IRQ6 . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  IRQ5 . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  IRQ4 . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  IRQ3 . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  IRQ2 . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  IRQ1 . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  IRQ0 . . . . . . . . . . . . .	 0000	   0001	     0001     ?
OCW2 . . . . . . . . . . . . . .	 0008	   0003
  O2CMD  . . . . . . . . . . . .	 0005	   0003	     00E0      0001
  O2X  . . . . . . . . . . . . .	 0003	   0002	     0018     ?
  O2L  . . . . . . . . . . . . .	 0000	   0003	     0007     ?
OCW3 . . . . . . . . . . . . . .	 0008	   0005
  O3D7 . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  ESMM . . . . . . . . . . . . .	 0005	   0002	     0060     ?
  O3D3 . . . . . . . . . . . . .	 0003	   0002	     0018      0001
  O3P  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  O3RR . . . . . . . . . . . . .	 0000	   0002	     0003     ?
PFLAGS . . . . . . . . . . . . .	 0010	   000A
  WARM . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  PKI  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  PKEY . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  PFDC . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  PFSK . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  PDMA . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  PMEM . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  PFXX . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  PTBD . . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  GRND . . . . . . . . . . . . .	 0000	   0002	     0003     ?
PIT_CW . . . . . . . . . . . . .	 0008	   0004
  PCWSC  . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  PCWRW  . . . . . . . . . . . .	 0004	   0002	     0030     ?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 246 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  PCWM . . . . . . . . . . . . .	 0001	   0003	     000E     ?
  PCWBCD . . . . . . . . . . . .	 0000	   0001	     0001     ?
PPI_B_F  . . . . . . . . . . . .	 0008	   0008
  PBKB . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  PBKC . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PBIO . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  PBPC . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  PBSW . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  PBTB . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PBSP . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PBST . . . . . . . . . . . . .	 0000	   0001	     0001     ?
PPI_CR . . . . . . . . . . . . .	 0008	   0007
  PPEN . . . . . . . . . . . . .	 0007	   0001	     0080      0001
  PPAM . . . . . . . . . . . . .	 0005	   0002	     0060      0000
  PPAD . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  PPCU . . . . . . . . . . . . .	 0003	   0001	     0008      0001
  PPBM . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PPBD . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PPCL . . . . . . . . . . . . .	 0000	   0001	     0001      0001
PPI_C_X_H  . . . . . . . . . . .	 0008	   0006
  PC2PE  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  PC2IE  . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PC2T2  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  PC2CI  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  PCDRV  . . . . . . . . . . . .	 0002	   0002	     000C     ?
  PCVID  . . . . . . . . . . . .	 0000	   0002	     0003     ?
PPI_C_X_L  . . . . . . . . . . .	 0008	   0007
  PCPE . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  PCIE . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PCT2 . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  PCCI . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  PCMB . . . . . . . . . . . . .	 0002	   0002	     000C     ?
  PCFP . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PCFD . . . . . . . . . . . . .	 0000	   0001	     0001     ?
PRN_CTRL . . . . . . . . . . . .	 0008	   0006
  LCX  . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  LCIRQ  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LCDR . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LCINI  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  LCLF . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  LCOUT  . . . . . . . . . . . .	 0000	   0001	     0001     ?
PRN_STAT . . . . . . . . . . . .	 0008	   0007
  LPBZ . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  LPACK  . . . . . . . . . . . .	 0006	   0001	     0040     ?
  LPOP . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  LPSEL  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LPIO . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LPX  . . . . . . . . . . . . .	 0001	   0002	     0006     ?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 247 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  LPTO . . . . . . . . . . . . .	 0000	   0001	     0001     ?
TD_UMA_CR  . . . . . . . . . . .	 0008	   0002
  TDUX . . . . . . . . . . . . .	 0001	   0007	     00FE     ?
  TDUB . . . . . . . . . . . . .	 0000	   0001	     0001     ?
TD_WS_CR . . . . . . . . . . . .	 0008	   0005
  TDWSI  . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  TDWSR  . . . . . . . . . . . .	 0004	   0002	     0030     ?
  TDWIO  . . . . . . . . . . . .	 0002	   0002	     000C     ?
  TDWRA  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  TDWRO  . . . . . . . . . . . .	 0000	   0001	     0001     ?
V40_WCY1 . . . . . . . . . . . .	 0008	   0004
  IOW  . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  UMW  . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  MMW  . . . . . . . . . . . . .	 0002	   0002	     000C     ?
  LMW  . . . . . . . . . . . . .	 0000	   0002	     0003     ?
VID_CSGFX  . . . . . . . . . . .	 0008	   0005
  CGPH . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  CGPL . . . . . . . . . . . . .	 0005	   0001	     0020      0001
  CGX  . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  CGIN . . . . . . . . . . . . .	 0003	   0001	     0008      0001
  CGBG . . . . . . . . . . . . .	 0000	   0003	     0007      0007
VID_CSTXT  . . . . . . . . . . .	 0008	   0004
  CTX  . . . . . . . . . . . . .	 0005	   0003	     00E0      0001
  CTBI . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  CTIN . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  CTBC . . . . . . . . . . . . .	 0000	   0003	     0007     ?
VID_STAT . . . . . . . . . . . .	 0008	   0005
  VSX  . . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  VSVS . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  VSPE . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  VSPT . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  VSHS . . . . . . . . . . . . .	 0000	   0001	     0001     ?
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 248 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

BIOS . . . . . . . . . . . . . .	16 Bit	 00010000 Para	  Private 
_BASIC . . . . . . . . . . . . .	16 Bit	 0000	  Abs	  Private 
_BDA_ABS . . . . . . . . . . . .	16 Bit	 0474	  Abs	  Private 
_BDA . . . . . . . . . . . . . .	16 Bit	 00ED	  Abs	  Private 
_BIOS  . . . . . . . . . . . . .	16 Bit	 FFF0	  Abs	  Private 
_BOOT_STACK  . . . . . . . . . .	16 Bit	 0102	  Abs	  Private 
_CGA_MEM . . . . . . . . . . . .	16 Bit	 4000	  Abs	  Private 
_DOS_DAT . . . . . . . . . . . .	16 Bit	 0034	  Abs	  Private 
_DOS_SEG . . . . . . . . . . . .	16 Bit	 0000	  Abs	  Private 
_IPL_SEG . . . . . . . . . . . .	16 Bit	 7E00	  Abs	  Private 
_IVT . . . . . . . . . . . . . .	16 Bit	 0080	  Abs	  Private 
_MDA_MEM . . . . . . . . . . . .	16 Bit	 1000	  Abs	  Private 
_OPT_ROM . . . . . . . . . . . .	16 Bit	 0000	  Abs	  Private 
_VID_BIOS  . . . . . . . . . . .	16 Bit	 0005	  Abs	  Private 
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 249 - 1




Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

BANNER_STRINGS . . . . . . . . .	P Near	 E46B	  BIOS	Length= 0037 Private
BEEP_OFF_P . . . . . . . . . . .	P Near	 E8EE	  BIOS	Length= 0007 Private
BEEP_ON_1  . . . . . . . . . . .	P Near	 E8E1	  BIOS	Length= 000D Private
BEEP_ON_P  . . . . . . . . . . .	P Near	 E8DB	  BIOS	Length= 0013 Private
BEEP . . . . . . . . . . . . . .	P Near	 E8AE	  BIOS	Length= 0014 Private
BIOS_ROM_SCAN  . . . . . . . . .	P Near	 E4ED	  BIOS	Length= 004B Private
BIOS_TOP . . . . . . . . . . . .	P Near	 E000	  BIOS	Length= 005B Private
BOOT . . . . . . . . . . . . . .	P Near	 E05B	  BIOS	Length= 0410 Private
BYTE_HEX . . . . . . . . . . . .	P Near	 F751	  BIOS	Length= 001F Private
CRLF_SHOW_CURSOR . . . . . . . .	P Near	 F032	  BIOS	Length= 0013 Private
CRLF . . . . . . . . . . . . . .	P Near	 F716	  BIOS	Length= 0009 Private
DETECT_MEMORY  . . . . . . . . .	P Near	 E54C	  BIOS	Length= 0099 Private
DWORD_HEX  . . . . . . . . . . .	P Near	 F73E	  BIOS	Length= 0032 Private
FDC_FORMAT . . . . . . . . . . .	P Near	 EDE4	  BIOS	Length= 001B Private
FDC_MOTOR_ON . . . . . . . . . .	P Near	 EE37	  BIOS	Length= 0040 Private
FDC_RECAL  . . . . . . . . . . .	P Near	 EF92	  BIOS	Length= 0033 Private
FDC_RECV_ALL . . . . . . . . . .	P Near	 EECE	  BIOS	Length= 002C Private
FDC_RECV_STATUS  . . . . . . . .	P Near	 EECC	  BIOS	Length= 002E Private
FDC_RECV . . . . . . . . . . . .	P Near	 EE77	  BIOS	Length= 004B Private
FDC_RWV  . . . . . . . . . . . .	P Near	 ED87	  BIOS	Length= 0054 Private
FDC_SEC_COUNT  . . . . . . . . .	P Near	 EDBD	  BIOS	Length= 001E Private
FDC_SEEK . . . . . . . . . . . .	P Near	 EDFF	  BIOS	Length= 0038 Private
FDC_SEND_PARAM . . . . . . . . .	P Near	 EE7E	  BIOS	Length= 0044 Private
FDC_SEND . . . . . . . . . . . .	P Near	 EE81	  BIOS	Length= 0041 Private
FDC_WAIT_INT . . . . . . . . . .	P Near	 EF6B	  BIOS	Length= 0027 Private
FDC_WAIT_SENSE . . . . . . . . .	P Near	 EEC2	  BIOS	Length= 0038 Private
FDC_WAIT_STATUS_ERR  . . . . . .	P Near	 EF02	  BIOS	Length= 0026 Private
FDC_WAIT_STATUS  . . . . . . . .	P Near	 EEFA	  BIOS	Length= 002E Private
GET_DISK_PARAMS  . . . . . . . .	P Near	 E71E	  BIOS	Length= 001B Private
HALT_BEEP  . . . . . . . . . . .	P Near	 E874	  BIOS	Length= 003A Private
HAS_FPU  . . . . . . . . . . . .	P Near	 FFC3	  BIOS	Length= 001D Private
HDD_POST_COUNT . . . . . . . . .	P Near	 E3DD	  BIOS	Length= 0013 Private
HDD_POST . . . . . . . . . . . .	P Near	 E3CF	  BIOS	Length= 002E Private
HELLO_RAND_TAGLINE . . . . . . .	P Near	 F8C7	  BIOS	Length= 006E Private
HIDE_CURSOR  . . . . . . . . . .	P Near	 F03B	  BIOS	Length= 000A Private
INT_02 . . . . . . . . . . . . .	P Near	 E2C3	  BIOS	Length= 0023 Private
INT_05 . . . . . . . . . . . . .	P Near	 FF54	  BIOS	Length= 006F Private
INT_08_PROC  . . . . . . . . . .	P Near	 FE97	  BIOS	Length= 0049 Private
INT_08 . . . . . . . . . . . . .	P Near	 FEA5	  BIOS	Length= 003B Private
INT_09_POST  . . . . . . . . . .	P Near	 E934	  BIOS	Length= 001B Private
INT_09 . . . . . . . . . . . . .	P Near	 E987	  BIOS	Length= 02BB Private
INT_0E . . . . . . . . . . . . .	P Near	 EF57	  BIOS	Length= 0014 Private
INT_10_0 . . . . . . . . . . . .	P Near	 F0E4	  BIOS	Length= 00BB Private
INT_10_1 . . . . . . . . . . . .	P Near	 F19F	  BIOS	Length= 0016 Private
INT_10_2 . . . . . . . . . . . .	P Near	 F1B5	  BIOS	Length= 0039 Private
INT_10_3_CUR_PAGE  . . . . . . .	P Near	 F1EE	  BIOS	Length= 001E Private
INT_10_3 . . . . . . . . . . . .	P Near	 F1FB	  BIOS	Length= 0011 Private
INT_10_5 . . . . . . . . . . . .	P Near	 F20C	  BIOS	Length= 0027 Private
INT_10_6 . . . . . . . . . . . .	P Near	 F234	  BIOS	Length= 0113 Private
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 250 - 1




Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

INT_10_7 . . . . . . . . . . . .	P Near	 F233	  BIOS	Length= 0114 Private
INT_10_8_MODE_GFX  . . . . . . .	P Near	 F361	  BIOS	Length= 0087 Private
INT_10_8 . . . . . . . . . . . .	P Near	 F347	  BIOS	Length= 00A1 Private
INT_10_9A_MODE_GFX . . . . . . .	P Near	 F413	  BIOS	Length= 00BF Private
INT_10_9 . . . . . . . . . . . .	P Near	 F3E8	  BIOS	Length= 00EA Private
INT_10_A . . . . . . . . . . . .	P Near	 F3E8	  BIOS	Length= 00EA Private
INT_10_B . . . . . . . . . . . .	P Near	 F4D2	  BIOS	Length= 002B Private
INT_10_C . . . . . . . . . . . .	P Near	 F4FD	  BIOS	Length= 0027 Private
INT_10_D . . . . . . . . . . . .	P Near	 F524	  BIOS	Length= 0013 Private
INT_10_E . . . . . . . . . . . .	P Near	 F576	  BIOS	Length= 006F Private
INT_10_F . . . . . . . . . . . .	P Near	 F5E5	  BIOS	Length= 0008 Private
INT_10_GET_CUR_ADDR  . . . . . .	P Near	 F5ED	  BIOS	Length= 0022 Private
INT_10_GFX_CHARPOS . . . . . . .	P Near	 F4BD	  BIOS	Length= 0015 Private
INT_10_GFX_PIXEL . . . . . . . .	P Near	 F537	  BIOS	Length= 003F Private
INT_10_IS_CGA80  . . . . . . . .	P Near	 F090	  BIOS	Length= 0013 Private
INT_10_IS_TXT  . . . . . . . . .	P Near	 F085	  BIOS	Length= 000B Private
INT_10_SCR_GFX . . . . . . . . .	P Near	 F2C0	  BIOS	Length= 0087 Private
INT_10 . . . . . . . . . . . . .	P Near	 F065	  BIOS	Length= 05B2 Private
INT_11 . . . . . . . . . . . . .	P Near	 F84D	  BIOS	Length= 000C Private
INT_12 . . . . . . . . . . . . .	P Near	 F841	  BIOS	Length= 000C Private
INT_13_0 . . . . . . . . . . . .	P Near	 EC97	  BIOS	Length= 004D Private
INT_13_1 . . . . . . . . . . . .	P Near	 ECE4	  BIOS	Length= 0007 Private
INT_13_2_5 . . . . . . . . . . .	P Near	 ECF1	  BIOS	Length= 0114 Private
INT_13 . . . . . . . . . . . . .	P Near	 EC59	  BIOS	Length= 036C Private
INT_14_0 . . . . . . . . . . . .	P Near	 E764	  BIOS	Length= 0036 Private
INT_14_1 . . . . . . . . . . . .	P Near	 E79A	  BIOS	Length= 001E Private
INT_14_2 . . . . . . . . . . . .	P Near	 E7B8	  BIOS	Length= 0016 Private
INT_14_3 . . . . . . . . . . . .	P Near	 E78A	  BIOS	Length= 000A Private
INT_14_DONE  . . . . . . . . . .	P Near	 E794	  BIOS	Length= 0006 Private
INT_14_EXIT  . . . . . . . . . .	P Near	 E798	  BIOS	Length= 0002 Private
INT_14_POLL_PORT . . . . . . . .	P Near	 E7D6	  BIOS	Length= 0018 Private
INT_14_POLL  . . . . . . . . . .	P Near	 E7CE	  BIOS	Length= 0020 Private
INT_14 . . . . . . . . . . . . .	P Near	 E739	  BIOS	Length= 00B5 Private
INT_15 . . . . . . . . . . . . .	P Near	 F859	  BIOS	Length= 000A Private
INT_16 . . . . . . . . . . . . .	P Near	 E82E	  BIOS	Length= 0046 Private
INT_17 . . . . . . . . . . . . .	P Near	 EFD2	  BIOS	Length= 0060 Private
INT_18 . . . . . . . . . . . . .	P Near	 E459	  BIOS	Length= 0012 Private
INT_19 . . . . . . . . . . . . .	P Near	 E6F2	  BIOS	Length= 002C Private
INT_1A_READ  . . . . . . . . . .	P Near	 FE81	  BIOS	Length= 000C Private
INT_1A_SET . . . . . . . . . . .	P Near	 FE8D	  BIOS	Length= 000A Private
INT_1A . . . . . . . . . . . . .	P Near	 FE6E	  BIOS	Length= 0029 Private
INT_1D . . . . . . . . . . . . .	P Near	 F0A4	  BIOS	Length= 0040 Private
INT_1E_PARAM . . . . . . . . . .	P Near	 EF28	  BIOS	Length= 000E Private
INT_IRQ  . . . . . . . . . . . .	P Near	 FF23	  BIOS	Length= 0024 Private
INT_KB_ALT . . . . . . . . . . .	P Near	 EA95	  BIOS	Length= 003F Private
INT_KB_CTRL_NO_ALT . . . . . . .	P Near	 EAD4	  BIOS	Length= 0041 Private
INT_KB_IS_FLAG . . . . . . . . .	P Near	 EB35	  BIOS	Length= 0053 Private
INT_KB_TOGGLE_TURBO  . . . . . .	P Near	 E978	  BIOS	Length= 000F Private
INT_RET  . . . . . . . . . . . .	P Near	 FF53	  BIOS	Length= 0001 Private
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 251 - 1




Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

IO_DELAY_MS  . . . . . . . . . .	P Near	 F774	  BIOS	Length= 0031 Private
IO_DELAY_TICK  . . . . . . . . .	P Near	 F778	  BIOS	Length= 002D Private
IO_WAIT_LATCH  . . . . . . . . .	P Near	 F795	  BIOS	Length= 0010 Private
IO_WAIT_MS_125 . . . . . . . . .	P Near	 F770	  BIOS	Length= 0035 Private
KB_BUF_CLEAR . . . . . . . . . .	P Near	 E94F	  BIOS	Length= 0011 Private
KB_KEY_STATUS  . . . . . . . . .	P Near	 E840	  BIOS	Length= 0013 Private
KB_SHIFT_STATUS  . . . . . . . .	P Near	 E86F	  BIOS	Length= 0005 Private
KB_WAIT_READ . . . . . . . . . .	P Near	 E853	  BIOS	Length= 001C Private
LPT_CHAR . . . . . . . . . . . .	P Near	 FFB3	  BIOS	Length= 0010 Private
LPT_CRLF . . . . . . . . . . . .	P Near	 FFAA	  BIOS	Length= 0019 Private
LPT_LF . . . . . . . . . . . . .	P Near	 FFB1	  BIOS	Length= 0012 Private
MEEPMEEP . . . . . . . . . . . .	P Near	 E8C2	  BIOS	Length= 0019 Private
MEEP . . . . . . . . . . . . . .	P Near	 E8C5	  BIOS	Length= 0016 Private
MEM_ADDR_TEST  . . . . . . . . .	P Near	 E5E5	  BIOS	Length= 0026 Private
MEM_CHECK  . . . . . . . . . . .	P Near	 E613	  BIOS	Length= 000F Private
MEM_TEST . . . . . . . . . . . .	P Near	 E60B	  BIOS	Length= 0017 Private
MOVE_COL . . . . . . . . . . . .	P Near	 F6FC	  BIOS	Length= 0017 Private
NIB_HEX  . . . . . . . . . . . .	P Near	 F75E	  BIOS	Length= 0012 Private
NMI_RESET  . . . . . . . . . . .	P Near	 E81D	  BIOS	Length= 000B Private
OUTLN_SZ . . . . . . . . . . . .	P Near	 F713	  BIOS	Length= 000C Private
OUT_CHAR . . . . . . . . . . . .	P Near	 F765	  BIOS	Length= 000B Private
OUT_DECU . . . . . . . . . . . .	P Near	 F727	  BIOS	Length= 0017 Private
OUT_SZ_ATTR  . . . . . . . . . .	P Near	 F6DB	  BIOS	Length= 0021 Private
OUT_SZ . . . . . . . . . . . . .	P Near	 F6ED	  BIOS	Length= 000F Private
PORT_TEST  . . . . . . . . . . .	P Near	 E7EE	  BIOS	Length= 002F Private
POST_BOOT_TYPE . . . . . . . . .	P Near	 E622	  BIOS	Length= 0027 Private
POST_COL . . . . . . . . . . . .	P Near	 F690	  BIOS	Length= 0083 Private
POST_END_COL_NL  . . . . . . . .	P Near	 F6CD	  BIOS	Length= 0005 Private
POST_END_COL_STR . . . . . . . .	P Near	 F6D5	  BIOS	Length= 0027 Private
POST_END_COL . . . . . . . . . .	P Near	 F6D2	  BIOS	Length= 002A Private
POST_ERROR_MSG . . . . . . . . .	P Near	 E91E	  BIOS	Length= 0016 Private
POST_KB_RESET  . . . . . . . . .	P Near	 E352	  BIOS	Length= 005E Private
POST_START_COL_1 . . . . . . . .	P Near	 F694	  BIOS	Length= 0027 Private
POST_START_COL_2 . . . . . . . .	P Near	 F6BB	  BIOS	Length= 0012 Private
POST_STRINGS . . . . . . . . . .	P Near	 E4A2	  BIOS	Length= 0041 Private
POST_SYS_CONFIG  . . . . . . . .	P Near	 F617	  BIOS	Length= 0079 Private
POST_SYS_VIDEO . . . . . . . . .	P Near	 E649	  BIOS	Length= 004F Private
POWER_ON . . . . . . . . . . . .	P Far	 FFF0	  BIOS	Length= 0010 Private
ROM_CHECKSUM . . . . . . . . . .	P Near	 E538	  BIOS	Length= 0014 Private
SET_CURSOR . . . . . . . . . . .	P Near	 F03E	  BIOS	Length= 0007 Private
SHOW_CURSOR  . . . . . . . . . .	P Near	 F035	  BIOS	Length= 0010 Private
SHOW_DISK_PARAMS . . . . . . . .	P Near	 F863	  BIOS	Length= 0064 Private
SHOW_PORT_COUNT  . . . . . . . .	P Near	 F678	  BIOS	Length= 0018 Private
SPACE  . . . . . . . . . . . . .	P Near	 F71F	  BIOS	Length= 0008 Private
STRINGS  . . . . . . . . . . . .	P Near	 E46B	  BIOS	Length= 0082 Private
TOGGLE_TURBO . . . . . . . . . .	P Near	 E28E	  BIOS	Length= 0016 Private
VECTOR_TABLE . . . . . . . . . .	P Near	 FEE3	  BIOS	Length= 0040 Private
WORD_HEX . . . . . . . . . . . .	P Near	 F74A	  BIOS	Length= 0026 Private
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 252 - 1




Symbols:

                N a m e                 Type     Value    Attr

??0001 . . . . . . . . . . . . .	L Near	 E120	  BIOS	
??0002 . . . . . . . . . . . . .	L Near	 E122	  BIOS	
??0003 . . . . . . . . . . . . .	L Near	 E14B	  BIOS	
??0004 . . . . . . . . . . . . .	L Near	 E14D	  BIOS	
??0005 . . . . . . . . . . . . .	L Near	 E15F	  BIOS	
??0006 . . . . . . . . . . . . .	L Near	 E161	  BIOS	
??0007 . . . . . . . . . . . . .	L Near	 E171	  BIOS	
??0008 . . . . . . . . . . . . .	L Near	 E173	  BIOS	
??0009 . . . . . . . . . . . . .	L Near	 E17B	  BIOS	
??000A . . . . . . . . . . . . .	L Near	 E17D	  BIOS	
??000B . . . . . . . . . . . . .	L Near	 E1BB	  BIOS	
??000C . . . . . . . . . . . . .	Number	 0030h	 
??000D . . . . . . . . . . . . .	Number	 0004h	 
??000E . . . . . . . . . . . . .	Number	 0010h	 
??0010 . . . . . . . . . . . . .	L Near	 E38B	  BIOS	
??0011 . . . . . . . . . . . . .	L Near	 E394	  BIOS	
??0012 . . . . . . . . . . . . .	L Near	 E409	  BIOS	
??0013 . . . . . . . . . . . . .	L Near	 E452	  BIOS	
??0016 . . . . . . . . . . . . .	L Near	 E7FD	  BIOS	
??0018 . . . . . . . . . . . . .	L Near	 E88C	  BIOS	
??0019 . . . . . . . . . . . . .	L Near	 E88E	  BIOS	
??001A . . . . . . . . . . . . .	L Near	 E890	  BIOS	
??001B . . . . . . . . . . . . .	L Near	 E897	  BIOS	
??001C . . . . . . . . . . . . .	L Near	 E899	  BIOS	
??001D . . . . . . . . . . . . .	L Near	 E89B	  BIOS	
??001E . . . . . . . . . . . . .	L Near	 E8D0	  BIOS	
??001F . . . . . . . . . . . . .	L Near	 E8D7	  BIOS	
??0024 . . . . . . . . . . . . .	L Near	 F02A	  BIOS	
??0027 . . . . . . . . . . . . .	Number	 00C0h	 
??0028 . . . . . . . . . . . . .	Number	 0006h	 
??0029 . . . . . . . . . . . . .	Number	 0011h	 
??002A . . . . . . . . . . . . .	Number	 000Eh	 
??002B . . . . . . . . . . . . .	Number	 0001h	 
??002C . . . . . . . . . . . . .	Number	 0011h	 
ANY_KEY  . . . . . . . . . . . .	Byte	 E48D	  BIOS	
ARCH_5150  . . . . . . . . . . .	Number	 0050h	 
ARCH_5160v2  . . . . . . . . . .	Number	 0059h	 
ARCH_5160  . . . . . . . . . . .	Number	 0058h	 
ARCH_EHB . . . . . . . . . . . .	Number	 0048h	 
ARCH_EMU . . . . . . . . . . . .	Number	 0045h	 
ARCH_FE2010  . . . . . . . . . .	Number	 0046h	 
ARCH_ID  . . . . . . . . . . . .	Number	 00FEh	 
ARCH_M88 . . . . . . . . . . . .	Number	 004Dh	 
ARCH_MARTY . . . . . . . . . . .	Number	 0043h	 
ARCH_MIST  . . . . . . . . . . .	Number	 0049h	 
ARCH_SUB_TYPE  . . . . . . . . .	Number	 0000h	 
ARCH_TD3300  . . . . . . . . . .	Number	 0053h	 
ARCH_TURBO . . . . . . . . . . .	Number	 0054h	 
ARCH_TYPE  . . . . . . . . . . .	Text   	 ARCH_TURBO
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 253 - 1




Symbols:

                N a m e                 Type     Value    Attr

ARCH_UM82  . . . . . . . . . . .	Number	 0055h	 
ARCH_VEN888  . . . . . . . . . .	Number	 0056h	 
ATKB_CMD . . . . . . . . . . . .	Number	 0064h	 
ATKB_IO  . . . . . . . . . . . .	Number	 0060h	 
BASE_RAM_ERROR . . . . . . . . .	L Near	 E163	  BIOS	
BASE_RAM_TEST  . . . . . . . . .	L Near	 E137	  BIOS	
BASE_RAM_ZERO  . . . . . . . . .	L Near	 E168	  BIOS	
BASIC_ROM  . . . . . . . . . . .	Number	 0000h	 
BASIC_TOP  . . . . . . . . . . .	Word	 0000	  _BASIC	
BEEP_1K7 . . . . . . . . . . . .	Number	 04A0h	 
BEEP_1K  . . . . . . . . . . . .	Number	 04B1h	 
BEEP_2K  . . . . . . . . . . . .	Number	 0250h	 
BEEP_A6  . . . . . . . . . . . .	Number	 054Ch	 
BEEP_B5  . . . . . . . . . . . .	Number	 0975h	 
BEEP_C5  . . . . . . . . . . . .	Number	 08F1h	 
BEEP_C6  . . . . . . . . . . . .	Number	 0474h	 
BEEP_DEFAULT . . . . . . . . . .	Text   	 BEEP_A6
BEEP_ERR_HIGH  . . . . . . . . .	Text   	 BEEP_F5
BEEP_ERR_LOW . . . . . . . . . .	Text   	 BEEP_C5
BEEP_F5  . . . . . . . . . . . .	Number	 06A5h	 
BEEP_G5  . . . . . . . . . . . .	Number	 05FAh	 
BELL . . . . . . . . . . . . . .	Number	 0007h	 
BIOS_BREAK . . . . . . . . . . .	Byte	 0071	  _BDA	
BIOS_INT_VECTORS_LOOP  . . . . .	L Near	 E1DB	  BIOS	
BIOS_VIDEO . . . . . . . . . . .	L Near	 E668	  BIOS	
BLACK  . . . . . . . . . . . . .	Number	 0000h	 
BLOCK_LOOP_DONE  . . . . . . . .	L Near	 E56D	  BIOS	
BLOCK_LOOP . . . . . . . . . . .	L Near	 E561	  BIOS	
BLUE . . . . . . . . . . . . . .	Number	 0009h	 
BOOT_DEVICE  . . . . . . . . . .	L Near	 E44A	  BIOS	
BOOT_FAIL  . . . . . . . . . . .	Byte	 E46E	  BIOS	
BOOT_NORMAL  . . . . . . . . . .	Number	 004Eh	 
BOOT_RETRY . . . . . . . . . . .	L Near	 E44D	  BIOS	
BOOT_SPEED . . . . . . . . . . .	Text   	 BOOT_TURBO
BOOT_TURBO . . . . . . . . . . .	Number	 0054h	 
BROWN  . . . . . . . . . . . . .	Number	 0006h	 
BS . . . . . . . . . . . . . . .	Number	 0008h	 
BULL . . . . . . . . . . . . . .	Number	 00F9h	 
BYTES_HERE_BOOT  . . . . . . . .	Number	 0000h	 
BYTES_HERE_GFX_CHARSET . . . . .	Number	 0139h	 
BYTES_HERE_INT_02  . . . . . . .	Number	 001Fh	 
BYTES_HERE_INT_08  . . . . . . .	Number	 0000h	 
BYTES_HERE_INT_09  . . . . . . .	Number	 0000h	 
BYTES_HERE_INT_0E  . . . . . . .	Number	 0021h	 
BYTES_HERE_INT_10_JMP  . . . . .	Number	 0000h	 
BYTES_HERE_INT_12  . . . . . . .	Number	 008Bh	 
BYTES_HERE_INT_13  . . . . . . .	Number	 0017h	 
BYTES_HERE_INT_14  . . . . . . .	Number	 0000h	 
BYTES_HERE_INT_16  . . . . . . .	Number	 0006h	 
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 254 - 1




Symbols:

                N a m e                 Type     Value    Attr

BYTES_HERE_INT_19  . . . . . . .	Number	 005Ah	 
BYTES_HERE_INT_1D  . . . . . . .	Number	 0001h	 
BYTES_HERE_INT_1E  . . . . . . .	Number	 0002h	 
BYTES_HERE_INT_RET . . . . . . .	Number	 0001h	 
BYTES_HERE_POWER_ON  . . . . . .	Number	 0001h	 
BYTES_HERE_VECTOR_TABLE  . . . .	Number	 0003h	 
BYTES_HERE_VER . . . . . . . . .	Number	 0000h	 
CASSETTE . . . . . . . . . . . .	Number	 0000h	 
CAS_CRC  . . . . . . . . . . . .	Word	 0069	  _BDA	
CAS_PREV . . . . . . . . . . . .	Byte	 006B	  _BDA	
CAS_TIME_CNT . . . . . . . . . .	Word	 0067	  _BDA	
CGA_CTRL . . . . . . . . . . . .	Number	 03D8h	 
CGA_MEM_40 . . . . . . . . . . .	Byte	 0800	  _CGA_MEM	
CGA_MEM_80 . . . . . . . . . . .	Byte	 1000	  _CGA_MEM	
CGA_MEM_FLD  . . . . . . . . . .	Number	 2000h	 
CGA_MEM_GFX  . . . . . . . . . .	Byte	 4000	  _CGA_MEM	
CGA_MEM_SZ . . . . . . . . . . .	Number	 4000h	 
CGA_MEM_TOP  . . . . . . . . . .	Byte	 0000	  _CGA_MEM	
CGA_MEM  . . . . . . . . . . . .	Byte	 4000	  _CGA_MEM	
CGA_SNOW_REMOVE  . . . . . . . .	Number	 0000h	 
CGA_STAT . . . . . . . . . . . .	Number	 03DAh	 
CHECKSUM_LOOP  . . . . . . . . .	L Near	 E541	  BIOS	
CHECKSUM_OK  . . . . . . . . . .	L Near	 E0E3	  BIOS	
CHECKSUM_ROM . . . . . . . . . .	L Near	 E0D1	  BIOS	
CHECKSUM . . . . . . . . . . . .	L Near	 E0D8	  BIOS	
CHECK_ALT_ON . . . . . . . . . .	L Near	 EAAD	  BIOS	
CHECK_EGA  . . . . . . . . . . .	L Near	 E683	  BIOS	
CHECK_ROM  . . . . . . . . . . .	L Near	 E4F2	  BIOS	
CHECK_TOP_ROW_NUM  . . . . . . .	L Near	 EA9E	  BIOS	
CHECK_VGA  . . . . . . . . . . .	L Near	 E675	  BIOS	
CLEAR_POST_SCREEN  . . . . . . .	L Near	 E436	  BIOS	
COLD_BOOT  . . . . . . . . . . .	Number	 0000h	 
COM1_DATA  . . . . . . . . . . .	Number	 03F8h	 
COM1_IER . . . . . . . . . . . .	Number	 03F9h	 
COM1_IIR . . . . . . . . . . . .	Number	 03FAh	 
COM1_LCR . . . . . . . . . . . .	Number	 03FBh	 
COM1_LSR . . . . . . . . . . . .	Number	 03FDh	 
COM1_MCR . . . . . . . . . . . .	Number	 03FCh	 
COM1_MSR . . . . . . . . . . . .	Number	 03FEh	 
COM1_SPR . . . . . . . . . . . .	Number	 03FFh	 
COM2_DATA  . . . . . . . . . . .	Number	 02F8h	 
COM3_DATA  . . . . . . . . . . .	Number	 03E8h	 
COM4_DATA  . . . . . . . . . . .	Number	 02E8h	 
COM_ADDR . . . . . . . . . . . .	Word	 0000	  _BDA	
COM_DETECT_LOOP  . . . . . . . .	L Near	 E309	  BIOS	
COM_TIME_B . . . . . . . . . . .	Number	 007Ch	 
COM_TIME . . . . . . . . . . . .	Byte	 007C	  _BDA	
COM_TO . . . . . . . . . . . . .	Number	 0001h	 
COPYRIGHT  . . . . . . . . . . .	Byte	 E031	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 255 - 1




Symbols:

                N a m e                 Type     Value    Attr

COPY_YEAR  . . . . . . . . . . .	Text   	 '2022-23'
CPU_8088 . . . . . . . . . . . .	Number	 0038h	 
CPU_CHECK_TYPE_2_DONE  . . . . .	L Near	 F62C	  BIOS	
CPU_CHECK_TYPE_2 . . . . . . . .	L Near	 F622	  BIOS	
CPU_INST_TEST  . . . . . . . . .	L Near	 E087	  BIOS	
CPU_IS_V20 . . . . . . . . . . .	L Near	 E1E6	  BIOS	
CPU_REG_PASS . . . . . . . . . .	L Near	 E085	  BIOS	
CPU_REG_TEST . . . . . . . . . .	L Near	 E060	  BIOS	
CPU_TEST_PASS  . . . . . . . . .	L Near	 E0A1	  BIOS	
CPU_TYPE_8088  . . . . . . . . .	L Near	 E1F4	  BIOS	
CPU_TYPE_DONE  . . . . . . . . .	L Near	 E1F4	  BIOS	
CPU_TYPE . . . . . . . . . . . .	Text   	 CPU_8088
CPU_V20  . . . . . . . . . . . .	Number	 0056h	 
CRT_MODE . . . . . . . . . . . .	Byte	 F60F	  BIOS	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
CURL_BOT . . . . . . . . . . . .	Number	 00F5h	 
CURL_TOP . . . . . . . . . . . .	Number	 00F4h	 
CURSOR_DEFAULT . . . . . . . . .	Word	 00E8	  _BDA	
CYAN . . . . . . . . . . . . . .	Number	 0003h	 
DARKBLUE . . . . . . . . . . . .	Number	 0001h	 
DARKGRAY . . . . . . . . . . . .	Number	 0008h	 
DARKGREEN  . . . . . . . . . . .	Number	 0002h	 
DARKMAGENTA  . . . . . . . . . .	Number	 0005h	 
DARKRED  . . . . . . . . . . . .	Number	 0004h	 
DBLARROW . . . . . . . . . . . .	Number	 001Dh	 
DETECT_MEMORY_ERR_2  . . . . . .	L Near	 E5DC	  BIOS	
DETECT_MEMORY_ERR_DONE . . . . .	L Near	 E5E0	  BIOS	
DETECT_MEMORY_ERR  . . . . . . .	L Near	 E5B6	  BIOS	
DISABLE_NMI  . . . . . . . . . .	L Near	 E085	  BIOS	
DMA_0_A  . . . . . . . . . . . .	Number	 0000h	 
DMA_0_C  . . . . . . . . . . . .	Number	 0001h	 
DMA_1_A  . . . . . . . . . . . .	Number	 0002h	 
DMA_1_C  . . . . . . . . . . . .	Number	 0003h	 
DMA_2_A  . . . . . . . . . . . .	Number	 0004h	 
DMA_2_C  . . . . . . . . . . . .	Number	 0005h	 
DMA_3_A  . . . . . . . . . . . .	Number	 0006h	 
DMA_3_C  . . . . . . . . . . . .	Number	 0007h	 
DMA_CMD  . . . . . . . . . . . .	Number	 0008h	 
DMA_FF . . . . . . . . . . . . .	Number	 000Ch	 
DMA_MASKR  . . . . . . . . . . .	Number	 000Eh	 
DMA_MASK . . . . . . . . . . . .	Number	 000Ah	 
DMA_MMASK  . . . . . . . . . . .	Number	 000Fh	 
DMA_MODE . . . . . . . . . . . .	Number	 000Bh	 
DMA_PASS . . . . . . . . . . . .	L Near	 E126	  BIOS	
DMA_P_C0 . . . . . . . . . . . .	Number	 0087h	 
DMA_P_C1 . . . . . . . . . . . .	Number	 0083h	 
DMA_P_C2 . . . . . . . . . . . .	Number	 0081h	 
DMA_P_C3 . . . . . . . . . . . .	Number	 0082h	 
DMA_REQ  . . . . . . . . . . . .	Number	 0009h	 
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 256 - 1




Symbols:

                N a m e                 Type     Value    Attr

DMA_RESET  . . . . . . . . . . .	Number	 000Dh	 
DMA_SETUP_CH . . . . . . . . . .	L Near	 E132	  BIOS	
DONE_ZERO_ALL_RAM  . . . . . . .	L Near	 E5B3	  BIOS	
DOS_FD_PARAM . . . . . . . . . .	Byte	 0022	  _DOS_DAT	
DOT  . . . . . . . . . . . . . .	Number	 00FAh	 
DRAM_REFRESH . . . . . . . . . .	Number	 0000h	 
EKB_FLAGS1 . . . . . . . . . . .	KBFLAGS3  0096	   _BDA	
EKB_FLAGS2 . . . . . . . . . . .	KBFLAGS4  0097	   _BDA	
EOI  . . . . . . . . . . . . . .	Number	 0020h	 
EQUIP_FLAGS  . . . . . . . . . .	EQFLAGS	 0010	  _BDA	
FD0_TRACK  . . . . . . . . . . .	Byte	 0094	  _BDA	
FD1_TRACK  . . . . . . . . . . .	Byte	 0095	  _BDA	
FDC_A_STAT . . . . . . . . . . .	Number	 03F0h	 
FDC_B_STAT . . . . . . . . . . .	Number	 03F1h	 
FDC_CMD_FMT  . . . . . . . . . .	Number	 000Dh	 
FDC_CMD_RDEL . . . . . . . . . .	Number	 000Ch	 
FDC_CMD_RD . . . . . . . . . . .	Number	 0006h	 
FDC_CMD_RECAL  . . . . . . . . .	Number	 0007h	 
FDC_CMD_RSID . . . . . . . . . .	Number	 000Ah	 
FDC_CMD_RTRK . . . . . . . . . .	Number	 0002h	 
FDC_CMD_SEEK . . . . . . . . . .	Number	 000Fh	 
FDC_CMD_SENSE  . . . . . . . . .	Number	 0008h	 
FDC_CMD_SPEC . . . . . . . . . .	Number	 0003h	 
FDC_CMD_STAT . . . . . . . . . .	Number	 0004h	 
FDC_CMD_WDEL . . . . . . . . . .	Number	 0009h	 
FDC_CMD_WR . . . . . . . . . . .	Number	 0005h	 
FDC_CTRL . . . . . . . . . . . .	Number	 03F2h	 
FDC_DATA . . . . . . . . . . . .	Number	 03F5h	 
FDC_DMA_BOUND  . . . . . . . . .	L Near	 ECEB	  BIOS	
FDC_DRIVE_STARTED  . . . . . . .	L Near	 EE74	  BIOS	
FDC_DRV_ALREADY_ON . . . . . . .	L Near	 EE6B	  BIOS	
FDC_ENABLE . . . . . . . . . . .	Number	 0000h	 
FDC_ERR1_MAP . . . . . . . . . .	Byte	 EF20	  BIOS	
FDC_ERR_MAP_LOOP . . . . . . . .	L Near	 EF13	  BIOS	
FDC_FORMAT_ERR . . . . . . . . .	L Near	 EDE0	  BIOS	
FDC_HLT_WAIT . . . . . . . . . .	Number	 0001h	 
FDC_INIT_DMA_EXIT  . . . . . . .	L Near	 ED55	  BIOS	
FDC_INIT_DMA . . . . . . . . . .	L Near	 ED12	  BIOS	
FDC_LAST_ST  . . . . . . . . . .	FDC_CSB	 0042	  _BDA	
FDC_RECAL_DONE . . . . . . . . .	L Near	 EFC3	  BIOS	
FDC_RECAL_ERR  . . . . . . . . .	L Near	 EFC3	  BIOS	
FDC_RECV_ALL_DONE  . . . . . . .	L Near	 EEF5	  BIOS	
FDC_RECV_ALL_LOOP  . . . . . . .	L Near	 EEDE	  BIOS	
FDC_RECV_CHECK_ERR . . . . . . .	L Near	 EEF0	  BIOS	
FDC_RECV_DELAY . . . . . . . . .	L Near	 EEE6	  BIOS	
FDC_RECV_READY . . . . . . . . .	L Near	 EEA9	  BIOS	
FDC_RECV_WAIT_POLL . . . . . . .	L Near	 EEA5	  BIOS	
FDC_RWVF . . . . . . . . . . . .	L Near	 ED6A	  BIOS	
FDC_RWV_ERR  . . . . . . . . . .	L Near	 EDE0	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 257 - 1




Symbols:

                N a m e                 Type     Value    Attr

FDC_RWV_SEND_WAIT  . . . . . . .	L Near	 EDB3	  BIOS	
FDC_SEC_COUNT_SAME_CYL . . . . .	L Near	 EDD5	  BIOS	
FDC_SEC_COUNT_SAME . . . . . . .	L Near	 EDD7	  BIOS	
FDC_SEEK_DONE  . . . . . . . . .	L Near	 EE2F	  BIOS	
FDC_SEEK_ERR . . . . . . . . . .	L Near	 EE31	  BIOS	
FDC_SEEK_RECAL_ERR . . . . . . .	L Near	 EE34	  BIOS	
FDC_SEND_READY . . . . . . . . .	L Near	 EEA0	  BIOS	
FDC_SEND_RECV  . . . . . . . . .	L Near	 EE86	  BIOS	
FDC_SEND_WAIT_POLL_1 . . . . . .	L Near	 EE9C	  BIOS	
FDC_SEND_WAIT_POLL . . . . . . .	L Near	 EE92	  BIOS	
FDC_SEND_WAIT_TIMER  . . . . . .	L Near	 EEB0	  BIOS	
FDC_STAT . . . . . . . . . . . .	Number	 03F4h	 
FDC_ST_BADCMD  . . . . . . . . .	Number	 0001h	 
FDC_ST_DMA_64K . . . . . . . . .	Number	 0009h	 
FDC_ST_DMA_OVR . . . . . . . . .	Number	 0008h	 
FDC_ST_ERR_CRC . . . . . . . . .	Number	 0010h	 
FDC_ST_ERR_FDC . . . . . . . . .	Number	 0020h	 
FDC_ST_ERR_MARK  . . . . . . . .	Number	 0002h	 
FDC_ST_ERR_SEC . . . . . . . . .	Number	 0004h	 
FDC_ST_ERR_SEEK  . . . . . . . .	Number	 0040h	 
FDC_ST_ERR_WP  . . . . . . . . .	Number	 0003h	 
FDC_ST_OK  . . . . . . . . . . .	Number	 0000h	 
FDC_ST_SENSE . . . . . . . . . .	Number	 00FFh	 
FDC_ST_TIMEOUT . . . . . . . . .	Number	 0080h	 
FDC_WAIT_DONE  . . . . . . . . .	L Near	 EEAA	  BIOS	
FDC_WAIT_ERR_EXIT_OK . . . . . .	L Near	 EF1F	  BIOS	
FDC_WAIT_ERR_EXIT  . . . . . . .	L Near	 EF1B	  BIOS	
FDC_WAIT_EXIT  . . . . . . . . .	L Near	 EEAC	  BIOS	
FDC_WAIT_INT_DONE  . . . . . . .	L Near	 EF8F	  BIOS	
FDC_WAIT_INT_LOOP1 . . . . . . .	L Near	 EF71	  BIOS	
FDC_WAIT_INT_LOOP2 . . . . . . .	L Near	 EF74	  BIOS	
FDC_WAIT_INT_OK  . . . . . . . .	L Near	 EF8A	  BIOS	
FDC_WAIT_SENSE_EXIT  . . . . . .	L Near	 EEF9	  BIOS	
FDC_WAIT_STATUS_ERR_DONE . . . .	L Near	 EF19	  BIOS	
FDC_WAIT_TIMEOUT . . . . . . . .	L Near	 EEBB	  BIOS	
FD_AUTO_DETECT . . . . . . . . .	Number	 0000h	 
FD_CAL_ST  . . . . . . . . . . .	FDC_SF	 003E	  _BDA	
FD_LAST_OP . . . . . . . . . . .	Byte	 0041	  _BDA	
FD_MEDIA_ST  . . . . . . . . . .	FDC_STATE  0090	    _BDA	
FD_MODE  . . . . . . . . . . . .	FDC_MODE  008F	   _BDA	
FD_MOTOR_CT_ABS  . . . . . . . .	Byte	 0440	  _BDA_ABS	
FD_MOTOR_CT  . . . . . . . . . .	Byte	 0040	  _BDA	
FD_MOTOR_ST  . . . . . . . . . .	FDC_MF	 003F	  _BDA	
FE2010_CONF_REG  . . . . . . . .	Byte	 00EC	  _BDA	
FIELD_EVEN . . . . . . . . . . .	L Near	 F567	  BIOS	
FOUND_ROM  . . . . . . . . . . .	L Near	 E504	  BIOS	
FPU_CHECK  . . . . . . . . . . .	L Near	 F632	  BIOS	
FPU_DISP_DONE  . . . . . . . . .	L Near	 F644	  BIOS	
FPU_TEST_CW  . . . . . . . . . .	L Near	 FFD2	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 258 - 1




Symbols:

                N a m e                 Type     Value    Attr

FPU_TEST_DONE  . . . . . . . . .	L Near	 FFDE	  BIOS	
FPU_TEST_SW  . . . . . . . . . .	L Near	 FFC6	  BIOS	
GAME_CTRL  . . . . . . . . . . .	Number	 0201h	 
GB_FLAGS . . . . . . . . . . . .	GFLAGS	 0012	  _BDA	
GET_DISK_PARAMS_ERR  . . . . . .	L Near	 E738	  BIOS	
GET_SW_SETTINGS  . . . . . . . .	L Near	 E1F4	  BIOS	
GFX_CHARSET  . . . . . . . . . .	Byte	 FA6E	  BIOS	
GRAY . . . . . . . . . . . . . .	Number	 0007h	 
GREEN  . . . . . . . . . . . . .	Number	 000Ah	 
HALT_BEEP_1  . . . . . . . . . .	L Near	 E165	  BIOS	
HALT_BEEP_2  . . . . . . . . . .	L Near	 E250	  BIOS	
HALT_BEEP_REP  . . . . . . . . .	L Near	 E885	  BIOS	
HALT_BEEP_START_ODD  . . . . . .	L Near	 E883	  BIOS	
HALT_BEEP_START  . . . . . . . .	L Near	 E87C	  BIOS	
HALT_ERROR . . . . . . . . . . .	L Near	 E10E	  BIOS	
HDC_CTRL . . . . . . . . . . . .	Number	 0321h	 
HDC_DMA  . . . . . . . . . . . .	Number	 0323h	 
HDC_PULSE  . . . . . . . . . . .	Number	 0322h	 
HDC_READ . . . . . . . . . . . .	Number	 0320h	 
HDC_STAT . . . . . . . . . . . .	Number	 0324h	 
HDD_POST_DONE  . . . . . . . . .	L Near	 E3FD	  BIOS	
HDD_POST_NONE  . . . . . . . . .	L Near	 E3FA	  BIOS	
HDD_POST_SHOW_LOOP . . . . . . .	L Near	 E3F2	  BIOS	
HD_COUNT . . . . . . . . . . . .	Byte	 0075	  _BDA	
HD_CTRL  . . . . . . . . . . . .	Byte	 0076	  _BDA	
HD_LAST_ST . . . . . . . . . . .	Byte	 0074	  _BDA	
HD_PORT  . . . . . . . . . . . .	Byte	 0077	  _BDA	
HEART  . . . . . . . . . . . . .	Number	 0003h	 
HELLO_WORLD  . . . . . . . . . .	L Near	 E266	  BIOS	
HL . . . . . . . . . . . . . . .	Number	 00C4h	 
INIT_DMA1  . . . . . . . . . . .	L Near	 E0E3	  BIOS	
INIT_PIT1_TEST_DONE  . . . . . .	L Near	 E110	  BIOS	
INIT_PIT1_TEST_READ  . . . . . .	L Near	 E0FE	  BIOS	
INIT_PIT1_TEST . . . . . . . . .	L Near	 E0F6	  BIOS	
INIT_PIT1  . . . . . . . . . . .	L Near	 E110	  BIOS	
INIT_SW_INT_VECTORS  . . . . . .	L Near	 E1D2	  BIOS	
INIT_VIDEO . . . . . . . . . . .	L Near	 E0A3	  BIOS	
INT_02_AFTER . . . . . . . . . .	L Near	 E2E6	  BIOS	
INT_02_LOOP  . . . . . . . . . .	L Near	 E2E2	  BIOS	
INT_02_NMI_HALT  . . . . . . . .	L Near	 E2D6	  BIOS	
INT_02_NMI_PAR . . . . . . . . .	L Near	 E2CC	  BIOS	
INT_05_DONE  . . . . . . . . . .	L Near	 FF9A	  BIOS	
INT_05_EXIT  . . . . . . . . . .	L Near	 FFA6	  BIOS	
INT_05_LOOP_1  . . . . . . . . .	L Near	 FF7C	  BIOS	
INT_05_NEXT_COL  . . . . . . . .	L Near	 FF94	  BIOS	
INT_08_EOI . . . . . . . . . . .	L Near	 FEC7	  BIOS	
INT_08_FD_MOTOR  . . . . . . . .	L Near	 FEBE	  BIOS	
INT_08_INT_1C  . . . . . . . . .	L Near	 FEC5	  BIOS	
INT_08_MOTOR_OFF . . . . . . . .	L Near	 FE97	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 259 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_08_RESET . . . . . . . . . .	L Near	 FED6	  BIOS	
INT_08_TICK_DAY  . . . . . . . .	L Near	 FED1	  BIOS	
INT_08_TICK_TIMER  . . . . . . .	L Near	 FEAF	  BIOS	
INT_09_POST_DONE . . . . . . . .	L Near	 E943	  BIOS	
INT_10_0_1 . . . . . . . . . . .	L Near	 F0F2	  BIOS	
INT_10_0_COLOR_BYTE  . . . . . .	L Near	 F187	  BIOS	
INT_10_0_CRTC_LOOP . . . . . . .	L Near	 F177	  BIOS	
INT_10_0_DETECT_DONE . . . . . .	L Near	 F147	  BIOS	
INT_10_0_IS_40_COL . . . . . . .	L Near	 F145	  BIOS	
INT_10_0_IS_CGA_GFX  . . . . . .	L Near	 F12E	  BIOS	
INT_10_0_IS_CGA_TEXT . . . . . .	L Near	 F13C	  BIOS	
INT_10_0_IS_CGA  . . . . . . . .	L Near	 F121	  BIOS	
INT_10_2_DONE  . . . . . . . . .	L Near	 F1EC	  BIOS	
INT_10_6_CHECK_CLS . . . . . . .	L Near	 F296	  BIOS	
INT_10_6_DONE  . . . . . . . . .	L Near	 F2BB	  BIOS	
INT_10_6_TXT_CLR_1 . . . . . . .	L Near	 F2AC	  BIOS	
INT_10_6_TXT_CLR_LOOP  . . . . .	L Near	 F2B0	  BIOS	
INT_10_6_TXT_CLR . . . . . . . .	L Near	 F2AE	  BIOS	
INT_10_6_TXT_MOVE_LOOP . . . . .	L Near	 F2A0	  BIOS	
INT_10_8_CHK_CGA . . . . . . . .	L Near	 F35B	  BIOS	
INT_10_8_FAST  . . . . . . . . .	L Near	 F357	  BIOS	
INT_10_8_GFX_DONE  . . . . . . .	L Near	 F3D2	  BIOS	
INT_10_8_GFX_HIGH  . . . . . . .	L Near	 F3DA	  BIOS	
INT_10_8_GFX_LOW_1 . . . . . . .	L Near	 F37F	  BIOS	
INT_10_8_GFX_LOW_2 . . . . . . .	L Near	 F38B	  BIOS	
INT_10_8_GFX_SEARCH_CHR  . . . .	L Near	 F3AF	  BIOS	
INT_10_8_GFX_SEARCH_TBL  . . . .	L Near	 F3AC	  BIOS	
INT_10_8_GFX_SEARCH  . . . . . .	L Near	 F3A1	  BIOS	
INT_10_8_MODE_GFX_LOW  . . . . .	L Near	 F37D	  BIOS	
INT_10_9A_FAST . . . . . . . . .	L Near	 F3FA	  BIOS	
INT_10_9A_GFX_2  . . . . . . . .	L Near	 F434	  BIOS	
INT_10_9A_GFX_FG . . . . . . . .	L Near	 F447	  BIOS	
INT_10_9A_GFX_HIGH_WORD  . . . .	L Near	 F49C	  BIOS	
INT_10_9A_GFX_HIGH_WR  . . . . .	L Near	 F4A9	  BIOS	
INT_10_9A_GFX_HIGH . . . . . . .	L Near	 F498	  BIOS	
INT_10_9A_GFX_LOW_BYTE . . . . .	L Near	 F459	  BIOS	
INT_10_9A_GFX_LOW_CHAR . . . . .	L Near	 F453	  BIOS	
INT_10_9A_GFX_LOW_NEXT . . . . .	L Near	 F488	  BIOS	
INT_10_9A_GFX_LOW_PDEP . . . . .	L Near	 F460	  BIOS	
INT_10_9A_GFX_LOW_WR . . . . . .	L Near	 F478	  BIOS	
INT_10_9A_GFX_LOW  . . . . . . .	L Near	 F442	  BIOS	
INT_10_9A_MODE_GFX_DONE  . . . .	L Near	 F491	  BIOS	
INT_10_9A_MODE_GFX_EXIT  . . . .	L Near	 F496	  BIOS	
INT_10_9_FAST  . . . . . . . . .	L Near	 F406	  BIOS	
INT_10_A_FAST  . . . . . . . . .	L Near	 F400	  BIOS	
INT_10_BOUNDS_OK . . . . . . . .	L Near	 F254	  BIOS	
INT_10_B_DONE  . . . . . . . . .	L Near	 F4EC	  BIOS	
INT_10_B_SET_COL . . . . . . . .	L Near	 F4DA	  BIOS	
INT_10_B_SET_PAL . . . . . . . .	L Near	 F4E1	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 260 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_10_CGA_CHECK . . . . . . . .	L Near	 F296	  BIOS	
INT_10_CHECK_BOUNDS  . . . . . .	L Near	 F24A	  BIOS	
INT_10_CHK_CGA . . . . . . . . .	L Near	 F40C	  BIOS	
INT_10_C_DONE  . . . . . . . . .	L Near	 F51C	  BIOS	
INT_10_C_XOR . . . . . . . . . .	L Near	 F51F	  BIOS	
INT_10_DONE  . . . . . . . . . .	L Near	 F081	  BIOS	
INT_10_E_BELL  . . . . . . . . .	L Near	 F5CF	  BIOS	
INT_10_E_BS  . . . . . . . . . .	L Near	 F5DE	  BIOS	
INT_10_E_CHAR  . . . . . . . . .	L Near	 F581	  BIOS	
INT_10_E_CR  . . . . . . . . . .	L Near	 F5D6	  BIOS	
INT_10_E_CTRL  . . . . . . . . .	L Near	 F5C1	  BIOS	
INT_10_E_CURS  . . . . . . . . .	L Near	 F5B9	  BIOS	
INT_10_E_DONE  . . . . . . . . .	L Near	 F5BC	  BIOS	
INT_10_E_LF  . . . . . . . . . .	L Near	 F5DA	  BIOS	
INT_10_E_SCROLL_UP . . . . . . .	L Near	 F5A4	  BIOS	
INT_10_E_SCROLL  . . . . . . . .	L Near	 F593	  BIOS	
INT_10_IRET  . . . . . . . . . .	L Near	 F084	  BIOS	
INT_10_IS_CGA80_DONE . . . . . .	L Near	 F0A0	  BIOS	
INT_10_IS_TXT_DONE . . . . . . .	L Near	 F08F	  BIOS	
INT_10_JMP . . . . . . . . . . .	Word	 F045	  BIOS	
INT_10_RET . . . . . . . . . . .	L Near	 F19E	  BIOS	
INT_10_SCR_GFX_2 . . . . . . . .	L Near	 F2EA	  BIOS	
INT_10_SCR_GFX_CLR_1 . . . . . .	L Near	 F328	  BIOS	
INT_10_SCR_GFX_CLR_LOOP  . . . .	L Near	 F32E	  BIOS	
INT_10_SCR_GFX_CLR . . . . . . .	L Near	 F32A	  BIOS	
INT_10_SCR_GFX_MOVE_LOOP . . . .	L Near	 F30A	  BIOS	
INT_10_SCR_GFX_RDY . . . . . . .	L Near	 F2F3	  BIOS	
INT_10_SCR_TXT . . . . . . . . .	L Near	 F262	  BIOS	
INT_10_SET_CUR_OFFSET  . . . . .	L Near	 F1CC	  BIOS	
INT_13_0A_DONE . . . . . . . . .	L Near	 ECF4	  BIOS	
INT_13_0_1 . . . . . . . . . . .	L Near	 ECAC	  BIOS	
INT_13_0_2 . . . . . . . . . . .	L Near	 ECB2	  BIOS	
INT_13_0_DONE  . . . . . . . . .	L Near	 ECE2	  BIOS	
INT_13_0_RESET_BAD . . . . . . .	L Near	 ECC9	  BIOS	
INT_13_0_RESET_DONE  . . . . . .	L Near	 ECCB	  BIOS	
INT_13_2_5_DONE  . . . . . . . .	L Near	 EDDB	  BIOS	
INT_13_2_5_EXIT  . . . . . . . .	L Near	 EDDD	  BIOS	
INT_13_2_5_SETUP_DMA . . . . . .	L Near	 ED11	  BIOS	
INT_13_BAD_CMD . . . . . . . . .	L Near	 EC7D	  BIOS	
INT_13_DONE  . . . . . . . . . .	L Near	 EC80	  BIOS	
INT_13_EXIT  . . . . . . . . . .	L Near	 EC8B	  BIOS	
INT_14_0_SET_BAUD  . . . . . . .	L Near	 E77C	  BIOS	
INT_14_0_SET_PSW . . . . . . . .	L Near	 E77F	  BIOS	
INT_14_POLL_DONE . . . . . . . .	L Near	 E7EC	  BIOS	
INT_14_POLL_LOOP . . . . . . . .	L Near	 E7DE	  BIOS	
INT_14_POLL_RET  . . . . . . . .	L Near	 E7ED	  BIOS	
INT_14_RW_ERR  . . . . . . . . .	L Near	 E7B3	  BIOS	
INT_15_EXIT  . . . . . . . . . .	L Near	 F85C	  BIOS	
INT_16_DONE  . . . . . . . . . .	L Near	 E86C	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 261 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_17_0_BUSY_LOOP . . . . . . .	L Near	 EFFB	  BIOS	
INT_17_0_OK  . . . . . . . . . .	L Near	 F009	  BIOS	
INT_17_0_TIMEOUT_LOOP  . . . . .	L Near	 EFF9	  BIOS	
INT_17_0 . . . . . . . . . . . .	L Near	 EFF7	  BIOS	
INT_17_1 . . . . . . . . . . . .	L Near	 F023	  BIOS	
INT_17_2_STATUS_2  . . . . . . .	L Near	 F018	  BIOS	
INT_17_2_STATUS  . . . . . . . .	L Near	 F015	  BIOS	
INT_17_2 . . . . . . . . . . . .	L Near	 F014	  BIOS	
INT_17_DONE  . . . . . . . . . .	L Near	 F01C	  BIOS	
INT_17_IRET  . . . . . . . . . .	L Near	 F022	  BIOS	
INT_19_BOOT_HD . . . . . . . . .	Number	 0000h	 
INT_19_IPL_FAIL  . . . . . . . .	L Near	 E71D	  BIOS	
INT_19_READ_MBR  . . . . . . . .	L Near	 E704	  BIOS	
INT_1A_DONE  . . . . . . . . . .	L Near	 FE89	  BIOS	
INT_1A_EXIT  . . . . . . . . . .	L Near	 FE8C	  BIOS	
INT_1D_40  . . . . . . . . . . .	CRTC	 F0A4	  BIOS	
INT_1D_80  . . . . . . . . . . .	CRTC	 F0B4	  BIOS	
INT_1D_GFX . . . . . . . . . . .	CRTC	 F0C4	  BIOS	
INT_1D_MDA . . . . . . . . . . .	CRTC	 F0D4	  BIOS	
INT_1E . . . . . . . . . . . . .	DBT	 EFC7	  BIOS	
INT_IMR  . . . . . . . . . . . .	Number	 0021h	 
INT_IRQ_DONE . . . . . . . . . .	L Near	 FF40	  BIOS	
INT_KB_ALT_BREAK . . . . . . . .	L Near	 EB88	  BIOS	
INT_KB_ALT_SKIP  . . . . . . . .	Byte	 EC16	  BIOS	
INT_KB_CHECK_CTRL_NUM  . . . . .	L Near	 E9F0	  BIOS	
INT_KB_CTRL_ALPHA  . . . . . . .	L Near	 EAFA	  BIOS	
INT_KB_CTRL_ALT_1  . . . . . . .	L Near	 EB2B	  BIOS	
INT_KB_CTRL_ALT_DEL  . . . . . .	L Near	 EB1F	  BIOS	
INT_KB_CTRL_ALT  . . . . . . . .	L Near	 EB1A	  BIOS	
INT_KB_CTRL_ASC_TBL_DONE . . . .	L Near	 EAEF	  BIOS	
INT_KB_CTRL_ASC_TBL_LOOP . . . .	L Near	 EADB	  BIOS	
INT_KB_CTRL_ASC_TBL  . . . . . .	Byte	 E960	  BIOS	
INT_KB_CTRL_BREAK  . . . . . . .	L Near	 E9E4	  BIOS	
INT_KB_CTRL_NO_ALT_1 . . . . . .	L Near	 EB08	  BIOS	
INT_KB_CTRL_NO_DONE  . . . . . .	L Near	 EAEC	  BIOS	
INT_KB_CTRL_SCAN_TBL . . . . . .	Byte	 E96A	  BIOS	
INT_KB_CTRL  . . . . . . . . . .	L Near	 EB15	  BIOS	
INT_KB_DONE3 . . . . . . . . . .	L Near	 EB67	  BIOS	
INT_KB_DONE_2  . . . . . . . . .	L Near	 EA17	  BIOS	
INT_KB_DONE  . . . . . . . . . .	L Near	 EA8C	  BIOS	
INT_KB_FLAG_CLEAR  . . . . . . .	L Near	 EB7F	  BIOS	
INT_KB_FLAG_FOUND  . . . . . . .	L Near	 EB4B	  BIOS	
INT_KB_FLAG_LOOP . . . . . . . .	L Near	 EB41	  BIOS	
INT_KB_FLAG_TOGGLE . . . . . . .	L Near	 EB5E	  BIOS	
INT_KB_ICNS_BREAK  . . . . . . .	L Near	 EB56	  BIOS	
INT_KB_ICNS_MAKE . . . . . . . .	L Near	 EB5C	  BIOS	
INT_KB_IS_ALT_000  . . . . . . .	L Near	 EAB7	  BIOS	
INT_KB_MEEP_DONE . . . . . . . .	L Near	 EA19	  BIOS	
INT_KB_NOT_ALT_000 . . . . . . .	L Near	 EAC4	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 262 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_KB_NOT_ICNS_1  . . . . . . .	L Near	 EB76	  BIOS	
INT_KB_NOT_ICNS  . . . . . . . .	L Near	 EB6A	  BIOS	
INT_KB_PAUSE_LOOP  . . . . . . .	L Near	 EA10	  BIOS	
INT_KB_PUT_BUFFER_2  . . . . . .	L Near	 EB95	  BIOS	
INT_KB_SET_PAUSE . . . . . . . .	L Near	 EA0A	  BIOS	
INT_KB_TURBO_IS_ON . . . . . . .	L Near	 E981	  BIOS	
INT_LAST_ABS . . . . . . . . . .	Byte	 046B	  _BDA_ABS	
INT_LAST . . . . . . . . . . . .	Byte	 006B	  _BDA	
INT_P0 . . . . . . . . . . . . .	Number	 0020h	 
IO_WAIT_MS_DONE  . . . . . . . .	L Near	 F794	  BIOS	
IO_WAIT_MS_LOOP  . . . . . . . .	L Near	 F783	  BIOS	
IPL_ID . . . . . . . . . . . . .	Word	 7DFE	  _IPL_SEG	
IPL_TOP  . . . . . . . . . . . .	Byte	 7C00	  _IPL_SEG	
ISA_TYPE . . . . . . . . . . . .	Byte	 FFFE	  BIOS	
IS_ALPHA_DONE  . . . . . . . . .	L Near	 EA45	  BIOS	
IS_ALPHA . . . . . . . . . . . .	L Near	 EA3B	  BIOS	
IS_TURBO . . . . . . . . . . . .	Number	 -0001h	  
IVT_08_SEG . . . . . . . . . . .	Word	 0022	  _IVT	
IVT_08 . . . . . . . . . . . . .	Word	 0020	  _IVT	
IVT_09_SEG . . . . . . . . . . .	Word	 0026	  _IVT	
IVT_09 . . . . . . . . . . . . .	Word	 0024	  _IVT	
IVT_10_SEG . . . . . . . . . . .	Word	 0042	  _IVT	
IVT_10 . . . . . . . . . . . . .	Word	 0040	  _IVT	
IVT_18_SEG . . . . . . . . . . .	Word	 0062	  _IVT	
IVT_18 . . . . . . . . . . . . .	Word	 0060	  _IVT	
IVT_1D . . . . . . . . . . . . .	DWord	 0074	  _IVT	
IVT_1E . . . . . . . . . . . . .	DWord	 0078	  _IVT	
IVT_1F . . . . . . . . . . . . .	DWord	 007C	  _IVT	
KB_ALT . . . . . . . . . . . . .	Byte	 0019	  _BDA	
KB_BUF_END_B . . . . . . . . . .	Number	 003Eh	 
KB_BUF_END . . . . . . . . . . .	Word	 003E	  _BDA	
KB_BUF_HAS_KEY . . . . . . . . .	L Near	 E84F	  BIOS	
KB_BUF_HD  . . . . . . . . . . .	Word	 001A	  _BDA	
KB_BUF_ST  . . . . . . . . . . .	Word	 0080	  _BDA	
KB_BUF_TL  . . . . . . . . . . .	Word	 001C	  _BDA	
KB_BUF . . . . . . . . . . . . .	Word	 001E	  _BDA	
KB_FLAGS1  . . . . . . . . . . .	KBFLAGS1  0017	   _BDA	
KB_FLAGS2  . . . . . . . . . . .	KBFLAGS2  0018	   _BDA	
KB_FLAGS . . . . . . . . . . . .	Word	 0017	  _BDA	
KB_GET_READ  . . . . . . . . . .	L Near	 E868	  BIOS	
KB_HAPPY . . . . . . . . . . . .	L Near	 E3A0	  BIOS	
KB_HLT_WAIT  . . . . . . . . . .	Number	 0001h	 
KB_INT_CHAR  . . . . . . . . . .	L Near	 EA1E	  BIOS	
KB_INT_CHECK_FN_KEY_DONE . . . .	L Near	 E9DB	  BIOS	
KB_INT_CHECK_FN_KEY  . . . . . .	L Near	 E9B6	  BIOS	
KB_INT_CHECK_FULL  . . . . . . .	L Near	 EA80	  BIOS	
KB_INT_IS_ALT_DONE . . . . . . .	L Near	 EA59	  BIOS	
KB_INT_IS_ALT  . . . . . . . . .	L Near	 EA4A	  BIOS	
KB_INT_IS_CAPS_DONE  . . . . . .	L Near	 EA4A	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 263 - 1




Symbols:

                N a m e                 Type     Value    Attr

KB_INT_IS_CAPS . . . . . . . . .	L Near	 EA36	  BIOS	
KB_INT_IS_CTRL_DONE  . . . . . .	L Near	 EA65	  BIOS	
KB_INT_IS_CTRL . . . . . . . . .	L Near	 EA59	  BIOS	
KB_INT_IS_NUM_DONE . . . . . . .	L Near	 EA1E	  BIOS	
KB_INT_IS_NUM  . . . . . . . . .	L Near	 E9F4	  BIOS	
KB_INT_IS_PAUSE  . . . . . . . .	L Near	 EA65	  BIOS	
KB_INT_NOT_FLAG  . . . . . . . .	L Near	 EA32	  BIOS	
KB_INT_PRTSC . . . . . . . . . .	L Near	 EA61	  BIOS	
KB_INT_PUT_BUFFER_2  . . . . . .	L Near	 E9D8	  BIOS	
KB_INT_PUT_BUFFER  . . . . . . .	L Near	 EA71	  BIOS	
KB_INT_SHIFT . . . . . . . . . .	L Near	 EA25	  BIOS	
KB_INT_UC  . . . . . . . . . . .	L Near	 EA26	  BIOS	
KB_KEY_STATUS_DONE . . . . . . .	L Near	 E849	  BIOS	
KB_RESET_TEST  . . . . . . . . .	L Near	 E37D	  BIOS	
KB_WAIT_READ_1 . . . . . . . . .	L Near	 E855	  BIOS	
KEY_FLAG_ON_TBL  . . . . . . . .	Byte	 EC0E	  BIOS	
KEY_SCAN_TBL_HIGH  . . . . . . .	Byte	 EC22	  BIOS	
KEY_SCAN_TBL . . . . . . . . . .	Byte	 EB98	  BIOS	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LIGHTCYAN  . . . . . . . . . . .	Number	 000Bh	 
LPT_ADDR_B . . . . . . . . . . .	Number	 0008h	 
LPT_ADDR . . . . . . . . . . . .	Word	 0008	  _BDA	
LPT_CHAR_EXIT  . . . . . . . . .	L Near	 FFC2	  BIOS	
LPT_CHAR_OUT . . . . . . . . . .	L Near	 FFBD	  BIOS	
LPT_DETECT_LOOP  . . . . . . . .	L Near	 E331	  BIOS	
LPT_TIME_B . . . . . . . . . . .	Number	 0078h	 
LPT_TIME . . . . . . . . . . . .	Byte	 0078	  _BDA	
LPT_TO . . . . . . . . . . . . .	Number	 0014h	 
L_INT_KB_ALT_SKIP  . . . . . . .	Number	 000Ah	 
L_INT_KB_CTRL_ASC_TBL  . . . . .	Number	 000Ch	 
L_INT_KB_CTRL_SCAN_TBL . . . . .	Number	 0006h	 
L_KEY_FLAG_ON_TBL  . . . . . . .	Number	 0008h	 
L_KEY_SCAN_TBL . . . . . . . . .	Number	 00AAh	 
L_POST_ERRORS  . . . . . . . . .	Number	 0006h	 
L_POST_L . . . . . . . . . . . .	Number	 0002h	 
L_VECTOR_TABLE . . . . . . . . .	Number	 001Fh	 
L_VID_BDA  . . . . . . . . . . .	Number	 001Eh	 
MAGENTA  . . . . . . . . . . . .	Number	 000Dh	 
MAGIC_WORD . . . . . . . . . . .	Number	 AA55h	 
MAX_RAM_AUTO_DONE  . . . . . . .	L Near	 E21F	  BIOS	
MAX_RAM_AUTO . . . . . . . . . .	Number	 0001h	 
MAX_RAM_CGA  . . . . . . . . . .	Number	 02E0h	 
MAX_RAM_MDA  . . . . . . . . . .	Number	 02C0h	 
MAX_RAM_PC . . . . . . . . . . .	Number	 0280h	 
MAX_RAM  . . . . . . . . . . . .	Number	 0280h	 
MBR_CHECK  . . . . . . . . . . .	Number	 0000h	 
MDA_ATTR . . . . . . . . . . . .	Number	 0001h	 
MDA_COLOR_FIX  . . . . . . . . .	L Near	 F6DC	  BIOS	
MDA_CTRL . . . . . . . . . . . .	Number	 03B8h	 
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 264 - 1




Symbols:

                N a m e                 Type     Value    Attr

MDA_MEM  . . . . . . . . . . . .	Byte	 1000	  _MDA_MEM	
MDA_STAT . . . . . . . . . . . .	Number	 03BAh	 
MEEP_DELAY . . . . . . . . . . .	Number	 0040h	 
MEM_ADDR_ERR . . . . . . . . . .	L Near	 E60A	  BIOS	
MEM_ADDR_LOOP  . . . . . . . . .	L Near	 E5EC	  BIOS	
MEM_SZ_KB  . . . . . . . . . . .	Word	 0013	  _BDA	
MEM_SZ_PC  . . . . . . . . . . .	Word	 0015	  _BDA	
MEM_TEST_VERIFY  . . . . . . . .	L Near	 E61A	  BIOS	
MOVE_COL_SET . . . . . . . . . .	L Near	 F708	  BIOS	
NEXT_COL . . . . . . . . . . . .	L Near	 F592	  BIOS	
NEXT_COM_PORT  . . . . . . . . .	L Near	 E327	  BIOS	
NEXT_LPT_PORT  . . . . . . . . .	L Near	 E350	  BIOS	
NEXT_ROM . . . . . . . . . . . .	L Near	 E52A	  BIOS	
NL2_ANY_KEY  . . . . . . . . . .	Byte	 E48A	  BIOS	
NL_ANY_KEY . . . . . . . . . . .	Byte	 E48B	  BIOS	
NL_Z . . . . . . . . . . . . . .	Byte	 E46B	  BIOS	
NMI_ERR_IO . . . . . . . . . . .	Byte	 E4E3	  BIOS	
NMI_ERR_PAR  . . . . . . . . . .	Byte	 E4E5	  BIOS	
NMI_R0 . . . . . . . . . . . . .	Number	 00A0h	 
NOTE1  . . . . . . . . . . . . .	Number	 000Dh	 
NOTE2  . . . . . . . . . . . . .	Number	 000Eh	 
NOT_HI_RES . . . . . . . . . . .	L Near	 F555	  BIOS	
NO_COM_PORT  . . . . . . . . . .	L Near	 E31A	  BIOS	
NO_GAME_PORT . . . . . . . . . .	L Near	 E301	  BIOS	
NO_LPT_PORT  . . . . . . . . . .	L Near	 E345	  BIOS	
OPT_ROM_END  . . . . . . . . . .	Number	 FE00h	 
OUT_DECU_DONE  . . . . . . . . .	L Near	 F736	  BIOS	
OUT_DECU_R . . . . . . . . . . .	L Near	 F72A	  BIOS	
OUT_SZ_ATTR_SET  . . . . . . . .	L Near	 F6E7	  BIOS	
OUT_SZ_DONE  . . . . . . . . . .	L Near	 F6FA	  BIOS	
OUT_SZ_LOOP  . . . . . . . . . .	L Near	 F6F0	  BIOS	
O_INT_1D_40  . . . . . . . . . .	Number	 0000h	 
O_INT_1D_80  . . . . . . . . . .	Number	 0010h	 
O_INT_1D_GFX . . . . . . . . . .	Number	 0020h	 
O_INT_1D_MDA . . . . . . . . . .	Number	 0030h	 
PIC_INT_FAIL . . . . . . . . . .	L Near	 E1A2	  BIOS	
PIC_INT_PASS . . . . . . . . . .	L Near	 E1C6	  BIOS	
PIC_INT_TEST . . . . . . . . . .	L Near	 E1A8	  BIOS	
PIC_REG_PASS . . . . . . . . . .	L Near	 E1A4	  BIOS	
PIC_VECT_TMP_LOOP  . . . . . . .	L Near	 E1AC	  BIOS	
PIT_CH0  . . . . . . . . . . . .	Number	 0040h	 
PIT_CH1  . . . . . . . . . . . .	Number	 0041h	 
PIT_CH2  . . . . . . . . . . . .	Number	 0042h	 
PIT_CTRL . . . . . . . . . . . .	Number	 0043h	 
PORT_COUNT_LOOP  . . . . . . . .	L Near	 F67A	  BIOS	
PORT_COUNT_NONE  . . . . . . . .	L Near	 F688	  BIOS	
PORT_TEST_DONE . . . . . . . . .	L Near	 E81C	  BIOS	
POST_BOOT_TYPE_OUT . . . . . . .	L Near	 E633	  BIOS	
POST_BOOT  . . . . . . . . . . .	Byte	 E63A	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 265 - 1




Symbols:

                N a m e                 Type     Value    Attr

POST_CARD_PORT . . . . . . . . .	Number	 0080h	 
POST_CGA . . . . . . . . . . . .	Byte	 F7AD	  BIOS	
POST_CHS . . . . . . . . . . . .	Byte	 F8C3	  BIOS	
POST_CLR_COLD  . . . . . . . . .	Text   	 BLUE
POST_CLR_GB  . . . . . . . . . .	Text   	 GRAY
POST_CLR_TXT . . . . . . . . . .	Text   	 CYAN
POST_CLR_VAL1  . . . . . . . . .	Text   	 GREEN
POST_CLR_VAL2  . . . . . . . . .	Text   	 YELLOW
POST_CLR_WARM  . . . . . . . . .	Text   	 DARKRED
POST_CLS . . . . . . . . . . . .	Number	 0000h	 
POST_COLD  . . . . . . . . . . .	Byte	 E644	  BIOS	
POST_COL_LBL_W . . . . . . . . .	Number	 0007h	 
POST_COL_PAD . . . . . . . . . .	Number	 0004h	 
POST_COL_VT  . . . . . . . . . .	Number	 0009h	 
POST_COL_W . . . . . . . . . . .	Number	 0006h	 
POST_COM . . . . . . . . . . . .	Byte	 E4D0	  BIOS	
POST_CPU_TEST  . . . . . . . . .	L Near	 E05D	  BIOS	
POST_CPU . . . . . . . . . . . .	Byte	 E4A2	  BIOS	
POST_DETECT_COM  . . . . . . . .	L Near	 E301	  BIOS	
POST_DETECT_GAM  . . . . . . . .	L Near	 E2F6	  BIOS	
POST_DETECT_LPT  . . . . . . . .	L Near	 E329	  BIOS	
POST_DETECT_PORTS  . . . . . . .	L Near	 E2F3	  BIOS	
POST_EGA . . . . . . . . . . . .	Byte	 F7A9	  BIOS	
POST_ERRORS  . . . . . . . . . .	Word	 E912	  BIOS	
POST_ERROR_MSG_EXIT  . . . . . .	L Near	 E933	  BIOS	
POST_ERROR_MSG_LOOP  . . . . . .	L Near	 E924	  BIOS	
POST_ERROR_MSG_NEXT  . . . . . .	L Near	 E931	  BIOS	
POST_ERROR . . . . . . . . . . .	L Near	 E416	  BIOS	
POST_ERR_ERR . . . . . . . . . .	Byte	 E8FC	  BIOS	
POST_ERR_PDMA  . . . . . . . . .	Byte	 E90E	  BIOS	
POST_ERR_PFDC  . . . . . . . . .	Byte	 E90A	  BIOS	
POST_ERR_PKEY  . . . . . . . . .	Byte	 E906	  BIOS	
POST_ERR_PKI . . . . . . . . . .	Byte	 E903	  BIOS	
POST_ERR_WAIT  . . . . . . . . .	Number	 0001h	 
POST_ERR . . . . . . . . . . . .	Byte	 E8F5	  BIOS	
POST_FDD . . . . . . . . . . . .	Byte	 E4D4	  BIOS	
POST_FLAG_DONE . . . . . . . . .	L Near	 E0B6	  BIOS	
POST_FPU . . . . . . . . . . . .	Byte	 E4AB	  BIOS	
POST_GLADOS  . . . . . . . . . .	Number	 0000h	 
POST_HDD . . . . . . . . . . . .	Byte	 E4D8	  BIOS	
POST_HD_CHECK  . . . . . . . . .	Number	 0001h	 
POST_HD_PARMS  . . . . . . . . .	Number	 0001h	 
POST_HD  . . . . . . . . . . . .	Byte	 E4B4	  BIOS	
POST_K_UNIT  . . . . . . . . . .	Text   	 'KB'
POST_LPT . . . . . . . . . . . .	Byte	 E4CC	  BIOS	
POST_LSEP  . . . . . . . . . . .	Byte	 E4DC	  BIOS	
POST_L . . . . . . . . . . . . .	Text   	 ' [ '
POST_MDA . . . . . . . . . . . .	Byte	 F7B1	  BIOS	
POST_MEMORY  . . . . . . . . . .	Byte	 E4BA	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 266 - 1




Symbols:

                N a m e                 Type     Value    Attr

POST_M_UNIT  . . . . . . . . . .	Text   	 'MB'
POST_NONE  . . . . . . . . . . .	Byte	 FF4D	  BIOS	
POST_OK  . . . . . . . . . . . .	L Near	 E436	  BIOS	
POST_OPT_ROM . . . . . . . . . .	Number	 0000h	 
POST_RSEP  . . . . . . . . . . .	Byte	 E4E0	  BIOS	
POST_R . . . . . . . . . . . . .	Text   	 ' ]'
POST_START_COL_2_40  . . . . . .	L Near	 F690	  BIOS	
POST_START_COL_START . . . . . .	L Near	 F697	  BIOS	
POST_SYS_VIDEO_DONE  . . . . . .	L Near	 E691	  BIOS	
POST_TAB_COL_I . . . . . . . . .	Number	 0013h	 
POST_TAB_COL . . . . . . . . . .	Number	 0020h	 
POST_TEST_CHK_ROM  . . . . . . .	Number	 0001h	 
POST_TEST_DMA  . . . . . . . . .	Number	 0001h	 
POST_TEST_FD . . . . . . . . . .	Number	 0000h	 
POST_TEST_INST . . . . . . . . .	Number	 0001h	 
POST_TEST_KB . . . . . . . . . .	Number	 0001h	 
POST_TEST_KEY  . . . . . . . . .	Number	 0001h	 
POST_TEST_PIC_INT  . . . . . . .	Number	 0001h	 
POST_TEST_PIC_REG  . . . . . . .	Number	 0001h	 
POST_TEST_PIT_1  . . . . . . . .	Number	 0001h	 
POST_TEST_SEEK . . . . . . . . .	Number	 0000h	 
POST_THEME . . . . . . . . . . .	Number	 0001h	 
POST_V20 . . . . . . . . . . . .	Byte	 E4C8	  BIOS	
POST_VGA . . . . . . . . . . . .	Byte	 F7A5	  BIOS	
POST_VIDEO_TYPE  . . . . . . . .	Number	 0001h	 
POST_VIDEO . . . . . . . . . . .	Byte	 FF47	  BIOS	
POST_WARM_COLD . . . . . . . . .	Number	 0001h	 
POST_WARM  . . . . . . . . . . .	Byte	 E63F	  BIOS	
PPI_A  . . . . . . . . . . . . .	Number	 0060h	 
PPI_B_BOOT . . . . . . . . . . .	Number	 00ADh	 
PPI_B  . . . . . . . . . . . . .	Number	 0061h	 
PPI_CW . . . . . . . . . . . . .	Number	 0063h	 
PPI_C  . . . . . . . . . . . . .	Number	 0062h	 
PTRSCN_ST  . . . . . . . . . . .	Byte	 0000	  _DOS_DAT	
RAM_PARITY . . . . . . . . . . .	Number	 0000h	 
RAM_TEST_1 . . . . . . . . . . .	Number	 95A5h	 
RAM_TEST_2 . . . . . . . . . . .	Number	 739Dh	 
RAM_TEST_LONG  . . . . . . . . .	Number	 0000h	 
RAM_TEST . . . . . . . . . . . .	Number	 95A5h	 
RANDOM_TAGLINE . . . . . . . . .	Number	 0001h	 
RED  . . . . . . . . . . . . . .	Number	 000Ch	 
REL_DATE . . . . . . . . . . . .	Byte	 FFF5	  BIOS	
RESET_PPI  . . . . . . . . . . .	L Near	 E0C5	  BIOS	
RESET_VIDEO_DONE . . . . . . . .	L Near	 E266	  BIOS	
RESET_VIDEO  . . . . . . . . . .	L Near	 E264	  BIOS	
ROM_INIT_SP  . . . . . . . . . .	Word	 0069	  _BDA	
ROM_INIT_SS  . . . . . . . . . .	Word	 0067	  _BDA	
ROM_SCAN_DONE  . . . . . . . . .	L Near	 E534	  BIOS	
RTC_DATA . . . . . . . . . . . .	Word	 00B0	  _BDA	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 267 - 1




Symbols:

                N a m e                 Type     Value    Attr

RTC_WAIT . . . . . . . . . . . .	Byte	 00A0	  _BDA	
SETTINGS_5160  . . . . . . . . .	L Near	 E1F7	  BIOS	
SETTINGS_DONE  . . . . . . . . .	L Near	 E224	  BIOS	
SETTINGS_SAVE  . . . . . . . . .	L Near	 E22F	  BIOS	
SHOW_DISK_PARAMS_DONE  . . . . .	L Near	 F8C0	  BIOS	
SQUARE . . . . . . . . . . . . .	Number	 00FEh	 
STACK_TOP  . . . . . . . . . . .	Word	 0100	  _BOOT_STACK	
SW1_FLP  . . . . . . . . . . . .	Number	 00C0h	 
SYN  . . . . . . . . . . . . . .	Number	 0016h	 
TAG0 . . . . . . . . . . . . . .	Byte	 E00E	  BIOS	
TAG1 . . . . . . . . . . . . . .	Byte	 F8E7	  BIOS	
TAG2 . . . . . . . . . . . . . .	Byte	 F8FA	  BIOS	
TAG3 . . . . . . . . . . . . . .	Byte	 F910	  BIOS	
TAGS . . . . . . . . . . . . . .	Word	 F92D	  BIOS	
TD_TURBO . . . . . . . . . . . .	Number	 0090h	 
TD_UMA . . . . . . . . . . . . .	Number	 00E0h	 
TD_WS  . . . . . . . . . . . . .	Number	 0070h	 
TIMER  . . . . . . . . . . . . .	TIMER_C	 006C	  _BDA	
TOGGLE_TURBO_CURSOR  . . . . . .	L Near	 E29F	  BIOS	
TOGGLE_TURBO_DONE  . . . . . . .	L Near	 E2A2	  BIOS	
TOP_BANNER . . . . . . . . . . .	Byte	 E000	  BIOS	
TRY_INT_18 . . . . . . . . . . .	L Near	 E457	  BIOS	
TURBO_NONE . . . . . . . . . . .	Number	 0000h	 
TURBO_REV  . . . . . . . . . . .	Number	 0002h	 
TURBO_STD  . . . . . . . . . . .	Number	 0001h	 
TURBO_TYPE . . . . . . . . . . .	Number	 0002h	 
UM82_SPEED . . . . . . . . . . .	Number	 00C0h	 
UM82_STATUS  . . . . . . . . . .	Number	 00E0h	 
UNITS_IEC  . . . . . . . . . . .	Number	 0000h	 
V40_WCR1 . . . . . . . . . . . .	Number	 FFF5h	 
V40_WCR2 . . . . . . . . . . . .	Number	 FFF6h	 
VER_DATE . . . . . . . . . . . .	Text   	 '07/23/23'
VER_NAME . . . . . . . . . . . .	Text   	 'GLaBIOS'
VER_NUM  . . . . . . . . . . . .	Text   	 '0.2.5'
VER  . . . . . . . . . . . . . .	Byte	 FFE0	  BIOS	
VID_ATTR . . . . . . . . . . . .	Text   	 DNB <BLACK, GRAY>
VID_BIOS_SZ  . . . . . . . . . .	Byte	 0002	  _VID_BIOS	
VID_BUF_SZ . . . . . . . . . . .	Word	 004C	  _BDA	
VID_COLOR  . . . . . . . . . . .	Byte	 0066	  _BDA	
VID_COLS . . . . . . . . . . . .	Word	 004A	  _BDA	
VID_CURS_POS . . . . . . . . . .	Word	 0050	  _BDA	
VID_CURS_TYPE  . . . . . . . . .	Word	 0060	  _BDA	
VID_DEF_COLS . . . . . . . . . .	Number	 0050h	 
VID_DEF_ROWS . . . . . . . . . .	Number	 0018h	 
VID_MEM_SEG  . . . . . . . . . .	Word	 00EA	  _BDA	
VID_MN . . . . . . . . . . . . .	Word	 0000	  _VID_BIOS	
VID_MODE_OK  . . . . . . . . . .	L Near	 E253	  BIOS	
VID_MODE_REG . . . . . . . . . .	Byte	 0065	  _BDA	
VID_MODE . . . . . . . . . . . .	Byte	 0049	  _BDA	
Microsoft (R) Macro Assembler Version 6.11		    07/24/23 12:11:50
GLaBIOS							     Symbols 268 - 1




Symbols:

                N a m e                 Type     Value    Attr

VID_PAGE . . . . . . . . . . . .	Byte	 0062	  _BDA	
VID_PORT . . . . . . . . . . . .	Word	 0063	  _BDA	
VID_SEG  . . . . . . . . . . . .	Word	 004E	  _BDA	
VID_SP . . . . . . . . . . . . .	Number	 0020h	 
VID_VEC  . . . . . . . . . . . .	Word	 0003	  _VID_BIOS	
VL . . . . . . . . . . . . . . .	Number	 00B3h	 
WARM_BOOT_MEM  . . . . . . . . .	Number	 4321h	 
WARM_BOOT_SUS  . . . . . . . . .	Number	 5678h	 
WARM_BOOT_TEST . . . . . . . . .	Number	 9ABCh	 
WARM_BOOT  . . . . . . . . . . .	Number	 1234h	 
WARM_ENABLE  . . . . . . . . . .	Number	 0001h	 
WARM_FLAG_ABS  . . . . . . . . .	Word	 0472	  _BDA_ABS	
WARM_FLAG  . . . . . . . . . . .	Word	 0072	  _BDA	
WB_LOW_CHECK_OK  . . . . . . . .	L Near	 E80E	  BIOS	
WB_READ_LOOP . . . . . . . . . .	L Near	 E809	  BIOS	
WB_WRITE_1 . . . . . . . . . . .	L Near	 E7F4	  BIOS	
WB_WRITE_LOOP  . . . . . . . . .	L Near	 E7FA	  BIOS	
WHITE  . . . . . . . . . . . . .	Number	 000Fh	 
YELLOW . . . . . . . . . . . . .	Number	 000Eh	 
ZERO_ALL_RAM . . . . . . . . . .	L Near	 E589	  BIOS	
ZERO_ALL_START . . . . . . . . .	L Near	 E5A8	  BIOS	
_BIOS_TOP  . . . . . . . . . . .	Word	 E000	  _BIOS	
_BOOT  . . . . . . . . . . . . .	Word	 E05B	  _BIOS	
_FDC_LAST_ST . . . . . . . . . .	Text   	 [DI][FDC_LAST_ST-FD_LAST_OP]
_FD_CAL_ST . . . . . . . . . . .	Text   	 _FD_LAST_OP[FD_CAL_ST-FD_LAST_OP]
_FD_LAST_OP  . . . . . . . . . .	Text   	 BYTE PTR [DI]
_FD_MOTOR_ST . . . . . . . . . .	Text   	 _FD_LAST_OP[FD_MOTOR_ST-FD_LAST_OP]
_KB_FLAGS1 . . . . . . . . . . .	Text   	 _KB_FLAGS2[-1]
_KB_FLAGS2 . . . . . . . . . . .	Text   	 BYTE PTR[BX]
_POWER_ON  . . . . . . . . . . .	Word	 FFF0	  _BIOS	

	   1 Warnings
	   0 Errors
