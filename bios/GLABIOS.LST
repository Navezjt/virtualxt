Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 1 - 1


					PAGE	 	59,132
					TITLE		GLaBIOS
				
				;----------------------------------------------------------------------------;
				; GLaBIOS (General Libraries and Basic Input Output System)
				;
				; An scratch-built, open-source 8088 PC/clone BIOS alternative.
				;
				; Copyright (c) 2022-2023, 640KB and contributors
				;
				;----------------------------------------------------------------------------;
				;
				; This program is free software: you can redistribute it and/or modify it under the terms 
				; of the GNU General Public License as published by the Free Software Foundation, either 
				; version 3 of the License, or (at your option) any later version.
				;
				; This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
				; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
				; See the GNU General Public License for more details.
				;
				; You should have received a copy of the GNU General Public License along with this program. 
				; If not, see <https://www.gnu.org/licenses/>.
				;
				;----------------------------------------------------------------------------;
				; References, Credits and Inspiration:
				; 
				;  https://stanislavs.org/helppc/
				;  http://www.minuszerodegrees.net/
				;  https://www.felixcloutier.com/x86/
				;  https://sites.google.com/site/pcdosretro/ (offline)
				;
				;  "Programmer's Guide to the IBM(R) PC", Peter Norton
				;  "System BIOS for IBM(R) PC/XT(TM)/AT(R) Computers and Compatibles",
				;	Phoenix Technologies Ltd.
				;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton
				;  (Many more inline...)
				;
				;  Font bitmaps by "VileR", (CC BY-SA 4.0)
				;  https://int10h.org/oldschool-pc-fonts/readme/#legal_stuff
				;
				;  @Raffzahn, Contributor and Meckerhut.
				;
				;  https://github.com/640-KB/GLaBIOS#further-credits-to
				;
				;  "Every byte is sacred, every byte is great,
				;  when a byte is wasted, God gets quite irate..."
				;  - David W. Plummer
				;----------------------------------------------------------------------------;
				; Build Instructions:
				;
				; Build using MASM 5 or later.
				;
				;  MAKE.BAT
				;
				; or
				;
				;  MASM GLABIOS;
				;  LINK GLABIOS;
				;  GLA2ROM GLABIOS.EXE GLABIOS.ROM		; Build 8K ROM
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 2 - 1


				;
				; MASM Build Options:
				;  /DVER_DATE='02/22/22'			; Must be MM/DD/YY format
				;  /DARCH_TYPE='X'				; P, X, Y or T (see ARCH_* below)
				;  /DCPU_TYPE='8'					; 8 or V (see CPU_* below)
				;
				;----------------------------------------------------------------------------;
				; POST Error Beep messages:
				;
				; Short  Long
				;	2	1	CPU register test failure
				;	3	1	CPU instruction test failed
				;	4	1	Build is V20 but not detected
				;	2	2	System BIOS ROM checksum error
				;	3	2	PIT counter 1 test failed
				;	4	2	DMA register test failed
				;	5	2	PIC test register failed
				;	5	3	PIC test interrupt failed
				;	1	3	Base RAM (0-16KB) read/write error
				;	3	3	Error loading video adapter ROM
				;	1	4	Base RAM (0-16KB) parity error
				;
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Build Target Architecture equates (do not edit these)
				;
 = 0050				ARCH_5150		EQU	'P'			; 5150
 = 0058				ARCH_5160		EQU	'X'			; 5160 v1
 = 0059				ARCH_5160v2		EQU	'Y'			; 5160 v2/3
 = 0054				ARCH_TURBO		EQU	'T'			; Standard Turbo or clone
 = 0053				ARCH_TD3300		EQU	'S'			; TD3300A (ST-xx/UNIQUE/Auva)
 = 0046				ARCH_FE2010		EQU	'F'			; Faraday FE2010A
 = 0048				ARCH_EHB		EQU	'H'			; EMM Computers/Homebrew8088
 = 0045				ARCH_EMU		EQU	'E'			; 86Box/Emulator
 = 004D				ARCH_M88		EQU	'M'			; micro_8088/NuXT
 = 0049				ARCH_MIST		EQU	'I'			; PCXT_MiSTer
 = 0055				ARCH_UM82		EQU	'U'			; UMC UM82C088 / ALi M1101
				
				;
				; CPU Instruction Set Target
				;
 = 0038				CPU_8088		EQU	'8'			; 808x compatible
 = 0056				CPU_V20		EQU	'V'			; V20 only
				
				;
				; Boot to Turbo or Normal Speed
				;
 = 0054				BOOT_TURBO		EQU	'T'
 = 004E				BOOT_NORMAL		EQU	'N'
				
				;
				; Turbo Switch Behavior
				;
 = 0000				TURBO_NONE		EQU	0			; fixed clock no turbo switching
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 3 - 1


 = 0001				TURBO_STD		EQU	1			; standard PPI B (bit 3)
 = 0002				TURBO_REV		EQU	2			; reversed PPI B (bit 3)
				
				;----------------------------------------------------------------------------;
				; BIOS Product Info
				;
 = 'GLaBIOS'			VER_NAME		EQU	'GLaBIOS'
					IFNDEF VER_NUM
 = '0.2.4'			VER_NUM		EQU	'0.2.4'		; (max 5 chars)
					ENDIF
					IFNDEF VER_DATE
 = '05/19/23'			VER_DATE		EQU	'05/19/23' 		; must be MM/DD/YY format
					ENDIF
 = '2022-23'			COPY_YEAR		EQU	'2022-23'		; Copyright year range
				
				;----------------------------------------------------------------------------;
				; BEGIN Configurable Build Options
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Select Target Architecture Preset
				;
					IFNDEF ARCH_TYPE
				;ARCH_TYPE		EQU	ARCH_5150		; PC 5150
				;ARCH_TYPE		EQU	ARCH_5160		; PC 5160 (recommended for non-Turbo)
				;ARCH_TYPE		EQU	ARCH_5160v2		; PC 5160v2 (not recommended)
 = ARCH_TURBO			ARCH_TYPE		EQU	ARCH_TURBO		; Standard Turbo
				;ARCH_TYPE		EQU	ARCH_TD3300		; TD3300A (ST-xx/UNIQUE/Auva)
				;ARCH_TYPE		EQU	ARCH_FE2010		; Faraday FE2010A
				;ARCH_TYPE		EQU	ARCH_UM82		; UMC UM82C088 / ALi M1101
				;ARCH_TYPE		EQU	ARCH_EHB		; EMM Computers/Homebrew 8088
				;ARCH_TYPE		EQU	ARCH_EMU		; 86Box/Emulators (not for real hardware)
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Sub Architecture Types (use with the ARCH_TYPE in parentheses)
				;
					IFNDEF ARCH_SUB_TYPE
				;ARCH_SUB_TYPE	EQU	ARCH_M88		; micro_8088/NuXT (TYPE ARCH_FE2010)
				;ARCH_SUB_TYPE	EQU	ARCH_MIST		; PCXT_MiSTer (TYPE ARCH_EMU)
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Default CPU Instruction Set Target
				;
					IFNDEF CPU_TYPE
 = CPU_8088			CPU_TYPE		EQU	CPU_8088		; CPU_8088 or CPU_V20
				;CPU_TYPE		EQU	CPU_V20		; use V20+ only instructions
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Turbo Type
				;
				; Some motherboards boot in Normal mode by default and the BIOS may or may not
				; switch to Turbo speed on boot. Others invert this behavior where it appears
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 4 - 1


				; reversed to the BIOS. Use these options to customize for your motherboard.
				;
					IFNDEF TURBO_TYPE
				;TURBO_TYPE		=	TURBO_NONE	; standard 4.77 MHz
				;TURBO_TYPE		=	TURBO_STD	; standard PPI 61h (1=turbo, 0=normal)
 = 0002				TURBO_TYPE		=	TURBO_REV	; reversed PPI 61h (1=normal, 0=turbo)
					ENDIF
				
				;----------------------------------------------------------------------------;
				; CGA Snow Removal Method
				;
 = 0000				CGA_SNOW_REMOVE	=	0		; 0: Snow, Normal Flashing, Fastest
										; 1: Less Snow, Some Flashing, Medium Fast
										; 2: No Snow, Moderate Flashing, Fast
										; 3: No Snow, More Flashing, Quite Fast
				
				;----------------------------------------------------------------------------;
				; Personality Traits
				;
 = 0000				POST_CLS		=	0		; clear screen after POST
 = 0000				POST_GLADOS		=	0		; say "Starting GLaDOS..." on boot
 = 0001				POST_HD_PARMS	=	1		; show hard drive parameters on POST
 = 0001				POST_THEME		=	1		; color theme for POST screen (see below)
 = 0001				POST_VIDEO_TYPE	=	1		; show the video adapter type on POST
 = 0001				POST_WARM_COLD	=	1		; show boot WARM or COLD
 = 0001				WARM_ENABLE		=	1		; 1=enable WARM boot or 0=always COLD boot
 = 0001				RANDOM_TAGLINE	=	1		; randomize pithy tagline
 = 0000				UNITS_IEC		=	0		; 0=period-correct "KB" or 1=modern IEC "KiB"
				
				;----------------------------------------------------------------------------;
				; Enable/Disable POST tests (not all tests can be enabled due to 8K ROM space)
				;
 = 0001				POST_TEST_INST	=	1		; POST CPU Instruction/Flag Test
 = 0001				POST_TEST_DMA	=	1		; POST DMA Register Test
 = 0001				POST_TEST_PIT_1	=	1		; POST Timer Channel 1 Test
 = 0001				POST_TEST_PIC_REG	=	1		; POST PIC Register Test
 = 0001				POST_TEST_PIC_INT	=	1		; POST PIC Interrupt Test
 = 0001				POST_TEST_CHK_ROM	=	1		; POST Checksum ROM
 = 0000				POST_TEST_FD	=	0		; POST Floppy Drive Test
 = 0000				POST_TEST_SEEK	=	0		; POST Seek Floppy Drives
 = 0001				POST_TEST_KB	=	1		; POST Keyboard Test
				
				;----------------------------------------------------------------------------;
				; Advanced Options (may void your warranty)
				;
 = 02E0				MAX_RAM 		=	736		; Max detectable low RAM (in KB)
										;   640 max using EGA/VGA
										;   704 max using MDA
										;   736 max using CGA
 = 0000				DRAM_REFRESH	=	0		; 1: Use standard DMA DRAM refresh
										; 0: Disable refresh (use only with SRAM!)
 = 0000				RAM_PARITY		=	0		; Enable RAM parity checking
 = 0000				RAM_TEST_LONG	=	0		; Long RAM test on cold boot
 = 0001				BASIC_ROM		=	1		; BASIC ROM support at 0F600h
 = FE00				OPT_ROM_END		=	0FE00H	; Option ROM scan ending address
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 5 - 1


 = 0000				FDC_ENABLE		=	0		; Enable INT 13h floppy support
 = 0001				FDC_HLT_WAIT	=	1		; Halt CPU during FD access
										;   Some chipsets (TD3300A known affected)
										;   hang during floppy access if this is
										;   enabled
 = 0001				KB_HLT_WAIT		=	1		; Halt CPU during KB wait
 = 0000				MBR_CHECK		=	0		; Verify magic number of DOS MBR at boot
										;   note: DOS 1.0 does not use MBR, so
										;   will not boot if this is enabled
 = 0001				POST_HD_CHECK	=	1		; Enable POST HD drive count and size
										;   note: Some older WD controller ROMs 
										;   (version 62-000043-0xx known affected)
										;   have bugs where INT 13h function are
										;   unusable during POST. Set to 0 to
										;   work around (disables POST_HD_PARMS)
 = 0000				FD_AUTO_DETECT	=	0		; Auto-detect number of floppy drives
										;   use only for DIP switch-less PCs!
 = 0001				POST_ERR_WAIT	=	1		; Wait for Any Key press to continue if
										;   there is a POST error
 = 0000				INT_19_BOOT_HD	=	0		; Try IPL to floppy then hard drive (80h)
 = 00C0				SW1_FLP		=	MASK FLP	; Default max number of floppy drives
				
				;----------------------------------------------------------------------------;
				; END Configurable Build Options
				;----------------------------------------------------------------------------;
				
				
				;----------------------------------------------------------------------------;
				; ARCH/build-specific configuration
				;----------------------------------------------------------------------------;
				; Defaults / BIOS ID Byte
				;
				; https://stanislavs.org/helppc/id_bytes.html
				; NOTE: DOS may re-vector some interrupts or attempt bug workarounds 
				; depending on this byte.
				;
 = 00FE				ARCH_ID		=	0FEH			; 0xFE=XT v1/clone (default)
 = 0000				CASSETTE		=	0			; disable cassette (default)
				
					IFNDEF ARCH_SUB_TYPE
 = 0000				ARCH_SUB_TYPE	EQU	0			; make sure this is defined
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_5150
				;----------------------------------------------------------------------------;
				; Configuration for 5150 board
				;
				ARCH_ID		=	0FFH			; 0xFF=5150
				CASSETTE		=	1			; enable INT 13h cassette
				MBR_CHECK		=	0			; disable MBR check for DOS 1.x
				TURBO_TYPE		=	TURBO_NONE
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Configuration for 5160 boards
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 6 - 1


				;
					IF ARCH_TYPE EQ ARCH_5160v2
				ARCH_ID		=	0FBH			; 0xFB=XT v2/v3
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
					ENDIF
					IF ARCH_TYPE EQ ARCH_5160
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_TD3300
				;----------------------------------------------------------------------------;
				; Configuration for TD3300A
				;
				BASIC_ROM		= 	0			; disable to free code space
				FDC_HLT_WAIT	=	0			; seems to cause issues on TD3300A
				TURBO_TYPE		=	TURBO_STD		; always use Standard
				TURBO_SWITCH	=	1			; boot under hardware Turbo control
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_UM82
				;----------------------------------------------------------------------------;
				; Configuration for UM82C088
				;
				BASIC_ROM		= 	0			; disable to free code space
						IF BASIC_ROM EQ 1			; if BASIC enabled, disable
				POST_TEST_PIC_REG	=	0			;  unnecessary tests to free code
				POST_TEST_PIC_INT	=	0			;  space since PIC is integrated
						ENDIF
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; Configuration for FE2010A
				;
				;BASIC_ROM		= 	0			; can be disabled to free code space
				FD_AUTO_DETECT	=	1			; auto-detect number of floppy drives
				;FE_CPU_CFG		=	110b			; boot to 9.54 MHz, 2 RAM WS
				FE_CPU_CFG		=	100b			; boot to 9.54 MHz, 4 RAM WS (safest)
				;FE_CPU_CFG		=	011b			; boot to 7.15 MHz, 0 RAM WS
				;FE_CPU_CFG		=	000b			; boot to 4.77 MHz, 0 RAM WS
				POST_TEST_PIT_1	=	0			; FE2010A chipset cannot read timer 1
				SW1_FLP		=	01b			; SW1 5/6 Max # of floppy drives (0-1)
				TURBO_TYPE		=	TURBO_REV		; always use reverse
					IF BASIC_ROM EQ 1				; if BASIC enabled, PIC tests are
				POST_TEST_PIC_REG	=	0			;  disabled to fit available code space
				POST_TEST_PIC_INT	=	0			; Since PIC is integrated on FE2010A
					ENDIF						;  these tests may be unnecessary
				
					IF ARCH_SUB_TYPE EQ ARCH_M88
				;----------------------------------------------------------------------------;
				; Additional Configuration for micro_8088 / NuXT
				;
				UNITS_IEC		=	1			; use modern IEC size units
				DRAM_REFRESH	=	0			; disable DRAM refresh (for SRAM)
				RAM_PARITY		=	0			; disable memory parity check
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 7 - 1


				CGA_SNOW_REMOVE	=	0			; disable snow removal
				FE_CPU_CFG		=	110b			; boot to 9.54 MHz, 2 RAM WS
					ENDIF
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_EHB
				;----------------------------------------------------------------------------;
				; Configuration for EMM/Homebrew
				;
				CGA_SNOW_REMOVE	=	0			; disable snow removal
				DRAM_REFRESH	=	0			; disable refresh (no DRAM)
				RAM_PARITY		=	0			; disable memory parity check
				DMA_INSTALLED	=	0			; no DMA 8237A installed
				;FDC_ENABLE		=	0			; disable all INT 13h floppy tests (if no DM
				A)
				;POST_TEST_FD	=	0			; disable Seek Floppy Drives
				POST_TEST_DMA	=	0			; disable DMA Register Test (no DMA)
				POST_TEST_KB	=	0			; disable PKEY and PKI errors
				POST_TEST_PIT_1	=	0			; disable Timer 1 Test (no DRAM)
				POST_TEST_PIC_REG	=	0			; disable PIC Register Test
				SW1_VID		=	00b			; SW1 5/6 Video Type (0=EGA/VGA
											;   1=CGA 40, 2=CGA 80, 3=MDA/Herc)
							IF FDC_ENABLE EQ 1
				SW1_FLP		=	01b			; SW1 7/8 Max # of floppy drives (0-3)
				FD_AUTO_DETECT	=	1			; auto-detect number of floppy drives
							ELSE
				SW1_FLP		=	00b			; SW1 7/8 Max # of floppy drives (0-3)
							ENDIF
							IF CPU_TYPE NE CPU_V20
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
							ENDIF
				POST_ERR_WAIT	=	0			; only warn POST errors (since DMA
											;   and FDC are optional)
				INT_19_BOOT_HD	=	1			; Try IPL to floppy then HD
					ENDIF
				
					IF ARCH_TYPE EQ ARCH_EMU
				;----------------------------------------------------------------------------;
				; Configuration for 86Box/Emulators
				;
				CGA_SNOW_REMOVE	=	0			; disable CGA snow removal
				DRAM_REFRESH	=	0			; disable DRAM refresh
				POST_TEST_CHK_ROM	=	0			; disable Checksum ROM
				POST_TEST_DMA	=	0			; disable DMA Register Test
				POST_TEST_PIC_INT	=	0			; disable PIC Interrupt Test
				POST_TEST_PIC_REG	=	0			; disable PIC Register Test
				POST_TEST_PIT_1	=	0			; disable Timer Channel 1 Test
				POST_TEST_FD	=	0			; disable Floppy Drive Seek Test
											; disable Floppy Head Settle Delay
				RAM_TEST_LONG	=	0			; disable long RAM test
				TURBO_TYPE		=	TURBO_NONE		; disable Turbo features
				
					IF ARCH_SUB_TYPE EQ ARCH_MIST
				;----------------------------------------------------------------------------;
				; Additional Configuration for PCXT_MiSTer
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 8 - 1


				;
				TURBO_TYPE		=	TURBO_STD		; enable Turbo features
				;FDC_ENABLE		=	0			; disable all INT 13h floppy tests
					ENDIF
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Boot to normal or turbo speed (if supported)
				;
 =-0001				IS_TURBO		=	TURBO_TYPE NE TURBO_NONE	; use for conditionals
				
					IF IS_TURBO
 = BOOT_TURBO			BOOT_SPEED		EQU	BOOT_TURBO
					ELSE
				BOOT_SPEED		EQU	BOOT_NORMAL
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Reconfigure features as needed
				;----------------------------------------------------------------------------;
				; If Cassette enabled, the following features must be disabled to 
				; free code space.
				;
					IF CASSETTE EQ 1
				POST_HD_PARMS	=	0			; disable HD size display
				RANDOM_TAGLINE	=	0			; disable random tagline
					ENDIF
				
					IF POST_HD_CHECK EQ 0
				POST_HD_PARMS	=	0			; disable HD PARM display also
					ENDIF
				
					IF WARM_ENABLE EQ 0
				POST_WARM_COLD	=	0			; disable show boot WARM or COLD
					ENDIF
				
				;----------------------------------------------------------------------------;
				; Enable 186 instructions if V20
				;
					IF CPU_TYPE EQ CPU_V20
				.186
					ENDIF
				
				
				;----------------------------------------------------------------------------;
				; POST colors and visuals
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; PC Text Colors
				; https://stanislavs.org/helppc/colors.html
				;
 = 0000				BLACK			EQU	0
 = 0001				DARKBLUE		EQU	1
 = 0002				DARKGREEN		EQU	2
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 9 - 1


 = 0003				CYAN			EQU	3
 = 0004				DARKRED		EQU	4
 = 0005				DARKMAGENTA		EQU	5
 = 0006				BROWN			EQU	6
 = 0007				GRAY			EQU	7
 = 0008				DARKGRAY		EQU	8
 = 0009				BLUE			EQU	9
 = 000A				GREEN			EQU	10
 = 000B				LIGHTCYAN		EQU	11
 = 000C				RED			EQU	12
 = 000D				MAGENTA		EQU	13
 = 000E				YELLOW		EQU	14
 = 000F				WHITE			EQU	15
				
				;----------------------------------------------------------------------------;
				; Theme My POST Test!
				; Pick theme from below or roll your own!
				;----------------------------------------------------------------------------;
						IF POST_THEME EQ 3
				
				; Theme #3 - "Boring"
				POST_CLR_TXT	EQU	GRAY			; primary color for text
				POST_CLR_VAL1	EQU	GRAY			; value text color
				POST_CLR_VAL2	EQU	GRAY			; value text alternate color
				POST_CLR_COLD	EQU	BLUE			; COLD color
				POST_CLR_WARM	EQU	RED			; WARM color
				POST_CLR_GB		EQU	GRAY			; BIOS name in bootup screen
						ELSE
						IF POST_THEME EQ 2
				
				; Theme #2 - "Kinda l33t?"
				POST_CLR_TXT	EQU	DARKGRAY
				POST_CLR_VAL1	EQU	BLUE
				POST_CLR_VAL2	EQU	GREEN
				POST_CLR_COLD	EQU	BLUE
				POST_CLR_WARM	EQU	RED
				POST_CLR_GB		EQU	WHITE
						ELSE
				
				; Theme #1 - "Old skool BBS" (default)
 = CYAN				POST_CLR_TXT	EQU	CYAN
 = GREEN			POST_CLR_VAL1	EQU	GREEN
 = YELLOW			POST_CLR_VAL2	EQU	YELLOW
 = BLUE				POST_CLR_COLD	EQU	BLUE
 = DARKRED			POST_CLR_WARM	EQU	DARKRED
 = GRAY				POST_CLR_GB		EQU	GRAY
						ENDIF
						ENDIF
				
				;----------------------------------------------------------------------------;
				; POST screen column layout options
				;
 = ' [ '			POST_L		EQU	<' [ '>		; left separator string
 = ' ]'				POST_R		EQU	<' ]'>		; right separator string
 = 0002				L_POST_L		EQU	2			; length of separator
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 10 - 1


				
 = 0020				POST_TAB_COL	EQU	32			; horiz tab width for second column
 = 0007				POST_COL_LBL_W	EQU	7			; column label width
 = 0004				POST_COL_PAD	EQU	4			; padding (non colored) space between cols
				
 = 0006				POST_COL_W		EQU	POST_COL_LBL_W-1	; zero-based column index
				
				; column label width plus separator
 = 0009				POST_COL_VT		EQU	POST_COL_LBL_W + L_POST_L
				
				; space between next column
 = 0013				POST_TAB_COL_I	EQU	POST_TAB_COL - POST_COL_LBL_W - L_POST_L - POST_COL_PAD
				
				; hard drive post display
 = 0028				POST_HD_CHS_L	EQU	'('			; chars to enclose CHS display
 = 0029				POST_HD_CHS_R	EQU	')'
				
				; prefer period-correct "KB" or IEC "KiB"
								IF UNITS_IEC EQ 1
				POST_K_UNIT		EQU	<'KiB'>		; KiB size unit abbrev.
				POST_M_UNIT		EQU	<'MiB'>		; MiB size
								ELSE
 = 'KB'				POST_K_UNIT		EQU	<'KB'>		; KB size unit abbrev.
 = 'MB'				POST_M_UNIT		EQU	<'MB'>		; MB size
								ENDIF
				
				;----------------------------------------------------------------------------;
				; Useful CP-437/Control Chars
				;
 = 000D				CR 			EQU	0DH 			; Carriage return
 = 000A				LF 			EQU	0AH 			; Line feed
 = 0008				BS			EQU	08H			; Backspace ASCII
 = 0007				BELL			EQU	07H			; BELL ASCII
 = 0016				SYN			EQU	16H			; SYN C0 control char
 = 00B3				VL			EQU	0B3H			; vertical line
 = 00C4				HL			EQU	0C4H			; horizontal line
 = 00F4				CURL_TOP		EQU	0F4H
 = 00F5				CURL_BOT		EQU	0F5H
 = 00F9				BULL			EQU	0F9H			; Bullet operator (medium centered dot)
 = 00FA				DOT			EQU	0FAH			; Small middle dot
 = 00FE				SQUARE		EQU	0FEH			; Black square (rectangle)
 = 0003				HEART			EQU	03H			; faithful companion
 = 000D				NOTE1			EQU	0DH
 = 000E				NOTE2			EQU	0EH
 = 001D				DBLARROW		EQU	01DH
				
				;----------------------------------------------------------------------------;
				; Beepin' Tones
				;----------------------------------------------------------------------------;
 = 0975				BEEP_B5		EQU	2421 			; B4 (493.88 Hz)
 = 08F1				BEEP_C5		EQU	2289			; C5 (523.25 Hz)
 = 06A5				BEEP_F5		EQU	1701			; F5 (698.46 Hz)
 = 05FA				BEEP_G5		EQU	1530			; G5 (783.99 Hz)
 = 054C				BEEP_A6		EQU	1356			; A5 (880.00 Hz)
 = 0474				BEEP_C6		EQU	1140			; C6 (1046.50 Hz)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 11 - 1


 = 04B1				BEEP_1K		EQU	1201			; ~1 KHz tone
 = 04A0				BEEP_1K7		EQU	1184			; ~1007 Hz (cassette 1 bit)
 = 0250				BEEP_2K		EQU	BEEP_1K7 / 2	; ~2015 Hz (cassette 0 bit)
				
 = BEEP_A6			BEEP_DEFAULT	EQU	BEEP_A6		; default beep
 = BEEP_F5			BEEP_ERR_HIGH	EQU	BEEP_F5		; perfect fourth apart for
 = BEEP_C5			BEEP_ERR_LOW	EQU	BEEP_C5		;  alternating error beeps
				
				;----------------------------------------------------------------------------;
				; PC ISA (Instruction Set Architecture) I/O Port Addresses
				;----------------------------------------------------------------------------;
				
				; 8237A DMA Controller
 = 0000				DMA_0_A		EQU	00H 			; W   Start Address Register channel 0
 = 0001				DMA_0_C		EQU	01H			; W   Count Register channel 0
 = 0002				DMA_1_A		EQU	02H			; W   Start Address Register channel 1
 = 0003				DMA_1_C		EQU	03H			; W   Count Register channel 1
 = 0004				DMA_2_A		EQU	04H			; W   Start Address Register channel 2
 = 0005				DMA_2_C		EQU	05H			; W   Count Register channel 2
 = 0006				DMA_3_A		EQU	06H			; W   Start Address Register channel 3
 = 0007				DMA_3_C		EQU	07H			; W   Count Register channel 3
 = 0008				DMA_CMD		EQU	08H			; RW  Status / Command Register
 = 0009				DMA_REQ		EQU	09H			; W   Request Register
 = 000A				DMA_MASK		EQU	0AH 			; W   Single Channel Mask Register
 = 000B				DMA_MODE		EQU	0BH 			; W   Mode Register
 = 000C				DMA_FF		EQU	0CH 			; W   Flip-Flop Reset Register
 = 000D				DMA_RESET		EQU	0DH 			; W   Master Reset Register (Mask bits ON)
 = 000E				DMA_MASKR		EQU	0EH 			; W   Mask Reset Register (Mask bits OFF)
 = 000F				DMA_MMASK		EQU	0FH 			; RW  MultiChannel Mask Register
				
				; DMA Page Registers (74LS670)
 = 0087				DMA_P_C0		EQU	87H			; DMA Channel (unused on PC)
 = 0083				DMA_P_C1		EQU	83H			; DMA Channel 0 and 1
 = 0081				DMA_P_C2		EQU	81H			; DMA Channel 2
 = 0082				DMA_P_C3		EQU	82H			; DMA Channel 3
				
				; 8259 PIC Interrupt Controller
 = 0020				INT_P0		EQU	20H 			; Port 0
 = 0021				INT_IMR		EQU	21H 			; Port 1 - OCW1 Interrupt Mask Register
				
				; 8253 PIT Timer
 = 0040				PIT_CH0		EQU	40H			; Timer Channel/Counter 0
 = 0041				PIT_CH1		EQU	41H			; Timer Channel/Counter 1
 = 0042				PIT_CH2		EQU	42H			; Timer Channel/Counter 2 - Speaker
 = 0043				PIT_CTRL		EQU	43H			; Timer Control Word
				
				; 8255 PPI Peripheral Interface
 = 0060				PPI_A			EQU	60H			; PPI (8255) Port A IN  - Keyboard input
 = 0061				PPI_B			EQU	61H			; PPI (8255) Port B OUT - Speaker, Switch se
				lection, Misc
 = 0062				PPI_C			EQU	62H			; PPI (8255) Port C IN  - Switches
 = 0063				PPI_CW		EQU	63H			; PPI (8255) Port Control Word
				
				; 8042 Keyboard Controller
 = 0060				ATKB_IO		EQU	60H			; 8042 Keyboard input/output buffer register
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 12 - 1


 = 0064				ATKB_CMD		EQU	64H			; 8042 Keyboard command/status register
				
				; POST TEST card I/O
 = 0080				POST_CARD_PORT	EQU	80H			; can be 60H, 80H, 300H, 313H
				
				; TD3300A (ST-xx/UNIQUE/Auva) Control Registers (90h)
 = 0070				TD_WS			EQU	70H			; RAM, I/O wait state control
 = 0090				TD_TURBO		EQU	90H			; Write 2 for Turbo, 3 for Normal
 = 00E0				TD_UMA		EQU	0E0H			; Upper Memory bank switch
				
				; UM82C088 Speed / Status registers
 = 00C0				UM82_SPEED		EQU	0C0H			; write any value to toggle speed mode
 = 00E0				UM82_STATUS		EQU	0E0H			; read memory size, speed mode
				
				; NMI flip/flop
 = 00A0				NMI_R0		EQU	0A0H			; NMI Mask Register
				
				; Joystick / Game Port
 = 0201				GAME_CTRL		EQU	0201H			; Game Port
				
				; Hard Disk Controller
 = 0320				HDC_READ		EQU	0320H			; Read from/Write to controller
 = 0321				HDC_CTRL		EQU	0321H			; Read: Controller Status, Write: controller
				 reset
 = 0322				HDC_PULSE		EQU	0322H			; Write: generate controller select pulse
 = 0323				HDC_DMA		EQU	0323H			; Write: Pattern to DMA and interrupt mask register
 = 0324				HDC_STAT		EQU	0324H			; disk attention/status
				
				; Video 6845 CRT Controller
 = 03B8				MDA_CTRL		EQU	03B8H			; MDA CRT Control Port 1
 = 03BA				MDA_STAT		EQU	03BAH			; MDA Status Register
 = 03D8				CGA_CTRL		EQU	03D8H			; CGA Mode Select Register
 = 03DA				CGA_STAT		EQU	03DAH			; CGA Status Register
				
				; Serial (COM) ports
 = 03F8				COM1_DATA		EQU	03F8H 		; 03F8H: TX/RX Buffer, Divisor LSB (RW)
 = 03F9				COM1_IER		EQU	COM1_DATA+1		; 03F9H: Interrupt Enable Register, Divisor 
				MSB (RW)
 = 03FA				COM1_IIR		EQU	COM1_DATA+2		; 03FAH: Interrupt Identification Register (
				R)
 = 03FB				COM1_LCR		EQU	COM1_DATA+3		; 03FBH: Line Control Register (RW)
 = 03FC				COM1_MCR		EQU	COM1_DATA+4		; 03FCH: Modem Control Register (RW)
 = 03FD				COM1_LSR		EQU	COM1_DATA+5		; 03FDH: Line Status Register (R)
 = 03FE				COM1_MSR		EQU	COM1_DATA+6		; 03FEH: Modem Status Register (R)
 = 03FF				COM1_SPR		EQU	COM1_DATA+7		; 03FFH: Scratch Pad Register (RW)
 = 02F8				COM2_DATA		EQU	COM1_DATA-100H	; 02F8H: TX/RX Buffer, Divisor LSB (RW)
 = 03E8				COM3_DATA		EQU	COM2_DATA+0F0H	; 03E8H: TX/RX Buffer, Divisor LSB (RW)
 = 02E8				COM4_DATA		EQU	COM3_DATA-100H	; 02E8H: TX/RX Buffer, Divisor LSB (RW)
				
				; Default LPT/COM I/O timeouts (# of 64K LOOPs)
 = 0014				LPT_TO		EQU	20			; LPT default timeout
 = 0001				COM_TO		EQU	1			; COM default timeout
				
				; V40 Control Registers
 = FFF6				V40_WCR2		EQU	0FFF6H		; WCU Wait Cycle 2 Register
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 13 - 1


 = FFF5				V40_WCR1		EQU	0FFF5H		; WCU Wait Cycle 1 Register
				
				;----------------------------------------------------------------------------;
				; FDC (NEC PD765x) Controller 
				;
				
				; Floppy Disk Controller Ports
 = 03F0				FDC_A_STAT		EQU	03F0H			; Diskette controller status A
 = 03F1				FDC_B_STAT		EQU	03F1H			; Diskette controller status B
 = 03F2				FDC_CTRL		EQU	03F2H			; FD controller control port
 = 03F4				FDC_STAT		EQU	03F4H			; FD controller status register
 = 03F5				FDC_DATA		EQU	03F5H			; data register (write 1-9 byte command, see
				 INT 13)
				
				; FDC Commands
 = 0002				FDC_CMD_RTRK	EQU	00000010B		; 02H: Read Track (Diagnostic)
 = 0003				FDC_CMD_SPEC 	EQU	00000011B		; 03H: Specify Step & Head Load
 = 0004				FDC_CMD_STAT 	EQU	00000100B		; 04H: Sense Drive Status
 = 0005				FDC_CMD_WR		EQU	00000101B		; 05H: Write Sector
 = 0006				FDC_CMD_RD		EQU	00000110B		; 06H: Read Sector
 = 0007				FDC_CMD_RECAL	EQU	00000111B		; 07H: Recalibrate
 = 0008				FDC_CMD_SENSE	EQU	00001000B		; 08H: Sense Interrupt Status
 = 0009				FDC_CMD_WDEL	EQU	00001001B		; 09H: Write Deleted Sector
 = 000A				FDC_CMD_RSID	EQU	00001010B		; 0AH: Read Sector ID
 = 000C				FDC_CMD_RDEL	EQU	00001100B		; 0CH: Read Deleted Sector
 = 000D				FDC_CMD_FMT		EQU	00001101B		; 0DH: Format Track
 = 000F				FDC_CMD_SEEK	EQU	00001111B		; 0FH: Seek
				
				; BDA INT 13H Status Flags 
				; https://stanislavs.org/helppc/int_13-1.html
 = 0000				FDC_ST_OK		EQU	00H			; No error
 = 0001				FDC_ST_BADCMD	EQU	01H			; Bad command passed to driver
 = 0002				FDC_ST_ERR_MARK	EQU	02H			; Address mark not found or bad sector
 = 0003				FDC_ST_ERR_WP	EQU	03H			; Write Protect Error
 = 0004				FDC_ST_ERR_SEC	EQU	04H			; Sector not found
 = 0008				FDC_ST_DMA_OVR	EQU	08H			; DMA overrun
 = 0009				FDC_ST_DMA_64K	EQU 	09H			; DMA access across 64k boundary
 = 0010				FDC_ST_ERR_CRC	EQU	10H			; ECC/CRC error on disk read
 = 0020				FDC_ST_ERR_FDC	EQU	20H			; Controller error
 = 0040				FDC_ST_ERR_SEEK	EQU	40H			; Seek failure
 = 0080				FDC_ST_TIMEOUT	EQU	80H 			; Time out, drive not ready
 = 00FF				FDC_ST_SENSE	EQU	0FFH 			; Sense operation failed
				
				; Trivial RAM / data patterns
 = 95A5				RAM_TEST_1		EQU 	1001010110100101B	; Simple RAM test 095A5H
 = 739D				RAM_TEST_2		EQU 	0111001110011101B	; Alternate RAM test 0739DH
 = 95A5				RAM_TEST		=	RAM_TEST_1		; pick one!
 = AA55				MAGIC_WORD		EQU	0AA55H		; Magic Word used for option ROM, IPL device
				
				; Warm Boot Flag options set in BDA 40:72H
 = 0000				COLD_BOOT		EQU	0			; Cold Boot - All POST tests
 = 1234				WARM_BOOT		EQU	1234H			; Warm Boot - Skip some POST tests
 = 4321				WARM_BOOT_MEM	EQU	4321H			; Warm Boot - Preserve memory
 = 5678				WARM_BOOT_SUS	EQU	5678H			; Warm Boot - System suspend
 = 9ABC				WARM_BOOT_TEST	EQU	9ABCH			; Warm Boot - Manufacturer test
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 14 - 1


				
				; Video Related
 = 0050				VID_DEF_COLS	EQU	80			; standard video mode columns
 = 0018				VID_DEF_ROWS	EQU	24			; standard video mode rows
 = DNB <BLACK, GRAY>		VID_ATTR		EQU	DNB <BLACK, GRAY>	; fill byte for blank video attribute
 = 0020				VID_SP		EQU	' '			; fill byte for blank video RAM char
				
				
				;============================================================================;
				;
				; 			   * * *   S T R U C T S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; BDA Timer Counters (6CH-70H)
				;----------------------------------------------------------------------------;
 0005				TIMER_C STRUC
 0000  0000			LW		DW	?	; 6CH  Timer Counter Low Word (ticks)
 0002  0000			HW	  	DW	? 	; 6EH  Timer Counter High Word (hours)
 0004  00			OF 		DB	? 	; 70H  Timer Overflow flag
				TIMER_C ENDS
				
				;----------------------------------------------------------------------------;
				; INT 1E Disk Initialization Parameter Table Vector
				;
				; https://stanislavs.org/helppc/dbt.html
				;----------------------------------------------------------------------------;
 000B				DBT	STRUC
 0000  00			SRT		DB	? 	; 00 step-rate time SRT (0CH), head unload time HUT (0FH)
 0001  00			HLT_ND	DB	? 	; 01 head load time HLT (01H), DMA mode ND (0)
 0002  00			FMCT		DB	? 	; 02 timer ticks to wait before disk motor shutoff
 0003  00			FBPS		DB	? 	; 03 bytes per sector (0=128, 1=256, 2=512, 3=1024)
 0004  00			SPT		DB	? 	; 04 sectors per track (last sector number)
 0005  00			SGAP		DB	? 	; 05 inter-block gap length/gap between sectors
 0006  00			LSEC		DB	? 	; 06 data length, if sector length not specified
 0007  00			FGAP		DB	? 	; 07 gap length between sectors for format
 0008  00			FFILL		DB	? 	; 08 fill byte for formatted sectors
 0009  00			HDST		DB	? 	; 09 head settle time in milliseconds
 000A  00			FMST		DB	? 	; 0A motor startup time in eighths of a second
				DBT	ENDS
				
				;----------------------------------------------------------------------------;
				; FDC Command Status Bytes (FDC_LAST_ST)
				;----------------------------------------------------------------------------;
 0007				FDC_CSB STRUC
 0000  00			SB0		DB	?	; 00 - status register 0
 0001  00			SB1		DB	?	; 01 - status register 1
 0002  00			SB2		DB	?	; 02 - status register 2
 0003  00			CYL		DB	?	; 03 - cylinder number
 0004  00			HEAD		DB	?	; 04 - head number
 0005  00			SEC		DB	?	; 05 - sector number
 0006  00			BPS		DB	?	; 06 - bytes per sector
				FDC_CSB ENDS
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 15 - 1


				;----------------------------------------------------------------------------;
				; INT 1D Video Initialization Parameter Table Vector (CRTC)
				;
				; https://stanislavs.org/helppc/6845.html
				;----------------------------------------------------------------------------;
 0010				CRTC	STRUC
 0000  00			H_TC		DB	?	; 00 - Horiz. total characters
 0001  00			H_CL		DB	?	; 01 - Horiz. displayed characters per line
 0002  00			H_SP		DB	?	; 02 - Horiz. synch position
 0003  00			H_SW		DB	?	; 03 - Horiz. synch width in characters
 0004  00			V_TL		DB	?	; 04 - Vert. total lines
 0005  00			V_SL		DB	?	; 05 - Vert. total adjust (scan lines)
 0006  00			V_DR		DB	?	; 06 - Vert. displayed rows
 0007  00			V_SP		DB	?	; 07 - Vert. synch position (character rows)
 0008  00			IL		DB	?	; 08 - Interlace mode
 0009  00			MSL		DB	?	; 09 - Maximum scan line address
 000A  00			CSL		DB	?	; 0A - Cursor start (scan line)
 000B  00			CEL		DB	?	; 0B - Cursor end (scan line)
 000C  00			SA_H		DB	0	; 0C - Start address (MSB)
 000D  00			SA_L		DB	0	; 0D - Start address (LSB)
 000E  00			CA_H		DB	0	; 0E - Cursor address (MSB) (read/write)
 000F  00			CA_L		DB	0	; 0F - Cursor address (LSB) (read/write)
				CRTC	ENDS
				
				;============================================================================;
				;
				; 			   * * *   R E C O R D S   * * *
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; Define Nibbles to Byte
				; Convert two nibbles to byte (big endian)
				;----------------------------------------------------------------------------;
				DNB	RECORD	HBN:4, LBN:4
				
				;----------------------------------------------------------------------------;
				; Define Bytes to Word
				; Convert two bytes to word (big endian)
				;----------------------------------------------------------------------------;
				DBW	RECORD	HWB:8, LWB:8
				
				;----------------------------------------------------------------------------;
				; x86 EFLAGS
				;----------------------------------------------------------------------------;
				EFLAGS86	RECORD FSF:1,FZF:1,FR1:1,FAF:1,FR2:1,FPF:1,FR3:1=1,FCF:1
				
				;----------------------------------------------------------------------------;
				; BDA Equipment Flags (40:10H)
				;----------------------------------------------------------------------------;
				; 00      |			- LPT : # of LPT ports
				;   x     |			- X1  :  unused, PS/2 internal modem
				;    0    |			- GAM : Game port present
				;     000 |			- COM : # of COM ports present
				;        0| 		- DMA : DMA (should always be 0)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 16 - 1


				;         |00	 	- FLP : Floppy drives present (+1) (0=1 drive,1=2,etc)
				;         |  00		- VIDM: Video mode (00=EGA/VGA, 01=CGA 40x25, 
				; 				-	10=CGA 80x25, 11=MDA 80x25)
				;         |    11 	- MBRAM: MB RAM (00=64K, 01=128K, 10=192K, 11=256K+)
				;         |      0	- FPU : FPU installed
				;         |       1	- IPL : Floppy drive(s) installed (always 1 on 5160)
				;----------------------------------------------------------------------------;
								IF FDC_ENABLE EQ 1
				EQFLAGS RECORD	LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VIDM:2,MBRAM:2=11b,FPU:1,IPL:1=1
								ELSE
				EQFLAGS RECORD	LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VIDM:2,MBRAM:2=11b,FPU:1,IPL:1=0
								ENDIF
				
				;----------------------------------------------------------------------------;
				; GLaBIOS Equipment Flags (40:12H)
				;----------------------------------------------------------------------------;
				; 76543210
				; xxxx    |			- TBD		Reserved
				;     x   |			- TURBO	Turbo supported
				;      x  |			- V20		1 if V20, 0 if 8088
				;       xx|			- TBD		Reserved
				; 84218421
				;----------------------------------------------------------------------------;
				GFLAGS RECORD	GTBD1:4,TURBO:1,V20:1,GTBD2:2
				
				;----------------------------------------------------------------------------;
				; POST status flags are stored in BP
				;----------------------------------------------------------------------------;
				; BP:
				; 76543210
				; x 	    |			- WARM  	Warm Boot flag
				;  x 	    |			- PKI   	POST Keyboard Interrupt Received
				;   x     |			- PKEY  	Keyboard key stuck
				;    x    |			- PFDC  	FDC init failure
				;     x   |			- PFSK  	FDC seek test failure
				;      x  |			- PDMA  	DMA error
				;       x |			- PMEM  	Memory Error
				;        x|			- PFXX  	Reserved (do not use)
				;         |xxxxxx		- TBD
				;         |      xx	- GRND	Random number for tagline
				; 84218421
				;----------------------------------------------------------------------------;
				PFLAGS RECORD WARM:1,PKI:1,PKEY:1,PFDC:1,PFSK:1,PDMA:1,PMEM:1,PFXX:1,PTBD:6,GRND:2
				
				;----------------------------------------------------------------------------;
				; BDA Keyboard Flags
				;----------------------------------------------------------------------------;
				; 40:17	Keyboard Flags Byte 1 (Low)
				;----------------------------------------------------------------------------;
				;          84218421
				; 	    |7 	    	- K1IN	insert is active
				; 	    | 6 	    	- K1CL	caps-lock is active
				; 	    |  5	    	- K1NL	num-lock is active
				; 	    |   4    	- K1SL	scroll-lock is active
				; 	    |    3   	- K1AL	ALT key depressed
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 17 - 1


				; 	    |     2  	- K1CT	CTRL key depressed
				; 	    |      1 	- K1LS	left shift key depressed
				; 	    |       0	- K1RS	right shift key depressed
				;----------------------------------------------------------------------------;
				KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1
				
				;----------------------------------------------------------------------------;
				; 40:18	Keyboard Flags Byte 2 (High)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- K2IN	insert key is depressed
				;  6 	    |			- K2CL	caps-lock key is depressed
				;   5	    |			- K2NL	num-lock key is depressed
				;    4    |			- K2SL	scroll lock key is depressed
				;     3   |			- K2PA	pause (Ctrl-NumLock) is active
				;      2  |			- K2SY	system key depressed and held
				;       1 |			- K2LA	left ALT key depressed
				;        0|			- K2LC	left CTRL key depressed
				;----------------------------------------------------------------------------;
				KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1
				
				;----------------------------------------------------------------------------;
				; FDC BDA Status Flags
				;----------------------------------------------------------------------------;
				; 40:3E	FD_CAL_ST	Drive recalibration status flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FWIF	1=working interrupt flag
				;  654    |			- FSTBD	unused
				;     3   |			- FCAL3	1=recalibrate drive 3
				;      2  |			- FCAL2	1=recalibrate drive 2
				;       1 |			- FCAL1	1=recalibrate drive 1
				;        0|			- FCAL0	1=recalibrate drive 0
				;----------------------------------------------------------------------------;
				FDC_SF RECORD	FWIF:1,FSTBD:3,FCAL3:1,FCAL2:1,FCAL1:1,FCAL0:1
				
				;----------------------------------------------------------------------------;
				; 40:3F	FD_MOTOR_ST	Diskette motor status flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FWRT	1=write operation
				;  654    |			- FMTBD	unused
				;     3210|			- FMOT	1=drive 3 motor on
				;----------------------------------------------------------------------------;
				FDC_MF RECORD	FWRT:1,FMTBD:3,FMOT:4
				
				;----------------------------------------------------------------------------;
				; 40:8F	FD_MODE	Floppy drive mode
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FM1X	unused
				;  6      |			- FM1D	1=drive 1 determined
				;   5     |			- FM1M	1=drive 1 supports multiple data rates
				;    4    |			- FM18	1=drive 1 supports 80-track
				;     3   |			- FM0X	unused
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 18 - 1


				;      2  |			- FM0D	1=drive 0 determined
				;       1 |			- FM0M	1=drive 0 supports multiple data rates
				;        0|			- FM08	1=drive 0 supports 80-track
				;----------------------------------------------------------------------------;
				FDC_MODE RECORD	FM1X:1,FM1D:1,FM1M:1,FM18:1,FM0X:1,FM0D:1,FM0M:1,FM08:1
				
				;----------------------------------------------------------------------------;
				; 40:90H-93H	Floppy drive media state (drives 0-3)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76      |			- FSR		data xfr rate in Kb/s (0=500,1=300,2=250)
				;   5     |			- FDDS	1=dub step required
				;    4    |			- FSE		1=media established
				;     3   |			- FSX		unused
				;      210|			- FSD		(see below)
				;----------------------------------------------------------------------------;
				; FSD values:
				;	0 = 360K disk/360K drive not established
				;	1 = 360K disk/1.2M drive not established
				;	2 = 1.2M disk/1.2M drive not established
				;	3 = 360K disk/360K drive established
				;	4 = 360K disk/1.2M drive established
				;	5 = 1.2M disk/1.2M drive established
				;	6 = reserved
				;	7 = none of the above
				;----------------------------------------------------------------------------;
				FDC_STATE RECORD	FSR:2,FDDS:1,FSE:1,FDX:1,FSD:3
				
				;----------------------------------------------------------------------------;
				; FDC Digital Output Register at 3F2h (write only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- FDMD	1 = turn floppy drive D motor on
				;  6      |			- FDMC	1 = turn floppy drive C motor on
				;   5     |			- FDMB	1 = turn floppy drive B motor on
				;    4    |			- FDMA	1 = turn floppy drive A motor on
				;     3   |			- FDDMA	1 = DMA & I/O interface enabled
				;      2  |			- FDCEN	1 = FDC enable, 0 = hold FDC at reset
				;       10|			- FDDRV	floppy drive select (0=A, 1=B, 2=C, 3=D)
				;----------------------------------------------------------------------------;
				FDC_DOR RECORD	FDMD:1,FDMC:1,FDMB:1,FDMA:1,FDDMA:1,FDCEN:1,FDSEL:2
				
				;----------------------------------------------------------------------------;
				; FDC 765 Status Flags
				;----------------------------------------------------------------------------;
				; FDC Main Status Register at 3F4h (read only)
				; 84218421
				; 7 	    |			- FDRR	data reg ready for I/O to/from CPU
				;  6      |			- FIOD	I/O direction; 1=FDC to CPU; 0=CPU to FDC
				;   5     |			- FDND	FDC is in non-DMA mode
				;    4    |			- FDRW	FDC read or write command in progress
				;     3   |			- F3SK	floppy drive 3 in seek mode/busy
				;      2  |			- F2SK	floppy drive 2 in seek mode/busy
				;       1 |			- F1SK	floppy drive 1 in seek mode/busy
				;        0|			- F0SK	floppy drive 0 in seek mode/busy
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 19 - 1


				;----------------------------------------------------------------------------;
				FDC_MSR RECORD	FDRR:1,FIOD:1,FDND:1,FDRW:1,F3SK:1,F2SK:1,F1SK:1,F0SK:1
				
				;----------------------------------------------------------------------------;
				; FDC Command Status Register 0 at 3F5h
				;----------------------------------------------------------------------------;
				; 84218421
				; 76	    |			- FR0CS	last command status (see below)
				;   5     |			- FR0SK	set to 1 when FDD completes a seek command
				;    4    |			- FR0CHK	equipment check (see note)
				;     3   |			- FR0NR	not ready on read/write or SS access to head 1
				;      2  |			- FR0HD	head number at interrupt (head 0 or 1)
				;       10|			- FR0DRV	unit selected at interrupt (0=A, 1=B, 2=...)
				;----------------------------------------------------------------------------;
				; Bits
				;	 76  Last Command Status
				;	 00  command terminated successfully
				;	 01  command execution started but terminated abnormally
				;	 10  invalid command issued
				;	 11  command terminated abnormally due to a change in state of
				;	     the Ready Signal from the FDC  (reserved on PS/2)
				;
				;	- equipment check can occur if FDD signals a fault or track zero is
				;	  not found after 77 steps on a recalibrate command
				;----------------------------------------------------------------------------;
				FDC_R0 RECORD	FR0CS:2,FR0SK:1,FR0CHK:1,FR0NR:1,FR0HD:1,FR0DRV:2
				
				;----------------------------------------------------------------------------;
				; FDC Command Byte 0
				;----------------------------------------------------------------------------;
				; 84218421
				; 7       |			- FC0MT	MT = Multi-Track
				;  6      |			- FC0MF	MF = MFM mode
				;   5     |			- FC0SK	SK = SKip Deleted-data address mark
				;    43210|			- FC0CMD	FDC command number
				;----------------------------------------------------------------------------;
				FDC_CB RECORD	FC0MT:1,FC0MF:1=1,FC0SK:1,FC0CMD:5
				
				;----------------------------------------------------------------------------;
				; Port 3BD Printer Status Flags returned from INT 17
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- LPBZ	not busy (note: 0 means busy)
				;  6      |			- LPACK	acknowledge (printer is attached)
				;   5     |			- LPOP	20H out of paper
				;    4    |			- LPSEL	10H selected (0 means off-line)
				;     3   |			- LPIO	08H I/O error
				;      21 |			- LPX		06H unused
				;        0|			- LPTO	01H time-out error
				;----------------------------------------------------------------------------;
				PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1
				
				;----------------------------------------------------------------------------;
				; Port 3BE printer control register   (Parallel Printer Port)
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 20 - 1


				; 84218421
				; 765	    |			- LCX		unused
				;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK
				;     3   |			- LCDR	1 = printer reads output,  (pin 17)
				;      2  |			- LCINI	0 = initialize printer,  (pin 16)
				;       1 |			- LCLF	1 = auto line feed,  (pin 14)
				;        0|			- LCOUT	1 = output data to printer,  (pin 1)
				;----------------------------------------------------------------------------;
				PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1
				
				;----------------------------------------------------------------------------;
				; Port 3FB - Line Control Register - LCR (read/write)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- DLAB	1 = baud rate divisor (DLAB)
				;  6      |			- LCBK	0 = turn break off, 1 = force spacing break state
				;   5     |			- LCPD	0 = parity disabled, 1 = enabled
				;    4    |			- LCEPS	0 = odd parity, 1 = even (EPS)
				;     3   |			- LCPEN	0 = no parity, 1 = parity (PEN)
				;      2  |			- LCSB	0 = 1 stop bit, 1 = 1.5 or 2
				;       10|			- LCWLS	word length select bits
				;----------------------------------------------------------------------------;
				COM_LCR RECORD	DLAB:1,LCBK:1,LCPD:1,LCEPS:1,LCPEN:1,LCSB:1,LCWLS:2
				
				;----------------------------------------------------------------------------;
				; Port 3FC - Modem Control Register - MCR (read/write)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |			- MCRX	unused
				;    4    |			- MCLB	0 = normal, 1 = loop back test
				;     3   |			- MCO2	OUT2
				;      2  |			- MCO1	OUT1
				;       1 |			- RTS		1 = activate RTS
				;        0|			- DTR		1 = activate DTR
				;----------------------------------------------------------------------------;
				COM_MCR RECORD	MCRX:3,MCLB:1,MCO2:1,MCO1:1,RTS:1,DTR:1
				
				;----------------------------------------------------------------------------;
				; Port 3FE - Modem Status Register - MSR (read only)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7	    |			- MLSD	1 = receive line signal detect
				;  6      |			- MRI		1 = ring indicator (RI)
				;   5     |			- MDSR	1 = DSR
				;    4    |			- MCTS	1 = CTS
				;     3   |			- DDCD	1 = DDCD Delta Data Carrier Detect (DCD changed)
				;      2  |			- DRI		1 = RI ring indicator changed
				;       1 |			- DDSR	1 = DDSR Delta DSR (DSR changed)
				;        0|			- DCTS	1 = DCTS Delta CTS (CTS changed)
				;----------------------------------------------------------------------------;
				COM_MSR RECORD	MLSD:1,MRI:1,MDSR:1,MCTS:1,DDCD:1,DRI:1,DDSR:1,DCTS:1
				
				;----------------------------------------------------------------------------;
				; Port 3FD/2FD - Line Status Register - LSR (read only)
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 21 - 1


				; 84218421
				; 7	    |			- LSX		unused
				;  6      |			- TSRE	1 = transmitter shift register empty (TSRE)
				;   5     |			- THRE	1 = transmitter holding register empty (THRE)
				;    4    |			- LBI		1 = break interrupt  (BI)
				;     3   |			- LFE		1 = framing error (FE)
				;      2  |			- LPE		1 = parity error (PE)
				;       1 |			- LOE		1 = overrun error (OE)
				;        0|			- LDR		1 = data ready
				;----------------------------------------------------------------------------;
				COM_LSR RECORD	LSX:1,TSRE:1,THRE:1,LBI:1,LFE:1,LPE:1,LOE:1,LDR:1
				
				;----------------------------------------------------------------------------;
				; HALT_BEEP Pattern - Short / Long
				;----------------------------------------------------------------------------;
				BEEP_SL RECORD	BEEP_S:4, BEEP_L: 4
				
				;----------------------------------------------------------------------------;
				; PIT Timer CW
				;----------------------------------------------------------------------------;
				; Control Word Counter 1 (port 43H) - System Timer:
				;  01 		- SC: Select Counter 1
				;    11		- RW: Read/Write 2xR/2xW
				;      010		- M:  Mode 2, Rate Gen
				;         0		- BCD: 0
				;----------------------------------------------------------------------------;
				PIT_CW RECORD	PCWSC:2, PCWRW:2, PCWM:3, PCWBCD:1
				
				;----------------------------------------------------------------------------;
				; DMA Mode Register
				;----------------------------------------------------------------------------;
				; 01 			; Mode 1 (Single)
				;   0 		; INC: address decrement
				;    1 		; Auto-initialization
				;     10 		; Operation: Read from memory
				;       00 		; Channel 0
				;----------------------------------------------------------------------------;
				DMA_MR RECORD	DMM:2=01B, DMINC:1, DMAI:1=1, DMOP:2, DMCH:2
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Command Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- DACK	1 = DACK sense active high, 0 = low
				;  6      |		- DREQ	1 = DREQ sense active high, 0 = low
				;   5     |		- DWS		1 = Extended write selection, 0 = Late write
				;    4    |		- DPRI	1 = Rotating priority, 0 = Fixed priority
				;     3   |		- DTIM	1 = Compressed timing, 0 = Normal timing
				;      2  |		- DDIS	1 = Controller disable, 0 = Controller enable
				;       1 |		- DHLD	1 = Channel 0 address hold enable, 0 = disable
				;        0|		- DM2M	1 = Memory-to-memory enable, 0 = disable
				;----------------------------------------------------------------------------;
				DMA_CR RECORD	DACK:1,DREQ:1,DWS:1,DPRI:1,DTIM:1,DDIS:1,DHLD:1,DM2M:1
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 22 - 1


				; 8237 DMA Status Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- CR3		1 = Channel 3 request
				;  6      |		- CR2		1 = Channel 2 request
				;   5     |		- CR1		1 = Channel 1 request
				;    4    |		- CR0		1 = Channel 0 request
				;     3   |		- TC3		1 = Channel 3 has reached TC
				;      2  |		- TC2		1 = Channel 2 has reached TC
				;       1 |		- TC1		1 = Channel 1 has reached TC
				;        0|		- TC0		1 = Channel 0 has reached TC
				;----------------------------------------------------------------------------;
				DMA_SR RECORD	CR3:1,CR2:1,CR1:1,CR0:1,TC3:1,TC2:1,TC1:1,TC0:1
				
				;----------------------------------------------------------------------------;
				; 8237 DMA Single Channel Mask Register
				;----------------------------------------------------------------------------;
				; 84218421
				;      2  |		- SMCLR	1 = Set mask bit, 0 = Clear mask bit
				;       10|		- SMCH	Select channel mask bit (0-3)
				;----------------------------------------------------------------------------;
				DMA_SMR RECORD	SMCLR:6,SMCH:2
				
				;----------------------------------------------------------------------------;
				; PIC Control Registers
				;----------------------------------------------------------------------------;
				; ICW1:
				;  000 		- A7-A5: unused on 8086 mode
				;     1 		- D4:   1 = ICW1 (and Port 0)
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition)
				;       0 		- ADI:  0 = Call Address Interval of 8
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3)
				;         1		- IC4:  1 = ICW4 Needed
				;----------------------------------------------------------------------------;
				ICW1	RECORD	D4:4=1, LTIM:1, ADI:1, SNGL:1=1, IC4:1=1
				
				; ICW2:
				;  00001 		- T7-T3: Interrupt Vector Address:
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15
				;       000 	- D2-D0: unused on 8086 mode
				;----------------------------------------------------------------------------;
				ICW2	RECORD	ICW2IVA:5, ICW2X:3=0
				
				; ICW4:
				;  000 		- D7-D5: unused
				;     0		- SFNM: 0 = Not Special Fully Nested Mode
				;      10		- BUF:  2 = Buffered Mode/Slave
				;        0		- AEOI: 0 = normal EOI
				;         1		- uPM:  1 = 8086 system
				;----------------------------------------------------------------------------;
				ICW4	RECORD	SFNM:4=0, ICWBUF:2, AEOI:1, uPM:1
				
				;----------------------------------------------------------------------------;
				; IMR / OCW1 Interrupt Mask
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 23 - 1


				; 84218421
				; 7 	    |		- IRQ7	1=interrupt masked (disabled), 0=not masked
				;  6      |		- IRQ6
				;   5     |		- IRQ5
				;    4    |		- IRQ4
				;     3   |		- IRQ3
				;      2  |		- IRQ2
				;       1 |		- IRQ1
				;        0|		- IRQ0
				;----------------------------------------------------------------------------;
				OCW1	RECORD	IRQ7:1,IRQ6:1,IRQ5:1,IRQ4:1,IRQ3:1,IRQ2:1,IRQ1:1,IRQ0:1
				
				;----------------------------------------------------------------------------;
				; OCW3
				;----------------------------------------------------------------------------;
				; 84218421
				; 765	    |		- O2CMD	Rotate and End of Interrupt Mode Command
				;					001b = Non-Specific EOI Command (default)
				;    43   |		- O2X		unused (00)
				;      210|		- O2L		Interrupt level acted upon
				;----------------------------------------------------------------------------;
				OCW2	RECORD	O2CMD:3=001b, O2X:2, O2L:3
				
				;----------------------------------------------------------------------------;
				; OCW3
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |		- O3D7	unused (0)
				;  65     |		- ESMM/SMM	Enable/special mask mode
				;    43   |		- O3D3	unused (01b)
				;      2  |		- O3P		1=Poll command, 0=No Poll command
				;       10|		- O3RR	Read Register command
				;----------------------------------------------------------------------------;
				OCW3	RECORD	O3D7:1, ESMM:2, O3D3:2=1, O3P:1, O3RR:2
				
				;----------------------------------------------------------------------------;
				; NMI Mask Register
				;----------------------------------------------------------------------------;
				; 84218421
				; x 	    |		- NMIE	1=enable NMI, 0=disable
				;  0000000|		- NMIX	unused (0)
				;----------------------------------------------------------------------------;
				NMI	RECORD	NMIE:1, NMIX:7
				
				;----------------------------------------------------------------------------;
				; V40 WCY1
				;----------------------------------------------------------------------------;
				; 84218421
				; 76 	    |		- IOW		I/O Wait States (0-3)
				;   54    |		- UMW		Upper Memory Block Wait States (0-3)
				;     32  |		- MMW		Middle Memory Block Wait States (0-3)
				;       10|		- LMW		Lower Memory Block Wait States (0-3)
				;----------------------------------------------------------------------------;
				V40_WCY1	RECORD	IOW:2, UMW:2, MMW:2, LMW:2
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 24 - 1


				;----------------------------------------------------------------------------;
				; 6845 Video - Port 3DA Status Register
				;----------------------------------------------------------------------------;
				; 84218421
				; 7654    |			- VSX		unused
				;     3   |			- VSVS	vertical retrace, RAM access OK (next 1.25ms)
				;      2  |			- VSPE	0 = light pen on, 1 = light pen off
				;       1 |			- VSPT	light pen trigger set
				;        0|			- VSHS	horiz or vert retrace, RAM access OK
				;----------------------------------------------------------------------------;
				VID_STAT	RECORD	VSX:4, VSVS:1, VSPE:1, VSPT:1, VSHS:1
				
				;----------------------------------------------------------------------------;
				; 6845 Video - 3D9 Color Select Register (Text)
				;----------------------------------------------------------------------------;
				; 84218421
				; 765     |			- CTX		unused
				;    4    |			- CTBI	background intensity
				;     3   |			- CTIN	select intensity setting
				;      210|			- CTBC	screen/border RGB
				;----------------------------------------------------------------------------;
				VID_CSTXT	RECORD	CTX:3=001B, CTBI:1=1B, CTIN:1, CTBC:3
				
				;----------------------------------------------------------------------------;
				; 6845 Video - 3D9 Color Select Register (Graphics)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76      |			- CGPH	palette high bits (unused)
				;   5     |			- CGPL	1 = palette 1, 0=palette 0
				;    4    |			- CGX		unused
				;     3   |			- CGIN	intensity
				;      210|			- CGBG	RGB for background
				;----------------------------------------------------------------------------;
				VID_CSGFX	RECORD	CGPH:2,CGPL:1=1B,CGX:1=1B,CGIN:1=1B,CGBG:3=111B
				
				;----------------------------------------------------------------------------;
				; 8255 PPI Channel Control Register Byte (Port 63h) Flags
				;----------------------------------------------------------------------------;
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT
				; 84218421
				; 1 	    |			- PPEN	1=Active
				;  00     |			- PPAM	Port A Mode: (0 default)
				;    1    |			- PPAD	Port A Dir: 0=output, 1=input (default)
				;     1   |			- PPCU	Port C (Upper): 0=output, 1=input (default)
				;      0  | 		- PPBM	Port B Mode: (0 default)
				;       0 | 		- PPBD	Port B Dir: 0=output (default), 1=input
				;        1|			- PPCL	Port C (Lower): 0=output, 1=input (default)
				;----------------------------------------------------------------------------;
				PPI_CR RECORD	PPEN:1=1,PPAM:2=00b,PPAD:1=1,PPCU:1=1,PPBM:1,PPBD:1,PPCL:1=1
				
				;----------------------------------------------------------------------------;
				; TD3300A Wait State Config Register (70H)
				;----------------------------------------------------------------------------;
				; 84218421
				; 76 	    |			- TDWSI	Slot I/O  (# of wait states 0-3)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 25 - 1


				;   54    |			- TDWSR	Slot RAM
				;     32  |			- TDWIO	Board I/O
				;       1 |			- TDWRA	Board RAM (# of wait states 0-1)
				;        0| 		- TDWRO	Board ROM
				;----------------------------------------------------------------------------;
				TD_WS_CR	RECORD	TDWSI:2,TDWSR:2,TDWIO:2,TDWRA:1,TDWRO:1
				
				;----------------------------------------------------------------------------;
				; TD3300A Speed (Turbo/Normal) Register (90H)
				;----------------------------------------------------------------------------;
				; 765432  |			- TDSX	Unused
				;       1 |			- TDSH	0=use hardware switch, 1=use bit 0 (TDSS)
				;        0| 		- TDSS	if TDSH=1: 1=4.77, 0=turbo
				;----------------------------------------------------------------------------;
							IF ARCH_TYPE EQ ARCH_TD3300
							IF TURBO_SWITCH EQ 1
				TD_TURBO_CR	RECORD	TDSX:6,TDSH:1=0,TDSS:1	; hardware switch enabled
							ELSE
				TD_TURBO_CR	RECORD	TDSX:6,TDSH:1=1,TDSS:1	; hardware switch disabled
							ENDIF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; TD3300A Upper Memory bank switch Register (E0H)
				;----------------------------------------------------------------------------;
				; 7654321 |			- TDUX	Unused
				;        0| 		- TDUB	map 2000h-F000h: 0=lower bank,1=upper bank
				;----------------------------------------------------------------------------;
				TD_UMA_CR	RECORD	TDUX:7,TDUB:1
				
							IF ARCH_TYPE EQ ARCH_UM82
				;----------------------------------------------------------------------------;
				; UM82C088 Status Register (E0H)
				;----------------------------------------------------------------------------;
				; 7       |			- U8SPD	Speed: 0=Low, 1=High
				;  6      | 		- U8X1	Unused
				;   54    |			- U8MEM	11b=256K, 01b=512K, x0b=640K
				;     32  |			- U8VID	Video adapter
				;       10|			- U8FLP	Floppy drives
				;----------------------------------------------------------------------------;
				UM82_ST	RECORD	U8SPD:1,U8X1:1,U8MEM:2,U8VID:2,U8FLP:2
				UM82_256K	EQU	UM82_ST <0,0,11b>		; 256K RAM
				UM82_512K	EQU	UM82_ST <0,0,01b>		; 512K RAM
				UM82_640K	EQU	UM82_ST <0,0,10b>		; 640K RAM
							ENDIF
				
							IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; FE2010A Configuration Register (Port 63h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 100	    |			- FSPD	CPU Clock Frequency and Wait States
				;         |						00x = 4.77, 1 IOWS, 0 MBWS *
				;         |						010 = 7.15, 4 IOWS, 2 MBWS
				;         |						011 = 7.15, 4 IOWS, 0 MBWS *
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 26 - 1


				;         |						100 = 9.54, 6 IOWS, 4 MBWS * default
				;         |						110 = 9.54, 6 IOWS, 2 MBWS
				;         |						101 = 9.54, 6 IOWS, 0 MBWS
				;         |						111 = 9.54, 6 IOWS, 0 MBWS
				;    0    |			- FME1	RAM size high bit
				;     0   |			- FLCK	1=lock bits 0-4 until next restart
				;      0  |			- FME2	RAM size low bit
				;         |						00  = 640K
				;         |						01  = 256K
				;         |						10  = 512K
				;       0 |			- FFPU	0=No FPU/NMI, 1=enable FPU/NMI
				;        1|			- FPAR	0=Parity check enabled, 1=Parity disabled
				;----------------------------------------------------------------------------;
								IF RAM_PARITY EQ 1
				FE_CR RECORD	FSPD:3=FE_CPU_CFG,FME1:1,FLCK:1,FME2:1,FFPU:1,FPAR:1
								ELSE
				FE_CR RECORD	FSPD:3=FE_CPU_CFG,FME1:1,FLCK:1,FME2:1,FFPU:1,FPAR:1=1
								ENDIF
				
				;----------------------------------------------------------------------------;
				; FE2010A: 8255 PPI Channel B (Port 61h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock
				;   5     |			- PBIO	0=enable i/o check, 1=disable
				;    4    |			- PBPC	0=enable memory parity check, 1=disable
				;     3   |			- PBTB	0=turbo, 1=normal*
				;      2  |			- PBSW	0=read SW1-4, 1=read SW-5-8*
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				; * Note: bits 2 and 3 are reversed on FE2010A motherboards
				;----------------------------------------------------------------------------;
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBTB:1,PBSW:1,PBSP:1,PBST:1
				
							ELSE					; NOT ARCH_FE2010
								IF ARCH_TYPE EQ ARCH_5150
				;----------------------------------------------------------------------------;
				; 5150: 8255 PPI Channel B (Port 61h) Flags
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock
				;   5     |			- PBIO	0=enable i/o check, 1=disable
				;    4    |			- PBPC	0=enable memory parity check, 1=disable
				;     3   |			- PBCM	0=cassette motor
				;      2  |			- PBSW	0=read SW1-4, 1=read SW-5-8 *turbo, 1=normal *
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				;----------------------------------------------------------------------------;
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBCM:1,PBSW:1,PBSP:1,PBST:1
				
								ELSE
				;----------------------------------------------------------------------------;
				; 5160/Standard: 8255 PPI Channel B (Port 61h) Flags
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 27 - 1


				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PBKB	0=enable keyboard read, 1=clear
				;  6      |			- PBKC	0=hold keyboard clock low, 1=enable clock
				;   5     |			- PBIO	0=enable i/o check, 1=disable
				;    4    |			- PBPC	0=enable memory parity check, 1=disable
				;     3   |			- PBSW	0=read SW1-4, 1=read SW-5-8
				;      2  |			- PBTB	0=turbo, 1=normal
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				;----------------------------------------------------------------------------;
				PPI_B_F RECORD	PBKB:1,PBKC:1,PBIO:1,PBPC:1,PBSW:1,PBTB:1,PBSP:1,PBST:1
								ENDIF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; 5160: 8255 PPI Channel C (Port 62h) Flags
				; * When PPI B PBSW = 0
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PCPE	0=no parity error, 1=memory parity error
				;  6      |			- PCIE	0=no i/o channel error, 1=i/o channel error
				;   5     |			- PCT2	timer 2 output / cassette data output
				;    4    |			- PCCI	cassette data input
				;     32  |			- PCMB	SW 3,4: MB RAM (00=64K, 01=128K, 10=192K, 11=256K)
				;       1 |			- PCFP	SW 2: 0=no FPU, 1=FPU installed
				;        0|			- PCFD	SW 1: Floppy drive (IPL) installed
				;----------------------------------------------------------------------------;
				PPI_C_X_L RECORD	PCPE:1,PCIE:1,PCT2:1,PCCI:1,PCMB:2,PCFP:1,PCFD:1
				
				;----------------------------------------------------------------------------;
				; 8255 PPI Channel C Flags (Port 62h)
				; * When PPI B PBSW = 1
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- PC2PE	0=no parity error, 1 r/w memory parity check error
				;  6      |			- PC2IE	0=no i/o channel error, 1 i/o channel check error
				;   5     |			- PC2T2	timer 2 output
				;    4    |			- PC2CI	cassette data input
				;     32  |			- PCDRV	SW 7,8: # of drives (00=1, 01=2, 10=3, 11=4)
				;       10|			- PCVID	SW 5,6: video Mode (00=ROM, 01=CG40, 10=CG80, 11=MDA)
				;----------------------------------------------------------------------------;
				PPI_C_X_H RECORD	PC2PE:1,PC2IE:1,PC2T2:1,PC2CI:1,PCDRV:2,PCVID:2
				
				;----------------------------------------------------------------------------;
				; Set up boot mode (PPI_B_BOOT) for PPI Channel B
				;----------------------------------------------------------------------------;
				
							IF ARCH_TYPE EQ ARCH_5150
				;----------------------------------------------------------------------------;
				; 5150 Power-On: KB hold low+disable, NMI on, spkr data off, cassette off
				;
				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW OR MASK PBST OR MASK PBCM
				
							ELSE				; ARCH_TYPE NE ARCH_5150
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 28 - 1


								IF BOOT_SPEED EQ BOOT_TURBO
				;----------------------------------------------------------------------------;
				; Turbo Std Power-On: KB hold low+disable, NMI on, spkr data off, turbo ON/OFF
				;
 = 00A9				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW OR MASK PBST
				
								ELSE			; BOOT_SPEED NE BOOT_TURBO
				;----------------------------------------------------------------------------;
				; Default Power-On: KB hold low+disable, NMI on, spkr data off, turbo OFF/ON
				;
				PPI_B_BOOT	= MASK PBKB OR MASK PBIO OR MASK PBSW OR MASK PBST OR MASK PBTB
				
								ENDIF			; /BOOT_SPEED EQ BOOT_TURBO
				
								IF TURBO_TYPE EQ TURBO_REV
				;----------------------------------------------------------------------------;
				; Turbo Reverse Power-On: Reverse PBTB
				;
 = 00AD				PPI_B_BOOT	= PPI_B_BOOT XOR MASK PBTB
								ENDIF			; /TURBO_TYPE EQ TURBO_REV
				
							ENDIF				; /ARCH_TYPE EQ ARCH_5150
				
								IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST)
				;----------------------------------------------------------------------------;
				; PCXT_MiSTer XTCTL register (port 8888h)
				;----------------------------------------------------------------------------;
				; 84218421
				; 7 	    |			- MCAT4	1=4MHz AT speed (high), 0=use MCSP speed
				;  6      |			- MCA0	a000h off
				;   5     |			- MCMD	MDA (Reserved)
				;    4    |			- MCAD	adlib off
				;     32  |			- MCSP	Speed: 01=5MHz, 10=8MHz, 11=10MHz
				;         |					(with MCAT4=0)
				;       1 |			- MCBR	border
				;        0|			- MCCP	composite
				;----------------------------------------------------------------------------;
				MC_XTCTL	RECORD	MCAT4:1,MCA0:1,MCMD:1,MCAD:1,MCSP:2,MCBR:1,MCCP:1
				
				MC_PORT	EQU	8888h			; PCXT_MiSTer control port
				MCSP_AT4	EQU	1b			; AT clock speed (with MCSP_4)
				MCSP_4	EQU	00b			; 4 MHz (MCSP)
				MCSP_5	EQU	01b			; 5 MHz (MCSP)
				MCSP_8	EQU	10b			; 8 MHz (MCSP)
				MCSP_10	EQU	11b			; 10 MHz (MCSP)
				MCSP_TOG	EQU	MC_XTCTL <MCSP_AT4,,,,MCSP_5>		; toggle high/low
				;MCSP_HIGH	EQU	MC_XTCTL <MCSP_AT4>			; AT speed bit
				MCSP_LOW	EQU	MC_XTCTL <,,,,MCSP_8 AND MCSP_10>	; clear 8/10 bit
				MCSP_SPD	EQU	MASK MCAT4 OR MASK MCSP			; speed bits
								ENDIF
				
				;============================================================================;
				;
				;	 			* * *   M A C R O S   * * *
				;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 29 - 1


				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; CALL NO STACK - a CALL without a writable stack
				;----------------------------------------------------------------------------;
				; Input:
				;	CALL_JMP = address for CALL
				;	JMP_SHORT = force SHORT jump
				;
				; - SS must be CS
				;----------------------------------------------------------------------------;
				CALL_NS 	MACRO CALL_JMP, JMP_SHORT
						LOCAL	CALL_JMP_PTR, CALL_JMP_RET	MOV	SP, OFFSET CALL_JMP_PTR
							IFNB <JMP_SHORT>
					JMP	SHORT CALL_JMP
							ELSE	JMP	CALL_JMP
							ENDIFCALL_JMP_PTR:
					DW	OFFSET CALL_JMP_RET
				CALL_JMP_RET:
						ENDM
				
				;----------------------------------------------------------------------------;
				; Introduce a short delay of ~15 clock cycles for I/O
				;----------------------------------------------------------------------------;
				; - Code size: 2 bytes
				; - 15 clock cycles
				; - Affects no registers or flags
				; - CPU Instruction cache is purged
				; - No stack required
				;----------------------------------------------------------------------------;
				IO_DELAY_SHORT	MACRO
						LOCAL _DONE			IF ARCH_TYPE NE ARCH_EMU
					JMP	SHORT _DONE
				_DONE:
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Variable delay ~ CX * 15 clock cycles
				;----------------------------------------------------------------------------;
				; Input: CX delay in 15 clock cycle increments
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY	MACRO
						LOCAL _DONE_DONE:
					LOOP	_DONE					; long delay for I/O
						ENDM
				
				;----------------------------------------------------------------------------;
				; Long delay ~1.18m clock cycles (roughly 1/4 second on 4.77MHz)
				;----------------------------------------------------------------------------;
				; Output: CX = 0
				;----------------------------------------------------------------------------;
				IO_DELAY_LONG	MACRO
							IF ARCH_TYPE NE ARCH_EMU
					XOR	CX, CX 				; delay 65535 LOOPs	IO_DELAY
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 30 - 1


							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Get an equipment flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from EQUIP_FLAGS RECORD
				;	SET_BDA = if defined, saves CX and sets DS = BDA
				;		otherwise assumes DS = BDA and clobbers CX
				; Output: AX = flag value
				;
				; Note: flags must not cross byte boundary (which they don't)
				;----------------------------------------------------------------------------;
				GET_EFLAG	MACRO	FLAG, SET_BDA
						LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM			IFNB <SET_BDA>
					PUSH	CX					; save CX	PUSH	DS	MOV	CX, 
				SEG _BDA			; DS = BDA
					MOV	DS, CX			ENDIF
				;----------------------------------------------------------------------------;; Shift if flag is in
				 high byte to low for byte operations;			IF FLAG LT 8		; is in low 
				byte?
				FLAG_MASK	= MASK FLAG
				FLAG_BIT	= FLAG AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte
							ELSE				; is in high byteFLAG_MASK	= HIGH MASK 
				FLAG
				FLAG_BIT	= (FLAG - 8) AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte
							ENDIF
					MOV	AL, BYTE PTR FLAG_MEM
					AND	AX, FLAG_MASK			; clear AH
				;----------------------------------------------------------------------------;; Determine optimal 
				number of shifts based on bit position and shift; right or left depending on fewest.;		
					IF CPU_TYPE	EQ CPU_V20
								IF FLAG_BIT GT 4
					ROL	AL, 8-FLAG_BIT			; shift value into position
								ELSE	ROR	AL, FLAG_BIT			; shift value into p
				osition
								ENDIF			ELSE				IF FLAG_BIT 
				GT 4
					MOV	CL, 8-FLAG_BIT			; CL = bit(s) position of record
					ROL	AL, CL				; shift value into position				
				ELSE	MOV	CL, FLAG_BIT			; CL = bit(s) position of record
					ROR	AL, CL				; shift value into position				
				ENDIF			ENDIF			IFNB <SET_BDA>
					POP	DS	POP	CX			ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Set an equipment flag
				;----------------------------------------------------------------------------;
				; Input: 
				;	AL = flag value (clobbered)
				;	FLAG = field name from EQUIP_FLAGS RECORD
				;	SET_BDA = if defined, saves CL and set DS = BDA 
				;		otherwise *requires* DS = BDA and CL clobbered
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 31 - 1


				; Output: none
				;----------------------------------------------------------------------------;
				SET_EFLAG	MACRO	FLAG, SET_BDA
							IFNB	<SET_BDA>
					PUSH	CX	PUSH	DS	MOV	CX, SEG _BDA			; DS = BDA
					MOV	DS, CX			ENDIF
							IF FLAG LT 8		; is in low byte?
				FLAG_MASK	= MASK FLAG
				FLAG_BIT	= FLAG AND 111B
				FLAG_MEM	= EQUIP_FLAGS[0]			; low BDA flags byte
							ELSE				; is in high byteFLAG_MASK	= HIGH MASK 
				FLAG
				FLAG_BIT	= (FLAG - 8) AND 0111B
				FLAG_MEM	= EQUIP_FLAGS[1]			; high BDA flags byte
							ENDIF
					AND	AL, MASK FLAG SHR FLAG		; isolate flag's bit width
				;----------------------------------------------------------------------------;; Determine optimal 
				number of shifts based on bit position and shift; right or left depending on fewest.;		
					IF CPU_TYPE	EQ CPU_V20
								IF FLAG_BIT GT 4
					ROR	AL, 8-FLAG_BIT			; shift value into position
								ELSE	ROL	AL, FLAG_BIT			; shift value into p
				osition
								ENDIF			ELSE				IF FLAG_BIT 
				GT 4
					MOV	CL, 8-FLAG_BIT			; CL = bit(s) position of record
					ROR	AL, CL				; shift value into position				
				ELSE	MOV	CL, FLAG_BIT			; CL = bit(s) position of record
					ROL	AL, CL				; shift value into position				
				ENDIF			ENDIF
					AND	BYTE PTR FLAG_MEM, NOT FLAG_MASK	; clear existing bits(s)
					OR	BYTE PTR FLAG_MEM, AL			; set new bit(s)
							IFNB <SET_BDA>
					POP	DS	POP	CX			ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Test a single BDA equipment flag
				;----------------------------------------------------------------------------;
				; Input: FLAG = field name from EQUIP_FLAGS RECORD
				; Output: ZF if 0, NZ if 1
				;
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				TEST_EFLAG	MACRO	FLAG
							IF FLAG LT 8
					TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FLAG
							ELSE	TEST	BYTE PTR EQUIP_FLAGS[1], HIGH MASK FLAG
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Set a single GLaBIOS flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from GB_FLAGS RECORD
				;	FLAG_CLR = if set, zeros flags first
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 32 - 1


				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				SET_GFLAG	MACRO	FLAG, FLAG_CLR
							IFNB	<FLAG_CLR>
					AND	GB_FLAGS, MASK FLAG		; clear existing flag(s)
							ENDIF	OR	GB_FLAGS, MASK FLAG		; set flag(s)
						ENDM
				
				;----------------------------------------------------------------------------;
				; Test a single GLaBIOS flag
				;----------------------------------------------------------------------------;
				; Input:
				;	FLAG = field name from GB_FLAGS RECORD
				; Output: ZF if 0, NZ if 1
				;
				; Requires: DS = BDA
				;----------------------------------------------------------------------------;
				TEST_GFLAG	MACRO	FLAG
					TEST	GB_FLAGS, MASK FLAG
						ENDM
				
				;----------------------------------------------------------------------------;
				; Shortcut to write a null-terminated string to console
				;----------------------------------------------------------------------------;
				; Input:
				;	SZ = string to print
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes)
				;----------------------------------------------------------------------------;
				PRINT_SZ	MACRO	SZ, SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	SI					; save SI		ENDIF		IFDI
				FI <SZ>,<SI>			; if SZ is not SI
					MOV	SI, OFFSET SZ
						ENDIF	CALL	OUT_SZ
						IFNB	<SAVE_REGS>
					POP	SI		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Same as above but print CRLF at the end
				;----------------------------------------------------------------------------;
				; Input:
				;	SZ = string to print
				;	SAVE_REGS = define (anything) to preserve SI (cost of 2 bytes)
				;
				; If called as PRINTLN_SZ SI, will use SI (effectively an alias to 
				;	'CALL OUTLN_SZ')
				;----------------------------------------------------------------------------;
				PRINTLN_SZ	MACRO	SZ, SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	SI					; save SI		ENDIF		IFDI
				FI <SZ>,<SI>			; if SZ is not SI
					MOV	SI, OFFSET SZ
						ENDIF	CALL	OUTLN_SZ
						IFNB	<SAVE_REGS>
					POP	SI		ENDIF		ENDM
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 33 - 1


				
				;----------------------------------------------------------------------------;
				; Set text attribute for a block of chars starting at current cursor
				;----------------------------------------------------------------------------;
				; This is a more efficient way to set text colors so any normal way to write
				; to console may be used.
				;
				; Example usage:
				;   SET_SZ_ATTR 0EH, 10			; set attribute to 0EH for next 10 chars
				;
				; Code size:
				; 	16 bytes if registers NOT saved
				;	22 bytes if registers saved
				; 	-3 bytes if ATTR is BL
				;----------------------------------------------------------------------------;
				SET_SZ_ATTR	MACRO	ATTR, LN, SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	AX	PUSH	BX	PUSH	CX		ENDIF ; IFNB	MOV	AX, DBW <9, 
				VID_SP>	; AH = write char w/attr, AL = space		IFDIFI <ATTR>,<BL>	; if ATTR is not BL
					MOV	BX, LOW ATTR		; BH = video page 0, BL = attribute
						ENDIF	; IFDIFI	MOV	CX, LN			; CX = repeat times
					INT	10H		IFNB	<SAVE_REGS>
					POP	CX	POP	BX	POP	AX		ENDIF	; IFNB		ENDM
				
				;----------------------------------------------------------------------------;
				; POST column UI
				;----------------------------------------------------------------------------;
				POST_COL_1	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF		IFNB
					<ZERO_BH>
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute
						ELSE	MOV	BL, LOW INNER_ATTR		; BL = attribute
						ENDIF	MOV	SI, OFFSET LBL_STR
					CALL	POST_START_COL_1
						IFNB	<SAVE_REGS>
					POP	BX		ENDIF
						ENDM
				
				POST_COL_2	MACRO LBL_STR, INNER_ATTR, SAVE_REGS, ZERO_BH
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF		IFNB
					<ZERO_BH>
					MOV	BX, LOW INNER_ATTR		; BH = 0, BL = attribute
						ELSE	MOV	BL, LOW INNER_ATTR		; BL = attribute
						ENDIF	MOV	SI, OFFSET LBL_STR
					CALL	POST_START_COL_2
						IFNB	<SAVE_REGS>
					POP	BX		ENDIF		ENDM
				
				POST_COL_END	MACRO	SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF	CALL	POST
				_END_COL
						IFNB	<SAVE_REGS>
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 34 - 1


					POP	BX		ENDIF		ENDM
				
				POST_COL_END_NL	MACRO SAVE_REGS
						IFNB	<SAVE_REGS>
					PUSH	BX					; save BX		ENDIF	CALL	POST
				_END_COL_NL
						IFNB	<SAVE_REGS>
					POP	BX		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Beepin' MACROs
				;----------------------------------------------------------------------------;
				; Beep on Man
				;----------------------------------------------------------------------------;
				BEEP_ON MACRO 	TONE, NO_SAVE_REGS
						IFNB	<TONE>
					MOV	AX, TONE 			; custom tone
						ELSE	MOV	AX, BEEP_DEFAULT
						ENDIF		IFB	<NO_SAVE_REGS>
					PUSH	BX		ENDIF	CALL	BEEP_ON_P
						IFB	<NO_SAVE_REGS>
					POP	BX		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Beep off Man
				;----------------------------------------------------------------------------;
				BEEP_OFF MACRO
					CALL	BEEP_OFF_P
						ENDM
				
				;----------------------------------------------------------------------------;
				; BYTES_HERE - Track and enforce code/byte space around fixed ORGs
				;----------------------------------------------------------------------------;
				; Use to mark a block of free code space. Outputs assembly warning if code 
				; overruns NEXT_LBL, and defines LBL so space can be viewed. Values displayed
				; in generated listing.
				;
				; WTF: why can't MASM %OUT display the value of NEXT_LBL-$?
				; WTF2: how to fix for MASM 6.1?
				;
					.LALL
				BYTES_HERE	MACRO	NEXT_LBL
						LOCAL LBL
				BYTES_HERE_&NEXT_LBL = NEXT_LBL-$
						IFDEF BYTES_HERE_&NEXT_LBL
						IF2		IF BYTES_HERE_&NEXT_LBL LT 0
						.ERR2	%OUT WARNING: Out of space at: NEXT_LBL (&BYTES_HERE_&NEXT_LBL)
						ENDIF		ENDIF		ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; V20 MACROs
				;
				; Polyfill for V20 instruction mnemonics not supported by MASM.
				; Not comprehensive of course.
				;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 35 - 1


				TEST1_BP	MACRO IMM4
					DB	0FH, 19H, 0C5H, IMM4	; TEST1 BP, IMM4
						ENDM
				
				SET1_BP	MACRO IMM4
					DB	0FH, 1DH, 0C5H, IMM4	; SET1  BP, IMM4
						ENDM
				
				NOT1_BP	MACRO IMM4
					DB	0FH, 1FH, 0C5H, IMM4	; NOT1  BP, IMM4
						ENDM
				
				CLR1_BP	MACRO IMM4
					DB	0FH, 1BH, 0C5H, IMM4	; CLR1  BP, IMM4
						ENDM
				
				;----------------------------------------------------------------------------;
				; Operations on POST test FLAGs
				;----------------------------------------------------------------------------;
				POST_FLAG_TEST MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					TEST1_BP  FLAG				; V20 only: TEST1 BP, FLAG
							ELSE	TEST	BP, MASK FLAG			; Is flag set?
							ENDIF		ENDM
				
				POST_FLAG_SET MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					SET1_BP   FLAG				; V20 only: SET1 BP, FLAG
							ELSE	OR	BP, MASK FLAG			; Set flag
							ENDIF		ENDM
				
				POST_FLAG_FLIP MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					NOT1_BP   FLAG				; V20 only: NOT1 BP, FLAG
							ELSE	XOR	BP, MASK FLAG			; Invert flag
							ENDIF		ENDM
				
				POST_FLAG_CLR MACRO	FLAG
							IF CPU_TYPE	EQ CPU_V20
					CLR1_BP   FLAG				; V20 only: CLR1 BP, FLAG
							ELSE	AND	BP, NOT MASK FLAG			; Clear flag
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Jump if Warm Boot
				;----------------------------------------------------------------------------;
				JWB		MACRO	LBL
							IF WARM_ENABLE EQ 1	TEST	BP, BP				; is warm bo
				ot?	JS	LBL					; jump if so
							ENDIF		ENDM
				
				;----------------------------------------------------------------------------;
				; Jump if not Warm Boot
				;----------------------------------------------------------------------------;
				JNWB		MACRO	LBL
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 36 - 1


					TEST	BP, BP				; is warm boot?	JNS	LBL			
						; jump if not
						ENDM
				
				;----------------------------------------------------------------------------;
				; Wait for a video retrace to enable RAM access for CGA 80 column
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = 03DAH (CGA Status Port)
				;
				; Output:
				;	Display is in retrace
				;	CLI: Interrupts OFF - must be re-enabled after read/write operation
				;
				; https://forum.vcfed.org/index.php?threads/cant-get-rid-of-cga-snow.39319/post-478150
				;
				; Due to timing requirements this must be unrolled - CALL/PROC too slow
				;----------------------------------------------------------------------------;
				CGA_WAIT_SYNC	MACRO
						LOCAL	WAIT_NO_HSYNC, WAIT_BLANK, IN_VSYNC			IF CGA_SNOW_REMOVE E
				Q 1	CLI						; [2] disable interrupts			
				ENDIFWAIT_NO_HSYNC:
							IF CGA_SNOW_REMOVE GT 1	STI						
				; [2] enable interrupts	NOP						; [3] handle pending
				 interrupts	CLI						; [2] disable interrupts		
					ENDIF	IN	AL, DX				; [12] read CGA status register		
					IF CGA_SNOW_REMOVE GT 1	TEST	AL, MASK VSVS			; [5] in vertical?	
				JNZ	IN_VSYNC				; [4/16] if so, do CGA I/O
							ENDIF	SHR	AL, 1					; [2] in horizontal?
					JC	WAIT_NO_HSYNC			; [4/16] if so, wait for next one
				WAIT_BLANK:
					IN	AL, DX				; [12] read CGA status register			
				IF CGA_SNOW_REMOVE GT 1	TEST	AL, MASK VSVS OR MASK VSHS	; [5] in either sync?	JZ	
				WAIT_BLANK				; [4/16]
							ELSE	SHR	AL, 1					; [2] in horizontal 
				sync?	JNC	WAIT_BLANK				; [4/16]
							ENDIFIN_VSYNC:
						ENDM
				
				;----------------------------------------------------------------------------;
				; IRET with all current flags
				;----------------------------------------------------------------------------;
				IRET_F	MACRO
					RETF	2		ENDM
				
				;============================================================================;
				;
				;	   		   * * *   S E G M E N T S   * * * 
				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
				; 0000:0000 - 8086 INT vector table
				;----------------------------------------------------------------------------;
				_IVT		SEGMENT AT 0H
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 37 - 1


						ORG 8H*4
				_INT_08H 		DW	?			; INT 08H - Timer
				_INT_08H_SEG	DW	?			; INT 08H - Timer Segment
				_INT_09H 		DW	?			; INT 09H - Keyboard
				_INT_09H_SEG	DW	?			; INT 09H - Keyboard Segment
						ORG 10H*4
				_INT_10H		DW	?			; INT 10H - BIOS video services
				_INT_10H_SEG	DW	?			; INT 10H - Segment
						ORG 18H*4
				_INT_18H		DW	?			; INT 18H - ROM BASIC
				_INT_18H_SEG	DW	?			; INT 18H - Segment
						ORG 1DH*4
				_INT_1DH		DD	?			; INT 1DH - CRTC param table
				_INT_1EH		DD	?			; INT 1EH - Floppy param table
				_INT_1FH		DD	?			; INT 1FH - User Font bitmap table
				_IVT 		ENDS
				
				;----------------------------------------------------------------------------;
				; 0000:0400 - BIOS data area (BDA) - Zero Page Segment Addressing
				; (Only used during early POST)
				;----------------------------------------------------------------------------;
				_BDA_ABS	SEGMENT AT 0H
						ORG 440H
				FD_MOTOR_CT_ABS	DB	?			; 40:40H FD motor shutoff counter
						ORG 46BH
				INT_LAST_ABS	DB	?			; 40:6BH POST / Interrupt happened?
						ORG 472H
				WARM_FLAG_ABS	DW	?			; 40:72H Warm Boot Flag
				_BDA_ABS	ENDS
				
				;----------------------------------------------------------------------------;
				; 0030:0000 - Bootstrap temporary stack
				;----------------------------------------------------------------------------;
				_BOOT_STACK	SEGMENT AT 30H
				_TEMP_MEM		LABEL BYTE 			; use for scratch space during POST
							DW 	80H DUP(?)
				STACK_TOP		DW 	?
				_BOOT_STACK	ENDS
				
				;----------------------------------------------------------------------------;
				; 0040:0000 - BIOS data area (BDA)
				;----------------------------------------------------------------------------;
				; https://stanislavs.org/helppc/bios_data_area.html
				; http://www.bioscentral.com/misc/bda.htm
				;----------------------------------------------------------------------------;
				_BDA		SEGMENT AT 40H
				COM_ADDR		DW	4 DUP(?) 		; 00H  COM1-4 base addresses
				LPT_ADDR_B		EQU	08H			;	 Low byte hack to force short sign-e
				xtend encoding
				LPT_ADDR		DW	3 DUP(?) 		; 08H  LPT1-3 base addresses
							DW	? 			; 0EH  Extended BIOS data area segment
				EQUIP_FLAGS		EQFLAGS <> 			; 10H  Equipment Flags
				GB_FLAGS		GFLAGS <> 			; 12H  Custom Equipment Flags
				MEM_SZ_KB		DW	?			; 13H  Memory size in kilobytes
				MEM_SZ_PC		DW	?			; 15H  Memory size SW2 on 5150
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 38 - 1


				KB_FLAGS		LABEL WORD
				KB_FLAGS1		KBFLAGS1 <>			; 17H  Keyboard flags 1
				KB_FLAGS2		KBFLAGS2 <>			; 18H  Keyboard flags 2
				KB_ALT 		DB	?			; 19H  Alt-keypad entry byte
				KB_BUF_HD		DW	?			; 1AH  Keyboard buffer head ptr
				KB_BUF_TL		DW	?			; 1CH  Keyboard buffer tail ptr
				KB_BUF		DW	16 DUP(?) 		; 1EH  Keyboard buffer
				KB_BUF_END		LABEL WORD			; 3EH  End of keyboard buffer (not inclusive
				)
				KB_BUF_END_B	EQU	3EH			;	 Low byte to force short sign-extend encodin
				g
				FD_CAL_ST		FDC_SF <>			; 3EH  Floppy drive recalibration status
											;	0 = drive not calibrated
											;	high bit = working interrupt flag
				FD_MOTOR_ST		FDC_MF <>			; 3FH  FD motor status
											;	high bit = write operation
				FD_MOTOR_CT		DB	?			; 40H  FD motor shutoff counter (decr. by IN
				T 8)
				FD_LAST_OP		DB	?			; 41H  BIOS Status of last FD operation
				FDC_LAST_ST		FDC_CSB <>			; 42H  FDC command status last result (7 byt
				es)
				VID_MODE		DB	?			; 49H  Current video mode
				VID_COLS		DW	?			; 4AH  Number of screen columns
				VID_BUF_SZ		DW	?			; 4CH  Size of video regen buffer in bytes
				VID_SEG		DW	? 			; 4EH  Starting address in video regen buffer (offse
				t) 
				VID_CURS_POS	DW	8 DUP(?)		; 50H-5FH Cursor position of pages 1-8, high=row, lo
				w=col
				VID_CURS_TYPE	DW	? 			; 60H  Starting (Top), Ending (bottom) scan line for
				 cursor
				VID_PAGE		DB	? 			; 62H  Active display page number
				VID_PORT		DW	?			; 63H  Base port address for active 6845 CRT
				 controller
				VID_MODE_REG	DB	?			; 65H  6845 CRT mode control register value (port 3x
				8H)
				VID_COLOR		DB	? 			; 66H  CGA current color palette setting (po
				rt 3D9H)
				L_VID_BDA		EQU	$-VID_MODE		;      Length in bytes of video data in BDA
				CAS_TIME_CNT	LABEL WORD			; 67H  5150 Cassette: Counter
				ROM_INIT_SS		DW	?			; 67H   or Temp location for SS:SP during bl
				ock move
				CAS_CRC		LABEL	WORD			; 69H  5150 Cassette: CRC
				ROM_INIT_SP 	DW	? 			; 69H	  or Option ROM init
				CAS_PREV		LABEL	BYTE			; 6BH  5150 Cassette: Previous byte
				;FE2010_CONF_REG	LABEL BYTE			; 6BH  FE2010A Config Reg (Standard 63H)
				INT_LAST		DB	? 			; 6BH  Reserved for POST / Interrupt happene
				d?
				TIMER			TIMER_C <>			; 6CH-70H Timer Counter
				BIOS_BREAK		DB	?			; 71H  BIOS break flag (high bit means ctrl-
				break)
				WARM_FLAG		DW	?			; 72H  Warm Boot Flag (1234H to bypass RAM t
				est)
				HD_LAST_ST		DB 	? 			; 74H  Status of last hard disk operation (s
				ee INT 13,1)
				HD_COUNT		DB 	? 			; 75H  Number of hard disks attached
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 39 - 1


				HD_CTRL		DB 	? 			; 76H  XT fixed disk drive control byte
				HD_PORT		DB 	? 			; 77H  Port offset to current fixed disk adapter
				LPT_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding
				LPT_TIME		DB	4 DUP(?) 		; 78H  Time-out value for LPT1-4 (in # of 64
				K LOOPs)
				COM_TIME_B		EQU	$-_BDA		;	 Low byte hack to force short sign-extend en
				coding
				COM_TIME		DB	4 DUP(?) 		; 7CH  Time-out value for COM1-4
				KB_BUF_ST		DW	?			; 80H  Keyboard buffer start
							DW	?			; 82H  Keyboard buffer end
						ORG	08BH
							DB	?			; 8BH  Last diskette data rate selected
						ORG	08FH
				FD_MODE		FDC_MODE <>			; 8FH  FDC Drive Mode (see FDC_MODE)
				FD_MEDIA_ST		FDC_STATE 4 DUP(<>)	; 90H-93H  Drive 0-3 media state
				FD0_TRACK		DB	?			; 94H  Drive 0 current track
				FD1_TRACK		DB	?			; 95H  Drive 1 current track
				KB_FLAGS3		DB	?			; 96H  Keyboard mode/type (Enhanced)
				KB_FLAGS4		DB	?			; 97H  Keyboard LED flags (Enhanced)
						ORG	0A0H
				RTC_WAIT		DB	?			; A0H  RTC wait function flag
						ORG	0ACH				; ACH-B3H "Reserved" (can be used?)
						ORG	0B0H
				RTC_DATA		DW	?			; B0H  GLaTICK address and RTC type
						ORG	0E8H				; E8H-EFH "Reserved" (can be used?)
				CURSOR_DEFAULT	DW	?			; E8H  Power on cursor bottom:top scan line (for Tur
				bo)
				VID_MEM_SEG		DW	?			; EAH	 Video mem segment (MDA = B000, CGA 
				= B800)
				FE2010_CONF_REG	DB	?			; ECH  FE2010A Config Reg (63H) (alternate)
				;			DB	2 DUP(?)
				_BDA		ENDS
				
				;----------------------------------------------------------------------------;
				; 0050:0000 - BIOS/DOS Data Area
				;----------------------------------------------------------------------------;
				_DOS_DAT	SEGMENT AT 50H
				PTRSCN_ST		DB 	?			; 00H  Print screen status
							DB	3  DUP(?)		; 01H  Used by BASIC
							DB	?			; 04H  Floppy drive flag for single
											;	  drive systems (0=A,1=B)
							DB	10 DUP(?)		; 05H  POST work area
							DB	19 DUP(?)		
				DOS_FD_PARAM	DB	14 DUP(?)		; 22H  Floppy drive parameter table
					 		DB	4  DUP(?)		; 30H  Mode command
				_DOS_DAT	ENDS
				
				;----------------------------------------------------------------------------;
				; 0070:0000 - "Kernel" of PC-DOS
				;----------------------------------------------------------------------------;
				_DOS_SEG	SEGMENT AT 70H
				_DOS_SEG	ENDS
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 40 - 1


				; 0000:7C00 - IPL / MBR / Boot Block Segment
				;----------------------------------------------------------------------------;
 0000				_IPL_SEG	SEGMENT AT 0H
						ORG	07C00H
 0020 0000			IPL_TOP		DB	510 DUP(?)		; MBR code then MBR magic number
 0022 0000			IPL_ID		DW	?			; 0AA55H if valid MBR
 0024 0000			_IPL_SEG	ENDS
 0026 0000			
				;----------------------------------------------------------------------------;
 0040 0000			; B000:0000 - MDA Video Memory
 0042 0000			;----------------------------------------------------------------------------;
				_MDA_MEM	SEGMENT AT 0B000H
 0060 0000						DB	1000H DUP(?)
 0062 0000			MDA_MEM	LABEL BYTE				; 4KiB (1000H) total MDA memory
				_MDA_MEM	ENDS
 0074 00000000			
 0078 00000000			;----------------------------------------------------------------------------;
 007C 00000000			; B800:0000 - CGA Video Memory
 0080				;----------------------------------------------------------------------------;
				_CGA_MEM	SEGMENT AT 0B800H
				CGA_MEM_TOP		DB	0800H DUP(?)	; page 1 of CGA 40 column
				CGA_MEM_40		DB	0800H DUP(?)	; page 1 of CGA 80 column
				CGA_MEM_80		DB	3000H DUP(?)
				CGA_MEM_GFX	LABEL BYTE
 0000				CGA_MEM	LABEL BYTE				; End of CGA memory offset
				CGA_MEM_SZ		= CGA_MEM - CGA_MEM_TOP	; 16 KiB (4000H) total CGA memory
 0440 00			CGA_MEM_FLD 	= CGA_MEM_SZ / 2		;  8 KiB (2000H) CGA memory field
				_CGA_MEM	ENDS
 046B 00			
				;----------------------------------------------------------------------------;
 0472 0000			; C000:0000 - Video Option ROM segment
 0474				;----------------------------------------------------------------------------;
				_VID_BIOS	SEGMENT AT 0C000H
				VID_MN		DW	?			; magic number (0AA55H)
				VID_BIOS_SZ		DB	?			; length in 512 byte blocks
				VID_VEC		DW	?			; FAR call to ROM init routine
 0000				_VID_BIOS	ENDS
 0000				
 0000  0080 [			;----------------------------------------------------------------------------;
        0000
       ]
 0100 0000			; C800:0000 - Start of Storage/Other Option ROM segment
 0102				;----------------------------------------------------------------------------;
				_OPT_ROM	SEGMENT AT 0C800H
				_OPT_ROM	ENDS
				
				;----------------------------------------------------------------------------;
				; F000:E000 - System BIOS ROM segment map
				;----------------------------------------------------------------------------;
				_BIOS		SEGMENT AT 0F000H
 0000						ORG	0E000H
 0000  0004 [			_BIOS_TOP	LABEL WORD
        0000
       ]
 = 0008						ORG	0E05BH
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 41 - 1


 0008  0003 [			_BOOT		LABEL WORD				; BIOS boot offset
        0000
       ]
 000E  0000					ORG	0FFF0H
 0010 000C			_POWER_ON	LABEL WORD				; CPU power-on jump address
GLABIOS.asm(2139): warning A4013: instructions and initialized data not supported in AT segments
 0012 00			_BIOS		ENDS
 0013 0000			
 0015 0000			;----------------------------------------------------------------------------;
 0017				; F600:0000 - ROM BASIC segment
 0017 00			;----------------------------------------------------------------------------;
 0018 00			_BASIC	SEGMENT AT 0F600H
 0019 00			BASIC_TOP	LABEL WORD 				; ROM BASIC load offset
 001A 0000			_BASIC	ENDS
 001C 0000			
 001E  0010 [			
        0000
       ]
 003E				;============================================================================;
 = 003E				;
 003E 00			;				* * *   C O D E   * * * 
				;
				;============================================================================;
 003F 00			
				;----------------------------------------------------------------------------;
 0040 00			; Main BIOS ROM begins
 0041 00			;----------------------------------------------------------------------------;
 0042 00 00 00 00 00 00		; Note: Memory space from F000:0000 - F000:E05A is available, though a
       00
 0049 00			; BIOS identifier string is typically at or near the top of this segment
 004A 0000			;----------------------------------------------------------------------------;
 004C 0000					ASSUME	DS:BIOS, SS:BIOS, CS:BIOS, ES:BIOS
 004E 0000			BIOS    	SEGMENT
 0050  0008 [			
        0000
       ]
 0060 0000			;----------------------------------------------------------------------------;
 0062 00			; F000:FFF0: 8086 power-on reset vector
 0063 0000			;----------------------------------------------------------------------------;
 0065 00			; The x86 CPU begins code excution at hard-coded address F000:FFF0.
 0066 00			; This is that address. Welcome to the party!
 0067 = 001E			;----------------------------------------------------------------------------;
 0067						ORG	0FFF0H
 0067 0000			POWER_ON	PROC	FAR
 0069					JMP	FAR	PTR _BOOT 		; always jump to power on routine
 0069 0000			
 006B						ORG	0FFF5H
				REL_DATE 	DB	VER_DATE		; Release date
 006B 00			
 006C 0000 0000 00				ORG	0FFFEH
 0071 00			ISA_TYPE	DB	ARCH_ID		; Architecture model
 0072 0000			
 0074 00					ORG	0FFFFH		; BIOS ROM checksum byte 
 0075 00					DB	?			; (computed at build time)
 0076 00			POWER_ON	ENDP
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 42 - 1


 0077 00			
 0078 = 0078			;----------------------------------------------------------------------------;
 0078  0004 [			; F000:E000: Top of BIOS ROM 8K segment
        00
       ]
 007C = 007C			;----------------------------------------------------------------------------;
 007C  0004 [					ORG	0E000H
        00
       ]
 0080 0000			BIOS_TOP	PROC	NEAR
 0082  0000			
				TOP_BANNER	DB	LF
 008B  00					DB	VER_NAME, ' [', HEART, '] '
								IF RANDOM_TAGLINE EQ 1
 008F 00					DB	0				; null terminate BANNER string
 0090  0004 [							ENDIF
        00
       ]
 0094 00			TAG0		DB	"The hero we need but don't deserve"
 0095 00							IF RANDOM_TAGLINE EQ 1
 0096 00					DB	0				; null terminate TAG0 string
 0097 00							ENDIF
				COPYRIGHT	DB	CR, LF
 00A0 00					DB	'(C) ', COPY_YEAR, ' '
						DB	'640KB Released under GPLv3'
						DB	LF
 00B0 0000					DB	0
				
 00E8 0000			BIOS_TOP 	ENDP
 00EA 0000			
 00EC 00			;
				; 0 BYTES HERE
 00ED				;
				BYTES_HERE	BOOT
				
							ASSUME CS:BIOS, DS:NOTHING, ES:NOTHING, SS:NOTHING
				;----------------------------------------------------------------------------;
 0000				; F000:E05B: Beginning of boot execution
 0000 00			;----------------------------------------------------------------------------;
 0001  0003 [			; Loosely follow these specs for BIOS POST operations:
        00
       ]
 0004  00			;
				; http://minuszerodegrees.net/5160/post/5160%20-%20POST%20-%20Detailed%20breakdown.htm
 0005  000A [			; http://minuszerodegrees.net/5150/post/5150%20-%20POST%20-%20Detailed%20breakdown.htm
        00
       ]
 000F  0013 [			; https://stanislavs.org/helppc/cold_boot.html
        00
       ]
 0022  000E [			; http://philipstorr.id.au/pcbook/book1/post.htm
        00
       ]
 0030  0004 [			;----------------------------------------------------------------------------;
        00
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 43 - 1


       ]
 0034						ORG	0E05BH
				BOOT 	PROC NEAR
					CLI 					; disable CPU interrupts
					CLD					; clear direction flag
				
 0000				;----------------------------------------------------------------------------;
 0000				; Early Chipset Setup for non-standard builds
				;----------------------------------------------------------------------------;
							IF ARCH_TYPE EQ ARCH_EHB
					JMP	INIT_V40			; Setup V40 for EMM
				INIT_V40_RET:
 0000							ENDIF
				
 7C00  01FE [			;----------------------------------------------------------------------------;
        00
       ]
 7DFE 0000			; POST Hardware/System Tests
 7E00				;----------------------------------------------------------------------------;
				
				POST_CPU_TEST:
				;----------------------------------------------------------------------------;
				; [1] Test and clear all CPU Registers
 0000				;----------------------------------------------------------------------------;
 0000  1000 [			; Check and set all registers to 0.
        00
       ]
 1000				;
 1000				; On Failure: 2 short and 1 long beep
				;----------------------------------------------------------------------------;
							ASSUME DS:_BDA_ABS, ES:_IVT
					MOV	AX, RAM_TEST		; use the standard test pattern
				CPU_REG_TEST:
 0000					MOV	BX, AX			; the game of telephone
 0000  0800 [				MOV	DS, BX			;  pass a
        00
       ]
 0800  0800 [				MOV	CX, DS			;  known value
        00
       ]
 1000  3000 [				MOV	ES, CX			;  through all
        00
       ]
 4000					MOV	SI, ES			;  registers and
 4000					MOV	SS, SI			;  ensure the
 = 4000					MOV	DI, SS			;  same value
 = 2000					MOV	BP, DI			;  makes it all
 4000					MOV	SP, BP			;  the way
					MOV	DX, SP			;  to the end
					TEST	DX, NOT RAM_TEST		; expected result?
					MOV	BL, BEEP_SL <2,1>		; on Failure: 2 short and 1 long beep
					JNZ	HALT_ERROR
 0000					XOR	AX, AX 			; otherwise repeat with AX = 0
 0000 0000				TEST	DX, DX			; if zero it was second pass
 0002 00				JNZ	CPU_REG_TEST		; Loop again to zero all registers
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 44 - 1


 0003 0000			CPU_REG_PASS:
 0005				
				;----------------------------------------------------------------------------;
				; Disable non-maskable interrupts (NMIs)
				;----------------------------------------------------------------------------;
				DISABLE_NMI:
 0000					OUT	NMI_R0, AL			; write AL = 0 to NMI register port
 0000				
				;----------------------------------------------------------------------------;
				; [1B] A brief test of flags and CPU instructions
				;----------------------------------------------------------------------------;
				; On Failure: 3 short and 1 long beep
 0000				;----------------------------------------------------------------------------;
							IF POST_TEST_INST EQ 1
 E000				CPU_INST_TEST:
					MOV	AL, 1				; start off with some complicated math
 E05B					MOV	BL, BEEP_SL <3,1>		; on error, 3 short and 1 long beep
					ADD	AL, AL			; can little Billy add 1 + 1?
 FFF0					JS	HALT_ERROR			; ...better not be negative
 FFF0					JZ	HALT_ERROR			; ...better not be zero
					JP	HALT_ERROR			; ...better have an odd number of 1 bits
					JC	HALT_ERROR			; ...better not be a borrower
					SUB	AL, 3				; 2 - 3 = ?
					JNS	HALT_ERROR			; ...better be negative
 0000					JNP	HALT_ERROR			; ...better have even bits
 0000					JNC	HALT_ERROR			; ...better have had to borrow
 0000					CBW					; zero extend the result
					INC	AX				; roll it back over to 0
					JNZ	HALT_ERROR			; AX = 0
				CPU_TEST_PASS:
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [3] Set Zero Page Register for DMA channels 0 and 1
				;----------------------------------------------------------------------------;
					OUT	DMA_P_C1, AL 		; AL = high nibble of segment for DMA (0)
				
				;----------------------------------------------------------------------------;
				; [4] Disable MDA/CGA adapters (for now)
				;----------------------------------------------------------------------------;
				INIT_VIDEO:
					MOV	DX, CGA_CTRL		; DX = 03D8H
 0000					OUT	DX, AL 			; send Disable to CGA Mode Select Register
					INC	AX 				; clear MDA control, disable video signal
					MOV	DL, LOW MDA_CTRL		; DX = 03B8H
					OUT	DX, AL 			; send to MDA CRT Control Port
				
				;----------------------------------------------------------------------------;
				; Set up POST flags in BP
				;----------------------------------------------------------------------------;
					CMP	WARM_FLAG_ABS, WARM_BOOT
 FFF0					JNZ	POST_FLAG_DONE
 FFF0  EA ---- E05B R			MOV	BP, MASK WARM		; clear and set POST warm boot flag
				POST_FLAG_DONE:
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 45 - 1


 FFF5 30 35 2F 31 39 2F					IF RANDOM_TAGLINE EQ 1
       32 33
				;----------------------------------------------------------------------------;
				; Read PIT for seed of random pithy tagline
 FFFE FE			;----------------------------------------------------------------------------;
					DEC	AX				; Counter 0, Latch (00b)
					OUT	PIT_CTRL, AL		; write command to CTC
 FFFF  00				IN	AL, PIT_CH0			; read low byte of Counter 0 latch
 00010000				SHR	AL, 1				; low bit is always 0
					AND	AL, MASK GRND		; use only last two bits
					OR	BP, AX			; save to low bits of BP
							ENDIF
				
				;----------------------------------------------------------------------------;
 E000				; Setup SS = CS
				;----------------------------------------------------------------------------;
 E000 0A			; Set up temporary stack to point at ROM to enable CALL_NS MACRO
 E001  47 4C 61 42 49 4F	;----------------------------------------------------------------------------;
       53 20 5B 03 5D 20
					MOV	DX, CS 			; DX = 0F000h (BIOS segment)
 E00D  00				MOV	SS, DX			; SS = temp boot stack in CS
				
 E00E 54 68 65 20 68 65		;----------------------------------------------------------------------------;
       72 6F 20 77 65 20
       6E 65 65 64 20 62
       75 74 20 64 6F 6E
       27 74 20 64 65 73
       65 72 76 65
				; [5] Setup 8255 PPI to normal operating state
 E030  00			;----------------------------------------------------------------------------;
				; Normal operation: Mode 0, Ports A,C (U and L) as INPUT, Port B as OUTPUT
 E031 0D 0A			;----------------------------------------------------------------------------;
 E033  28 43 29 20 32 30	RESET_PPI:
       32 32 2D 32 33 20
 E03F  36 34 30 4B 42 20				IF ARCH_TYPE EQ ARCH_FE2010
       52 65 6C 65 61 73
       65 64 20 75 6E 64
       65 72 20 47 50 4C
       76 33
 E059  0A				MOV	AL, FE_CR <>		; set speed 9.54MHz, Memory 640KB, no FPU
 E05A  00						ELSE
					MOV	AL, PPI_CR <>		; set 8255 A,C to INPUT, B to OUTPUT
 E05B							ENDIF
					OUT	PPI_CW, AL 			; send to PPI control port (63H)
				
				;----------------------------------------------------------------------------;
				; Set up PPI port B
				;
 E05B			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_BOOT = BOOT-$
			     1	
			     1			IFDEF BYTES_HERE_BOOT
			     1			IF2
			     1			IF BYTES_HERE_BOOT LT 0
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 46 - 1


			     1			.ERR2
			     1		%OUT WARNING: Out of space at: BOOT (BYTES_HERE_BOOT)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					MOV	AL, PPI_B_BOOT		; KB hold low+disable, NMI on, spkr off
					OUT	PPI_B, AL			; send to 8255 Port B
				
							IF ARCH_TYPE EQ ARCH_TD3300
					IN	AL, TD_TURBO		; read current register
								IF BOOT_SPEED EQ BOOT_TURBO
					MOV	AL, TD_TURBO_CR<,,0>	; switch to turbo
								ELSE
					MOV	AL, TD_TURBO_CR<,,1>	; switch to normal (4.77)
								ENDIF
					OUT	TD_TURBO, AL		; write new register
							ENDIF			; ENDIF ARCH_TD3300
				
 E05B				;			IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST)
 E05B  FA			;----------------------------------------------------------------------------;
 E05C  FC			; Set up Turbo mode for PCXT_MiSTer
				;
				;	MOV	DX, MC_PORT			; DX = XTCTL port
				;	IN	AL, DX			; read current speed
				;	AND	AL, NOT MCSP_SPD		; clear speed bits
				;			IF BOOT_SPEED EQ BOOT_TURBO
				;	OR	AL, MC_XTCTL <MCSP_AT4>	; boot to AT 4MHz
				;			ELSE
				;	OR	AL, MC_XTCTL <,,,,MCSP_5> ; boot to XT 5MHz
				;			ENDIF
				;	OUT	DX, AL			; set new speed
				;	MOV	DX, SS			; restore DX
				;			ENDIF			; ARCH_MIST
				
 E05D							IF POST_TEST_CHK_ROM EQ 1
				;----------------------------------------------------------------------------;
				; [8] Checksum (8 bit) the main ROM to ensure it is not corrupt
				;----------------------------------------------------------------------------;
				; Input: AH = 0, CX = 0, DX = 0F000h
				; On Failure: 2 long and 2 short beeps
				;----------------------------------------------------------------------------;
					JWB	CHECKSUM_OK			; skip on warm boot
				CHECKSUM_ROM:
 E05D  B8 95A5						ASSUME DS:BIOS
 E060					MOV	DS, DX			; DS to 0F000h BIOS segment
 E060  8B D8				MOV	SI, OFFSET BIOS_TOP 	; offset to top of BIOS ROM
 E062  8E DB				MOV	CH, HIGH (8 * 1024 / 2)	; checksum 8KB (in 2 byte words)
 E064  8C D9			CHECKSUM:
 E066  8E C1				LODSW 				; next two bytes into AL and AH
 E068  8C C6				ADD	DL, AL			; DL = accumulator for sum
 E06A  8E D6				ADD	DL, AH			; ZF if sum is 0
 E06C  8C D7				LOOP	CHECKSUM 			; loop through entire ROM
 E06E  8B EF				MOV	BL, BEEP_SL <2,2>		; on failure, 2 short and 2 long beeps
 E070  8B E5				JNZ	HALT_ERROR			; if sum not 0, fail
 E072  8B D4			CHECKSUM_OK:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 47 - 1


 E074  F7 C2 6A5A					ENDIF
 E078  B3 21			
 E07A  74 03 E9 008F		;----------------------------------------------------------------------------;
 E07F  33 C0			; [9] Disable the 8237 DMA controller chip.
 E081  85 D2			;----------------------------------------------------------------------------;
 E083  75 DB			INIT_DMA1:
 E085					MOV	AL, MASK DDIS		; Set Controller Disable bit
					OUT	DMA_CMD, AL 		; write to DMA Command Register
				
							IF POST_TEST_PIT_1 EQ 1
				;----------------------------------------------------------------------------;
 E085				; [10] Test Channel #1 on 8253 timer chip.
 E085  E6 A0			;----------------------------------------------------------------------------;
				; Channel #1 on 8253 timer chip. Channel #1 is used in RAM refresh process.  
				; If the test fails, beep failure code
				;
				; Test that all data lines are working by reading counter and checking 
				; that all bits from counter go both high and low.
				;----------------------------------------------------------------------------;
				; Use 16-bit mode to test low three address lines using high byte of counter.
 E087				; This avoids a situation where the read counter code is a binary multiple
 E087  B0 01			; of the counter causing a bit to not be observed as changing.
 E089  B3 31			;
 E08B  02 C0			; Control Word Counter 1 (port 43H) - System Timer:
 E08D  78 7F			;  01 		- SC: Select Counter 1
 E08F  74 7D			;    11		- RW: Read/Write 2xR/2xW
 E091  7A 7B			;      010		- M:  Mode 2, Rate Gen
 E093  72 79			;         0		- BCD: 0
 E095  2C 03			;
 E097  79 75			; Output: Success SI and DI = 0, Failure 3 short, 2 long beeps
 E099  7B 73			;----------------------------------------------------------------------------;
 E09B  73 71				MOV	AL, PIT_CW <1, 11B, 2>	; Control Word: Counter 1
 E09D  98									;   Format: R/W low/high byte: 11b
 E09E  40									;   Mode: 2 Rate Gen, BCD: 0
 E09F  75 6D				OUT	PIT_CTRL, AL		; set Counter mode
 E0A1					MOV	DX, LOW PIT_CH1		; DX = PIT channel 1
					OUT	DX, AL			; set low byte (any value)
					MOV	SI, 0FFH SHL 3		; flag bits 10-3 for 1 check
					MOV	DI, NOT 0FFH SHL 3	; flag bits 10-3 for 0 check
					OUT	DX, AL			; set high byte (any value)
				INIT_PIT1_TEST:
 E0A1  E6 83				TEST	DI, DI			; have all bits flipped to 0?
					JNZ	INIT_PIT1_TEST_READ	; if not, keep reading PIT
					INC	SI				; have all bits flipped to 1?
					JZ	INIT_PIT1_TEST_DONE	; if so, success
					DEC	SI				; if not, undo INC and keep reading PIT
 E0A3				INIT_PIT1_TEST_READ:
 E0A3  BA 03D8				MOV	AL, PIT_CW <1,0>		; latch Counter 1 command
 E0A6  EE				OUT	PIT_CTRL, AL		; write command to CTC
 E0A7  40				IN	AL, DX			; read timer LSB
 E0A8  B2 B8				MOV	AH, AL			; save LSB
 E0AA  EE				IN	AL, DX			; read timer MSB
					AND	DI, AX			; clear all lines read as 0
					OR	SI, AX			; set all lines read as 1
					LOOP	INIT_PIT1_TEST		; loop until timeout
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 48 - 1


					MOV	BL, BEEP_SL <3,2>		; beep pattern (3 short, 2 long)
 E0AB  81 3E 0472 R 1234	HALT_ERROR:
 E0B1  75 03				JMP	SHORT HALT_BEEP_1		; NEAR jump for POST errors
 E0B3  BD 8000						ELSE
 E0B6					JMP	SHORT INIT_PIT1_TEST_DONE ; jump over the NEAR jump
				HALT_ERROR:
					JMP	SHORT HALT_BEEP_1		; must still be here if PIT test is off
					IO_DELAY_SHORT			; I/O delay
							ENDIF
				
 E0B6  48			INIT_PIT1_TEST_DONE:
 E0B7  E6 43			
 E0B9  E4 40			;----------------------------------------------------------------------------;
 E0BB  D0 E8			; [9B] 8253 PIT Programmable Interval Timer Initialization Channel 1
 E0BD  24 03			;----------------------------------------------------------------------------;
 E0BF  0B E8			; Counter 1 - DRAM Refresh
				;----------------------------------------------------------------------------;
				INIT_PIT1:
					MOV	AL, PIT_CW <1, 01B, 2>	; Control Word: Select Counter(SC): 1
										;   Format(RW): 01b (R/W byte LE)
										;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary)
					OUT	PIT_CTRL, AL		; set Counter mode
				
 E0C1  8C CA			;----------------------------------------------------------------------------;
 E0C3  8E D2			; [12] Reset, Clear and test DMA Offset and Block Size Registers
				;----------------------------------------------------------------------------;
				; - Master Reset of DMA controller
				; - Test 8237 DMA Address/Count Register channels 0-3
				;----------------------------------------------------------------------------;
					OUT	DMA_RESET, AL 		; Master Reset (send any value of AL)
				
 E0C5							IF POST_TEST_DMA EQ 1
					MOV	BH, 8				; test 8 ports
					XOR	DX, DX			; starting at port 00H
					CALL_NS  PORT_TEST		; ZF and CX = 0 if pass, NZ if failed
 E0C5  B0 99				MOV	BL, BEEP_SL <4,2>		; beep pattern (4 short, 2 long)
					JNZ	HALT_ERROR
 E0C7  E6 63			DMA_PASS:
					OUT	DMA_RESET, AL 		; master reset of DMA again
							ENDIF			; POST_TEST_DMA
				
							IF DRAM_REFRESH EQ 1
 E0C9  B0 AD			;----------------------------------------------------------------------------;
 E0CB  E6 61			; [13] Set Counter DMA Channel 0 for memory refresh
				;----------------------------------------------------------------------------;
				; https://www.reenigne.org/blog/how-to-get-away-with-disabling-dram-refresh/
				;----------------------------------------------------------------------------;
					MOV	AL, 0FFH			; Memory refresh counter (16-bit) is 0FFFFH
					OUT	DMA_0_C, AL			; write low order bits
					NOP					; very short I/O delay
					OUT	DMA_0_C, AL			; write high order bits
				
				;----------------------------------------------------------------------------;
				; [13] Set Mode DMA Channel 0
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 49 - 1


				; 01 			; Mode 1 (Single)
				;   0 		; INC: address decrement
				;    1 		; Auto-initialization
				;     10 		; type: Read from memory (2)
				;       00 		; Channel 0
				;----------------------------------------------------------------------------;
					MOV	AL, DMA_MR <1,0,1,2,0>
					OUT	DMA_MODE, AL		; write to DMA Mode Register
				
				;----------------------------------------------------------------------------;
				; [13B] 8253 Timer set channel #1 for DMA/DRAM refresh
				;----------------------------------------------------------------------------;
					MOV	AL, 18 			; divisor: 1.19318 MHz / 18 = 66,287.7 Hz
					OUT	PIT_CH1, AL			; refresh DRAM every 2ms
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [13C] Enable DMA and clear mask register on Channels 0-3
				;----------------------------------------------------------------------------;
					MOV	AL, DMA_CR <>		; Set Controller Enable bit
					OUT	DMA_CMD, AL 		; write to DMA Command Register
					MOV	CL, 3				; Set mode on Channels 1-3 for [13D]
										;  (and I/O delay between OUTs)
					OUT	DMA_MASK, AL		; clear mask (enable) on all channels
			     1				IF WARM_ENABLE EQ 1
 E0CD  85 ED		     1		TEST	BP, BP				; is warm boot?
 E0CF  78 12		     1		JS	CHECKSUM_OK					; jump if so
			     1				ENDIF
 E0D1				
				;----------------------------------------------------------------------------;
 E0D1  8E DA			; [13D] Set default Mode for DMA Channels 1-3
 E0D3  BE E000 R		;----------------------------------------------------------------------------;
 E0D6  B5 10			; 01 			; Mode 1 (Single)
 E0D8				;   0 		; INC: address decrement
 E0D8  AD			;    0 		; No Auto-initialization
 E0D9  02 D0			;     00 		; type: Verify (0)
 E0DB  02 D4			;       xx 		; Channels 1-3
 E0DD  E2 F9			;
 E0DF  B3 22			; Input: CL = 3 (from [13C]), CH = 0 (from CALL_NS in [12])
 E0E1  75 2B			;----------------------------------------------------------------------------;
 E0E3					MOV	AL, DMA_MR <1,0,0,0,1>	; start with channel 1
				DMA_SETUP_CH:
					OUT	DMA_MODE, AL		; write to DMA Mode Register
					INC	AX				; next channel
					LOOP	DMA_SETUP_CH		; (delay 13-17 clocks between OUTs)
				
 E0E3				;----------------------------------------------------------------------------;
 E0E3  B0 04			; [14] Detect and enable expansion chassis / extension card
 E0E5  E6 08			;----------------------------------------------------------------------------;
				; http://minuszerodegrees.net/5161/doco/5161_documentation.htm
				;
				; http://minuszerodegrees.net/5161/misc/5161_not_supported.htm
				; "note: research revealed that the substituted code is not required; the circuit 
				; diagram of the extender card shows that the card is automatically enabled 
				; at application of power."
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 50 - 1


				;
				; Based on the above, it would appear this is not necessary at all.
				;----------------------------------------------------------------------------;
				;INIT_EXP_CHASSIS:
				;	MOV	DX, 213H			; PC Expansion Chassis
				;	IN	AL, DX
				;	INC	AL 				; Is 213H == 0FFH?
				;	JZ	NO_EXP_CHASSIS 		; if so, no expansion chassis
				;	MOV	AL, 1 			; otherwise, send 1 to enable
				;	OUT	DX, AL
				;NO_EXP_CHASSIS:
				
				;----------------------------------------------------------------------------;
				; [15] Test and zero first 16KB of RAM
				;----------------------------------------------------------------------------;
				; This is necessary to utilize the BIOS Data Area and a usable stack
				;
 E0E7  B0 74			; Parity bits are in an indeterminate state on power up so parity check must
				; be disabled until memory is written once.
				;
 E0E9  E6 43			; On failure: 
 E0EB  BA 0041			; - Read/Write Error: 1 short, 3 long beeps
 E0EE  EE			; - Parity Error: 1 short, 4 long beeps
 E0EF  BE 07F8			;
 E0F2  BF F807			; Input: CX = 0 from [13D]
 E0F5  EE			;----------------------------------------------------------------------------;
 E0F6							ASSUME DS:_BDA_ABS, ES:_IVT
 E0F6  85 FF			BASE_RAM_TEST:
 E0F8  75 04				IN	AL, PPI_B 				; AL = PB0 flags
 E0FA  46				OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags
 E0FB  74 13				OUT	PPI_B, AL
 E0FD  4E				XCHG	AX, CX				; AX = 0 = MEM_CHECK pattern and
 E0FE					MOV	DS, AX				; DS and ES = IVT segment 0000
 E0FE  B0 40				MOV	SI, OFFSET WARM_FLAG_ABS	; SI = warm boot flag offset
 E100  E6 43				MOV	DX, [SI]				; save warm boot flag
 E102  EC				CALL_NS  MEM_CHECK			; clear memory and parity bits
 E103  8A E0				JNZ	BASE_RAM_ERROR
 E105  EC				IN	AL, PPI_B				; read PPI channel B
 E106  23 F8				OR	AL, MASK PBPC 			; clear MB RAM parity flag only
 E108  0B F0				OUT	PPI_B, AL
 E10A  E2 EA				AND	AL, NOT MASK PBPC 		; enable MB RAM parity for test
 E10C  B3 32				OUT	PPI_B, AL
 E10E					CALL_NS  MEM_ADDR_TEST			; test address lines
 E10E  EB 55				JZ	BASE_RAM_ZERO			; continue if no errors
				BASE_RAM_ERROR:
					MOV	BL, BEEP_SL <1,3>			; on failure, 1 short and 3 long beeps
				HALT_BEEP_1:
					JMP	HALT_BEEP				; NEAR jump to HALT BEEP PROC
				BASE_RAM_ZERO:
					MOV	AX, RAM_TEST			; test pattern
					CALL_NS  MEM_CHECK			; write and verify test pattern
 E110					JNZ	BASE_RAM_ERROR			; ZF and AX = 0 if okay
					CALL_NS  MEM_CHECK			; write and verify zeros
					JNZ	BASE_RAM_ERROR
					XCHG	[SI], DX				; restore warm boot flag, DX = 0
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 51 - 1


					INC	AX					; AL = 1
					MOV	FD_MOTOR_CT_ABS, AL 		; set motor to turn off on next tick
							IF RAM_PARITY EQ 1
 E110					IN	AL, PPI_C				; read PPI channel C
 E110  B0 54				AND	AL, MASK PCPE			; check MB RAM parity flag
					JZ	BASE_RAM_TEST_DONE		; either set?
					MOV	BL, BEEP_SL <1,4>			; Halt with 1 short beep, 4 long beeps
 E112  E6 43				JMP	SHORT HALT_BEEP_1
				BASE_RAM_TEST_DONE:
					IN	AL, PPI_B
					OR	AL, MASK PBIO OR MASK PBPC	; disable RAM parity and I/O ch. flags
					OUT	PPI_B, AL
							ENDIF				; END RAM_PARITY EQ 1
				
				;----------------------------------------------------------------------------;
 E114  E6 0D			;
				; YAY! It's now okay to use the first 16KB of RAM: 0000:0000-0000:1FFF
				;
 E116  B7 08			;----------------------------------------------------------------------------;
 E118  33 D2			
				;----------------------------------------------------------------------------;
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E11A  BC E120 R	     1		MOV	SP, OFFSET ??0001
			     1				IFNB <>
			     1		JMP	SHORT PORT_TEST
			     1				ELSE
 E11D  E9 06CE		     1		JMP	PORT_TEST
			     1				ENDIF
 E120			     1	??0001:
 E120  E122 R		     1		DW	OFFSET ??0002
 E122			     1	??0002:
 E122  B3 42			; [18] Setup BOOT R/W stack memory segment
 E124  75 E8			;----------------------------------------------------------------------------;
 E126							ASSUME SS:_BOOT_STACK
 E126  E6 0D				MOV	AX, SEG STACK_TOP 		; SP to temp boot stack 0030:0100
					MOV	SS, AX
					MOV	SP, OFFSET STACK_TOP
				
				;----------------------------------------------------------------------------;
				; [19] 8259A PIC Interrupt controller Initialization
				;----------------------------------------------------------------------------;
				; PIC chip Initialization as follows:
				;
				; ICW1:
				;     1 		- D4:   1 = ICW1 (and Port 0)
				;      0 		- LTIM: 0 = Edge Triggered Mode (low to high TTL transition)
				;       0 		- ADI:  0 = Call Address Interval of 8
				;        1 		- SNGL: 1 = Single mode (no cascading PICs or ICW3)
				;         1		- IC4:  1 = ICW4 Needed
				;----------------------------------------------------------------------------;
				; ICW2:
				;  00001 		- T7-T3: Interrupt Vector Address:
				;				INT = INT | 8 -> IRQ 0-7 to CPU INT 8-15
				;       000 	- D2-D0: unused on 8086 mode
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 52 - 1


				; ICW4:
				;     0		- SFNM: 0 = Not Special Fully Nested Mode
				;      10		- BUF:  2 = Buffered Mode/Slave
				;        0		- AEOI: 0 = normal EOI
				;         1		- uPM:  1 = 8086 system
				;----------------------------------------------------------------------------;
					MOV	DL, LOW INT_P0		; DX = PIC Port 0
					MOV	AL, ICW1 <1,0,0,1,1>	; ICW1 - Port 0
					OUT	DX, AL
					INC	DX				; DX = PIC Port 1
					MOV	AL, ICW2 <1>		; ICW2 - Port 1
					OUT	DX, AL
					MOV	BH, 1				; short delay and test 1 port for [22]
					MOV	AL, ICW4 <0,2,0,1>	; ICW4 - Port 1
					OUT	DX, AL
 E128  B0 00			
 E12A  E6 08						IF POST_TEST_PIC_REG EQ 1
 E12C  B1 03			;----------------------------------------------------------------------------;
				; [22] 8259A PIC Test
 E12E  E6 0A			;----------------------------------------------------------------------------;
				; - Read and write registers (IMR) and verify result
				;----------------------------------------------------------------------------;
					CALL	PORT_TEST			; test of PIC IMR register
					MOV	BL, BEEP_SL <5,2>		; beep error 5 short, 2 long
					JZ	PIC_REG_PASS
				PIC_INT_FAIL:
					JMP	SHORT HALT_BEEP_1
				PIC_REG_PASS:
					DEC	DX				; DX = Port 1 (0021h)
							ELSE
					NOP
							ENDIF			; IF POST_TEST_PIC_REG EQ 1
 E130  B0 41			
 E132					MOV	AL, OCW1 <1,1,1,1,1,1,1,1> ; OCW1 - mask all interrupts (for now)
 E132  E6 0B				OUT	DX, AL			; write IMR to PIC
 E134  40			
 E135  E2 FB						IF POST_TEST_PIC_INT EQ 1
				;----------------------------------------------------------------------------;
				; - Set up test interrupt handler for all interrupts
				;
				PIC_INT_TEST:
					MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE)
					XOR	DI, DI			; DI = beginning to IVT
				PIC_VECT_TMP_LOOP:
					MOV	AX, OFFSET INT_IRQ	; offset for handler
					STOSW					; write to IVT
					MOV	AX, CS			; segment for hanlder (BIOS)
					STOSW					; write to IVT
					LOOP	PIC_VECT_TMP_LOOP
				
				;----------------------------------------------------------------------------;
				; - Mask all interrupts and ensure none are received
				; Input: AL = 0 (from MOV AX, CS)
				;
					MOV	DI, OFFSET INT_LAST_ABS
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 53 - 1


					MOV	[DI], AL			; clear last interrupt flag
					STI					; enable interrupts
					IO_DELAY				; wait for it...
					CLI
					INC	BX				; beep error 5 short, 3 long
					OR	[DI], AL			; did any interrupts happen?
				
							IF POST_TEST_PIC_REG EQ 1
					JNZ	PIC_INT_FAIL
							ELSE
					JZ	PIC_INT_PASS
					JMP	SHORT HALT_BEEP_1
							ENDIF			; IF POST_TEST_PIC_REG EQ 1
							ENDIF			; IF POST_TEST_PIC_INT EQ 1
				
					MOV	AL, NOT MASK IRQ0		; OCW1 - unmask timer
					OUT	DX, AL			; write IMR to PIC
				
				PIC_INT_PASS:
 E137				
 E137  E4 61			;----------------------------------------------------------------------------;
 E139  0C 30			; [23] Setup Channel #0 on 8253 timer chip.
 E13B  E6 61			;----------------------------------------------------------------------------;
 E13D  91			; Control Word Counter 0 (port 43H) - System Timer:
 E13E  8E D8			;  00 		- SC: Select Counter 0
 E140  BE 0472 R		;    11		- RW: Read/Write 2xR/2xW
 E143  8B 14			;      011		- M:  Mode 3, Square Wave
				;         0		- BCD: 0
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E145  BC E14B R	     1		MOV	SP, OFFSET ??0003
			     1				IFNB <>
			     1		JMP	SHORT MEM_CHECK
			     1				ELSE
 E148  E9 04BD		     1		JMP	MEM_CHECK
			     1				ENDIF
 E14B			     1	??0003:
 E14B  E14D R		     1		DW	OFFSET ??0004
 E14D			     1	??0004:
 E14D  75 14			;----------------------------------------------------------------------------;
 E14F  E4 61				MOV	AL, PIT_CW <0, 11B, 3>	; Control Word: Select Counter(SC): 1
 E151  0C 10									;   Format(RW): 11b (Read/Write 2xR/2xW)
 E153  E6 61									;   Mode(M): 2 (Rate Gen), BCD: 0 (Binary)
 E155  24 EF				OUT	PIT_CTRL, AL
 E157  E6 61				PUSH	CS				; I/O delay and set up for DS = CS below
				
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E159  BC E15F R	     1		MOV	SP, OFFSET ??0005
			     1				IFNB <>
			     1		JMP	SHORT MEM_ADDR_TEST
			     1				ELSE
 E15C  E9 047B		     1		JMP	MEM_ADDR_TEST
			     1				ENDIF
 E15F			     1	??0005:
 E15F  E161 R		     1		DW	OFFSET ??0006
 E161			     1	??0006:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 54 - 1


 E161  74 05			;----------------------------------------------------------------------------;
 E163				; This is what generates IRQ 0 (system timer).
 E163  B3 13			; Timer set channel #0 output to a square wave of approx. 18.2 Hz based on
 E165				;	f = 1,193,180 / 10000H = ~ 18.2Hz
 E165  E9 070C			; Reload counter to WORD (0) to port 40H
 E168				;
 E168  B8 95A5				XOR	AL, AL			; reload counter is 2^16 (0) ~ 18.2Hz
					OUT	PIT_CH0, AL	  		; send low byte
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E16B  BC E171 R	     1		MOV	SP, OFFSET ??0007
			     1				IFNB <>
			     1		JMP	SHORT MEM_CHECK
			     1				ELSE
 E16E  E9 0497		     1		JMP	MEM_CHECK
			     1				ENDIF
 E171			     1	??0007:
 E171  E173 R		     1		DW	OFFSET ??0008
 E173			     1	??0008:
 E173  75 EE				POP	DS				; I/O delay and set DS = CS
					OUT	PIT_CH0, AL 		; send high byte
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E175  BC E17B R	     1		MOV	SP, OFFSET ??0009
			     1				IFNB <>
			     1		JMP	SHORT MEM_CHECK
			     1				ELSE
 E178  E9 048D		     1		JMP	MEM_CHECK
			     1				ENDIF
 E17B			     1	??0009:
 E17B  E17D R		     1		DW	OFFSET ??000A
 E17D			     1	??000A:
 E17D  75 E4			
 E17F  87 14			;----------------------------------------------------------------------------;
 E181  40			; [25] Setup default BIOS interrupt vectors (00h - 01Eh)
 E182  A2 0440 R		;----------------------------------------------------------------------------;
				; All segments are set to BIOS (CS) segment by default.
				; INT 1Fh is skipped and left as 0000:0000.
				; Exceptions (such as ROM BASIC) are reset below.
				;----------------------------------------------------------------------------;
							ASSUME DS:BIOS, ES:_IVT
				INIT_SW_INT_VECTORS:
					MOV	AX, CS 			; AX to BIOS segment
					MOV	CL, 1FH			; 0 - 1EH BIOS vectors (LOW L_VECTOR_TABLE)
					XOR	DI, DI			; DI = beginning to IVT
					MOV	SI, OFFSET VECTOR_TABLE
				BIOS_INT_VECTORS_LOOP:
					MOVSW 				; copy vector offset to IVT
					STOSW 				; write BIOS/CS segment
					LOOP	BIOS_INT_VECTORS_LOOP	; loop and set CX = 0
				
							IF BASIC_ROM EQ 1
				;----------------------------------------------------------------------------;
				; Check for valid BASIC ROMs and set INT 18H vector if detected
				;----------------------------------------------------------------------------;
				; - Scan 4 x 8K ROMs starting at seg 0F600h.
				; - BASIC dectected if for all ROMs, all of the folowing are true:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 55 - 1


				; 	- first two bytes not option ROM (0AAFFh)
 E185  B8 ---- R		;	- first two bytes not the same as the previous ROM (this checks to
 E188  8E D0			;		 make sure are not all 0000 or FFFF)
 E18A  BC 0100 R		;	- 8K ROM block has a valid checksum at offset 1FFE
				;----------------------------------------------------------------------------;
							ASSUME DS:_BASIC
				INIT_ROM_BASIC_SEG:
					MOV	BX, SEG _BASIC 			; BX = BASIC SEG in ROM
					MOV	DX, BX				; DX = save first BASIC SEG
					MOV	DI, MAGIC_WORD			; start with a negative check result
					MOV	CL, 4					; checksum 4 x 8K ROMs
				CHECK_BASIC_ROM:
					MOV	DS, BX				; set DS to current segment
					MOV	AX, BASIC_TOP			; AX = first two bytes of ROM
					CMP	AX, MAGIC_WORD			; is an option ROM?
					JE	INIT_ROM_BASIC_DONE		; if so, not ROM BASIC
					XCHG	AX, DI				; save last ROM's header to DI
					CMP	AX, DI				; is same as last ROM?
					JE	INIT_ROM_BASIC_DONE		; if so, valid ROM not present
					MOV	AL, 8 * 1024 / 512 		; 8K ROM size (in 512B blocks)
					ADD	BH, HIGH (8 * 1024 SHR 4)	; BX = next BASIC 8K ROM segment
					CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, size AL
					LOOPZ	CHECK_BASIC_ROM			; loop 4 ROMs or checksum fail
					JNZ	INIT_ROM_BASIC_DONE		; if NZ, checksum failed
				
				;----------------------------------------------------------------------------;
				; BASIC ROM detected - set as INT 18h in IVT
				;
 E18D  B2 20				MOV	DI, OFFSET _INT_18H		; DI = BASIC offset in IVT
 E18F  B0 13				XCHG	AX, CX				; AX = vector offset 0000
 E191  EE				STOSW 					; write to IVT
 E192  42				XCHG	AX, DX 				; AX = BASIC SEG
 E193  B0 08				STOSW						; write to IVT
 E195  EE			INIT_ROM_BASIC_DONE:
 E196  B7 01						ENDIF
 E198  B0 09			
 E19A  EE			;----------------------------------------------------------------------------;
				; [18] Setup DS and ES to BDA segment
				;----------------------------------------------------------------------------;
							ASSUME DS:_BDA, ES:_BDA
					MOV	AX, SEG _BDA 			; DS and ES to BDA
					MOV	DS, AX
					MOV	ES, AX
				
 E19B  E8 0650			;----------------------------------------------------------------------------;
 E19E  B3 52			; Check CPU type
 E1A0  74 02			;----------------------------------------------------------------------------;
 E1A2				; If V20 is build target but V20 not detected - beep 1 long, 4 short
 E1A2  EB C1			;----------------------------------------------------------------------------;
 E1A4				CPU_IS_V20:
 E1A4  4A				MOV	AX, DBW <1,1>			; Attempt to pack bytes into nibbles
					DB	0D5H, 10H				; AAD	10H
					CMP	AL, 0BH				; result is 0Bh if V20, 11h if x86
											;   ZF = 1 if V20, ZF = 0 if 8088
					JNZ	CPU_TYPE_8088			; jump if not V20
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 56 - 1


 E1A5  B0 FF				SET_GFLAG	V20				; set V20 flag
 E1A7  EE						IF CPU_TYPE	EQ CPU_V20
					JMP	SHORT CPU_TYPE_DONE		; continue booting
				CPU_TYPE_8088:
					MOV	BL, BEEP_SL <4,1>			; Build is V20 but not detected
					JMP	SHORT HALT_BEEP_2			;  beep 4 short, 1 long
							ELSE
 E1A8				CPU_TYPE_8088:
 E1A8  B1 1F						ENDIF
 E1AA  33 FF			CPU_TYPE_DONE:
 E1AC				
 E1AC  B8 FF23 R		;----------------------------------------------------------------------------;
 E1AF  AB			; [14] Read DIP switch settings and init proper EQUIP_FLAGS
 E1B0  8C C8			;----------------------------------------------------------------------------;
 E1B2  AB			;
 E1B3  E2 F7			; https://sites.google.com/site/pcdosretro/biosdata
				; https://stanislavs.org/helppc/int_11.html
				;
				; 5150 Sense Switches:
				;  Port A - when Port B bit 7 = 1
				;     High| Low
 E1B5  BF 046B R		; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4)
 E1B8  88 05			; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA)
 E1BA  FB			;	    |00		; MB RAM (00=16KB, 01=32K, 10=48K, 11=64K)
				;	    |  0		; FPU installed ("Reserved")
			     1			LOCAL _DONE
 E1BB			     1	??000B:
 E1BB  E2 FE		     1		LOOP	??000B					; long delay for I/O
 E1BD  FA			; 	    |   0		; IPL Floppy Disk Drive (0=floppy drive installed)
 E1BE  43			;  Port C - I/O RAM (x 32KB)
 E1BF  08 05			;	High| Low
				;	    |4321		; RAM size bits 1-4   when Port B bit 2 = 1
				;	     4325		; RAM size bits 5,2-4 when Port B bit 2 = 0
 E1C1  75 DF			;----------------------------------------------------------------------------;
				; 5160 Sense Switches:
				;  Port C
				;	High| Low
				; 	00  |			; Disk Drives (00=1, 01=2, 10=3, 11=4)
				; 	  00| 		; Video (00=EGA/VGA, 01=CGA 40, 10=CGA 80, 11=MDA)
				;	    |00		; MB RAM Banks (00=Bank 0, Bank 0/1, 10=0/1/2, 11=0/1/2/3)
 E1C3  B0 FE			;	    |  0		; FPU installed
 E1C5  EE			; 	    |   0		; Test Loop (always 0)
				;
 E1C6				; EQUIP_FLAGS: LPT:2,X1:1,GAM:1,COM:3,DMA:1,FLP:2,VIDM:2,MBRAM:2,FPU:1,IPL:1
				;----------------------------------------------------------------------------;
				GET_SW_SETTINGS:
					IN	AL, PPI_B 				; read Port B register
					PUSH	AX					; save original switches, AH = 0
				
						IF ARCH_TYPE EQ ARCH_5150
				;----------------------------------------------------------------------------;
				; Is a 5150 build
				;
				SETTINGS_5150:
 E1C6  B0 36				OR	AL, MASK PBKB OR MASK PBSW	; Enable SW1 switches, SW2 1-4
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 57 - 1


					OUT	PPI_B, AL
					XCHG	AX, CX				; save modified settings
 E1C8  E6 43			
 E1CA  0E			;----------------------------------------------------------------------------;
				; Read 5150 memory size from SW1 3,4 (motherboard) and SW2 1-5 (expansion)
				;
					IN	AL, PPI_C				; get expansion card memory size
					AND	AL, 1111B				; isolate memory size (in 32KB)
					MOV	CH, AL				; save low 4 bits
					XCHG	AX, CX				; AL = switches, AH = low 4 bits
					AND	AL, NOT MASK PBSW			; Read SW2 5
 E1CB  32 C0				OUT	PPI_B, AL
 E1CD  E6 40				IN	AL, PPI_C				; read bit 5
 E1CF  1F				AND	AL, 0001B				; isolate memory size bit 5
 E1D0  E6 40				MOV	CL, 4
					SHL	AL, CL				; shift into correct position
					OR	AL, AH				; combine with bits 1-4
					CBW						; clear AH
					INC	CX					; convert to KB (CL = 5)
					SHL	AX, CL				; AX = blocks * 32
					XCHG	AX, DX				; DX = expansion RAM in KB
				
				;----------------------------------------------------------------------------;
				; Get motherboard RAM size
 E1D2				;
 E1D2  8C C8				IN	AL, PPI_A				; get drive, MB RAM, video
 E1D4  B1 1F				PUSH	AX					; save SW1
 E1D6  33 FF				AND	AL, MASK PCMB			; isolate MB RAM
 E1D8  BE FEE3 R			ADD	AL, 4					; start at 16KB since SW1 00 = 16KB
 E1DB					SHL	AX, 1					; AX = MB RAM size in KB
 E1DB  A5				SHL	AX, 1					; (AX = AX * 4)
 E1DC  AB				ADD	AX, DX				; add expansion RAM to total
 E1DD  E2 FC				MOV	MEM_SZ_PC, AX			; save to BDA
					POP	AX					; restore SW1
				
						ELSE
						IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; Is a FE2010A PC
				; Note: FPU won't be detected if BOOT_NORMAL (too many bytes to fix)
				;
				; Set AL for BDA / switch register
				; Set AH for system config register
				;
				SETTINGS_FE2010:
					AND	AL, NOT MASK PBSW			; select register for PPI Bits 4-7
 E1DF					OUT	PPI_B, AL				; port 61H Control Register
 E1DF  BB ---- R			AND	AL, MASK PBTB			; Turbo bit set?
 E1E2  8B D3				JZ	SETTINGS_FE2010_1			; jump if not turbo (AH already 0)
 E1E4  BF AA55				MOV	AX, DBW <FE_CR <,,,,1,>>	; set AH default with FPU bit, clear AL
 E1E7  B1 04			SETTINGS_FE2010_1:
 E1E9					OUT	PPI_C, AL				; write 0 to port 62H Switch Register
 E1E9  8E DB				IN	AL, PPI_C				; port 62H Switch Register
 E1EB  A1 0000 R					IF CPU_TYPE	EQ CPU_V20
 E1EE  3D AA55				SHL	AL, 4					; shift drives and video to high nibble
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 58 - 1


 E1F1  74 18						ELSE
 E1F3  97				MOV	CL, 4
 E1F4  3B C7				SHL	AL, CL				; shift drives and video to high nibble
 E1F6  74 13						ENDIF
 E1F8  B0 10				AND	AL, MASK VIDM			; Bits 4-5 Video only
 E1FA  80 C7 02				OR	AL, EQFLAGS <,,,,,SW1_FLP AND 1,,,1>; set FPU: 1, defaults and SW1_FLP
 E1FD  E8 0330										;   FD: 00b=1 drive, 01b=2 drives
 E200  E1 E7			
 E202  75 07					ELSE					; not ARCH_5150 OR ARCH_FE2010
						IF ARCH_TYPE EQ ARCH_EHB
				;----------------------------------------------------------------------------;
				; Is EMM/Homebrew 8088
				;
 E204  BF 0060 R			MOV	AL, EQFLAGS <,,,,,SW1_FLP,SW1_VID>	; use preconfigured values
 E207  91			
 E208  AB					ELSE
 E209  92			;----------------------------------------------------------------------------;
 E20A  AB			; Is a 5160 or standard clone build
 E20B				;
				SETTINGS_5160:
					AND	AL, NOT MASK PBSW			; set bit 3 = 0 for low switch select
					PUSH	AX		 			; save port settings
					OUT	PPI_B, AL
					IN	AL, PPI_C 				; get low switches
					AND	AL, MASK MBRAM OR MASK FPU OR MASK IPL ; isolate MB RAM and FPU bits
 E20B  B8 ---- R			MOV	CH, AL				; save to CH
 E20E  8E D8				POP	AX 					; get port settings
 E210  8E C0				OR	AL, MASK PBSW 			; set bit 3 = 1 for high switch select
					OUT	PPI_B, AL
					IN	AL, PPI_C 				; get high switches
							IF CPU_TYPE	EQ CPU_V20
					SHL	AL, 4					; shift drives and video to high nibble
							ELSE
					MOV	CL, 4
 E212					SHL	AL, CL				; shift drives and video to high nibble
 E212  B8 0101						ENDIF
 E215  D5 10				OR	AL, CH				; combine RAM, FPU with drives and vid
 E217  3C 0B			
						ENDIF					; not ARCH_TYPE EQ ARCH_EHB
 E219  75 05					ENDIF					; not ARCH_TYPE EQ ARCH_FE2010
						ENDIF					; not ARCH_TYPE EQ ARCH_5150
			     1				IFNB	<>
			     1		AND	GB_FLAGS, MASK V20		; clear existing flag(s)
			     1				ENDIF
 E21B  80 0E 0012 R 04	     1		OR	GB_FLAGS, MASK V20		; set flag(s)
				
				SETTINGS_DONE:
				;----------------------------------------------------------------------------;
				; If set on MB DIP SW1, test and verify FPU. If not detected, disable in BDA.
				;
					TEST	AL, MASK FPU			; is FPU set?
 E220					JZ	SETTINGS_SAVE			; if not, skip to save flags
					CALL	HAS_FPU				; check FPU, ZF=0 if not detected
 E220					JZ	SETTINGS_SAVE			; if detected, save flags
							IF ARCH_TYPE EQ ARCH_FE2010
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 59 - 1


					AND	AX, NOT DBW <MASK FPU, MASK FPU> ; otherwise clear FPU flags
							ELSE
					AND	AL, NOT MASK FPU			; otherwise clear FPU flag
							ENDIF
				SETTINGS_SAVE:
					MOV	BYTE PTR EQUIP_FLAGS, AL	; set to low byte of EQUIP_FLAGS
				
							IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
				; Write to FE2010A switch registers
				;
					OUT	PPI_C, AL				; write to switch register
					XCHG	AH, AL
					CALL	FE2010_SETUP_SAVE			; save to memory and register
					XCHG	AH, AL
					CBW						; clear AH (cannot have > 2 FDs)
							ENDIF
				
					XCHG	AX, DX				; save EQUIP_FLAGS to DL for later
					POP	AX					; AL = original settings, AH = 0
					OUT	PPI_B, AL				; restore original settings
				
				;----------------------------------------------------------------------------;
				; [21] Video BIOS Option ROM scan
				;----------------------------------------------------------------------------;
				; Scan 0C000H - 0C800H for video option ROMs (EGA, VGA, etc)
				;
				; A video option ROM should set the BDA video type flag to a non-zero value
				; If the flag is still 0 afterwards, no ROMs loaded succesfully.
				;----------------------------------------------------------------------------;
					MOV	AX, SEG _VID_BIOS			; starting segment (C000H)
 E220					MOV	DI, SEG _OPT_ROM			; ending segment (C800H)
 E220  E4 61				PUSH	DX					; save EQUIP_FLAGS for below
 E222  50				CALL	BIOS_ROM_SCAN			; scan segments AX to DI for ROMs
					POP	DX					; restore EQUIP_FLAGS
				
				;----------------------------------------------------------------------------;
				; Check for a valid video mode in BDA:
				;  - If BDA video mode is 0, video option ROM was not loaded. Beep and halt
				;  - If MB video switch is 0 (option ROM), skip reset
				;  - If not 0, determine correct 6845 video mode and do INT 10H reset
				;----------------------------------------------------------------------------;
					GET_EFLAG  VIDM				; AX = 00=error(ZF), 01=CGA 40, 10=CGA 80, 11=MDA
					XCHG	AX, DX				; AL = EQUIP_FLAGS, DX = BDA initial video mode
					JNZ	VID_MODE_OK				; jump if mode valid or video option ROM loa
				ded
					MOV	BL, BEEP_SL <3,3>			; Beep 3 long, 3 short
				HALT_BEEP_2:
					JMP	HALT_BEEP				; NEAR jump to beep
				VID_MODE_OK:
					TEST	AL, MASK VIDM			; is SW1 mode 00?
					JZ	RESET_VIDEO_DONE			; if custom video ROM, skip reset
					DEC	DX
					MOV	AX, 1					; CGA 40x25 color, AH = 0 (for INT 10h below
				)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 60 - 1


					JZ	RESET_VIDEO				; ZF if CGA 40
					MOV	AL, 3					; CGA 80x25 color
					DEC	DX					; ZF if CGA 80
					JZ	RESET_VIDEO				; jump if CGA, fall through if Mono
					MOV	AL, 7					; else Mono
				
				;----------------------------------------------------------------------------;
				; Clear screen and reset the video display.
				;
				RESET_VIDEO:
					INT	10H					; AH = 0 - Set Video Mode
				RESET_VIDEO_DONE:
				
				;----------------------------------------------------------------------------;
				; Hello Computer ("just use the keyboard")
				;----------------------------------------------------------------------------;
				HELLO_WORLD:
							IF RANDOM_TAGLINE EQ 1
					CALL	HELLO_RAND_TAGLINE		; display banner and random tagline
							ELSE
					PRINTLN_SZ	TOP_BANNER			; display banner and fixed tagline
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Save the initial cursor mode to BDA for hot key and POST display
				;
					XOR	BX, BX				; BH = video page 0
					MOV	AH, 3					; get cursor: CX = power-on cursor
					INT	10H					;  DX = position
					MOV	CURSOR_DEFAULT, CX		; save to BDA for Turbo toggle
				
				;----------------------------------------------------------------------------;
				; Display VERSION notice in bottom left
				;
					PUSH	DX					; save cursor position
					MOV	DX, DBW <24, 0> 			; bottom left row = 24, col = 0
					MOV	AH, 2 				; set bottom cursor position 
					INT	10H 					; row = DH, column = DL
					PRINT_SZ  VER				; display version
					PRINT_SZ  REL_DATE			; display build date
					POP	DX					; restore previous cursor
					MOV	AH, 2 				; reset cursor position
					INT	10H 					; row = DH, column = DL
				
				;----------------------------------------------------------------------------;
				; Jump over INT 02h fixed ORG to continue...
				;
							IF (ARCH_TYPE EQ ARCH_EMU) OR (ARCH_TYPE EQ ARCH_EHB) OR (ARCH_TYPE EQ ARCH_
				FE2010)
					JMP	 NEAR PTR INT_02_AFTER			; (jump hack)
							ELSE
					JMP	 SHORT INT_02_AFTER
							ENDIF
				
							IF IS_TURBO
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 61 - 1


				;----------------------------------------------------------------------------;
				; Toggle Turbo mode on/off
				;----------------------------------------------------------------------------;
				; Note: some references state that flipping both bit 2 and 3 (0Ch) are
				; required, and some only bit 2 (04h). Flipping only bit 2 seems to work fine.
				;
				; Size: 25 bytes
				;
 E223				; Clobbers AX, CX, DX
 E223  24 F7			;----------------------------------------------------------------------------;
 E225  50			; NOTE: ORG located here to fill the space taken up by additional 5150 code
 E226  E6 61			;----------------------------------------------------------------------------;
 E228  E4 62			TOGGLE_TURBO PROC
 E22A  24 0F						ASSUME DS:_BDA
 E22C  8A E8				CLI						; interrupts off
 E22E  58			
 E22F  0C 08					IF ARCH_TYPE EQ ARCH_TD3300
 E231  E6 61			;----------------------------------------------------------------------------;
 E233  E4 62			; TD3300A Port 90h Turbo switch
				; If port 90 == 1, send 2 (0010b) Normal -> Turbo
				; If port 90 == 0, send 3 (0011b) Turbo -> Normal
				;
 E235  B1 04				IN	AL, TD_TURBO			; read current state
 E237  D2 E0				CMP	AL, MASK TDSS			; is 1 or 0?
					JA	TOGGLE_TURBO_DONE			; exit if register not valid
 E239  0A C5				JZ	TOGGLE_TURBO_TD_1			; jump if 1 (currently Turbo)
					OR	AL, MASK TDSH			; set software speed bit
				TOGGLE_TURBO_TD_1:
					XOR	AL, MASK TDSS			; toggle turbo bit
					OUT	TD_TURBO, AL			; write to board
					CMP	AL, MASK TDSH OR MASK TDSS	; turbo on? (NZ = turbo)
 E23B				
							ELSE				; NOT ARCH_TD3300
				;----------------------------------------------------------------------------;
				; Standard PPI B Turbo switch
 E23B  A8 02			;
 E23D  74 07				IN	AL, PPI_B				; read PPI
 E23F  E8 1D81				XOR	AL, MASK PBTB			; flip turbo bit
 E242  74 02				OUT	PPI_B, AL
				
							IF ARCH_TYPE EQ ARCH_FE2010
				;----------------------------------------------------------------------------;
 E244  24 FD			; FE2010 Turbo switch
				;
 E246					XCHG	AX, CX				; save AX
 E246  A2 0010 R			MOV	AL, FE2010_CONF_REG		; get current register
					XOR	AL, FE_CR <> AND MASK FSPD	; flip speed bit(s)
					CALL	FE2010_SETUP_SAVE			; write to memory and register
					XCHG	AX, CX				; restore AX
							ENDIF				; ARCH_FE2010
				
							IF ARCH_TYPE EQ ARCH_UM82
				;----------------------------------------------------------------------------;
				; UM82C088 speed mode
				;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 62 - 1


					OUT	UM82_SPEED, AL			; write any value to toggle speed
							ENDIF				; ARCH_UM82
				
 E249  92						IF ARCH_TYPE EQ ARCH_EHB
 E24A  58			;----------------------------------------------------------------------------;
 E24B  E6 61			; EMM Homebrew/V40 - Toggle wait state FF = 3 W/S, 0 = zero W/S
				;
					MOV	DX, V40_WCR1			; V40 wait state register
					IN	AL, DX				; read current register
					NOT	AL					; toggle FF to 0
					OUT	DX, AL				; write register
					NOT	AL					; revert since NZ is Turbo
							ENDIF				; ARCH_EHB
				
							IF (ARCH_TYPE EQ ARCH_EMU) AND (ARCH_SUB_TYPE EQ ARCH_MIST)
 E24D  B8 ---- R		;----------------------------------------------------------------------------;
 E250  BF ---- R		; PCXT_MiSTer - Toggle between 4 MHz AT and 5MHz XT
 E253  52			;
 E254  E8 028E				MOV	DX, MC_PORT				; DX = XTCTL port
 E257  5A				IN	AL, DX				; read current speed
					AND	AL, NOT MCSP_LOW			; clear high bit (if set by XTCTL)
					XOR	AL, MCSP_TOG			; toggle speed bits
					OUT	DX, AL				; set new speed
					TEST	AL, MASK MCAT4			; high speed bit set?
							ELSE				; NOT ARCH_MIST AND NOT ARCH_TD3300
					TEST	AL, MASK PBTB			; standard turbo bit set?
							ENDIF				; ARCH_MIST
						ENDIF					; ARCH_TD3300
			     1			LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
			     1				IFNB <>
			     1		PUSH	CX					; save CX
			     1		PUSH	DS
			     1		MOV	CX, SEG _BDA			; DS = BDA
			     1		MOV	DS, CX
			     1				ENDIF
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Shift if flag is in high byte to low for byte operations
			     1	;
			     1				IF VIDM LT 8		; is in low byte?
 = 0030			     1	??000C	= MASK VIDM
 = 0004			     1	??000D	= VIDM AND 0111B
 = 0010			     1	??000E	= EQUIP_FLAGS[0]			; low BDA flags byte
			     1				ELSE				; is in high byte
			     1	??000C	= HIGH MASK VIDM
			     1	??000D	= (VIDM - 8) AND 0111B
			     1	??000E	= EQUIP_FLAGS[1]			; high BDA flags byte
			     1				ENDIF
			     1	
 E258  A0 0010 R	     1		MOV	AL, BYTE PTR ??000E
 E25B  83 E0 30		     1		AND	AX, ??000C			; clear AH
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Determine optimal number of shifts based on bit position and shift
			     1	; right or left depending on fewest.
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 63 - 1


			     1	;
			     1				IF CPU_TYPE	EQ CPU_V20
			     1					IF ??000D GT 4
			     1		ROL	AL, 8-??000D			; shift value into position
			     1					ELSE
			     1		ROR	AL, ??000D			; shift value into position
			     1					ENDIF
			     1				ELSE
			     1					IF ??000D GT 4
			     1		MOV	CL, 8-??000D			; CL = bit(s) position of record
			     1		ROL	AL, CL				; shift value into position
			     1					ELSE
 E25E  B1 04		     1		MOV	CL, ??000D			; CL = bit(s) position of record
 E260  D2 C8		     1		ROR	AL, CL				; shift value into position
			     1					ENDIF
			     1				ENDIF
			     1				IFNB <>
			     1		POP	DS
			     1		POP	CX
			     1				ENDIF
 E262  92			
 E263  75 05				MOV	CX, CURSOR_DEFAULT		; original power-on cursor (fast)
 E265  B3 33				JNZ	TOGGLE_TURBO_CURSOR		; Jump if turbo, use original cursor
 E267					XOR	CH, CH 				; starting scan line 0 ("big cursor")
 E267  E9 060A			TOGGLE_TURBO_CURSOR:
 E26A					CALL	SET_CURSOR				; Video set cursor
 E26A  A8 30			
 E26C  74 0F			TOGGLE_TURBO_DONE:
 E26E  4A				STI						; Enable interrupts
 E26F  B8 0001				RET
 E272  74 07			TOGGLE_TURBO ENDP
 E274  B0 03						ENDIF				; IF IS_TURBO
 E276  4A			
 E277  74 02						IF ARCH_TYPE EQ ARCH_FE2010
 E279  B0 07			;----------------------------------------------------------------------------;
				; Initial Set up Memory
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = memory in paragraphs
 E27B				; 	FE2010_CONF_REG set for 640K
 E27B  CD 10			;
 E27D				; AX clobbered
				;----------------------------------------------------------------------------;
				FE2010_SETUP_MEM PROC
					MOV	AL, FE2010_CONF_REG		; get register
					CMP	DH, HIGH 8000H			; is memory size 8000H? (512K)
 E27D					JA	FE2010_SETUP_OUT			; is > 512K (already set for 640K)
					MOV	AH, MASK FME1			; set for 512K
 E27D  E8 1651				JE	FE2010_SETUP_SET			; is 512K, set to 512K
					MOV	AH, MASK FME2			; else set for 256K
				FE2010_SETUP_SET:
					OR	AL, AH				; set bits if not 640K
				
				;----------------------------------------------------------------------------;
				; Write AL to memory and control register
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 64 - 1


				;
 E280  33 DB			FE2010_SETUP_SAVE PROC
 E282  B4 03				MOV	FE2010_CONF_REG, AL		; save register to memory
 E284  CD 10			FE2010_SETUP_OUT:
 E286  89 0E 00E8 R			OUT	PPI_CW, AL				; write to config register
					RET
				FE2010_SETUP_SAVE ENDP
				
				FE2010_SETUP_MEM ENDP
 E28A  52						ENDIF
 E28B  BA 1800			
 E28E  B4 02						IF ARCH_TYPE EQ ARCH_UM82
 E290  CD 10			;----------------------------------------------------------------------------;
				; Read UM82 memory size
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <VER>,<SI>			; if SZ is not SI
 E292  BE FFE0 R	     1		MOV	SI, OFFSET VER
			     1			ENDIF
 E295  E8 1455		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
				;----------------------------------------------------------------------------;
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <REL_DATE>,<SI>			; if SZ is not SI
 E298  BE FFF5 R	     1		MOV	SI, OFFSET REL_DATE
			     1			ENDIF
 E29B  E8 144F		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E29E  5A			; Output: CX = memory in # of 16K blocks above the first 16K block
 E29F  B4 02			;----------------------------------------------------------------------------;
 E2A1  CD 10			UM82_IS_512	= NOT UM82_512K AND MASK U8MEM
				UM82_IS_640	= NOT UM82_640K AND MASK U8MEM
				UM82_MEM_SIZE PROC
					IN	AL, UM82_STATUS			; read UM82 status
					MOV	CX, 40 - 1				; 40 * 16K = 640K
					TEST	AL, UM82_IS_640			; is 640K?
					JE	UM82_DONE				; if so, done
					MOV	CL, 32 - 1				; 32 * 16K = 512K
 E2A3  EB 41				TEST	AL, UM82_IS_512			; is 512K?
					JE	UM82_DONE				; if so, done
					MOV	CL, 16 - 1				; 16 * 16K = 256K
				UM82_DONE:
					RET
				UM82_MEM_SIZE ENDP
							ENDIF
				
							IF ARCH_TYPE EQ ARCH_EHB
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 65 - 1


				; V40 Compatibility Register Setup
				;----------------------------------------------------------------------------;
				; Use with EMM Computers/homebrew8088.com
				; Contributed by @Hak Foo
				;
				; Size: 45 bytes
 E2A5				;----------------------------------------------------------------------------;
				INIT_V40 PROC
 E2A5  FA						IF CPU_TYPE	EQ CPU_V20
					MOV	CX, 10			; counter = size of V40_REG
					MOV	SI, OFFSET V40_REG	; register data
					MOV	DH, 0FFH			; high byte of DX is always FF
				V40_REG_LOOP:
					LODS	WORD PTR CS:[SI]		; AH = low byte of reg, AL = reg value
					MOV	DL, AH			; DX = next register
					OUT	DX, AL			; write to register
					LOOP	V40_REG_LOOP
							ENDIF			; IF CPU_TYPE EQ CPU_V20
				
				;----------------------------------------------------------------------------;
				; EMM/8042 Keyboard reset
				;
					MOV	AL, 0AAH		; Test Controller
					OUT	ATKB_CMD, AL	; OUT Command Port (64h)
					IO_DELAY
					IN	AL, ATKB_IO		; Read Data Port and discard (60h)
				
					MOV	AL, 01100000B	; Write Command Byte to Keyboard Controller
					OUT	ATKB_CMD, AL	; OUT Command Port (64h)
					INC	AX			; PC Mode, Enable Interrupt (01100001b)
 E2A6  E4 61				OUT	ATKB_IO, AL		; OUT Data Port (60h)
 E2A8  34 04				JMP	INIT_V40_RET	; continue POST
 E2AA  E6 61			
							IF CPU_TYPE	EQ CPU_V20
				V40_REG LABEL BYTE
					DB	00000000B,	0FEH 	; FFFE: OPCN - INT Select
					DB	00000110B,	0FDH 	; FFFD: OPSEL - Enable TCU/ICU, Disable DMAU/SCU
									;	Only Enable The Interrupt Controller And Timer
					DB	00H, 		0FCH	; FFFC: OPHA - On-chip Peripheral High Address Register
									;	Any 256K Block Except Overlap with Registers
					DB	00100000B,	0FAH	; FFFA: IULA - 8259 Lower Address Register
					DB	01000000B,	0F9H 	; FFF9: TULA - 8254 Lower Address Register
					DB	00000000B		; FFF6: WCY2 - Number of wait cycles for DMA and refresh
					DB	LOW V40_WCR2	;	00 seems safe for SRAM since no refresh happens
							IF NOT PPI_B_BOOT AND MASK PBTB 	; Boot to Turbo/0-WS speed?
					DB	V40_WCY1<0,0,0,0>	;	WCY1 - All Zero wait state
							ELSE
					DB	V40_WCY1<3,3,3,3>	;	WCY1 - 3 W/S everywhere
							ENDIF
					DB	LOW V40_WCR1	; FFF5: WCY1 - WAIT Wait bits 7-6 = IO, 5-4 = Upper Mem,
									;	3-2 = Middle Mem, 1-0 Lower Mem
									;	0FFH: Super conservative: 3WS everywhere
									;	025H: Bolder: Zero wait-state I/O
									;	 00H: Full Zero wait state, best performance
					DB	00000110B,	0F4H 	; FFF4: WMB - Memory Boundaries
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 66 - 1


									;	Bits 6-4 are size of "high" memory, 2-0 "low"
									;	in 32k units.  Default puts bottom 32k "low"
									;	and above 640k in "high" for stuff like slow
									;	video cards and option BIOSes
					DB	00H,		0F2H	; FFF2: RFC - Refresh Control
									;	00 (disabled refresh) for SRAM
					DB	00011100B,	0F0H 	; FFF0: TCKS - Timer Pin Selection
									; 	Bits 4-2 set sources for timers (1 for TCLK)
									;	1=Pin, 0=internal, Bits 1-0 Prescale Div For Interna
				l
				L_V40_REG	=	($-V40_REG)/2
							ENDIF		; /IF CPU_TYPE EQ CPU_V20
				
				INIT_V40 ENDP
							ENDIF		; /IF ARCH_TYPE EQ ARCH_EHB
				
							IF FD_AUTO_DETECT EQ 1
				;----------------------------------------------------------------------------;
				; Set BDA Floppy disk count in to AL
				;----------------------------------------------------------------------------;
 E2AC  A8 04			SET_EFLAG_FLP PROC
					TEST	AX, AX				; zero drives found?
					JZ	SHORT SET_EFLAG_FLP_RET		; don't change BDA (no option for 0)
					PUSH	AX
 E2AE  8B 0E 00E8 R			DEC	AX					; adjust 0-based count
 E2B2  75 02				AND	AL, SW1_FLP				; max number of drives
 E2B4  32 ED				SET_EFLAG  FLP				; set floppy count
 E2B6					POP	AX
 E2B6  E8 0D85			SET_EFLAG_FLP_RET:
					RET
 E2B9				SET_EFLAG_FLP ENDP
 E2B9  FB						ENDIF
 E2BA  C3			
 E2BB				;
				; 2 BYTES HERE
				;
				BYTES_HERE	INT_02
				
				;----------------------------------------------------------------------------;
				; INT 2 - NMI 
				;----------------------------------------------------------------------------;
				; If NMI / IRQ 2 occurs (a parity or I/O exception), display error type and
				; halt. Exit if it was an 8087 exception as that should be intercepted by 
				; a user coprocessor exception handler.
				;----------------------------------------------------------------------------;
						ORG 0E2C3H
				INT_02 PROC
						ASSUME DS:_BDA
					PUSH	AX
					IN	AL, PPI_C 				; get PC0 register
					TEST	AL, MASK PCPE OR MASK PCIE	; parity or I/O error?
					JNZ	INT_02_NMI_PAR 			; first, check parity
					POP	AX					; if neither, exit
					IRET						; must have been an 8087 NMI
				INT_02_NMI_PAR:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 67 - 1


					MOV	SI, OFFSET NMI_ERR_PAR 		; Parity error string
					TEST	AL, MASK PCPE			; parity error?
					JNZ	INT_02_NMI_HALT
					MOV	SI, OFFSET NMI_ERR_IO 		; otherwise is I/O error
				INT_02_NMI_HALT:
					XOR	AX, AX				; reset video, clear screen
					OUT	NMI_R0, AL				; mask the unmaskable
					INT	10H					; switch to text video mode
					CALL	OUT_SZ 				; display string in CS:SI
					CALL	NMI_RESET				; clear NMI/parity flags
				INT_02_LOOP:
					CLI						; ensure interrupts off
					HLT						; halt CPU
					JMP	SHORT INT_02_LOOP
				INT_02 ENDP
				
				INT_02_AFTER:
				
				;----------------------------------------------------------------------------;
				; [37] Setup LPT/COM default timeouts
				;----------------------------------------------------------------------------;
					MOV	DI, OFFSET LPT_TIME
					MOV	AX, DBW <LPT_TO, LPT_TO>	; LPT timeout values
					STOSW						; write x 4 to BDA
					STOSW
					MOV	AX, DBW <COM_TO, COM_TO>	; COM timeout values
					STOSW
					STOSW
				
				POST_DETECT_PORTS:
					MOV	BX, OFFSET EQUIP_FLAGS[1]	; BX = high byte of EQUIP_FLAGS
				
				;----------------------------------------------------------------------------;
				; [38] Detect and enable Game port
				;----------------------------------------------------------------------------;
				; Port 201H
				; Input: 
				;	BX = high byte of EQUIP_FLAGS
				;
				; Equipment Bit is set if the lower nibble of an I/O port 201h read is zero
				; http://www.minuszerodegrees.net/5150_5160/post/IBM%205150%20and%205160%20-%20Bit%2012%20of%20Equip
				ment%20Flag.htm
				;----------------------------------------------------------------------------;
				POST_DETECT_GAM:
					MOV	DX, GAME_CTRL
					IN	AL, DX 				; will be 0FFH if no port
					TEST	AL, 0FH
					JNZ	NO_GAME_PORT
					OR	BYTE PTR [BX], HIGH MASK GAM	; enable Game Port bit
				NO_GAME_PORT:
				
				;----------------------------------------------------------------------------;
				; [37] Detect and enable COM ports 1-4
				;----------------------------------------------------------------------------;
				; Ports 3F8H, 2F8H, 3E8H, 2E8H
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 68 - 1


				; Input:
				;	BX = high byte of EQUIP_FLAGS
				;	ES, DS = BDA segment
				;----------------------------------------------------------------------------;
				POST_DETECT_COM:
					MOV	CX, 4
					XOR	DI, DI 				; 00H BDA COM1-4 base addresses
					MOV	DX, COM1_IIR			; 03FAH: COM1 Interrupt Ident Reg
				COM_DETECT_LOOP:
					XOR	AL, AL				; AL = 0
					OUT	DX, AL				; clear FIFO Control Register (FCR)
					IN	AL, DX 				; read IIR to clear DMA flags
					IN	AL, DX 				; read IIR again
					DEC	DX
					DEC	DX					; get base port
					TEST	AL, 11110000B 			; check if any high 4 bits are set
					JNZ	NO_COM_PORT				; if so, not a valid port
					XCHG	AX, DX				; AX = detected port
					STOSW 					; write I/O port to COM BDA table
					XCHG	AX, DX
					ADD	BYTE PTR[BX], HIGH(1 SHL COM)	; INC COM port count in flags
				NO_COM_PORT:
					SUB	DX, 3F8H-2FAH			; base port to next data port
					CMP	CL, 3 				; is 2F8H (COM3)?
					JNZ	NEXT_COM_PORT
					ADD	DX, 3EAH-(2F8H-0FEH)		; if so, diff to get to 3EAH again
				NEXT_COM_PORT:
					LOOP	COM_DETECT_LOOP
				
				;----------------------------------------------------------------------------;
				; [36] Detect and enable LPT ports
				;----------------------------------------------------------------------------;
				; Ports 3BCH, 378H, 278H
				; Input: 
				;	BX = high byte of EQUIP_FLAGS
				;	CH = 0
				;----------------------------------------------------------------------------;
				POST_DETECT_LPT:
					MOV	DI, OFFSET LPT_ADDR		; 08H BDA LPT1-3 base addresses
					MOV	DX, 03BCH				; start with MDA printer base
					MOV	CL, 3
				LPT_DETECT_LOOP:
					MOV	AL, MASK LCDR OR MASK LCINI-1	; use init byte - 1 as test data
					OUT	DX, AL				; send to LPT data port
					INC	DX
					INC	DX					; DX = control port
					INC	AX					; AL = Strobe off / init (1100b)
					OUT	DX, AL				; send to LPT control port
					DEC	DX
					DEC	DX					; DX = data port
					IN	AL, DX				; read from LPT data port
					XOR	AL, MASK LCDR OR MASK LCINI-1	; valid port if same test data
					JNZ	NO_LPT_PORT
					XCHG	AX, DX				; AX = detected port
					STOSW 					; store to LPT BDA table
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 69 - 1


					XCHG	AX, DX
					ADD	BYTE PTR[BX], HIGH(1 SHL LPT)	; INC LPT port count in flags
				NO_LPT_PORT:
					DEC	DH 					; DX = DX - 100H
					CMP	CL, 3 				; is 3BCH?
					JNZ	NEXT_LPT_PORT
					ADD	DX, 378H-(3BCH-100H)		; if so, add diff to get to 378H
				NEXT_LPT_PORT:
					LOOP	LPT_DETECT_LOOP
				
				;----------------------------------------------------------------------------;
				; Reset Keyboard Interface
				;----------------------------------------------------------------------------;
				; http://minuszerodegrees.net/5160/keyboard/5160_keyboard_startup.jpg
				;
				; KB Status Port 61h high bits:
				; 01 - normal operation. wait for keypress, when one comes in,
				;		force data line low (forcing keyboard to buffer additional
				;		keypresses) and raise IRQ1 high
				; 11 - stop forcing data line low. lower IRQ1 and don't raise it again.
 E2BB			     1			LOCAL LBL
			     1	
 = 0008			     1	BYTES_HERE_INT_02 = INT_02-$
			     1	
			     1			IFDEF BYTES_HERE_INT_02
			     1			IF2
			     1			IF BYTES_HERE_INT_02 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_02 (BYTES_HERE_INT_02)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				;		drop all incoming keypresses on the floor.
				; 10 - lower IRQ1 and force clock line low, resetting keyboard
				; 00 - force clock line low, resetting keyboard, but on a 01->00 transition,
				;		IRQ1 would remain high
				;----------------------------------------------------------------------------;
				POST_KB_RESET PROC
					MOV	DX, PPI_B 				; DX = PPI port B (61H)
					IN	AL, DX
					AND	AL, NOT (MASK PBKB OR MASK PBKC) ; keyboard clock hold LOW and enable
 E2C3					OUT	DX, AL				; send to PPI port B
					XCHG	AX, SI				; save modified PPI port B
 E2C3  50			
 E2C4  E4 62			;----------------------------------------------------------------------------;
 E2C6  A8 C0			; [31] - Set up and clear keyboard buffer
 E2C8  75 02			;----------------------------------------------------------------------------;
 E2CA  58				MOV	AX, OFFSET KB_BUF 		; AX = initial start of buffer
 E2CB  CF				MOV	DI, OFFSET KB_BUF_HD 		; DI = buffer head
 E2CC					STOSW 					; write to head pointer
 E2CC  BE E82A R			STOSW 					; write to tail pointer
 E2CF  A8 80				MOV	DI, OFFSET KB_BUF_ST 		; setup buffer start and end
 E2D1  75 03				STOSW
 E2D3  BE E828 R			MOV	AL, LOW OFFSET KB_BUF_END	; (AH already 00)
 E2D6					STOSW
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 70 - 1


 E2D6  33 C0			
 E2D8  E6 A0			;----------------------------------------------------------------------------;
 E2DA  CD 10			; Hold clock low 20+ ms to signal keyboard to reset. Clear and re-enable.
 E2DC  E8 140E			;
 E2DF  E8 053B				MOV	AL, 30				; I/O delay for at least 20ms
 E2E2					CALL	IO_DELAY_MS
 E2E2  FA				XCHG	AX, SI				; restore modified PPI port B
 E2E3  F4			
 E2E4  EB FC				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E2E6					OUT	DX, AL				; send to PPI port B
					AND	AL, NOT MASK PBKB			; keyboard enable (clear low)
 E2E6					OUT	DX, AL				; send to PPI port B
				
				;----------------------------------------------------------------------------;
				; Unmask KB interrupt IRQ1
				;
 E2E6  BF 0078 R			IN	AL, INT_IMR 			; get PIC Port 1 INT mask
 E2E9  B8 1414				XCHG	AX, SI 				; SI = save previous INT mask
 E2EC  AB				MOV	AL, NOT MASK IRQ1			; unmask only keyboard interrupt
 E2ED  AB				OUT	INT_IMR, AL
 E2EE  B8 0101			
 E2F1  AB			;----------------------------------------------------------------------------;
 E2F2  AB			; Check if reset scan code was received
				;
 E2F3				; Temporary INT_09_POST interrupt will set 4000H flag on BP
 E2F3  BB 0011 R		; when IRQ1 is received with successful reset code of 0AAh
				;
						IF POST_TEST_KB NE 0
					STI 						; enable interrupts
				KB_RESET_TEST:
					NOP 						; give a little more time
					POST_FLAG_TEST  PKI			; KB test flag yet?
					LOOPZ	KB_RESET_TEST			; Loop until KB flag OR CX is 0 (timeout)
					CLI 						; disable interrupts again
					POST_FLAG_FLIP  PKI			; invert PKI flag: 1 = error, 0 = success
						ENDIF
					IO_DELAY_LONG 				; additional delay, CX = 0
 E2F6				
 E2F6  BA 0201			;----------------------------------------------------------------------------;
 E2F9  EC			; Ack scan code, clear keyboard again and check that no scan codes were received
 E2FA  A8 0F			;
 E2FC  75 03				IN	AL, DX				; read PPI port B
 E2FE  80 0F 10				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E301					OUT	DX, AL				; send to PPI port B
					AND	AL, NOT MASK PBKB			; keyboard enable (clear low)
					OUT	DX, AL				; send to PPI port B
					IO_DELAY					; delay for KBC, CX = 0
					IN	AL, PPI_A 				; check KB for extraneous key
							IF POST_TEST_KB NE 0
					TEST	AL, AL				; AL should be 0
					JZ	KB_HAPPY				; if so, KB is ready
					POST_FLAG_SET  PKEY			; otherwise set flag for keyboard error
							ELSE
 E301					POST_FLAG_CLR  PKI			; clear any KB error
 E301  B9 0004						ENDIF
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 71 - 1


 E304  33 FF			
 E306  BA 03FA			KB_HAPPY:
 E309				;----------------------------------------------------------------------------;
 E309  32 C0			; Disable keyboard for rest of POST
 E30B  EE			;
 E30C  EC				IN	AL, DX
 E30D  EC				OR	AL, MASK PBKB OR MASK PBKC	; keyboard enable clock and clear
 E30E  4A				OUT	DX, AL				; send to PPI port B
 E30F  4A			
 E310  A8 F0				XCHG	AX, SI 				; restore interrupt mask register
 E312  75 06				OUT	INT_IMR, AL
 E314  92			
 E315  AB			;----------------------------------------------------------------------------;
 E316  92			; Set up the real INT 09H keyboard interrupt handler
 E317  80 07 02			;
 E31A					MOV	ES, CX 				; ES = IVT seg (CX is 0 from above)
 E31A  81 EA 00FE			MOV	DI, OFFSET _INT_09H 		; DI = INT 9H offset in IVT (24H)
 E31E  80 F9 03				MOV	AX, OFFSET INT_09 		; Vector offset
 E321  75 04				STOSW 					; replace in IVT
 E323  81 C2 01F0		
 E327				POST_KB_RESET ENDP
 E327  E2 E0			
				;----------------------------------------------------------------------------;
				; Begin Hardware POST Test Results
				;----------------------------------------------------------------------------;
					CALL	HIDE_CURSOR				; cursor movement is distracting
				
							IF POST_WARM_COLD EQ 1
					CALL	POST_BOOT_TYPE			; Display "WARM" or "COLD" boot
							ENDIF
				
 E329				;----------------------------------------------------------------------------;
 E329  BF 0008 R		; [17] Detect and test conventional memory
 E32C  BA 03BC			;----------------------------------------------------------------------------;
 E32F  B1 03				CALL	DETECT_MEMORY			; detect and display memory count
 E331				
 E331  B0 0B						IF POST_VIDEO_TYPE NE 1
 E333  EE				CALL	CRLF					; clear row if video type not shown
 E334  42						ENDIF
 E335  42			
 E336  40					IF DRAM_REFRESH EQ 1
 E337  EE			;----------------------------------------------------------------------------;
 E338  4A			; [27B] Verify that the 8237 DMA Channel 0 Terminal Count (TC 0) status bit 
 E339  4A			; is on. This test is only done on a cold boot.
 E33A  EC			;----------------------------------------------------------------------------;
 E33B  34 0B				JWB	DMA_STATUS_OK			; skip on warm boot
 E33D  75 06				IN	AL, DMA_CMD				; verify DMA status register
 E33F  92				TEST	AL, MASK TC0			; Channel 0 TC
 E340  AB				JNZ	DMA_STATUS_OK			; jump if zero reached
 E341  92				POST_FLAG_SET  PDMA			; else mark in POST error flags
 E342  80 07 40			DMA_STATUS_OK:
 E345						ENDIF
 E345  FE CE			
 E347  80 F9 03			;----------------------------------------------------------------------------;
 E34A  75 04			; Display Additional Configuration Items such as COM/LPT, CPU, FPU, etc
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 72 - 1


 E34C  81 C2 00BC		;----------------------------------------------------------------------------;
 E350					CALL	POST_SYS_CONFIG
 E350  E2 DF				CALL	CRLF_SHOW_CURSOR			; CRLF and re-enable cursor
				
				;----------------------------------------------------------------------------;
				; Unmask IRQs for Timer (IRQ0), Keyboard (IRQ1) and Floppy (IRQ6)
				;----------------------------------------------------------------------------;
					IN	AL, INT_IMR 			; get current OCW1/IMR register
					AND	AL, NOT (MASK IRQ6 OR MASK IRQ1 OR MASK IRQ0) ; unmask IR6, IR1, IR0
					OUT	INT_IMR, AL 			; send to A1 (Port 1)
				
				;----------------------------------------------------------------------------;
				; [28] Option ROM scan for other ROMs (storage, etc)
				;----------------------------------------------------------------------------;
					MOV	AX, SEG _OPT_ROM			; start at 0C800H
					MOV	DI, OPT_ROM_END 			; end below 0FE00H
					CALL	BIOS_ROM_SCAN
				
				;----------------------------------------------------------------------------;
 E352				; [31] Enable interrupts
 E352  BA 0061			;----------------------------------------------------------------------------;
 E355  EC				STI 						; Interrupts now enabled
 E356  24 3F			
 E358  EE						IF FDC_ENABLE EQ 1
 E359  96			;----------------------------------------------------------------------------;
				; [30] Recalibrate and test seek the floppy drive
				;----------------------------------------------------------------------------;
				FDC_POST PROC
					XOR	AX, AX 				; AH = reset (0)
 E35A  B8 001E R			CWD						; DL = start at drive 0
 E35D  BF 001A R			INT	13H					; Reset the controller
 E360  AB				JC	FDC_POST_CT_ERR			; jump if controller reset failed
 E361  AB				GET_EFLAG  FLP				; AX = # of floppy drives (0 based)
 E362  BF 0080 R			INC	AX					; fixup for 1 based drive count
 E365  AB			
 E366  B0 3E R						IF POST_TEST_FD EQ 1
 E368  AB			;----------------------------------------------------------------------------;
				; Test FDC drives - seek on cold boot, recal on warm boot
				;
					XCHG	AX, CX				; CX = number of floppy drives
				FDC_POST_TESTS_DRV:
 E369  B0 1E							IF POST_TEST_SEEK EQ 1
 E36B  E8 1410				CALL	FDC_RECAL_SEEK_TEST		; recal and seek test
 E36E  96							ELSE
					CALL	FDC_RECAL				; do a recal only
 E36F  0C C0							ENDIF
 E371  EE				JC	FDC_POST_DRV_ERR			; jump if error
 E372  24 7F				INC	DX					; DL = next drive
 E374  EE				LOOP	FDC_POST_TESTS_DRV
					JMP	SHORT FDC_POST_TESTS_DONE	; tests successful
				FDC_POST_DRV_ERR:					; POST: drive seek error
								IF FD_AUTO_DETECT EQ 0
					POST_FLAG_SET  PFSK			; mark in POST error flags
 E375  E4 21							ENDIF
 E377  96				JMP	SHORT FDC_POST_TESTS_DONE	; end POST test at failed drive
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 73 - 1


 E378  B0 FD				;LOOP	FDC_POST_TESTS_DRV		;  or continue to next drive
 E37A  E6 21			
							ELSE				; No POST seek test
					JMP	SHORT	FDC_POST_TESTS_COL
							ENDIF				; /POST_TEST_FD EQ 1
				
				FDC_POST_CT_ERR:					; POST: controller error
					POST_FLAG_SET  PFDC			; mark in POST error flags
				
							IF POST_TEST_FD EQ 1
 E37C  FB				XOR	DX, DX				; DX = 0 drives detected
 E37D				FDC_POST_TESTS_DONE:
 E37D  90				XCHG	AX, DX				; AX = drive count
				
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		TEST1_BP  PKI				; V20 only: TEST1 BP, PKI
			     1				ELSE
 E37E  F7 C5 4000	     1		TEST	BP, MASK PKI			; Is flag set?
			     1				ENDIF
 E382  E1 F9							IF FD_AUTO_DETECT EQ 1
 E384  FA			;----------------------------------------------------------------------------;
				; Update BDA FD count based on successfully tested drives
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		NOT1_BP   PKI				; V20 only: NOT1 BP, PKI
			     1				ELSE
 E385  81 F5 4000	     1		XOR	BP, MASK PKI			; Invert flag
			     1				ENDIF
				;
					CALL	SET_EFLAG_FLP			; set drive count in AL
			     1				IF ARCH_TYPE NE ARCH_EMU
 E389  33 C9		     1		XOR	CX, CX 				; delay 65535 LOOPs
			     1		IO_DELAY
			     2			LOCAL _DONE
 E38B			     2	??0010:
 E38B  E2 FE		     2		LOOP	??0010					; long delay for I/O
			     1				ENDIF
								ENDIF			; /FD_AUTO_DETECT EQ 1
				
							ENDIF				; /POST_TEST_FD EQ 1
				
 E38D  EC			FDC_POST_TESTS_COL:
 E38E  0C C0			;----------------------------------------------------------------------------;
 E390  EE			; Display FDC POST drive count column in AX
 E391  24 7F			;
 E393  EE				POST_COL_1  POST_FDD, POST_CLR_VAL2	; display FDC column label
					CALL	NIB_HEX				; display decimal value in AL
			     1			LOCAL _DONE
 E394			     1	??0011:
 E394  E2 FE		     1		LOOP	??0011					; long delay for I/O
 E396  E4 60				POST_COL_END				;  NIB_HEX returns AL <= 46h
				
 E398  84 C0			FDC_POST ENDP
 E39A  74 04						ENDIF				; IF FDC_ENABLE
				
			     1				IF CPU_TYPE	EQ CPU_V20
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 74 - 1


			     1		SET1_BP   PKEY				; V20 only: SET1 BP, PKEY
			     1				ELSE
 E39C  81 CD 2000	     1		OR	BP, MASK PKEY			; Set flag
			     1				ENDIF
				;----------------------------------------------------------------------------;
				; Detect and show hard drive info
				;----------------------------------------------------------------------------;
				HDD_POST PROC
 E3A0							IF POST_HD_CHECK EQ 1
					CBW						; AH = 0 reset
					MOV	DL, 80H				; reset C: (80H)
					INT	13H
 E3A0  EC				JC	HDD_POST_NONE			; if CF, no HD or reset failure
 E3A1  0C C0			
 E3A3  EE				MOV	DL, 80H
					CALL	GET_DISK_PARAMS			; return # HD's in DX
 E3A4  96				JC	HDD_POST_NONE
 E3A5  E6 21			
				HDD_POST_COUNT PROC
				;----------------------------------------------------------------------------;
				; Display HDD POST drive count column
				;
 E3A7  8E C1				POST_COL_2	POST_HDD, POST_CLR_VAL2	; display HDC column label
 E3A9  BF 0024 R		
 E3AC  B8 E987 R			PUSH	DX					; save drive count
 E3AF  AB				XCHG	AX, DX				; AL = drive count
					CALL	NIB_HEX				; write as hex to console (clobs AX)
 E3B0					POST_COL_END_NL				; end column
					POP	CX					; CX = drive count
					JCXZ	HDD_POST_DONE			; reset passed but 0 drives
				
				HDD_POST_COUNT ENDP
 E3B0  E8 0C88			
							IF POST_HD_PARMS EQ 1
				;----------------------------------------------------------------------------;
 E3B3  E8 0261			; Display HDD drive letter(s) and size(s)
				;	
					MOV	DL, 80H				; start with drive 80H (C:)
				HDD_POST_SHOW_LOOP:
					CALL	SHOW_DISK_PARAMS			; show drive letter and geometry
					INC	DX					; move to next drive
 E3B6  E8 018D				LOOP	HDD_POST_SHOW_LOOP
					JMP	SHORT HDD_POST_DONE
							ENDIF				; ENDIF POST_HD_PARMS EQ 1
				HDD_POST_NONE:
							ENDIF				; ENDIF POST_HD_CHECK EQ 1
					CALL	CRLF
				HDD_POST_DONE:
				HDD_POST ENDP
				
				;----------------------------------------------------------------------------;
				; [39] Clear and enable I/O and parity NMIs
				;----------------------------------------------------------------------------;
					CALL	NMI_RESET				; reset NMI flags
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 75 - 1


							IF RAM_PARITY EQ 1
				ENABLE_NMI:
					MOV	AL, NMI <1>				; AL = enable NMI
					OUT	NMI_R0, AL				; write to controller
							ENDIF
				
				;----------------------------------------------------------------------------;
				; Enable keyboard
 E3B9  E8 125B			;
 E3BC  E8 0C73				CALL	KB_BUF_CLEAR			; clear any stray keys in buffer
					IN	AL, PPI_B 				; AL = PB0 flags
					AND	AL, NOT MASK PBKB			; keyboard clear LOW (enable KB)
					IO_DELAY_SHORT
					OUT	PPI_B, AL				; send to PPI port B
 E3BF  E4 21			
 E3C1  24 BC			;----------------------------------------------------------------------------;
 E3C3  E6 21			; Check for POST errors and clear warm boot flag
				;
					XOR	AX, AX				; AX = 0
					MOV	WARM_FLAG, AX			; clear warm boot flag in BDA
					POST_FLAG_CLR  WARM			; remove warm boot flag, NZ if error
 E3C5  B8 ---- R			JZ	POST_OK				; if no errors, go ahead and boot
 E3C8  BF FE00			
 E3CB  E8 0117			;----------------------------------------------------------------------------;
				; Display any POST errors
				;
				POST_ERROR:
					PRINT_SZ  POST_ERR			; display "Post Error"
 E3CE  FB				MOV	AX, BP				; AX = POST error flags
					CALL	WORD_HEX				; display POST error value
					CALL	CRLF
					CALL	POST_ERROR_MSG			; display POST error messages, BP=0
				
							IF POST_ERR_WAIT GT 0
				;----------------------------------------------------------------------------;
				; Wait for Any Key if there was an error
				;
					CALL	MEEPMEEP				; alert that there was an error, CX=0
					PRINT_SZ  NL_ANY_KEY			; "Any key" string
					XCHG	AX, CX				; wait for key press (AH=0)
					INT	16H
					CALL	CRLF					; move to next line
							ENDIF
				
				POST_OK:
				;----------------------------------------------------------------------------;
				; Clear screen (partially or completely) and attempt boot
				;
				CLEAR_POST_SCREEN:
					MOV	BH, 7					; attribute fill for on blank line
							IF POST_CLS EQ 1		; clear the whole screen
					MOV	AX, DBW <7, 25>			; AH = 7, scroll down 25 lines
					MOV	CX, DBW <0, 0>			; upper left row 0, column 0
							ELSE				; clear only the lower two rows
					MOV	AX, DBW <7, 2>			; AH = 7, scroll down 2 lines
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 76 - 1


					MOV	CX, DBW <23, 0>			; upper left row 23, column 0
							ENDIF
				
					MOV	DX, DBW <25, 80>			; lower right row 25, column 80
					INT	10H
				
							IF POST_CLS EQ 1		; set cursor to top of screen
					MOV	AH, 2					; set cursor position
					MOV	BH, 0					; video page 0
					CWD						; row = 0, col = 0
					INT	10H
							ENDIF
				
					CALL	BEEP 					; beep to signify POST test is done
							IF POST_GLADOS EQ 1
					PRINT_SZ  BOOT_BEGIN			; Starting DOS...
							ELSE
					CALL	CRLF
							ENDIF
				
				;----------------------------------------------------------------------------;
				; [40] DO BOOTSTRAP!
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; Attempt to IPL three times. If failure, call INT 18h / ROM BASIC.
				; If INT_19_BOOT_HD is 1, BIOS will also attempt to IPL from 80h (C:)
				;
					CWD						; start IPL from drive 0 (A:)
				BOOT_DEVICE:
					MOV	CX, 3 				; retry three times
				BOOT_RETRY:
					PUSH	CX					; save retry counter
							IF INT_19_BOOT_HD EQ 1
					PUSH	DX					; save drive number
							ENDIF
					INT	19H
					IO_DELAY_LONG				; delay between attempts
							IF INT_19_BOOT_HD EQ 1
					POP	DX					; restore drive number
							ENDIF
					POP	CX					; restore retry counter
					LOOP	BOOT_RETRY
							IF INT_19_BOOT_HD EQ 1
 E3CF					XOR	DL, 80H				; flip to HD
					JNZ	BOOT_DEVICE				; retry if HD, otherwise INT 18
 E3CF  98						ENDIF
 E3D0  B2 80			
 E3D2  CD 13			TRY_INT_18:
 E3D4  72 24				INT	18H					; Try vectored ROM BASIC or boot failure
											; INT 18h should never return...
 E3D6  B2 80										;  fall through just in case
 E3D8  E8 0343			
 E3DB  72 1D			;----------------------------------------------------------------------------;
				; INT 18 - Unbootable IPL
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 77 - 1


 E3DD				;----------------------------------------------------------------------------;
				; Display a disk boot failure message and wait for a key to cold reboot.
				;
				; This may be re-vectored to ROM BASIC, if present.
				;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL2		; BH = 0, BL = attribute
			     1			ELSE
 E3DD  B3 0E		     1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute
			     1			ENDIF
 E3DF  BE E4DA R	     1		MOV	SI, OFFSET POST_HDD
 E3E2  E8 12D6		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				; Size: 18 bytes
 E3E5  52			;----------------------------------------------------------------------------;
 E3E6  92			INT_18 PROC
 E3E7  E8 137E					ASSUME DS:_BDA_ABS
					PRINT_SZ  BOOT_FAIL			; print boot failure string
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E3EA  E8 12E0		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E3ED  59				XOR	AX, AX				; AH = 0 (wait for key)
 E3EE  E3 0D				MOV	DS, AX				; DS = 0000
					MOV	WARM_FLAG_ABS, AX			; do a cold boot
 E3F0					INT	16H					; wait for key press
					JMP	BOOT					; reboot
				INT_18 ENDP
				
				BOOT ENDP
				
 E3F0  B2 80			;----------------------------------------------------------------------------;
 E3F2				;
 E3F2  E8 146E			; END OF BIOS POST/BOOTSTRAP
 E3F5  42			;
 E3F6  E2 FA			;----------------------------------------------------------------------------;
 E3F8  EB 03			
						ASSUME DS:_BDA
 E3FA				STRINGS PROC
				;----------------------------------------------------------------------------;
 E3FA  E8 1319			; Banner Strings
 E3FD				;
 E3FD				BANNER_STRINGS PROC
				
									IF POST_GLADOS EQ 1
				BOOT_BEGIN		DB	CR, LF
							DB	'Starting GLaDOS...'
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 78 - 1


 E3FD  E8 041D			NL2_Z			DB	LF				; two NL's, null term'd
									ENDIF
				NL_Z			DB	CR, LF, 0			; one NL, null term'd
				BOOT_FAIL		DB	'Disk Boot Fail.'
							DB	' You monster.'
				NL2_ANY_KEY		DB	LF
				NL_ANY_KEY		DB	CR, LF
				ANY_KEY		DB	'Press the Any Key'
							DB	'...'
							DB	 0
				
 E400  E8 0844			BANNER_STRINGS ENDP
 E403  E4 61			
 E405  24 7F			POST_STRINGS PROC
				;----------------------------------------------------------------------------;
			     1			LOCAL _DONE
			     1				IF ARCH_TYPE NE ARCH_EMU
 E407  EB 00		     1		JMP	SHORT ??0012
 E409			     1	??0012:
			     1				ENDIF
 E409  E6 61			; POST Test Strings
				;
				POST_CPU		DB	'CPU',  0			; 'CPU' followed by default
							DB	'8088', 0			;  *must be after POST_CPU
				POST_FPU		DB	'FPU',  0			; 'FPU' followed by default
 E40B  33 C0						DB	'8087', 0			;  *must be after POST_FPU
 E40D  A3 0072 R		POST_HD		DB	':',    0			; HD size letter display
							DB	' ', POST_M_UNIT		;  MB or MiB units display
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		CLR1_BP   WARM				; V20 only: CLR1 BP, WARM
			     1				ELSE
 E410  81 E5 7FFF	     1		AND	BP, NOT MASK WARM			; Clear flag
			     1				ENDIF
 E414  74 20						DB	' ', POST_HD_CHS_L, 0	;  *must be after POST_HD
				POST_MEMORY		DB	'RAM',  0			; RAM Memory test
							DB	'000 ', POST_K_UNIT	;  and KB or KiB
							DB	' OK',  0			;  *must be after POST_MEMORY
				POST_V20		DB	'V20'
 E416									IF ARCH_TYPE EQ ARCH_EHB
							DB	'/V40'			; could be a V40 on EHB
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <POST_ERR>,<SI>			; if SZ is not SI
 E416  BE E8F5 R	     1		MOV	SI, OFFSET POST_ERR
			     1			ENDIF
 E419  E8 12D1		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E41C  8B C5								ENDIF
 E41E  E8 1333						DB	0
 E421  E8 12F2			POST_LPT		DB	'LPT',  0
 E424  E8 04F7			POST_COM		DB	'COM',  0
				POST_FDD		DB	'FDD',  0
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 79 - 1


				POST_HDD		DB	'HDD',  0
				POST_LSEP		DB	POST_L, 0
				POST_RSEP		DB	POST_R, 0
				
 E427  E8 0498			POST_STRINGS ENDP
				
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <NL_ANY_KEY>,<SI>			; if SZ is not SI
 E42A  BE E48B R	     1		MOV	SI, OFFSET NL_ANY_KEY
			     1			ENDIF
 E42D  E8 12BD		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E430  91			STRINGS ENDP
 E431  CD 16			
 E433  E8 12E0			;============================================================================;
				;
				;		        * * *   P R O C s  &  I N T s  * * *
 E436				;
				;============================================================================;
				
				;----------------------------------------------------------------------------;
 E436				; Scan, checksum and call BIOS ROMs
 E436  B7 07			;----------------------------------------------------------------------------;
				; Input:
				;	AX = starting segment
				;	DI = ending segment
				;
 E438  B8 0702			; Note: ROM init's can clobber any or all registers so important to save
 E43B  B9 1700			; any that are used here between calls.
				;
				; Clobbers: AX, BX, SI (anything else the ROM might, except for DS, ES and BP)
 E43E  BA 1950			; Size: 73 bytes
 E441  CD 10			;----------------------------------------------------------------------------;
				BIOS_ROM_SCAN PROC
						ASSUME ES:_BDA
					PUSH	BP					; some option ROMs may clobber BP
					PUSH	DS					; call-preserve DS
					PUSH	ES
					MOV	DS, AX 				; DS = starting segment
				CHECK_ROM:
					CLD						; direction flag forward
 E443  E8 0468				MOV	BX, SEG _BDA 			; ES = 0040H (BIOS BDA segment)
					MOV	ES, BX				; re-set ES for each ROM call
					PUSH	DS					; save current DS segment
					MOV	BL, 2048 SHR 4			; next 2K segment boundary length
 E446  E8 12CD				PUSH	BX					; save for use if no ROM found
					XOR	SI, SI 				; reset offset to 0
					LODSW 					; AX = first word (should be 0AA55H)
					CMP	AX, MAGIC_WORD			; is it an extension ROM?
					JNE	NEXT_ROM 				; if not, check next 2K block
				FOUND_ROM:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 80 - 1


					LODSB						; AL = ROM size in 512B blocks
					CMP	AL, 0					; is size "reasonable"?
					JLE	NEXT_ROM				; if not 1-127, skip it
					CALL	ROM_CHECKSUM 			; checksum ROM at DS:0, size AL
					JNZ	NEXT_ROM				; if NZ, checksum failed, skip it
 E449  99				POP	BX					; discard previous boundary size
 E44A							IF CPU_TYPE	EQ CPU_V20
 E44A  B9 0003				SHR	AX, 4					; V20: 512 byte blocks to paragraph
 E44D							ELSE
 E44D  51				MOV	CL, 4					; 8088: 512 byte blocks to paragraph
					SHR	AX, CL
							ENDIF
					PUSH	AX					; replace next boundary size
 E44E  CD 19			
				;----------------------------------------------------------------------------;
			     1				IF ARCH_TYPE NE ARCH_EMU
 E450  33 C9		     1		XOR	CX, CX 				; delay 65535 LOOPs
			     1		IO_DELAY
			     2			LOCAL _DONE
 E452			     2	??0013:
 E452  E2 FE		     2		LOOP	??0013					; long delay for I/O
			     1				ENDIF
				; Call Option ROM's BIOS init routine
				;
					IN	AL, INT_IMR 			; get current OCW1/IMR register
 E454  59				PUSH	AX					; save IMR
 E455  E2 F6				PUSH	DI					; save ending segment
					MOV	DI, OFFSET ROM_INIT_SS		; BDA = temp location for FAR CALL
					MOV	ES:[DI], SI				; init vector offset (always 3)
					MOV	ES:[DI][2], DS			; init vector segment
					CALL	DWORD PTR ES:[DI]			; CALL Option ROM init
					CLI						; make sure interrupts are disabled
 E457					POP	DI					; restore ending segment
 E457  CD 18				POP	AX					; restore IMR
					OUT	INT_IMR, AL				; reset IMR
				NEXT_ROM:
					POP	BX					; restore next boundary size
					POP	AX					; restore current DS segment
					ADD	AX, BX				; next boundary
					MOV	DS, AX
					CMP	AX, DI 				; end of extension ROM regions?
					JB	CHECK_ROM 				; if not, check next
				ROM_SCAN_DONE:
					POP	ES
					POP	DS 					; restore regs
					POP	BP
 E459					RET
				BIOS_ROM_SCAN ENDP
				
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <BOOT_FAIL>,<SI>			; if SZ is not SI
 E459  BE E46E R	     1		MOV	SI, OFFSET BOOT_FAIL
			     1			ENDIF
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 81 - 1


 E45C  E8 128E		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E45F  33 C0			;----------------------------------------------------------------------------;
 E461  8E D8			; Perform 8 bit Checksum on a ROM at DS:0000
 E463  A3 0472 R		;----------------------------------------------------------------------------;
 E466  CD 16			; Input:
 E468  E9 FBF0			;	DS = segment for ROM
 E46B				;	AL = ROM size in 512k blocks (1-127)
				; Output:
 E46B				;	ZF if checksum is valid
				;	AX = number of bytes read
				;
				; Size: 22 bytes
				;----------------------------------------------------------------------------;
				ROM_CHECKSUM PROC
						ASSUME DS:BIOS
					PUSH	DX
					PUSH	CX
 E46B					PUSH	SI
					CBW					; AH = 0
					CWD					; DL = 0 (accumulator for sum)
					MOV	SI, DX			; start at offset 0
 E46B					XCHG	AL, AH			; convert 512 byte blocks to 16 bit words
					XCHG	AX, CX			; CX = size in 2 byte WORDs
				CHECKSUM_LOOP:
					LODSW					; next two bytes into AL and AH
					ADD	DL, AL			; add both to sum
					ADD	DL, AH			; ZF if sum is 0
					LOOP	CHECKSUM_LOOP		; loop through entire ROM
 E46B 0D 0A 00				XCHG	AX, SI			; AX = bytes read
 E46E 44 69 73 6B 20 42			POP	SI
       6F 6F 74 20 46 61
       69 6C 2E
 E47D  20 59 6F 75 20 6D		POP	CX
       6F 6E 73 74 65 72
       2E
 E48A 0A				POP	DX
 E48B 0D 0A				RET
 E48D 50 72 65 73 73 20		ROM_CHECKSUM ENDP
       74 68 65 20 41 6E
       79 20 4B 65 79
 E49E  2E 2E 2E			
 E4A1  00			;----------------------------------------------------------------------------;
				; DETECT_MEMORY - Detect, test and clear RAM
 E4A2				;----------------------------------------------------------------------------;
				; Attempt to determine how much RAM is installed using MEM_ADDR_TEST for 
 E4A2				; more reliable memory detection.
				;
				; Output: Memory count to console
				;
 E4A2 43 50 55 00		; NOTE: Testing first two bytes of each block is problematic:
 E4A6  38 30 38 38 00		; http://minuszerodegrees.net/5160/problems/5160_known_problems_issues.htm
 E4AB 46 50 55 00		; http://minuszerodegrees.net/5160/problems/5160_ram_size_flaw.htm
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 82 - 1


 E4AF  38 30 38 37 00		;----------------------------------------------------------------------------;
 E4B4 3A 00			DETECT_MEMORY PROC
 E4B6  20 4D 42						ASSUME DS:_BDA, ES:NOTHING
 E4B9  20 28 00				PUSH	ES
 E4BC 52 41 4D 00			PUSH	DS
 E4C0  30 30 30 20 4B 42		MOV	AX, SEG _BDA
 E4C6  20 4F 4B 00			MOV	DS, AX
 E4CA 56 32 30			
				;----------------------------------------------------------------------------;
				; 5150: get MAX RAM from SW2
				;
 E4CD  00						IF ARCH_TYPE EQ ARCH_5150
 E4CE 4C 50 54 00			MOV	AX, MEM_SZ_PC			; SW2 RAM size in KB
 E4D2 43 4F 4D 00			MOV	CL, 4					; shift counter
 E4D6 46 44 44 00			SHR	AX, CL				; Number of 16KB RAM blocks
 E4DA 48 44 44 00			XCHG	AX, CX				; CX = 16KB RAM blocks
 E4DE 20 5B 20 00			DEC	CX					;  after first 16K block
 E4E2 20 5D 00						ELSE
				
 E4E5				;----------------------------------------------------------------------------;
				; UM82C088: get RAM status register
 E4E5				;
								IF ARCH_TYPE EQ ARCH_UM82
					CALL	UM82_MEM_SIZE			; CX = 16KB RAM blocks - 1
				
				;----------------------------------------------------------------------------;
				; Otherwise, use default for MAX_RAM and detect
				;
								ELSE
					MOV	CX, (MAX_RAM SHR 4) - 1		; Max number of 16KB RAM blocks
											; (ex: 640K / 16K = 40)
								ENDIF
							ENDIF
					MOV	DX, 16 * 1024 SHR 4		; Start at second 16KB block
					MOV	ES, DX				; ES = seg 0400H
				BLOCK_LOOP:
					CALL	MEM_ADDR_TEST			; address test on 16KB RAM block at ES
					JNZ	BLOCK_LOOP_DONE			; exit loop if test failed
					ADD	DH, 4					; add 400h paras (4000h bytes)
					MOV	ES, DX
					LOOP	BLOCK_LOOP				; loop until MAX_RAM
				BLOCK_LOOP_DONE:
 E4E5				
				;----------------------------------------------------------------------------;
 E4E5  55			; Test and clear RAM, show memory count
 E4E6  1E			;
 E4E7  06			; Input:
 E4E8  8E D8			;	ES = highest memory segment "detected"
 E4EA				;	DX = size of memory in paras
 E4EA  FC			;
 E4EB  BB ---- R					IF ARCH_TYPE EQ ARCH_FE2010
 E4EE  8E C3				CALL	FE2010_SETUP_MEM			; set up FE2010 configuration
 E4F0  1E						ENDIF
 E4F1  B3 80			
 E4F3  53						IF CPU_TYPE	EQ CPU_V20
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 83 - 1


 E4F4  33 F6				SHR	DX, 6					; V20: shift right 6 times to get K
 E4F6  AD						ELSE
 E4F7  3D AA55				MOV	CL, 6					; 8088: shift right 6 times to get K
 E4FA  75 26				SHR	DX, CL
 E4FC							ENDIF
 E4FC  AC				MOV	MEM_SZ_KB, DX 			; save to BDA
 E4FD  3C 00				MOV	DX, ES				; DX = highest RAM segment detected
 E4FF  7E 21			
 E501  E8 002C			;----------------------------------------------------------------------------;
 E504  75 1C			; Display RAM row
 E506  5B			;
					POST_COL_1	POST_MEMORY, POST_CLR_VAL1 ; display RAM column, SI returned
											;  as POST_KB_OK (next string)
					CALL	OUT_SZ				; display '000 KB OK'
 E507  B1 04				POST_COL_END				; end post column
 E509  D3 E8				XOR	BX, BX				; BX = 0, segment and memory test counter
					MOV	ES, BX				; start at segment 0000
 E50B  50			ZERO_ALL_RAM:
					XOR	AX, AX				; zero AX
					ADD	BX, 16				; increment Memory count value
					CMP	BX, 100				; CF if two digit number
					ADC	AL, POST_COL_VT			; space inner column for 2 or 3 digits
 E50C  E4 21				CALL	MOVE_COL				; move to start of inner column
 E50E  50				MOV	AX, BX				; move RAM size to AX for display
 E50F  57				CALL	OUT_DECU				; display AX as decimal
 E510  BF 0067 R			MOV	AX, ES				; AX = last segment tested
 E513  26: 89 35			ADD	AX, 16 * 1024 SHR 4		; move to next 16K segment/block
 E516  26: 8C 5D 02			CMP	AX, DX				; is last segment of RAM?
 E51A  26: FF 1D			JNB	DONE_ZERO_ALL_RAM			; exit if end
 E51D  FA				MOV	ES, AX				; ES = last segment tested
 E51E  5F			
 E51F  58						IF RAM_TEST_LONG EQ 1
 E520  E6 21				JWB	ZERO_ALL_START			; skip long tests on warm boot
 E522				
 E522  5B			;----------------------------------------------------------------------------;
 E523  58			; Perform memory checks on this block
 E524  03 C3			;
 E526  8E D8			TEST_MEM_LONG:
 E528  3B C7				CALL	NMI_RESET				; clear NMI/parity flags
 E52A  72 BE				CALL	MEM_TEST				; read/write test on 16KB RAM block at ES
 E52C					JNZ	DETECT_MEMORY_ERR
 E52C  07			
 E52D  1F						IF RAM_PARITY EQ 1
 E52E  5D				XCHG	AX, DX				; save AX
 E52F  C3				IN	AL, PPI_C				; read PPI Port C
 E530					AND	AL, MASK PCPE OR MASK PCIE	; was there parity or NMI error?
					XCHG	AX, DX				; DL = parity error flag(s)
					JNZ	DETECT_MEMORY_ERR			; jump if parity error
							ENDIF				; END RAM_PARITY EQ 1
							ENDIF				; END RAM_TEST_LONG EQ 1
				
				;----------------------------------------------------------------------------;
				; Write 0's to all memory in this block
				;
				ZERO_ALL_START:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 84 - 1


					XOR	AX, AX 				; write zeros
					MOV	CX, 16 * 1024 / 2			; loop 16KB in WORDs
					XOR	DI, DI				; DI = beginning of segment
					REP	STOSW 				; write zero to next 16KB
 E530					JMP	SHORT ZERO_ALL_RAM
				DONE_ZERO_ALL_RAM:
 E530  52	POP	DS
 E531  51				POP	ES
 E532  56				RET
 E533  98			
 E534  99			;----------------------------------------------------------------------------;
 E535  8B F2			; Compare the result read from memory to the expected results to determine
 E537  86 C4			; which bit(s) did not match.
 E539  91			;
 E53A				; Error will be displayed as SEG:OFF BBBB.
 E53A  AD			;
 E53B  02 D0			; - SEG: location/bank in memory of the failed IC, which can be calculated
 E53D  02 D4			;   using the following:
 E53F  E2 F9			;   http://minuszerodegrees.net/5160/ram/5160_ram_201_error_breakdown.jpg
 E541  96			; - OFF: offset where the failure occurred
 E542  5E			; - BBBB: bit pattern difference between what was expected and what was 
 E543  59			;   read. This should reveal which IC in that bank failed.
 E544  5A			;----------------------------------------------------------------------------;
 E545  C3			; Input:
 E546				; 	DL = 0 if no parity error, bit 7 or 6 set if error
				;
				DETECT_MEMORY_ERR:
					POST_FLAG_SET  PMEM			; set POST Memory error flag
					CALL	CRLF					; start on new line
					POST_COL_1	POST_ERR_ERR, RED
					DEC	DI					; move back to last address
					DEC	DI
					XOR	AX, ES:[DI]				; determine incorrect bit(s)
					XCHG	AX, DI				; DI = bit pattern, AX = err offset
					MOV	BX, ES				; segment of error
					CALL	DWORD_HEX				; write address
					CALL	SPACE
					TEST	DL, DL				; was there a parity error?
 E546					JZ	DETECT_MEMORY_ERR_2		; jump if not
					PRINT_SZ  NMI_ERR_PAR			; print 'PARITY'
 E546  06				JMP	SHORT DETECT_MEMORY_ERR_DONE
 E547  1E			DETECT_MEMORY_ERR_2:
 E548  B8 ---- R			XCHG	AX, DI				; restore failed bit pattern
 E54B  8E D8				CALL	WORD_HEX
				DETECT_MEMORY_ERR_DONE:
					POST_COL_END
					JMP	SHORT DONE_ZERO_ALL_RAM
				
				DETECT_MEMORY ENDP
				
				;----------------------------------------------------------------------------;
				; Test Memory Address Lines on a 16KB block
				;----------------------------------------------------------------------------;
				; Write a byte to the first address in a segment and write a different
				; value with one address line toggled. Read back the values to ensure
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 85 - 1


				; they are both correct. Repeat 8 times for each starting bit.
				;
				; Input:
				;	ES = segment to test
				; Output:
				;	ZF if okay, NZ if fail
				;	BX = offset of failed byte/line, DI
				;
				; Clobbers AL
				;
				; Inspired by:
 E54D  B9 002D			; http://www.ganssle.com/testingram.htm
				; http://www.paul.de/tips/ramtest.htm
				; https://www.memtest86.com/tech_memtest-algoritm.html
				; Size: 38 bytes
 E550  BA 0400			;----------------------------------------------------------------------------;
 E553  8E C2			MEM_ADDR_TEST PROC
 E555					MOV	AL, 1					; pattern to rotate
 E555  E8 0082				XOR	BX, BX				; base address
 E558  75 07				MOV	DI, 2000H				; highest address in 16KB segment
 E55A  80 C6 04			MEM_ADDR_LOOP:
 E55D  8E C2				MOV	ES:[BX], AL				; write to base address
 E55F  E2 F4				NOT	AL					; invert value
 E561					MOV	ES:[DI], AL				; write inverted value
					NOT	AL					; revert value
					CMP	ES:[BX], AL				; is base value the same?
					JNZ	MEM_ADDR_ERR			; jump if not
					NOT	AL					; invert value again
					CMP	ES:[DI], AL				; is second value the same?
					JNZ	MEM_ADDR_ERR			; jump if not
					NOT	AL					; revert value again
					ROL	AL, 1					; walk test value
					SHR	DI, 1					; move to next address line
					JNZ	MEM_ADDR_LOOP			; loop until offset is 0
				MEM_ADDR_ERR:
					RET
				MEM_ADDR_TEST ENDP
				
				;----------------------------------------------------------------------------;
 E561  B1 06			; Test a 16KB block of Memory at ES:0000
 E563  D3 EA			;----------------------------------------------------------------------------;
				; Trivial read/write test - Write pattern RAM_TEST and reads it back, then 
 E565  89 16 0013 R		; repeat with inverse RAM_TEST. If NMI is on, this could trigger a parity
 E569  8C C2			; error.
				;
				; Input:
				; 	ES = segment to test
				;
				; Clobbers AX, CX, DI
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 86 - 1


 E56B  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 E56D  BE E4BC R	     1		MOV	SI, OFFSET POST_MEMORY
 E570  E8 1121		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
				;
 E573  E8 1177			; ZF and AX = 0 if pass, NZ if fail
				; Size: 22 bytes
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E576  E8 1159		     1		CALL	POST_END_COL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E579  33 DB			;----------------------------------------------------------------------------;
 E57B  8E C3			MEM_TEST PROC
 E57D					MOV	AX, RAM_TEST			; test pattern
 E57D  33 C0				CALL	MEM_CHECK
 E57F  83 C3 10				NOT	AX					; invert pattern
 E582  83 FB 64			
 E585  14 09			;----------------------------------------------------------------------------;
 E587  E8 1172			; Write and verify a 16KB block of Memory at ES:0000
 E58A  8B C3			;----------------------------------------------------------------------------;
 E58C  E8 1198			; Input:
 E58F  8C C0			;	AX = pattern to write
 E591  05 0400			; 	ES = segment for test
 E594  3B C2			;
 E596  73 0D			; ZF and AX = 0 if pass, NZ if fail
 E598  8E C0			;----------------------------------------------------------------------------;	
				MEM_CHECK PROC
					MOV	CX, 16 * 1024 / 2			; loop 16KB in WORDs
					XOR	DI, DI 				; start at offset 0
					REP	STOSW 				; write test pattern
				MEM_TEST_VERIFY:
					MOV	CH, HIGH (16 * 1024 / 2)	; restart loop 16KB in WORDs
					XOR	DI, DI 				; start at offset 0
					REPZ	SCASW 				; loop until CX = 0 OR WORD is not AX
					XCHG	AX, CX				; AX = 0 if success
					RET
				MEM_CHECK ENDP
				MEM_TEST ENDP
				
							IF POST_WARM_COLD EQ 1
				;----------------------------------------------------------------------------;
				; Display "WARM" or "COLD" boot
				;----------------------------------------------------------------------------;
				; Size: 39 bytes
				;----------------------------------------------------------------------------;
				POST_BOOT_TYPE PROC
					MOV	SI, OFFSET POST_BOOT		; BOOT string
					MOV	BL, POST_CLR_WARM			; attribute to warm color
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 87 - 1


					CALL	POST_START_COL_1			; display column label
											;  CX=POST_TAB_COL_I, SI=WARM string
 E59A					JWB	POST_BOOT_TYPE_OUT		; jump if warm boot
 E59A  33 C0				MOV	BL, POST_CLR_COLD			; attribute to cold color
 E59C  B9 2000				MOV	SI, OFFSET POST_COLD		; COLD string
 E59F  33 FF			POST_BOOT_TYPE_OUT:
 E5A1  F3/ AB				CALL	OUT_SZ_ATTR				; write string with attribute
 E5A3  EB D8				POST_COL_END_NL				; end of column end NL
 E5A5					RET
 E5A5  1F			
 E5A6  07			POST_BOOT	DB	'Boot', 0
 E5A7  C3			POST_WARM	DB	'WARM', 0
				POST_COLD	DB	'COLD', 0
				
				POST_BOOT_TYPE ENDP
							ENDIF
				
							IF POST_VIDEO_TYPE EQ 1
				;----------------------------------------------------------------------------;
				; Display Video Type
				;----------------------------------------------------------------------------;
				; Size: 109 bytes
				;----------------------------------------------------------------------------;
				POST_SYS_VIDEO PROC
					POST_COL_2	POST_VIDEO, POST_CLR_VAL1 ; display "Video" left column
											; default to "None"
				
				;----------------------------------------------------------------------------;
				; Check if INT 10 is using the BIOS. If so, must be CGA or MDA.
 E5A8				;
				; Necessary to check both segment and offset? (would save a few bytes if not)
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		SET1_BP   PMEM				; V20 only: SET1 BP, PMEM
			     1				ELSE
 E5A8  81 CD 0200	     1		OR	BP, MASK PMEM			; Set flag
			     1				ENDIF
 E5AC  E8 1167			;
					PUSH	DS
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW RED		; BH = 0, BL = attribute
			     1			ELSE
 E5AF  B3 0C		     1		MOV	BL, LOW RED		; BL = attribute
			     1			ENDIF
 E5B1  BE E8FC R	     1		MOV	SI, OFFSET POST_ERR_ERR
 E5B4  E8 10DD		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
 E5B7  4F				XOR	AX, AX				; AX = SEG _IVT
 E5B8  4F				MOV	DS, AX				; set IVT segment for LDS
 E5B9  26: 33 05					ASSUME DS:_IVT
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 88 - 1


 E5BC  97				LDS	AX, DWORD PTR _INT_10H		; if BIOS, DS = 0F000H, AX = 0F065H
 E5BD  8C C3				CMP	AX, OFFSET INT_10			; is offset the BIOS IRR for INT 10?
 E5BF  E8 1186				MOV	AX, DS				; save for next compare
 E5C2  E8 115A				POP	DS					; restore DS
 E5C5  84 D2						ASSUME DS:_BDA
 E5C7  74 08				JNE	CHECK_VGA				; jump to VGA check if not
					MOV	BX, CS				; AX = BIOS code segment
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <NMI_ERR_PAR>,<SI>			; if SZ is not SI
 E5C9  BE E82A R	     1		MOV	SI, OFFSET NMI_ERR_PAR
			     1			ENDIF
 E5CC  E8 111E		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E5CF  EB 04				CMP	AX, BX				; is segment BIOS?
 E5D1					JNE	CHECK_VGA
 E5D1  97			
 E5D2  E8 117F			;----------------------------------------------------------------------------;
 E5D5				; Read BDA for video type
				;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E5D5  E8 10FA		     1		CALL	POST_END_COL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E5D8  EB CB			BIOS_VIDEO:
					CALL	INT_10_IS_TXT			; CF = 1 if MDA mode 7
 E5DA					MOV	SI, OFFSET POST_MDA		; default "MDA"
					JC	POST_SYS_VIDEO_DONE
					MOV	SI, OFFSET POST_CGA		; otherwise "CGA"
					JMP	SHORT POST_SYS_VIDEO_DONE
				
				;----------------------------------------------------------------------------;
				; Check if VGA
				; stanislavs.org/helppc/int_10-1a.html
				;
				CHECK_VGA:
					MOV	AX, DBW <1AH, 0>			; AH = 1AH, get video display
					INT	10H					; BL = display type
					CMP	AL, 1AH				; is VGA?
					JNE	CHECK_EGA				; jump if not VGA
					MOV	SI, OFFSET POST_VGA		; is "VGA"
					JMP	SHORT POST_SYS_VIDEO_DONE
				
				;----------------------------------------------------------------------------;
				; Check if EGA
				; stanislavs.org/helppc/int_10-12.html
				;
				CHECK_EGA:
					MOV 	AH, 12H				; AH = 12H, get video configuration
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 89 - 1


 E5DA					MOV	BL, 10H				; configuration info
 E5DA  B0 01				INT	10H
 E5DC  33 DB				CMP	BL, 10H				; check if param hasn't changed
 E5DE  BF 2000				JE	POST_SYS_VIDEO_DONE		; jump if not EGA
 E5E1					MOV	SI, OFFSET POST_EGA		; is "EGA"
 E5E1  26: 88 07		
 E5E4  F6 D0			POST_SYS_VIDEO_DONE:
 E5E6  26: 88 05			CALL	OUT_SZ				; display detected video adapter
 E5E9  F6 D0				POST_COL_END_NL
 E5EB  26: 38 07			RET
 E5EE  75 0F			
 E5F0  F6 D0			POST_MDA		DB	'Mono', 0
 E5F2  26: 38 05		
 E5F5  75 08			POST_SYS_VIDEO ENDP
 E5F7  F6 D0							ENDIF
 E5F9  D0 C0			
 E5FB  D1 EF			;
 E5FD  75 E2			; 5 BYTES HERE
 E5FF				;
 E5FF  C3			BYTES_HERE	INT_19
 E600				
				;----------------------------------------------------------------------------;
				; INT 19 - Bootstrap Loader
				;----------------------------------------------------------------------------;
				; IPL: track 0, sector 1 is loaded into address 0:7C00 and control 
				; is transferred.
				;
				; Input:
				; 	DL = physical drive where boot sector is located (00=A:,80h=C:)
				; Output:
				;	Transfer control to bootable MBR if success
				;	IRET if failure
				;
				; Clobbers AX, BX, CX, DH, DI, DS, ES
				;----------------------------------------------------------------------------;
						ORG 0E6F2H
				INT_19 PROC
 E600							ASSUME DS:_IPL_SEG, ES:_IPL_SEG
 E600  B8 95A5				STI						; enable interrupts
 E603  E8 0002				CLD						; clear direction for STOS
 E606  F7 D0				XOR	CX, CX				; CX = 0
					MOV	DS, CX				; DS = IPL Segment (0000)
					MOV	ES, CX				; ES = IPL Segment (0000)
					MOV	DI, OFFSET _INT_1EH		; INT 1E vector table address
					MOV	AX, OFFSET INT_1E 		; INT 1E DBT address
					STOSW
					MOV	AX, CS				; INT 1E DBT segment
					STOSW
				INT_19_READ_MBR:
					XCHG	AX, CX				; AH = 0 (reset)
					INT	13H					; reset disk 0
 E608					JC	INT_19_IPL_FAIL			; exit if error
 E608  B9 2000				MOV	AX, DBW <2, 1>			; AH = 2 (read), AL = 1 sector
 E60B  33 FF				MOV	BX, OFFSET IPL_TOP		; ES:BX = IPL boot sector offset
 E60D  F3/ AB				MOV	CX, DBW <0, 1>			; CH = cyl 0, CL = sec 1
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 90 - 1


 E60F					XOR	DH, DH 				; DH = head 0
 E60F  B5 20				INT	13H					; read 1 sector into ES:BX
 E611  33 FF				JC	INT_19_IPL_FAIL			; exit if error
 E613  F3/ AF						IF MBR_CHECK EQ 1
 E615  91				CMP	IPL_ID, MAGIC_WORD		; verify bootable MBR signature
 E616  C3				JNZ	INT_19_IPL_FAIL			; jump if MBR not bootable
 E617							ENDIF
 E617					JMP 	FAR PTR IPL_TOP 			; jump to IPL segment and boot!
				INT_19_IPL_FAIL:
					IRET
				INT_19 ENDP
				
						IF POST_HD_CHECK EQ 1
				;----------------------------------------------------------------------------;
				;  Get Hard Drive Parameters
 E617				;----------------------------------------------------------------------------;
 E617  BE E62F R		;  Input:
 E61A  B3 04			;	DL = drive number
 E61C  E8 1075			;  Output:
				; 	CF if Error
				;	AL = number of heads (AX if no error)
			     1				IF WARM_ENABLE EQ 1
 E61F  85 ED		     1		TEST	BP, BP				; is warm boot?
 E621  78 05		     1		JS	POST_BOOT_TYPE_OUT					; jump if so
			     1				ENDIF
 E623  B3 09			; 	AH = return code
 E625  BE E639 R		;	BX = last cylinder
 E628				; 	CX = logical last index of sectors/track
 E628  E8 10B0			;	DX = number of hard disk drives (all)
				;----------------------------------------------------------------------------;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E62B  E8 109F		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E62E  C3			GET_DISK_PARAMS PROC
					MOV	AH, 8 			; Get Drive in DL Parameters: 
 E62F 42 6F 6F 74 00			INT	13H				;  CH = Last cyl, CL = # cylinders
 E634 57 41 52 4D 00								;  DH = heads, DL = # drives
 E639 43 4F 4C 44 00								;  ES:DI = drive table
					JC	GET_DISK_PARAMS_ERR 	; if error, exit
 E63E					MOV	BX, CX 			; BX = last cylinder
					XCHG	BH, BL 			; swap bytes
					ROL	BH, 1 			; rotate high two bits into low bits
					ROL	BH, 1
					AND	BH, 11B			; BX = cylinder (10 bits)
					AND	CX, 00111111B		; CX = logical last index of sectors/track
					MOV	AL, DH
					INC	AX				; convert heads to 1 index (count)
					INC	BX				; convert cylinders to 1 index
 E63E					XOR	DH, DH			; clear high byte of DX, CF = 0
				GET_DISK_PARAMS_ERR:
			     1			IFNB	<>
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 91 - 1


			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 E63E  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 E640  BE F93F R	     1		MOV	SI, OFFSET POST_VIDEO
 E643  E8 1075		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
					RET
				GET_DISK_PARAMS ENDP
						ENDIF
				
				;
				; 0 BYTES HERE
				;
 E646  1E			BYTES_HERE	INT_14
 E647  33 C0			
 E649  8E D8			;----------------------------------------------------------------------------;
				; INT 14 - BIOS COM Port Services
 E64B  C5 06 0040 R		;----------------------------------------------------------------------------;
 E64F  3D F065 R		;	INT 14,0  Initialize serial port parameters
 E652  8C D8			;	INT 14,1  Send/write character in AL
 E654  1F			;	INT 14,2  Receive/read character in AL
				;	INT 14,3  Get Serial port status
 E655  75 13			;
 E657  8C CB			; All functions have:
 E659  3B C3			;	  AH = function number
 E65B  75 0D			;	  AL = character to send or receive
				;	  DX = zero based RS232 card number
				;
				; All registers call-preserved (except AX)
				;----------------------------------------------------------------------------;
 E65D				; Ref:
 E65D  E8 0A25			; https://stanislavs.org/helppc/int_14.html
 E660  BE E68D R		;----------------------------------------------------------------------------;
 E663  72 21					ORG 0E739H
 E665  BE F7B7 R		INT_14 PROC
 E668  EB 1C						ASSUME DS:_BDA
					STI 					; enable interrupts
					PUSH	CX 				; call-preserve CX
					MOV	CX, 3 			; will use this 3 in multiple places
					CMP	DX, CX			; is less than 4?
					JA	INT_14_EXIT 		; if not, exit
 E66A					PUSH	DI 				; call-preserve registers used
 E66A  B8 1A00				PUSH	BX
 E66D  CD 10				PUSH	DX
 E66F  3C 1A				PUSH	DS
 E671  75 05				MOV	DI, SEG _BDA 		; DS = BDA
 E673  BE F7AF R			MOV	DS, DI
 E676  EB 0E				MOV	DI, DX 			; DI = COM port index (0-3)
					SHL	DI, 1 			; convert to word index
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 92 - 1


					MOV	DX, [DI] 			; DX = 3F8/2F8 base port address
					SHR	DI, 1 			; back to byte index
					TEST	DX, DX 			; is port index valid (detected)?
					JZ	INT_14_DONE 		; if not, exit
 E678					CMP	AH, CL			; check function number (CL = 3)
 E678  B4 12				JA	INT_14_DONE			; > 3? Not valid
 E67A  B3 10				JZ 	INT_14_3	 		; = 3 then status
 E67C  CD 10				CMP	AH, 1				; check remaining functions
 E67E  80 FB 10				JA	INT_14_2 			; = 2 then read
 E681  74 03				JZ	INT_14_1 			; = 1 then write
 E683  BE F7B3 R								; = 0 fall through to init
				
 E686				;----------------------------------------------------------------------------;
 E686  E8 1064			; INT 14,0  Initialize serial port parameters
				;----------------------------------------------------------------------------;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 E689  E8 1041		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 E68C  C3			; https://stanislavs.org/helppc/int_14-0.html
				; https://stanislavs.org/helppc/8250.html
 E68D 4D 6F 6E 6F 00		;----------------------------------------------------------------------------;
				; Baud rate divisor table:
 E692				;	0 (000) = 110 baud -> 417H	|	4 (100) = 1200 baud -> 60H
				;	1 (001) = 150 baud -> 300H	|	5 (101) = 2400 baud -> 30H
				;	2 (010) = 300 baud -> 180H	|	6 (110) = 4800 baud -> 18H
				;	3 (011) = 600 baud -> 0C0H	|	7 (111) = 9600 baud -> 0CH
				;
				; Formula:
				;	if (baud == 110) then
 E692			     1			LOCAL LBL
			     1	
 = 0060			     1	BYTES_HERE_INT_19 = INT_19-$
			     1	
			     1			IFDEF BYTES_HERE_INT_19
			     1			IF2
			     1			IF BYTES_HERE_INT_19 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_19 (BYTES_HERE_INT_19)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				; 		divisor = 417H
				;	else
				;		divisor = 600H >> index
				;----------------------------------------------------------------------------;
				; Input:
				;	DX = base port address
				;	AL = port params, AH = 0
				;	CX = 3 (from earlier)
				;----------------------------------------------------------------------------;
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 93 - 1


				INT_14_0 PROC
				;----------------------------------------------------------------------------;
				; Set baud rate
				;
					MOV	DI, DX 			; DX = 3F8/2F8 base port
					ADD	DX, CX			; DX = 3FB/2FB - Line Control Register (LCR), CX = 3
 E6F2					XCHG	AX, BX			; save port params to BL
					MOV	AL, MASK DLAB 		; set baud rate divisor (DLAB); 0 = RBR, THR or IER
 E6F2  FB				OUT	DX, AL 			; write to 3FB/2FB (LCR)
 E6F3  FC				SHL	BX, CL 			; BH = baud rate, CL = 3
 E6F4  33 C9				SHR	BL, CL 			; BL = flags
 E6F6  8E D9				MOV	AX, 417H 			; divisor for 110 baud
 E6F8  8E C1				MOV	CL, BH 			; CL = shift counter or 0 for 110 baud (CH = 0)
 E6FA  BF 0078 R			JCXZ	INT_14_0_SET_BAUD		; Jump if 110 baud
 E6FD  B8 EFC7 R			MOV	AX, 600H 			; AX = divisor base (see above formula)
 E700  AB				SHR	AX, CL			; divisor = 600H >> CL
 E701  8C C8			INT_14_0_SET_BAUD:
 E703  AB				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4)
 E704										; AL = Divisor LSB, AH = Divisor MSB (4)
 E704  91				OUT	DX, AX			; write LSB, then MSB to ports 3F8/3F9
 E705  CD 13			;----------------------------------------------------------------------------;
 E707  72 14			; Set parity, stop and word bits
 E709  B8 0201			; 
 E70C  BB 7C00 R		INT_14_0_SET_PSW:
 E70F  B9 0001				XCHG	AX, BX 			; AL = parity, stop and word bits (4)
 E712  32 F6				XCHG	DX, DI 			; DX = 3FB/2FB, DI = 3F8/2F8 (4)
 E714  CD 13				OUT	DX, AL			; set LCR parity, stop and word bits
 E716  72 05				XCHG	DX, DI 			; DX = 3F8/2F8, DI = 3FB/2FB (4)
				;----------------------------------------------------------------------------;
				; Disable IER
				;
					XOR	AX, AX 			; AL = 0 (3)
 E718  EA ---- 7C00 R			INC	DX 				; DX = 3F9/2F9 (3)
 E71D					OUT	DX, AL			; DX = 3F9 - Interrupt Enable Register (IER) disabled
 E71D  CF				DEC	DX 				; DX = 3F8 (3)
 E71E										; fall through to get status
				
				;----------------------------------------------------------------------------;
				; INT 14,3  Get Serial port status
				;----------------------------------------------------------------------------;
				; Input:
				; 	DX = base port address
				; Output:
				;	AH = port status
				;	AL = modem status
				;----------------------------------------------------------------------------;
				INT_14_3 PROC
					ADD	DX, 5 			; DX = 3FD/2FD LSR - Line Status Register
					PUSH	BX				; delay for I/O
					IN	AL, DX 			; get line/port status 
					XCHG	AH, AL 			; save to AH
 E71E					INC	DX 				; DX = 3FE/2FE MSR - Modem Status Register
 E71E  B4 08				POP	BX 				; delay for I/O
 E720  CD 13				IN	AL, DX 			; get modem status 
				INT_14_3 ENDP
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 94 - 1


				
 E722  72 14			INT_14_DONE PROC
 E724  8B D9				POP	DS 				; restore all registers
 E726  86 FB				POP	DX
 E728  D0 C7				POP	BX
 E72A  D0 C7				POP	DI
 E72C  80 E7 03			INT_14_EXIT PROC
 E72F  83 E1 3F				POP	CX
 E732  8A C6				IRET
 E734  40			INT_14_EXIT ENDP
 E735  43			INT_14_DONE ENDP
 E736  32 F6			
 E738				INT_14_0 ENDP
 E738  C3			
 E739				;----------------------------------------------------------------------------;
				; INT 14, 1 - Send/write character in AL
				;----------------------------------------------------------------------------;
				; Input:
				; 	DX = base port address
				;	BL = port timeout
				;----------------------------------------------------------------------------;
 E739			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_14 = INT_14-$
			     1	
			     1			IFDEF BYTES_HERE_INT_14
			     1			IF2
			     1			IF BYTES_HERE_INT_14 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_14 (BYTES_HERE_INT_14)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				INT_14_1 PROC
					PUSH	DX 					; save base port
					PUSH	AX
					ADD	DX, 4 				; DX = 3FC/2FC - Modem Control Register
					MOV	AL, MASK RTS OR MASK DTR	; activate DTR & RTS
					OUT	DX, AL				; set DTR or RTS
					INC	DX
					INC	DX 					; DX = 3FE - Modem Status Register
					MOV	BX, DBW <MASK THRE OR MASK LBI, MASK MDSR> ; BH = line (THRE)
											;  BL = modem (DSR/CTS)
					CALL	INT_14_POLL 			; poll both registers, AH = status
					POP	BX
					MOV	AL, BL 				; AL = output char
					POP	DX 					; restore base port
					JNZ	INT_14_RW_ERR			; Jump if port timeout
					OUT	DX, AL
					JMP	SHORT INT_14_DONE
				INT_14_RW_ERR:
					OR	AH, 10000000B			; set error bit
					JMP	SHORT INT_14_DONE
 E739				INT_14_1 ENDP
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 95 - 1


 E739  FB			;----------------------------------------------------------------------------;
 E73A  51			; INT 14, 2 - Receive/read character in AL
 E73B  B9 0003			;----------------------------------------------------------------------------;
 E73E  3B D1			; Input:
 E740  77 56			;	DX = base port address
 E742  57			;	BL = port timeout
 E743  53			; Output:
 E744  52			;	AH = port status
 E745  1E			;	AL = character read
 E746  BF ---- R		;	NZ = timeout or failure occurred
 E749  8E DF			;
 E74B  8B FA			; Clobbers: BX
 E74D  D1 E7			;----------------------------------------------------------------------------;
 E74F  8B 15			INT_14_2 PROC
 E751  D1 EF				PUSH	DX 					; save base port
 E753  85 D2				ADD	DX, 4 				; DX = 3FC/2FC - Modem Control Register
 E755  74 3D				MOV	AL, MASK DTR			; activate DTR
 E757  38 CC				OUT	DX, AL				; set DTR
 E759  77 39				INC	DX
 E75B  74 2D				INC	DX 					; DX = 3FE/2FE - Modem Status Register
 E75D  80 FC 01				MOV	BX, DBW <MASK MDSR, MASK LDR>	; BH = modem (DSR), BL = line (data ready)
 E760  77 56				CALL	INT_14_POLL 			; poll both registers, AH = status
 E762  74 36				POP	DX 					; restore base port
					AND	AH, MASK LBI OR MASK LFE OR MASK LPE OR MASK LOE ; include only 
											;  error bits in port status
					IN	AL, DX				; read char from buffer
					JMP	SHORT INT_14_DONE
				INT_14_2 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 14 - Poll line then modem status registers
				;----------------------------------------------------------------------------;
				; Input:
				;	DI = port index (0 based byte)
				; 	DX = 3FE Modem Status Register
				;	BL = line status expected masked
				;	BH = modem status expected masked
				; Output:
				;	AH = port status
				;	DX = 3FD Line Status Register
				;	NZ = timeout or failure occurred
				;
				; Clobbers: AX, CX
				;----------------------------------------------------------------------------;
				INT_14_POLL PROC
					CALL	INT_14_POLL_PORT 		; first poll modem status
					JNZ	INT_14_POLL_RET  		; jump if ZF = 0, timeout or failure occurred
					XCHG	BH, BL 			; BH = line status
					DEC	DX				; DX = 3FD Line Status Register (LSR)
 E764				
				;----------------------------------------------------------------------------;
				; INT 14 - Poll status register in DX
				;----------------------------------------------------------------------------;
 E764  8B FA			INT_14_POLL_PORT PROC
 E766  03 D1				PUSH	SI 				; call-preserve SI
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 96 - 1


 E768  93				XOR	CX, CX			; reset poll loop counter
 E769  B0 80				MOV	AL, COM_TIME_B[DI]	; AL = port timeout (< 127)
 E76B  EE				CBW					; clear high byte of AX for move to SI
 E76C  D3 E3				XCHG	AX, SI 			; SI = port timeout
 E76E  D2 EB			INT_14_POLL_LOOP:
 E770  B8 0417				IN	AL, DX 			; check port status
 E773  8A CF				MOV	AH, AL 			; save to AH
 E775  E3 05				XOR	AL, BH 			; mask result bits
 E777  B8 0600				TEST	AL, BH 			; did it match expected result?
 E77A  D3 E8				JZ	INT_14_POLL_DONE
 E77C					LOOP	INT_14_POLL_LOOP		; poll port 65,535 * timeout times
 E77C  87 D7				DEC	SI 				; 
					JNZ	INT_14_POLL_LOOP		; Jump if timeout not expired
 E77E  EF			INT_14_POLL_DONE:
					POP	SI
				INT_14_POLL_RET:
					RET
 E77F				INT_14_POLL_PORT ENDP
 E77F  93			INT_14_POLL ENDP
 E780  87 D7			
 E782  EE			INT_14 ENDP
 E783  87 D7			
				;----------------------------------------------------------------------------;
				; I/O port register test
				;----------------------------------------------------------------------------;
 E785  33 C0			; Do a Walking Bit/March test on I/O port registers.
 E787  42			;
 E788  EE			; Input:
 E789  4A			;	DX = starting port
				;	BH = number of sequential ports to test
				; Output:
				;	ZF and CX = 0 if success
				;	NZ if failed
				;
				; Adapted from:
				; https://barrgroup.com/embedded-systems/how-to/memory-test-suite-c
				; https://www.edaboard.com/threads/walking-1-0-test-for-memory-bist.241278/
				;
				; Size: 47 bytes
				; Clobbers AX, BX, CX, DX, DI
 E78A				;----------------------------------------------------------------------------;
 E78A  83 C2 05			PORT_TEST PROC
 E78D  53				MOV	AH, 1				; start with low order bit
 E78E  EC				XOR	CX, CX			; clear counter
 E78F  86 E0				MOV	DI, DX			; save starting port
 E791  42			
 E792  5B			;----------------------------------------------------------------------------;
 E793  EC			; Write a single 1 bit to a different position in each register
 E794				;
				WB_WRITE_1:
 E794					MOV	CL, BH			; register counter
 E794  1F				MOV	DX, DI 			; start at first register
 E795  5A				MOV	AL, AH			; AL = starting bit to write
 E796  5B			WB_WRITE_LOOP:
 E797  5F				OUT	DX, AL			; write to low byte
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 97 - 1


 E798					IO_DELAY_SHORT
 E798  59				OUT	DX, AL			; write to high byte
 E799  CF				INC	DX				; next register/port
 E79A					ROL	AL, 1				; walk bit to next position
 E79A					LOOP	WB_WRITE_LOOP
				
 E79A				;----------------------------------------------------------------------------;
				; Read back bit pattern from each register
				;
					MOV	CL, BH			; register counter
					MOV	DX, DI 			; start at first register
					MOV	BL, AH			; BL = starting bit to compare
				WB_READ_LOOP:
					IN	AL, DX			; read low byte
					CMP	AL, BL			; compare to correct bit
 E79A					JNZ	PORT_TEST_DONE		; jump if not okay
 E79A  52			WB_LOW_CHECK_OK:
 E79B  50				IN	AL, DX			; read high byte
 E79C  83 C2 04				CMP	AL, BL			; compare to correct bit
 E79F  B0 03				JNZ	PORT_TEST_DONE		; jump if not okay
 E7A1  EE				INC	DX				; next register/port
 E7A2  42				ROL	BL, 1				; rotate for next register/bit
 E7A3  42				LOOP	WB_READ_LOOP		; loop all eight registers
 E7A4  BB 3020				SHL	AH, 1				; rotate to next starting bit
					JNZ	WB_WRITE_1			; loop until AH = 0
 E7A7  E8 0024			PORT_TEST_DONE:
 E7AA  5B				RET
 E7AB  8A C3			PORT_TEST ENDP
 E7AD  5A			
 E7AE  75 03			;----------------------------------------------------------------------------;
 E7B0  EE			; Reset NMI enable flags
 E7B1  EB E1			;----------------------------------------------------------------------------;
 E7B3				; Output:
 E7B3  80 CC 80			;	AL = current PPI B flags
 E7B6  EB DC			;
 E7B8				; Size: 11 bytes
				;----------------------------------------------------------------------------;
				NMI_RESET PROC
					IN	AL, PPI_B				; read current flags
					OR	AL, MASK PBIO OR MASK PBPC	; parity, I/O flags high (disable)
					OUT	PPI_B, AL				; write to PPI
					XOR	AL, MASK PBIO OR MASK PBPC	; flags low (enable)
					OUT	PPI_B, AL				; write to PPI
					RET
				NMI_RESET ENDP
				NMI_ERR_IO		DB	'IO'			; NMI I/O Error string
				NMI_ERR_PAR		DB	'PAR', 0		; NMI Parity Error
				
				;
				; 0 BYTES HERE
 E7B8				;
 E7B8  52			BYTES_HERE	INT_16
 E7B9  83 C2 04			
 E7BC  B0 01			;----------------------------------------------------------------------------;
 E7BE  EE			; INT 16 - Keyboard BIOS Services
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 98 - 1


 E7BF  42			;----------------------------------------------------------------------------;
 E7C0  42			;	INT 16,0   Wait for keystroke and read
 E7C1  BB 2001			;	INT 16,1   Get keystroke status
 E7C4  E8 0007			;	INT 16,2   Get shift status
 E7C7  5A			;----------------------------------------------------------------------------;
 E7C8  80 E4 1E					ORG 0E82EH
				INT_16 PROC
 E7CB  EC					ASSUME DS:_BDA
 E7CC  EB C6				STI
 E7CE					CLD
					PUSH	DS
					PUSH	SI
					MOV	SI, SEG _BDA
					MOV	DS, SI 			; DS = BDA segment
					CMP	AH, 2
					JE	KB_SHIFT_STATUS 		; AH = 2 - Get Shift Status
					JA	INT_16_DONE			; AH > 2 - Not valid, exit
					JNP	KB_WAIT_READ_1		; AH = 0 - Wait for keystroke and read
										; AH = 1 - Get Keystroke (fall through)
				
				;----------------------------------------------------------------------------;
				; AH = 1 - Get keystroke status
				;----------------------------------------------------------------------------;
				; Check if a key press is in buffer and return. Does not wait or remove.
				; Output:
				;	ZF = 0 if a key pressed (even Ctrl-Break)
 E7CE				;	AH = scan code
 E7CE  E8 0005			;	AL = ASCII character or zero if special function key
 E7D1  75 1A			;----------------------------------------------------------------------------;
 E7D3  86 FB			; Note: many PC references refer to the "read" pointer as "head" and "write"
 E7D5  4A			; pointer as "tail". This seems backwards (to me) and their typical definition
				; in a circular buffer. For the purposes of being consistent with the PC
				; termonology, "head" and "tail" are defined as:
				;	KB_BUF_HD (1Ah) = "head" next character stored in keyboard buffer
				;	KB_BUF_TL (1Ch) = "tail" next spot available in keyboard buffer
 E7D6				;----------------------------------------------------------------------------;
 E7D6  56			KB_KEY_STATUS PROC
 E7D7  33 C9				MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr
 E7D9  8A 45 7C				CLI 					; disable interrupts
 E7DC  98				LODSW 				; AX = head, SI = tail ptr
 E7DD  96				CMP	AX, [SI]	 		; head == tail?
 E7DE					JNE	KB_BUF_HAS_KEY 		; if not, buffer has a key
 E7DE  EC			KB_KEY_STATUS_DONE:
 E7DF  8A E0				STI					; re-enable interrupts
 E7E1  32 C7				POP	SI
 E7E3  84 C7				POP	DS
 E7E5  74 05				IRET_F				; IRET with current flags
 E7E7  E2 F5			KB_BUF_HAS_KEY:
 E7E9  4E				XCHG	AX, SI 			; SI = head
 E7EA  75 F2				LODSW 				; AX = buffer[head], SI = next
 E7EC					JMP	KB_KEY_STATUS_DONE
 E7EC  5E			KB_KEY_STATUS ENDP
 E7ED				
 E7ED  C3			;----------------------------------------------------------------------------;
 E7EE				; AH = 0 - Wait for keystroke and read
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 99 - 1


 E7EE				;----------------------------------------------------------------------------;
				; Wait until keystroke is in buffer. Key press is removed from buffer.
 E7EE				; Output:
				;	AH = scan code
				;	AL = ASCII code
				;----------------------------------------------------------------------------;
				KB_WAIT_READ PROC
					STI					; enable interrupts
						IF KB_HLT_WAIT EQ 1
					HLT					; wait for keystroke interrupt
						ELSE
					NOP					; wait for any interrupt
						ENDIF
				KB_WAIT_READ_1:
					MOV	SI, OFFSET KB_BUF_HD 	; SI = head ptr
					CLI 					; disable interrupts again
					LODSW 				; AX = head, SI = tail ptr
					CMP	AX, [SI] 			; head == tail?
					JE	KB_WAIT_READ 		; if so, buffer is empty
					XCHG	AX, SI 			; SI = tail
					LODSW 				; AX = buffer[tail], SI = next
					CMP	SI, KB_BUF_END_B		; is next >= end of buffer?
					JB	KB_GET_READ 		; if not, get tail value
 E7EE					MOV	SI, OFFSET KB_BUF 	; otherwise, wrap next to buffer top
 E7EE  B4 01			KB_GET_READ:
 E7F0  33 C9				MOV	KB_BUF_HD, SI 		; head ptr = next
 E7F2  8B FA			INT_16_DONE:
					POP	SI
					POP	DS
					IRET
				KB_WAIT_READ ENDP
 E7F4				
 E7F4  8A CF			;----------------------------------------------------------------------------;
 E7F6  8B D7			; AH = 2 - Get shift status
 E7F8  8A C4			;----------------------------------------------------------------------------;
 E7FA				; Read Keyboard Flags
 E7FA  EE			; Output:
				;	AL = BIOS keyboard flags (from BDA 0040:0017)
			     1			LOCAL _DONE
			     1				IF ARCH_TYPE NE ARCH_EMU
 E7FB  EB 00		     1		JMP	SHORT ??0016
 E7FD			     1	??0016:
			     1				ENDIF
 E7FD  EE			;----------------------------------------------------------------------------;
 E7FE  42			KB_SHIFT_STATUS PROC
 E7FF  D0 C0				MOV	AL, KB_FLAGS1
 E801  E2 F7				JMP	SHORT INT_16_DONE
				KB_SHIFT_STATUS ENDP
				
				INT_16 ENDP
				
 E803  8A CF			;----------------------------------------------------------------------------;
 E805  8B D7			; Repeats LONG_BEEPs then SHORT_BEEPs indefinetly
 E807  8A DC			;----------------------------------------------------------------------------;
 E809				; Input:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 100 - 1


 E809  EC			;	BL low nibble = long beeps
 E80A  38 D8			;	BL high nibble = short beeps
 E80C  75 0E			;
 E80E				; Note: must use LOOP for beep since BEEP could occur if PIT is not working
 E80E  EC			; Note 2: cannot use stack since HALT_BEEP could occur before stack
 E80F  38 D8			;
 E811  75 09			; Size: 60 bytes
 E813  42			;----------------------------------------------------------------------------;
 E814  D0 C3			HALT_BEEP PROC NEAR
 E816  E2 F1				MOV	DX, CS 				; SS to CS
 E818  D0 E4				MOV	SS, DX				; for CALL_NS
 E81A  75 D8				XCHG	AX, BX				; beep pattern to AL
 E81C					DB	0D4H, 10H				; AAM 10H ; split nibbles
 E81C  C3				XCHG	AX, BP				; BP(H) = short beeps, BP(L) = long beeps
 E81D				HALT_BEEP_START:
					MOV	DX, BP 				; restore original beep pattern
					MOV	SI, BEEP_ERR_LOW			; low C5
					XOR	CX, CX				; low beep on 100%
				HALT_BEEP_START_ODD:
					MOV	DI, CX				; save counter length
				HALT_BEEP_REP:
					MOV	AX, SI				; restore beep tone
					CALL_NS  BEEP_ON_P, 1			; turn on speaker / beep
					MOV	CX, DI				; restore counter
 E81D					IO_DELAY					; delay for beep
 E81D  E4 61				CALL_NS  BEEP_OFF_P, 1			; turn off speaker
 E81F  0C 30				SUB	CX, DI				; set for remainder of counter
 E821  E6 61				IO_DELAY					; delay for silence
 E823  34 30				DEC	DL					; dec beep repeat count
 E825  E6 61				JNZ	HALT_BEEP_REP			; jump if more of this length
 E827  C3				XCHG	DL, DH				; swap beep counts
 E828					TEST	DX, DX				; both cycles done?
 E828 49 4F				JZ	HALT_BEEP_START			; if so, restart beep pattern
 E82A 50 41 52 00			MOV	CH, 100H * 1/3			; else, short beep on 33%
					MOV	SI, BEEP_ERR_HIGH			; high F5
					JMP	SHORT HALT_BEEP_START_ODD	; start short cycle
				HALT_BEEP ENDP
				
				;----------------------------------------------------------------------------;
 E82E			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_16 = INT_16-$
			     1	
			     1			IFDEF BYTES_HERE_INT_16
			     1			IF2
			     1			IF BYTES_HERE_INT_16 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_16 (BYTES_HERE_INT_16)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				; Make a beepin' beep
				;----------------------------------------------------------------------------;
				; Play a (correctly pitched) A6 for 250ms
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 101 - 1


				BEEP PROC
					PUSH	AX
					BEEP_ON
					MOV	AX, 250			; 1/4 second pause
					CALL	IO_DELAY_MS
 E82E					BEEP_OFF
					POP	AX
 E82E  FB				RET
 E82F  FC			BEEP ENDP
 E830  1E			
 E831  56			;----------------------------------------------------------------------------;
 E832  BE ---- R		; Two very short beeps
 E835  8E DE			; Size: 27 bytes
 E837  80 FC 02			; Output: CX = 0
 E83A  74 33			;----------------------------------------------------------------------------;
 E83C  77 2E						IF IS_TURBO
 E83E  7B 15			MEEP_DELAY	EQU	40H
							ELSE
				MEEP_DELAY	EQU	20H
							ENDIF
				MEEPMEEP PROC
					CALL MEEP
				
				;----------------------------------------------------------------------------;
				; One very short beep
				;----------------------------------------------------------------------------;
				MEEP PROC
					PUSH	AX
					BEEP_ON
					MOV	CH, MEEP_DELAY
					IO_DELAY				; delay while beeping
					BEEP_OFF
					MOV	CH, MEEP_DELAY
					IO_DELAY				; delay between beeps
					POP	AX
 E840					RET
 E840  BE 001A R		MEEP ENDP
 E843  FA			MEEPMEEP ENDP
 E844  AD			
 E845  3B 04			;----------------------------------------------------------------------------;
 E847  75 06			; Turn on speaker at given tone
 E849				;----------------------------------------------------------------------------;
 E849  FB			; Input:
 E84A  5E			; 	AX = TONE
 E84B  1F			;
				; http://www.cs.binghamton.edu/~reckert/220/8254_timer.html
 E84C  CA 0002		     1		RETF	2
 E84F				;
 E84F  96			; Clobbers BX
 E850  AD			; Cannot use stack since this could be called before it is working.
 E851  EB F6			;----------------------------------------------------------------------------;
 E853				BEEP_ON_P PROC
					XCHG	AX, BX				; save tone to BX
					MOV	AL, PIT_CW <2, 11B, 3>		; Select Timer 2, LE, Mode 3 (square)
					OUT	PIT_CTRL, AL			; Send to PIT control word (43H)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 102 - 1


					XCHG	AX, BX				; restore tone
				BEEP_ON_1 PROC
					OUT	PIT_CH2, AL				; send low byte to timer
					MOV	AL, AH 				; select high byte
					OUT	PIT_CH2, AL				; send high byte to timer
					IN	AL, PPI_B				; read current PPI port B status
 E853					OR	AL, MASK PBSP OR MASK PBST	; turn on speaker bits
 E853  FB				OUT	PPI_B, AL				; write back to port B
					RET
 E854  F4			BEEP_ON_1 ENDP
				BEEP_ON_P ENDP
				
				;----------------------------------------------------------------------------;
 E855				; Turn off speaker
 E855  BE 001A R		;
 E858  FA			; Clobbers: AX
 E859  AD			;----------------------------------------------------------------------------;
 E85A  3B 04			BEEP_OFF_P PROC
 E85C  74 F5				IN	AL, PPI_B				; read current PPI port B status
 E85E  96				AND	AL, NOT (MASK PBSP OR MASK PBST)	; turn off speaker bits
 E85F  AD				OUT	PPI_B, AL				; write back to port B
 E860  83 FE 3E				RET
 E863  72 03			BEEP_OFF_P ENDP
 E865  BE 001E R		
 E868				;----------------------------------------------------------------------------;
 E868  89 36 001A R		; Display all POST messages
 E86C				;----------------------------------------------------------------------------;
 E86C  5E			; See PFLAGS
 E86D  1F			; Output: BP (high byte) = 0
 E86E  CF			; Clobbers: AX, CX, SI
 E86F				; Size: 22 bytes
				;----------------------------------------------------------------------------;
				
				;----------------------------------------------------------------------------;
				; POST Error Strings
				;
				POST_ERR		DB	CR, LF, 'POST '	; POST Error
				POST_ERR_ERR	DB	'Error ', 0		; Error
				POST_ERR_PKI	DB	'KB',   0		; Reset returned non-success "301"
 E86F				POST_ERR_PKEY	DB	'Key',  0		; Reset did not clear KBC
 E86F  A0 0017 R		POST_ERR_PFDC	DB	'FDC',  0		; General FD init failure
 E872  EB F8			POST_ERR_PDMA	DB	'DMA',  0		; DMA TC0 error
 E874				
				;----------------------------------------------------------------------------;
 E874				; POST String Vectors - indexed by PFLAGS
				;
				POST_ERRORS LABEL WORD
					DW	OFFSET POST_ERR_PKI		; PKI  : Keyboard Interrupt Error
					DW	OFFSET POST_ERR_PKEY		; PKEY : Keyboard Key Stuck
					DW	OFFSET POST_ERR_PFDC		; PFDC : FDC Init Failure
					DW	OFFSET POST_FDD			; PFSK : FDC Seek Test Failure
					DW	OFFSET POST_ERR_PDMA		; PDMA : DMA TC0 Error
					DW	OFFSET POST_MEMORY		; PMEM : RAM Error
				L_POST_ERRORS	EQU	($-POST_ERRORS)/SIZE POST_ERRORS
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 103 - 1


				POST_ERROR_MSG PROC
					MOV	CX, L_POST_ERRORS+1		; # of available POST error messages
					MOV	SI, OFFSET POST_ERRORS-2	; SI = string table pointer
 E874											;  add one LOOP for WARM BOOT flag
 E874  8C CA			POST_ERROR_MSG_LOOP:
 E876  8E D2				LODS	WORD PTR CS:[SI]			; AX = next message offset
 E878  93				SHL	BP, 1					; CF = POST error flag
 E879  D4 10				JNC	POST_ERROR_MSG_NEXT		; no flag?
 E87B  95				PUSHF						; save BP ZF
 E87C					XCHG	AX, SI				; SI = error string
 E87C  8B D5				PRINTLN_SZ  SI				; write string with CRLF
 E87E  BE 08F1				XCHG	AX, SI				; SI = string table pointer
 E881  33 C9				POPF
 E883				POST_ERROR_MSG_NEXT:
 E883  8B F9				LOOPNZ  POST_ERROR_MSG_LOOP		; loop until end of strings or flags
 E885				POST_ERROR_MSG_EXIT:
 E885  8B C6				RET
				POST_ERROR_MSG ENDP
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E887  BC E88C R	     1		MOV	SP, OFFSET ??0018
			     1				IFNB <1>
 E88A  EB 4F		     1		JMP	SHORT BEEP_ON_P
			     1				ELSE
			     1		JMP	BEEP_ON_P
			     1				ENDIF
 E88C			     1	??0018:
 E88C  E88E R		     1		DW	OFFSET ??0019
 E88E			     1	??0019:
 E88E  8B CF			
				;----------------------------------------------------------------------------;
			     1			LOCAL _DONE
 E890			     1	??001A:
 E890  E2 FE		     1		LOOP	??001A					; long delay for I/O
				; Additional INT 9h - Keyboard Code
			     1			LOCAL	CALL_JMP_PTR, CALL_JMP_RET
 E892  BC E897 R	     1		MOV	SP, OFFSET ??001B
			     1				IFNB <1>
 E895  EB 57		     1		JMP	SHORT BEEP_OFF_P
			     1				ELSE
			     1		JMP	BEEP_OFF_P
			     1				ENDIF
 E897			     1	??001B:
 E897  E899 R		     1		DW	OFFSET ??001C
 E899			     1	??001C:
 E899  2B CF			;----------------------------------------------------------------------------;
				
			     1			LOCAL _DONE
 E89B			     1	??001D:
 E89B  E2 FE		     1		LOOP	??001D					; long delay for I/O
 E89D  FE CA			;----------------------------------------------------------------------------;
 E89F  75 E4			; INT 9 - Test keyboard during POST
 E8A1  86 D6			; Size: 27 bytes
 E8A3  85 D2			;----------------------------------------------------------------------------;
 E8A5  74 D5			INT_09_POST PROC
 E8A7  B5 55				PUSH	AX
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 104 - 1


 E8A9  BE 06A5				POST_FLAG_CLR PKI				; clear POST test int flag
 E8AC  EB D5				IN	AL, PPI_A				; read keyboard scan from PPI
 E8AE					CMP	AL, 0AAH
					JNZ	INT_09_POST_DONE
					POST_FLAG_SET PKI				; POST keyboard test flag
				INT_09_POST_DONE:
					IN	AL, PPI_B				; read keyboard status
					OR	AL, MASK PBKB OR MASK PBKC	; set clear keyboard and enable clock
					OUT	PPI_B, AL				; write to PPI Control Port B
 E8AE					MOV	AL, OCW2 <001b>			; Send End of Interrupt
 E8AE  50				OUT	INT_P0, AL
					POP	AX
			     1			IFNB	<>
			     1		MOV	AX,  			; custom tone
			     1			ELSE
 E8AF  B8 054C		     1		MOV	AX, BEEP_DEFAULT
			     1			ENDIF
			     1			IFB	<>
 E8B2  53		     1		PUSH	BX
			     1			ENDIF
 E8B3  E8 0025		     1		CALL	BEEP_ON_P
			     1			IFB	<>
 E8B6  5B		     1		POP	BX
			     1			ENDIF
 E8B7  B8 00FA				IRET
 E8BA  E8 0EC1			INT_09_POST ENDP
				
 E8BD  E8 002E		     1		CALL	BEEP_OFF_P
 E8C0  58			;----------------------------------------------------------------------------;
 E8C1  C3			; KB Ctrl-NumLock Screen Pause
 E8C2				;----------------------------------------------------------------------------;
				INT_KB_SET_PAUSE PROC
							ASSUME DS:_BDA
					MOV	AL, OCW2 <001b> 			; End of Interrupt OCW
					OUT	INT_P0, AL				; write EOI to port 0
					MOV	BX, OFFSET KB_FLAGS2		; (-1 byte to use indirect addr)
					OR	BYTE PTR [BX], MASK K2PA	; set PAUSE flag
				
 = 0040								IF CGA_SNOW_REMOVE GT 0
				;----------------------------------------------------------------------------;
				; Make sure CGA is not currently being blanked
				;
 E8C2					CALL	INT_10_IS_CGA80			; ZF = 1 if CGA 80 col
 E8C2  E8 0000				JNZ	INT_KB_PAUSE_LOOP			; jump if not CGA 80 col
					MOV	AL, VID_MODE_REG			; get default CGA control register
					MOV	DX, CGA_CTRL			; DX = CGA control port 03D8h
					OUT	DX, AL				; enable video signal
								ENDIF
 E8C5				
 E8C5  50			;----------------------------------------------------------------------------;
				; Loop until Pause flag is cleared
			     1			IFNB	<>
			     1		MOV	AX,  			; custom tone
			     1			ELSE
 E8C6  B8 054C		     1		MOV	AX, BEEP_DEFAULT
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 105 - 1


			     1			ENDIF
			     1			IFB	<>
 E8C9  53		     1		PUSH	BX
			     1			ENDIF
 E8CA  E8 000E		     1		CALL	BEEP_ON_P
			     1			IFB	<>
 E8CD  5B		     1		POP	BX
			     1			ENDIF
 E8CE  B5 40			;
				INT_KB_PAUSE_LOOP:
			     1			LOCAL _DONE
 E8D0			     1	??001E:
 E8D0  E2 FE		     1		LOOP	??001E					; long delay for I/O
					HLT						; be a good neighbor
 E8D2  E8 0019		     1		CALL	BEEP_OFF_P
 E8D5  B5 40				NOP						; let another interrupt happen
					TEST	BYTE PTR [BX], MASK K2PA	; check the Pause flag
			     1			LOCAL _DONE
 E8D7			     1	??001F:
 E8D7  E2 FE		     1		LOOP	??001F					; long delay for I/O
 E8D9  58				JNZ	INT_KB_PAUSE_LOOP			; loop until clear
 E8DA  C3				JMP	INT_KB_DONE				; exit INT
 E8DB				INT_KB_SET_PAUSE ENDP
 E8DB				
				;----------------------------------------------------------------------------;
				; INT 9 - Keyboard Additional Data Tables
				;----------------------------------------------------------------------------;
				; When CTRL held, modify ASCII codes for these scan codes (10 bytes)
				;
				INT_KB_CTRL_ASC_TBL LABEL BYTE
					DB	00H, 03H				; Ctrl 2	-> ASCII 0
					DB	1EH, 07H				; Ctrl 6	-> ASCII 1EH
					DB	1FH, 0CH				; Ctrl '-'	-> ASCII 1FH
					DB	7FH, 0EH				; Ctrl BS 	-> ASCII 07FH
					DB	0AH, 1CH				; Ctrl Enter -> ASCII 0AH
				
 E8DB				;----------------------------------------------------------------------------;
 E8DB  93			; When CTRL held, modify scan codes for these scan codes (14 bytes)
 E8DC  B0 B6			;
 E8DE  E6 43			INT_KB_CTRL_SCAN_TBL LABEL BYTE
 E8E0  93				DB	77H, 47H 				; Ctrl Home
 E8E1					DB	84H, 49H 				; Ctrl PgUp
 E8E1  E6 42				DB	73H, 4BH 				; Ctrl Left Arrow
 E8E3  8A C4				DB	74H, 4DH 				; Ctrl Right Arrow
 E8E5  E6 42				DB	75H, 4FH 				; Ctrl End
 E8E7  E4 61				DB	76H, 51H 				; Ctrl PgDn
 E8E9  0C 03				DB	72H, 37H				; Keypad * / PrtSc
 E8EB  E6 61			
 E8ED  C3			L_INT_KB_CTRL_ASC_TBL	EQU ($-INT_KB_CTRL_ASC_TBL)/2		; 12 total
 E8EE				L_INT_KB_CTRL_SCAN_TBL	EQU ($-INT_KB_CTRL_SCAN_TBL)/2-1	; 6
 E8EE				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	INT_09
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 106 - 1


				
				;----------------------------------------------------------------------------;
 E8EE				; INT 9 - Keyboard Interrupt IRQ1 (Hardware Handler)
 E8EE  E4 61			;----------------------------------------------------------------------------;
 E8F0  24 FC			; Handles hardware Interrupt generated by the KBC connected to IRQ 1. The 
 E8F2  E6 61			; scan code that is received is translated to all of the behaviors and key
 E8F4  C3			; combinations used by the PC.
 E8F5				;
				;----------------------------------------------------------------------------;
				; References:
				;  https://stanislavs.org/helppc/scan_codes.html
				;  https://stanislavs.org/helppc/make_codes.html
				;  https://stanislavs.org/helppc/keyboard_commands.html
				;  https://stanislavs.org/helppc/8042.html
				;  http://www.techhelpmanual.com/106-int_09h__keyboard_interrupt.html
				;  https://www.phatcode.net/res/223/files/html/Chapter_20/CH20-1.html
				;
				; KBFLAGS1 RECORD	K1IN:1,K1CL:1,K1NL:1,K1SL:1,K1AL:1,K1CT:1,K1LS:1,K1RS:1
				; KBFLAGS2 RECORD	K2IN:1,K2CL:1,K2NL:1,K2SL:1,K2PA:1,K2SY:1,K2LA:1,K2LC:1
				;----------------------------------------------------------------------------;
				; Things you must do:
 E8F5 0D 0A 50 4F 53 54		; - Check for a scan code from the KBC via PPI Port A (60h)
       20
 E8FC 45 72 72 6F 72 20		; - Clear and Enable the keyboard bit (7) on PPI Port B
       00
 E903 4B 42 00			; - Examine the Make or Break system scan code
 E906 4B 65 79 00		; - If a toggle key (Shift, Alt, Ctrl, Caps Lock, Num Lock or Scroll Lock),
 E90A 46 44 43 00		;	update that flag in the BDA (17-18h)
 E90E 44 4D 41 00		; - Determine if the scan code is altered by an active shift or toggle state
				; - If Ctrl-Alt-Del is pressed, do a warm reboot of the system
				; - If Print Screen is pressed, call INT 05h
				; - If Pause/Ctrl-NumLock is pressed, enter pause/hold state
				; - If Ctrl-Break is pressed, call INT 1Bh
 E912				; - Handle any special, non-standard translations
 E912  E903 R			; - Translate printable chars to their ASCII/CP-437 value
 E914  E906 R			;
 E916  E90A R			; In short, it needs to do this:
 E918  E4D6 R			;    https://stanislavs.org/helppc/scan_codes.html
 E91A  E90E R			;
 E91C  E4BC R			; TODO: this still needs some clean up.
 E91E = 0006			;----------------------------------------------------------------------------;
						ORG 0E987H
 E91E				INT_09 PROC
 E91E  B9 0007						ASSUME DS:_BDA
 E921  BE E910 R			PUSH	AX						; save AX first
					IN	AL, PPI_A 					; read scan code from PPI Port A
 E924					MOV	AH, AL					; save scan code to AH
 E924  2E: AD				IN	AL, PPI_B 					; read Control Port B
 E926  D1 E5				PUSH	AX						; save status, and I/O delay
 E928  73 07				OR	AL, MASK PBKB				; set clear keyboard bit
 E92A  9C				OUT	PPI_B, AL 					; write to Control Port B
 E92B  96				POP	AX						; restore status, and I/O delay
					OUT	PPI_B, AL 					; write to Control Port B
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 107 - 1


			     1			ENDIF
			     1			IFDIFI <SI>,<SI>			; if SZ is not SI
			     1		MOV	SI, OFFSET SI
			     1			ENDIF
 E92C  E8 0DE4		     1		CALL	OUTLN_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 E92F  96			
 E930  9D			;----------------------------------------------------------------------------;
 E931				; Send non-specific EOI to PIC
 E931  E0 F1			;
 E933					MOV	AL, OCW2 <001b> 				; End of Interrupt OCW
 E933  C3				OUT	INT_P0, AL					; write EOI to port 0
 E934					STI							; enable interrupts
					CLD							; string functions increment
					PUSH	BX						; save other used registers
					PUSH	CX						; (now that interrupts are on)
					PUSH	DX
					PUSH	DI
					PUSH	SI
					PUSH	DS
					PUSH	ES
					MOV	AL, AH					; AL = original scan code
 E934					CMP	AL, 0FFH 					; check for Detection Error/Overrun
 E934  50				JZ	INT_KB_MEEP_DONE				; If overrun, meep and exit
					MOV	DX, SEG _BDA 				; DS = BIOS Data Area
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		CLR1_BP   PKI				; V20 only: CLR1 BP, PKI
			     1				ELSE
 E935  81 E5 BFFF	     1		AND	BP, NOT MASK PKI			; Clear flag
			     1				ENDIF
 E939  E4 60				MOV	DS, DX
 E93B  3C AA				MOV	DX, KB_FLAGS				; DL=KB_FLAGS1, DH=KB_FLAGS2
 E93D  75 04			
				;----------------------------------------------------------------------------;
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		SET1_BP   PKI				; V20 only: SET1 BP, PKI
			     1				ELSE
 E93F  81 CD 4000	     1		OR	BP, MASK PKI			; Set flag
			     1				ENDIF
 E943				; 1. Is a function key?
 E943  E4 61			; Function keys have different scan codes based on shift, ALT or CTRL state
 E945  0C C0			;
 E947  E6 61			KB_INT_CHECK_FN_KEY:
 E949  B0 20				CMP	AL, 044H					; is above F10 scan code?
 E94B  E6 20				JA	KB_INT_CHECK_FN_KEY_DONE
 E94D  58				CMP	AL, 03BH					; is below F1 scan code?
 E94E  CF				JB	KB_INT_CHECK_FN_KEY_DONE
 E94F					MOV	AL, 0						; ASCII always 0 on F-keys
				
				;----------------------------------------------------------------------------;
				; Is a Function key. Check if shift, ALT or Ctrl is held?
				;
 E94F					TEST	DL, MASK K1AL OR MASK K1CT OR MASK K1LS OR MASK K1RS
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 108 - 1


					JZ	KB_INT_CHECK_FN_KEY_DONE
 E94F  B0 20			
 E951  E6 20			KB_INT_CHECK_FN_ALT:					; is it ALT?
 E953  BB 0018 R			TEST	DL, MASK K1AL
 E956  80 0F 08				JZ	KB_INT_CHECK_FN_SHIFT
					ADD	AH, 2DH
					JMP	SHORT KB_INT_PUT_BUFFER_2
				
				KB_INT_CHECK_FN_SHIFT:					; is it shift?
					TEST	DL, MASK K1LS OR MASK K1RS
					JZ	KB_INT_CHECK_FN_CTRL
					ADD	AH, 19H
					JMP	SHORT KB_INT_PUT_BUFFER_2
				
				;----------------------------------------------------------------------------;
				; Handle Shift-PrtSc
				;
				KB_INT_PRTSC:
					INT	5H						; call print screen handler
					JMP	SHORT INT_KB_DONE_2
 E959				
 E959  F4			KB_INT_CHECK_FN_CTRL:					; must be CTRL
 E95A  90				ADD	AH, 23H
 E95B  F6 07 08			
 E95E  75 F9			KB_INT_PUT_BUFFER_2:					; fit short jumps above
 E960  E9 0114				JMP	SHORT KB_INT_PUT_BUFFER
 E963				
				KB_INT_CHECK_FN_KEY_DONE:				; not a function key
				
				;----------------------------------------------------------------------------;
				; 2. Handle "early" Ctrl such as Ctrl-Break and Ctrl-NumLock
				;
					TEST	DL, MASK K1CT				; is Ctrl held?
 E963					JZ	KB_INT_IS_NUM				; if not, skip to IS_NUM
 E963  00 03			
 E965  1E 07			;----------------------------------------------------------------------------;
 E967  1F 0C			; Is Ctrl-Break?
 E969  7F 0E			;
 E96B  0A 1C				CMP	AL, 46H					; Scroll Lock (Break)
					JNZ	INT_KB_CHECK_CTRL_NUM			; jump if not Break
				
				INT_KB_CTRL_BREAK:
					CALL	KB_BUF_CLEAR				; clear keyboard buffer
 E96D					MOV	BIOS_BREAK, 10000000b			; BIOS break flag
 E96D  77 47				INT	1BH						; call BIOS Break handler
 E96F  84 49				JMP	SHORT INT_KB_DONE_2
 E971  73 4B			
 E973  74 4D			;----------------------------------------------------------------------------;
 E975  75 4F			; Is Ctrl-NumLock (Pause)?
 E977  76 51			;
 E979  72 37			INT_KB_CHECK_CTRL_NUM:
					CMP	AL, 45H					; is Num Lock key?
 E97B = 000C				;CMP	AL, 35H					; key pad / (for testing)
 E97B = 0006				JNZ	KB_INT_IS_NUM				; if not, continue to num pad
					JMP	INT_KB_SET_PAUSE				; otherwise put in Pause
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 109 - 1


				
				;----------------------------------------------------------------------------;
				; Emit a feeble meep and exit
				;
 E97B			     1			LOCAL LBL
			     1	
 = 000C			     1	BYTES_HERE_INT_09 = INT_09-$
			     1	
			     1			IFDEF BYTES_HERE_INT_09
			     1			IF2
			     1			IF BYTES_HERE_INT_09 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_09 (BYTES_HERE_INT_09)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				INT_KB_MEEP_DONE:
					CALL	MEEP
				INT_KB_DONE_2:
					JMP	SHORT INT_KB_DONE
				
				;----------------------------------------------------------------------------;
				; 3. Handle numeric keypad entry according to the following:
				;
				;	Num	Shift	ASCII	Scan
				; 	0	0	0	52h	5230 0020
				;	0	1	'0'	52h	5200 80A2
				;	1	0	'0'	52h	5200 8000
				;	1	1	0	52h	5200 8080
				;
				KB_INT_IS_NUM:
					TEST	DL, MASK K1NL				; is NUM LOCK on?
					JZ	KB_INT_IS_NUM_DONE			; if not, do nothing
					CMP	AL, 53H					; is higher than Del key?
					JA	KB_INT_IS_NUM_DONE
					CMP	AL, 47H					; is lower than Home/7 key?
					JB	KB_INT_IS_NUM_DONE
				
				;----------------------------------------------------------------------------;
				; Keypad number pressed and Num Lock is on, so invert shift behavior.
				;
					SHL	AL, 1						; invert NumLock and Shift
					TEST	DL, MASK K1LS OR MASK K1RS		;  behavior and jump ahead
					JZ	KB_INT_UC					; jump if no shift held
					JMP	SHORT KB_INT_SHIFT
				
				KB_INT_IS_NUM_DONE:
				
				;----------------------------------------------------------------------------;
				; 4. Do scan code to ASCII translation
				;----------------------------------------------------------------------------;
				KB_INT_CHAR:						; is a regular key ?
					SHL	AL, 1						; align index for table
					TEST	DL, MASK K1LS OR MASK K1RS OR MASK K1AL	; is either shift key or ALT already pressed
				?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 110 - 1


					JNZ	KB_INT_UC					; if so, use uppercase table
				KB_INT_SHIFT:
 E987					INC	AX 						; if not shifted, increment one to u
				se lower case
				KB_INT_UC:
 E987  50				MOV	BX, OFFSET KEY_SCAN_TBL
 E988  E4 60			KB_INT_XLAT:
 E98A  8A E0				XLAT	CS:[BX]					; ASCII key in AL = CS:BX[AL]
 E98C  E4 61				TEST	AL, AL					; a is flag key code?
 E98E  50				;JS	INT_KB_IS_FLAG
 E98F  0C 80				JNS	KB_INT_NOT_FLAG
 E991  E6 61				JMP	INT_KB_IS_FLAG
 E993  58			KB_INT_NOT_FLAG:
 E994  E6 61				TEST	AH, AH					; test high bit of scan code
					JS	INT_KB_DONE					; if set, it is an unhandled break c
				ode
												; TODO verify this where 0Eh are cau
				ght
				KB_INT_IS_CAPS:
					TEST	DL, MASK K1CL				; is CAPS LOCK on?
 E996  B0 20				JZ	KB_INT_IS_CAPS_DONE
 E998  E6 20				CALL	IS_ALPHA					; CF if AL is not [A-Za-z]
 E99A  FB				JC	KB_INT_IS_CAPS_DONE
 E99B  FC				XOR	AL, 'a'-'A'					; toggle case
 E99C  53			KB_INT_IS_CAPS_DONE:
 E99D  51			
 E99E  52			;----------------------------------------------------------------------------;
 E99F  57			; 5. Handle ALT chars that require ASCII translation
 E9A0  56			;
 E9A1  1E			KB_INT_IS_ALT:
 E9A2  06				TEST	DL, MASK K1AL				; is ALT currently held?
 E9A3  8A C4				JNZ	INT_KB_ALT
 E9A5  3C FF			
 E9A7  74 51			;----------------------------------------------------------------------------;
 E9A9  BA ---- R		; 6. Handle additional Non-ALT special case chars
 E9AC  8E DA			;
 E9AE  8B 16 0017 R			CMP	AX, 3700H					; is Shift-PrtSc?
					JZ	KB_INT_PRTSC				; jump if so
					CMP	AX, 4C00H					; Numeric 5 key (unshifted)
					JZ	INT_KB_DONE					; discard and exit
				
				KB_INT_IS_ALT_DONE:
 E9B2				
 E9B2  3C 44			;----------------------------------------------------------------------------;
 E9B4  77 28			; 7. Handle CTRL chars
 E9B6  3C 3B			;
 E9B8  72 24			KB_INT_IS_CTRL:
 E9BA  B0 00				TEST	DL, MASK K1CT				; is CTRL currently held?
					;JNZ	INT_KB_CTRL					; way too far for short jump
					JZ	KB_INT_IS_CTRL_DONE			; jump if not held
					JMP	INT_KB_CTRL
				
 E9BC  F6 C2 0F			KB_INT_IS_CTRL_DONE:
 E9BF  74 1D			
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 111 - 1


 E9C1				; Test if in Ctrl-NumLock PAUSE
 E9C1  F6 C2 08			; If in Pause, any remaining key will exit and be discarded
 E9C4  74 05			;
 E9C6  80 C4 2D			KB_INT_IS_PAUSE:
 E9C9  EB 11				TEST	DH, MASK K2PA				; is in pause?
					JZ	KB_INT_PUT_BUFFER
 E9CB					AND	KB_FLAGS2, NOT MASK K2PA		; clear pause flag
 E9CB  F6 C2 03				JMP	SHORT INT_KB_DONE				; discard key and exit int
 E9CE  74 09			
 E9D0  80 C4 19			;----------------------------------------------------------------------------;
 E9D3  EB 07			; All special cases have been handled
				; - put AX into keyboard buffer
				;
				KB_INT_PUT_BUFFER:
					MOV	DI, KB_BUF_TL 				; DI = tail ptr
 E9D5					LEA	SI, [DI+2]					; SI = next (maybe)
 E9D5  CD 05				CMP	SI, KB_BUF_END_B				; is next >= end of buffer?
 E9D7  EB 24				JB	KB_INT_CHECK_FULL 			; if not, check if buffer is full
					MOV	SI, OFFSET KB_BUF 			; otherwise, wrap to first address
 E9D9				KB_INT_CHECK_FULL:
 E9D9  80 C4 23				CMP	SI, KB_BUF_HD 				; next == head?
					JZ	INT_KB_MEEP_DONE				; Beep if ZF - buffer is full
 E9DC					MOV	[DI], AX 					; buffer[head] = AX
 E9DC  EB 7E				MOV	KB_BUF_TL, SI 				; tail = next
				
 E9DE				;----------------------------------------------------------------------------;
				; Restore registers and exit
				;
				INT_KB_DONE:
					POP	ES
 E9DE  F6 C2 04				POP	DS
 E9E1  74 1C				POP	SI
					POP	DI
					POP	DX
					POP	CX
					POP	BX
 E9E3  3C 46				POP	AX
 E9E5  75 0C				IRET
				
 E9E7				;----------------------------------------------------------------------------;
 E9E7  E8 025D			; 6. Only ALT key is held (no CTRL)
 E9EA  C6 06 0071 R 80		;
 E9EF  CD 1B			; Space bar is the only key that returns the same scan code and ASCII code 
 E9F1  EB 0A			; when ALT is held.
				;
				INT_KB_ALT PROC
					CMP	AH, 39H					; is space bar?
					JZ	KB_INT_IS_ALT_DONE			; continue
 E9F3					MOV	BX, AX
 E9F3  3C 45				MOV	AL, 0						; AL will be 0 for any others
				
 E9F5  75 08			CHECK_TOP_ROW_NUM:
 E9F7  E9 FF55				CMP	AH, 0DH					; is above '=' scan code?
					JA	CHECK_ALT_ON
					CMP	AH, 2
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 112 - 1


					JB	CHECK_ALT_ON
					ADD	AH, 76H
 E9FA					JMP	SHORT KB_INT_PUT_BUFFER
 E9FA  E8 FEC8			
 E9FD				;----------------------------------------------------------------------------;
 E9FD  EB 78			; 7. Check for ALT + 000 numeric entry
				; Alt held, and number is valid numeric keypad
				; Note: AH must be preserved
				;
				CHECK_ALT_ON:
					SUB	BL, '0'					; ASCII convert and test
					JB	INT_KB_NOT_ALT_000			; jump if less than 0
					CMP	BL, 9
					JA	INT_KB_NOT_ALT_000			; jump if above 9
				
				INT_KB_IS_ALT_000:
 E9FF					MOV	AL, KB_ALT					; get partial working byte
 E9FF  F6 C2 20				MOV	BH, 10					; multiply by 10
 EA02  74 11				MUL	BH						; AL = AL * 10
 EA04  3C 53				ADD	AL, BL					; Add new unit digit
 EA06  77 0D				MOV	KB_ALT, AL					; save to BDA
 EA08  3C 47				MOV	AL, 0						; ASCII code is 0
 EA0A  72 09			INT_KB_DONE2:
					JMP	SHORT INT_KB_DONE				; interrupt complete
				
				; Hack for short conditional jump
				INT_KB_NOT_ALT_000:
 EA0C  D0 E0			
 EA0E  F6 C2 03			;----------------------------------------------------------------------------;
 EA11  74 0A			; 8. Check for ALT modified chars that are skipped
 EA13  EB 07			; Uses table INT_KB_ALT_SKIP
				;
 EA15					MOV	DI, CS
					MOV	ES, DI
					MOV	DI, OFFSET INT_KB_ALT_SKIP
					MOV	CX, 11					; L_INT_KB_ALT_SKIP
					XCHG	AH, AL
 EA15					REPNE SCASB						; is in table?
 EA15  D0 E0				XCHG	AH, AL
 EA17  F6 C2 0B				JNZ	KB_INT_IS_ALT_DONE			; if not found, continue
 EA1A  75 01				JMP	SHORT INT_KB_DONE				; if found, skip
 EA1C				
 EA1C  40			;ALT_MOD_LEN	EQU $-INT_KB_NOT_ALT_000+L_INT_KB_ALT_SKIP	; 30 bytes
 EA1D				
 EA1D  BB EB9D R		INT_KB_ALT ENDP
 EA20				
 EA20  2E: D7			;----------------------------------------------------------------------------;
 EA22  84 C0			; 9. Only CTRL key is held (no ALT)
				;----------------------------------------------------------------------------;
 EA24  79 03			INT_KB_CTRL_NO_ALT PROC
 EA26  E9 0103			
 EA29				;----------------------------------------------------------------------------;
 EA29  84 E4			; Handle CTRL exceptions after ASCII or scan code is modified. These require
 EA2B  78 4A			; a lookup table since they do not follow a predictable pattern.
				;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 113 - 1


 EA2D					XCHG	AX, BX					; BH = scan code, BL = ASCII
 EA2D  F6 C2 40				MOV	CX, 12					; length of table (L_INT_KB_CTRL_ASC_TBL)
 EA30  74 07				MOV	SI, OFFSET INT_KB_CTRL_ASC_TBL
 EA32  E8 1512			INT_KB_CTRL_ASC_TBL_LOOP:
 EA35  72 02				LODS	WORD PTR CS:[SI]				; AH = scan code, AL = new ASCII
 EA37  34 20				CMP	AH, BH					; scan code match?
 EA39					LOOPNE INT_KB_CTRL_ASC_TBL_LOOP		; if not keep looping until end
					JNZ	INT_KB_CTRL_ASC_TBL_DONE		; no matches, restore AX and continue
					CMP	CL, 6						; was first list segment? (L_INT_KB_
				CTRL_SCAN_TBL)
					JG	INT_KB_CTRL_NO_DONE			; if so, match found and AX is set, exit
					CBW							; ASCII code = 0
 EA39					XCHG	AL, AH					; replace scan code in AH, AL = 0
 EA39  F6 C2 08			INT_KB_CTRL_NO_DONE:
 EA3C  75 42				JMP	KB_INT_IS_CTRL_DONE			; AX set, exit
				INT_KB_CTRL_ASC_TBL_DONE:
					XCHG	AX, BX					; restore AX
				
				;----------------------------------------------------------------------------;
 EA3E  3D 3700			; Skip ; ' `
 EA41  74 92			;
 EA43  3D 4C00				CMP	AH, 27H					; pass < 27
 EA46  74 2F				JB	INT_KB_CTRL_ALPHA
					CMP	AH, 29H					; pass > 29
 EA48					JA	INT_KB_CTRL_ALPHA
					JMP	INT_KB_DONE					; skip 27-29
				
				;----------------------------------------------------------------------------;
				; For scan codes 10H-32H return only low 5 bits of ASCII code when CTRL is held
 EA48				;
 EA48  F6 C2 04			INT_KB_CTRL_ALPHA:
					CMP	AH, 10H
 EA4B  74 03				JB	INT_KB_CTRL_NO_ALT_1
 EA4D  E9 00B8				CMP	AH, 32H
					JA	INT_KB_CTRL_NO_ALT_1
 EA50					AND	AL, 00011111B				; adjust ASCII value
					JMP	SHORT INT_KB_CTRL_NO_DONE
				INT_KB_CTRL_NO_ALT_1:
				
				;----------------------------------------------------------------------------;
				; If scan code between 02H-35H and hasn't been modified yet, return nothing
 EA50				;
 EA50  F6 C6 08				CMP	AH, 2
 EA53  74 07				JB	INT_KB_CTRL_NO_DONE			; pass < 2
 EA55  80 26 0018 R F7			CMP	AH, 35H
 EA5A  EB 1B				JA	INT_KB_CTRL_NO_DONE			; pass > 35
					JMP	INT_KB_DONE					; don't return 2-35?
				
				INT_KB_CTRL_NO_ALT ENDP
				
				;----------------------------------------------------------------------------;
 EA5C				; 8. Ctrl key is held
 EA5C  8B 3E 001C R		;----------------------------------------------------------------------------;
 EA60  8D 75 02			INT_KB_CTRL:
 EA63  83 FE 3E				TEST	DL, MASK K1AL				; is ALT also currently held?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 114 - 1


 EA66  72 03				JZ	INT_KB_CTRL_NO_ALT			; jump if no ALT
 EA68  BE 001E R		
 EA6B				;----------------------------------------------------------------------------;
 EA6B  3B 36 001A R		; 9. Ctrl-Alt keys are held
 EA6F  74 89			;----------------------------------------------------------------------------;
 EA71  89 05			INT_KB_CTRL_ALT PROC
 EA73  89 36 001C R			CMP	AH, 53H					; Del key
					;JZ	INT_KB_CTRL_ALT_DEL			; three finger salute
					JNZ	INT_KB_CTRL_ALT_1				; jump if not Ctrl-Alt-Del
				
				;----------------------------------------------------------------------------;
 EA77				; Handle Ctrl-Alt-Del - warm reboot
 EA77  07			;
 EA78  1F			INT_KB_CTRL_ALT_DEL:
 EA79  5E				CALL	BEEP						; BEEP on ctrl-alt-del
 EA7A  5F						IF WARM_ENABLE EQ 1
 EA7B  5A				MOV	WARM_FLAG, WARM_BOOT			; set warm boot flag
 EA7C  59						ELSE
 EA7D  5B				MOV	WARM_FLAG, COLD_BOOT			; clear warm boot flag
 EA7E  58						ENDIF
 EA7F  CF				JMP	BOOT						; warm reboot
				
				INT_KB_CTRL_ALT ENDP
				
				;----------------------------------------------------------------------------;
				; 10. Handle Ctrl-Alt, but not Del
				;
				INT_KB_CTRL_ALT_1:
 EA80				
 EA80  80 FC 39						IF IS_TURBO
 EA83  74 C3			;----------------------------------------------------------------------------;
 EA85  8B D8			; Is Turbo speed toggle Ctrl-Alt-+ hotkey?
 EA87  B0 00			;
					CMP	AH, 4EH					; numeric pad + key
 EA89					;JZ	INT_KB_TOGGLE_TURBO
 EA89  80 FC 0D				JNZ	INT_KB_CTRL_ALT_1_DONE			; put in buffer as-is and exit
 EA8C  77 0A			
 EA8E  80 FC 02			;	;CMP	AH, 4AH					; numeric pad - key
 EA91  72 05			;	;JZ	INT_KB_TURBO_MINUS
 EA93  80 C4 76			
 EA96  EB C4			;----------------------------------------------------------------------------;
				; Handle Turbo speed mode toggle
				;
					CALL	INT_KB_TOGGLE_TURBO			; meep meep and switch speed
					JMP	INT_KB_DONE
				
							ENDIF
 EA98				
 EA98  80 EB 30			INT_KB_CTRL_ALT_1_DONE:
 EA9B  72 15				JMP	KB_INT_IS_CTRL_DONE			; put in buffer as-is and exit
 EA9D  80 FB 09			
 EAA0  77 10			;----------------------------------------------------------------------------;
				; 5. Is a flag key?
 EAA2				;----------------------------------------------------------------------------;;
 EAA2  A0 0019 R		;  40:18	Keyboard Flags Byte 2 (High)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 115 - 1


 EAA5  B7 0A			; 84218421
 EAA7  F6 E7			; 7 	    |			- K2IN	insert key is depressed
 EAA9  02 C3			;  6 	    |			- K2CL	caps-lock key is depressed
 EAAB  A2 0019 R		;   5	    |			- K2NL	num-lock key is depressed
 EAAE  B0 00			;    4    |			- K2SL	scroll lock key is depressed
 EAB0				;     3   |			- K2PA	suspend key has been toggled
 EAB0  EB C5			;      2  |			- K2SY	system key depressed and held
				;       1 |			- K2LA	left ALT key depressed
				;        0|			- K2LC	left CTRL key depressed
 EAB2				;
				INT_KB_IS_FLAG PROC
					MOV	DI, CS					; ES to BIOS code
					MOV	ES, DI
					MOV	DI, OFFSET KEY_FLAG_ON_TBL
					MOV	AL, AH					; AL = original scan code
 EAB2  8C CF				AND	AL, 01111111B				; clear high bit for search
 EAB4  8E C7				MOV	CL, 1						; set up bit mask counter
 EAB6  BF EC1B R		INT_KB_FLAG_LOOP:
 EAB9  B9 000B				SCASB 						; look for scan code
 EABC  86 E0				JZ	INT_KB_FLAG_FOUND
 EABE  F2/ AE				SHL	CL, 1 					; CL will contain bit mask
 EAC0  86 E0				JNZ	INT_KB_FLAG_LOOP				; CF if not found too
 EAC2  75 84				JMP	KB_INT_NOT_FLAG
 EAC4  EB B1			INT_KB_FLAG_FOUND:
					CLI
					MOV	AL, CL					; move to AL for work
				
 EAC6				;----------------------------------------------------------------------------;
				; Ins, Caps, Num, Scrl send break codes, but state is kept by BIOS so ignore those.
				;
					TEST	AL, MASK K1IN OR MASK K1CL OR MASK K1NL OR MASK K1SL
					JZ	INT_KB_NOT_ICNS				; don't clear on break code on these
 EAC6					TEST	AH, AH					; is Ins, Caps, Num, Scrl break code?
				;	JS	INT_KB_FLAG_DONE				; if so, do nothing and exit
					JNS	INT_KB_ICNS_MAKE				; if not, jump to make
				
				;----------------------------------------------------------------------------;
				; Handle KB_FLAGS2 for Ins, Caps, Num, Scroll Lock for both make and break
 EAC6  93			;
 EAC7  B9 000C			INT_KB_ICNS_BREAK:
 EACA  BE E963 R			NOT	AL
 EACD					AND	KB_FLAGS2, AL				; clear flag in KB_FLAGS2
 EACD  2E: AD				JMP	SHORT	INT_KB_FLAG_DONE
 EACF  38 FC			INT_KB_ICNS_MAKE:
 EAD1  E0 FA				OR	KB_FLAGS2, AL				; set flag in KB_FLAGS2
 EAD3  75 0B			
 EAD5  80 F9 06			;----------------------------------------------------------------------------;
 EAD8  7F 03			; Otherwise simply toggle the flag for Ins, Caps, Num, Scrl.
 EADA  98			;
 EADB  86 C4			; Note: this approach does not seem to work properly for Alt, Ctrl, Shift, 
 EADD				; Caps Lock. It appears that order is not completely guaranteed so it is
 EADD  E9 FF70			; possible to receive to break codes for the same key in a row, which mean
 EAE0				; just toggling will cause flags to be lost.
 EAE0  93			;
				; Note 2: The Ins key passes through as a key press with code 5200H.
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 116 - 1


				;
				INT_KB_FLAG_TOGGLE:
					XOR	KB_FLAGS1, AL				; toggle flag
 EAE1  80 FC 27				TEST	AL, MASK K1IN				; is insert key?
 EAE4  72 07				MOV	AL, 0
 EAE6  80 FC 29				JNZ	INT_KB_PUT_BUFFER_2			; pass through as a key if so
 EAE9  77 02			INT_KB_DONE3:
 EAEB  EB 8A				JMP	INT_KB_DONE
				
				;----------------------------------------------------------------------------;
				; Scan code for Alt, Ctrl, Left or Right Shift
				; On make code, set flag.  On break code, clear flag.
 EAED				;
 EAED  80 FC 10			INT_KB_NOT_ICNS:
 EAF0  72 09			
 EAF2  80 FC 32			;----------------------------------------------------------------------------;
 EAF5  77 04			; Handle KB_FLAGS2 for Ctrl or Alt
 EAF7  24 1F			;
 EAF9  EB E2				TEST	AL, MASK K1AL OR MASK K1CT		; is Alt or Ctrl?
 EAFB					JZ	INT_KB_NOT_ICNS_1				; jump if not
					SHR	AL, 1						; adjust for KB_FLAGS2
					SHR	AL, 1
					XOR	KB_FLAGS2, AL				; toggle flag
					MOV	AL, CL					; restore AL
 EAFB  80 FC 02			
 EAFE  72 DD			INT_KB_NOT_ICNS_1:
 EB00  80 FC 35				TEST	AH, AH					; is a break code?
 EB03  77 D8				JNS	INT_KB_FLAG_SET				; if not, set flag
 EB05  E9 FF6F			
				INT_KB_FLAG_CLEAR:
 EB08					NOT	AL						; invert mask
					AND	KB_FLAGS1, AL				; clear flag
					CMP	CL, MASK K1AL				; was it ALT key?
					JZ	INT_KB_ALT_BREAK				; if so, handle more ALT break
					;JMP	INT_KB_DONE					; INT_KB_DONE short jump too far
 EB08					JMP	SHORT INT_KB_FLAG_DONE			; (saves 1 byte)
 EB08  F6 C2 08			
 EB0B  74 B9			INT_KB_FLAG_SET:
					OR	KB_FLAGS1, AL				; set flag
				
				INT_KB_FLAG_DONE:
					JMP	INT_KB_DONE					; done
 EB0D				
 EB0D  80 FC 53			INT_KB_IS_FLAG ENDP
				
 EB10  75 0C			;----------------------------------------------------------------------------;
				; ALT has just been released
				;----------------------------------------------------------------------------;
				; Check if there a partial value of ALT+000 (ALT-GR) numpad entry work byte?
				;
 EB12				INT_KB_ALT_BREAK:
 EB12  E8 FD99				MOV	AL, KB_ALT
					TEST	AL, AL			; is ALT working sum 0?
 EB15  C7 06 0072 R 1234		JZ	INT_KB_DONE3		; if so, end
					MOV	AH, 0				; Scan code is 0
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 117 - 1


					MOV	KB_ALT, AH			; clear ALT byte working sum
				INT_KB_PUT_BUFFER_2:
 EB1B  E9 F53D				JMP	KB_INT_PUT_BUFFER		; use this value as output char
				
 EB1E				;----------------------------------------------------------------------------;
				; Keyboard scancode mapping tables
				;----------------------------------------------------------------------------;
				; For each scan code this table contains ASCII characters. The first byte is
				; the shifted (shift held) ASCII char, followed by the non-shifted ASCII char.
 EB1E				;
				; Flag chars (noted by *) return their scan code with most sig bit set 
				; (also their break code).
				;----------------------------------------------------------------------------;
				KEY_SCAN_TBL:
					DB	2 DUP(0), 2 DUP(1BH) 		; 00-01H	None, Escape
 EB1E  80 FC 4E				DB	'!1@2#3$4%5^6' 			; 02-		(Top row keys)
					DB	'&7*8(9)0_-+='			;   -0DH
 EB21  75 06				DB	8, 8, 0, 9 				; 0E-0FH	Backspace, Tab
					DB	'QqWwEeRrTtYy' 			; 10-		(Second row keys)
					DB	'UuIiOoPp{[}]' 			;    1BH
					DB	2 DUP(0DH) 				; 1C		Enter
					DB	2 DUP(01DH OR 80H) 		; 1D		*Ctrl
					DB	'AaSsDdFfGgHh'			; 1E-		(Third row keys)
					DB	'JjKkLl:;"', "'", '~`'		;   -29H
					DB	2 DUP(02AH OR 80H)  		; 2A		*Left shift
 EB23  E8 0D9C				DB	'|\ZzXxCcVvBb' 			; 2B-		(Fourth row keys)
 EB26  E9 FF4E				DB	'NnMm<,>.?/' 			;   -35H
					DB	2 DUP(36H OR 80H)			; 36H		*Right Shift
					DB	0, '*' 				; 37H		PrtSc/'*'
					DB	2 DUP(38H OR 80H)			; 38H		*Alt
 EB29					DB	2 DUP(' ')				; 39H		Space
 EB29  E9 FF24				DB	2 DUP(3AH OR 80H) 		; 3AH		*Caps Lock
				
				;----------------------------------------------------------------------------;
				; IMPORTANT NOTE: these next two tables are placed here to fill the "hole"
				; for the F1-F10 keys, so MUST be exactly 20 bytes to maintain the table
				; index. Left in commented out below for reference:
				
				;	DW	10 DUP(0) 				; 3B-44H	F1-F10
				
				;----------------------------------------------------------------------------;
				; Table for scan codes that are keys that set flags.
				; The byte's index corresponds to the flag bit position in BDA's KB_FLAGS1.
				; Length: 8 bytes
				;
				KEY_FLAG_ON_TBL:			;                            ICNSATLR
					DB	36H			; Right shift on	0110110 -> 00000001
 EB2C					DB	2AH			; Left shift on	0101010 -> 00000010
 EB2C  8C CF				DB	1DH			; cTrl on		0011101 -> 00000100
 EB2E  8E C7				DB	38H			; Alt on		0111000 -> 00001000
 EB30  BF EC13 R			DB	46H			; Scroll lock on 	1000110 -> 00010000
 EB33  8A C4				DB	45H			; Num lock on	1000101 -> 00100000
 EB35  24 7F				DB	3AH			; Caps lock on	0111010 -> 01000000
 EB37  B1 01				DB	52H			; Insert on		1010010 -> 10000000
 EB39				L_KEY_FLAG_ON_TBL	EQU $-KEY_FLAG_ON_TBL
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 118 - 1


 EB39  AE			
 EB3A  74 07			;----------------------------------------------------------------------------;
 EB3C  D0 E1			; Alt keys that are "skipped" and return no scan codes
 EB3E  75 F9			; Length: 10 bytes
 EB40  E9 FEE6			;
 EB43				INT_KB_ALT_SKIP	LABEL	BYTE
 EB43  FA				DB	0FH					; Tab
 EB44  8A C1				DB	1CH					; Enter
					DB	27H					; ;
					DB	28H					; '
					DB	29H					; `
					DB	2BH					; \
 EB46  A8 F0				DB	33H					; ,
 EB48  74 1D				DB	34H					; .
 EB4A  84 E4				DB	35H					; /
					DB	37H					; * PrcSc
 EB4C  79 08			L_INT_KB_ALT_SKIP	EQU $-INT_KB_ALT_SKIP
				
					DB	2 DUP(0)				; pad 2 bytes to maintain index
				
				; must be KEY_FLAG_ON_TBL + 20 here to maintain index
 EB4E				
 EB4E  F6 D0			KEY_SCAN_TBL_HIGH:
 EB50  20 06 0018 R			DB	2 DUP(45H OR 80H)			; 45H		*Num Lock
 EB54  EB 34				DB	2 DUP(46H OR 80H)			; 46H		*Scroll Lock
 EB56					DB	'7', 0				; 47H		Home/7
 EB56  08 06 0018 R			DB	'8', 0				; 48H		Up/8
					DB	'9', 0				; 49H		PgUp/9
					DB	2 DUP('-')				; 4AH		Keypad '-'
					DB	'4', 0				; 4BH		Left/4
					DB	'5', 0				; 4CH		Center/5
					DB	'6', 0				; 4DH		Right/6
					DB	2 DUP('+')				; 4EH		Keypad '+'
					DB	'1', 0				; 4FH		End/1
					DB	'2', 0				; 50H		Down/2
					DB	'3', 0				; 51H		PgDn/3
					DB	'0', 52H OR 80H			; 52H		*Ins/0
					DB	'.', 0				; 53H		Del
 EB5A					DB	2 DUP(0)				; 54H		SysReq
 EB5A  30 06 0017 R		L_KEY_SCAN_TBL EQU $-KEY_SCAN_TBL
 EB5E  A8 80			
 EB60  B0 00			;----------------------------------------------------------------------------;
 EB62  75 36			; Clear keyboard circular buffer
 EB64				;----------------------------------------------------------------------------;
 EB64  E9 FF10			; Clear/init circular buffer at KB_BUF
				; Clobbers AX, DI
				;
				; Size: 17 bytes
				;----------------------------------------------------------------------------;
				KB_BUF_CLEAR PROC
 EB67						ASSUME ES:_BDA
					PUSH	ES 					; save ES
					MOV	AX, SEG _BDA 			; get BDA segment
					MOV	ES, AX
					MOV	AX, ES:KB_BUF_ST 			; AX = original start of buffer
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 119 - 1


 EB67  A8 0C				MOV	DI, OFFSET ES:KB_BUF_HD 	; DI = buffer head
 EB69  74 0A				STOSW 					; write to head pointer
 EB6B  D0 E8				STOSW 					; write to tail pointer
 EB6D  D0 E8				POP	ES
 EB6F  30 06 0018 R			RET
 EB73  8A C1			KB_BUF_CLEAR ENDP
				
 EB75				INT_09 ENDP
 EB75  84 E4			
 EB77  79 0D			;
				; 1 BYTE HERE
 EB79				;
 EB79  F6 D0			BYTES_HERE	INT_13
 EB7B  20 06 0017 R		
 EB7F  80 F9 08			;----------------------------------------------------------------------------;
 EB82  74 09			; INT 13H - Diskette BIOS Services
				;----------------------------------------------------------------------------;
 EB84  EB 04			;	INT 13,0  Reset disk system
				;	INT 13,1  Get disk status
 EB86				;	INT 13,2  Read disk sectors
 EB86  08 06 0017 R		;	INT 13,3  Write disk sectors
				;	INT 13,4  Verify disk sectors
 EB8A				;	INT 13,5  Format disk track
 EB8A  E9 FEEA			;
				;  Typical params:
 EB8D				;	AH = function request number
				;	AL = number of sectors	(1-128)
				;	CH = cylinder number	(0-1023)
				;	CL = sector number	(1-17)
				;	DH = head number		(0-15)
				;	DL = drive number		(0=A:, 1=B:, 80H=C:, 81H=D:) (for AH=2-5)
				;	ES:BX = address of user buffer
 EB8D				;
 EB8D  A0 0019 R		;  Output:
 EB90  84 C0			;	CF = 0 if successful
 EB92  74 D0			;	   = 1 if error
 EB94  B4 00			;	AH = status of operation (https://stanislavs.org/helppc/int_13-1.html)
 EB96  88 26 0019 R		;
 EB9A				;----------------------------------------------------------------------------;
 EB9A  E9 FEBF			;  All functions:
				;	- return FD_LAST_OP ([41H]) in AH
				;	- set CF if error
				;	- reset motor shutoff counter
				;
				;  Reference:
				;	https://stanislavs.org/helppc/int_13.html
				;	https://stanislavs.org/helppc/765.html
				;	NEC Microcomputers, Inc. PD765C Application Note 8 (Mar 1979)
				;
				;  Ports:
 EB9D				;	3F0-3F7 Floppy disk controller (except PCjr)
 EB9D  0002 [			;	3F0 Diskette controller status A
        00
       ]
       0002 [
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 120 - 1


        1B
       ]
 EBA1  21 31 40 32 23 33	;	3F1 Diskette controller status B
       24 34 25 35 5E 36
 EBAD  26 37 2A 38 28 39	;	3F2 controller control port
       29 30 5F 2D 2B 3D
 EBB9  08 08 00 09		;	3F4 controller status register
 EBBD  51 71 57 77 45 65	;	3F5 data register (write 1-9 byte command, see INT 13)
       52 72 54 74 59 79
 EBC9  55 75 49 69 4F 6F	;	3F6 Diskette controller data
       50 70 7B 5B 7D 5D
 EBD5  0002 [			;	3F7 Diskette digital input
        0D
       ]
 EBD7  0002 [			;
        9D
       ]
 EBD9  41 61 53 73 44 64	;----------------------------------------------------------------------------;
       46 66 47 67 48 68
 EBE5  4A 6A 4B 6B 4C 6C			ORG 0EC59H
       3A 3B 22 27 7E 60
 EBF1  0002 [			
        AA
       ]
 EBF3  7C 5C 5A 7A 58 78	INT_13_STAT	EQU BYTE PTR [DI]					; use as FD_LAST_OP
       43 63 56 76 42 62
 EBFF  4E 6E 4D 6D 3C 2C	INT_13_LAST	EQU BYTE PTR [DI][FDC_LAST_ST-FD_LAST_OP]	; use as FDC_LAST_ST
       3E 2E 3F 2F
 EC09  0002 [			
        B6
       ]
 EC0B  00 2A			INT_13 PROC
 EC0D  0002 [				STI 						; enable interrupts
        B8
       ]
 EC0F  0002 [				CLD
        20
       ]
 EC11  0002 [				PUSH	DS
        BA
       ]
					PUSH	DI
					PUSH	DX
					PUSH	CX
					PUSH	BX
					PUSH	AX					; save original AX
					PUSH	BX
					MOV	BX, SEG _BDA			; set DS = BDA
					MOV	DS, BX
					POP	BX
					MOV	DI, OFFSET FD_LAST_OP		; DI = FD_LAST_OP throughout
					CMP	AH, 1 				; AH = 1?
					JB	INT_13_0 				; AH = 0, jump to Reset
					JZ	INT_13_1 				; AH = 1, jump to Status
 EC13					CMP	DL, 3 				; is drive number > 3?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 121 - 1


 EC13  36				JA	INT_13_BAD_CMD 			; if so, exit
 EC14  2A				MOV	INT_13_STAT, FDC_ST_OK		; clear last operation
 EC15  1D				CMP	AH, 6 				; AH = 2 through 5?
 EC16  38				JB	INT_13_2_5 				; jump to FDC RWVF command
 EC17  46			INT_13_BAD_CMD:
 EC18  45				MOV	INT_13_STAT, FDC_ST_BADCMD	; otherwise return "bad command"
 EC19  3A			INT_13_DONE:
 EC1A  52				MOV	AL, DBT.FMCT 			; INT_1E[2] = motor shutoff counter
 EC1B = 0008				CALL	INT_1E_PARAM 			; AL = shutoff counter value (37)
					MOV	FD_MOTOR_CT, AL 			; update in BDA
					POP	AX 					; restore original AL
					MOV	AH, INT_13_STAT 			; AH = last operation status
				INT_13_EXIT:
					POP	BX 					; restore original registers
 EC1B					POP	CX
 EC1B  0F				POP	DX
 EC1C  1C				POP	DI
 EC1D  27				POP	DS
 EC1E  28				CMP	AH, FDC_ST_OK+1			; check AH for error (CF = AH < 1)
 EC1F  29				CMC   					; invert CF for return (CF = ! CF)
 EC20  2B				IRET_F 					; return from int with current flags
 EC21  33			
 EC22  34			;----------------------------------------------------------------------------;
 EC23  35			; INT 13, 0: Reset disk system
 EC24  37			;----------------------------------------------------------------------------;
 EC25 = 000A			; Performs hard reset on FDC controller
				;
 EC25  0002 [			; Input:
        00
       ]
				;	AH = 00
				;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
				;		(unused - drive is determined by BDA motor status)
 EC27				;
 EC27  0002 [			; Output:
        C5
       ]
 EC29  0002 [			;	AH = disk operation status  (see INT 13,STATUS)
        C6
       ]
 EC2B  37 00			;	CF = 0 if successful
 EC2D  38 00			;	   = 1 if error
 EC2F  39 00			;
 EC31  0002 [			; To Convert FD_MOTOR_ST to FDC byte use the following table/formula:
        2D
       ]
 EC33  34 00			;	Motors On 	Drive #
 EC35  35 00			;	0 0 0 0	 	0 			AND with 1111, jump if AL = 0
 EC37  36 00			;	1 x x x		3			TEST bit 1000, if non-zero then AL = 3
 EC39  0002 [			;	0 1 x x		2 			Shift right once and AL will be correct
        2B
       ]
 EC3B  31 00			;	0 0 1 x		1 			"
 EC3D  32 00			;	0 0 0 x	 	0			"
 EC3F  33 00			;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 122 - 1


 EC41  30 D2			;----------------------------------------------------------------------------;
 EC43  2E 00			; Things you must do:
 EC45  0002 [			;
        00
       ]
 EC47 = 00AA			;	- if a motor flag is on in BDA, turn it on in the FDC also
				;	- clear reset flag in controller and pull heads to track 0
				;	- set ALL disks need recalibration on next seek (Why all drives?)
				;	- setting the controller reset flag causes the disk to recalibrate
				;	  	on the next disk operation
				;	- if bit 7 is set, the diskette drive indicated by the lower 7 bits
				;		will reset then the hard disk will follow; return code in AH is
				;		for the drive requested (this is done by HD BIOS)
				;----------------------------------------------------------------------------;
				INT_13_0 PROC
 EC47					MOV	DX, FDC_CTRL			; port 3F2H, FDC Digital Output
					CLI 						; disable interrupts
 EC47  06				MOV	AL, FD_MOTOR_ST 			; 3FH - Diskette motor status
 EC48  B8 ---- R			MOV	CH, AL 				; save to CH
 EC4B  8E C0				AND	AL, MASK FMOT			; isolate motor status flags
 EC4D  26: A1 0080 R			JZ	INT_13_0_2				; jump if no motors are on, default to 0
 EC51  BF 001A R		
 EC54  AB			;----------------------------------------------------------------------------;
 EC55  AB			; One motor is on (according to BDA). Convert motor run flags to binary number
 EC56  07			; since FDC requires a drive index for the reset.
 EC57  C3			;
 EC58					SHR	AL, 1					; disregard low bit (will be 0 either way)
					TEST	AL, 0100B 				; test for drive 3?
 EC58					JZ	INT_13_0_1				; if not drive 3, AL is now correct
					MOV	AL, 3 				; otherwise set AL to drive 3
				INT_13_0_1:
							IF CPU_TYPE	EQ CPU_V20
					SHL	CH, 4					; move original low nibble into CH
							ELSE
 EC58			     1			LOCAL LBL
			     1	
 = 0001			     1	BYTES_HERE_INT_13 = INT_13-$
			     1	
			     1			IFDEF BYTES_HERE_INT_13
			     1			IF2
			     1			IF BYTES_HERE_INT_13 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_13 (BYTES_HERE_INT_13)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					MOV	CL, 4 				; move original low nibble
					SHL	CH, CL				;  into high nibble of CH
							ENDIF
					OR	AL, CH 				; combine nibbles with AL
				
				;----------------------------------------------------------------------------;
				; Reset the controller by holding FDC reset (bit 2) at 0.
				; Flag all drives for recalibration (not just the drive in DL)
				; Clear last FDC operation status in BDA
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 123 - 1


				;
				INT_13_0_2:
					OR	AL, MASK FDDMA			; enable DMA & I/O interface, FDC reset
					OUT	DX, AL				; send to FDC
					XOR	CX, CX 				; clear CX, delay for FDC to settle	(3)
					MOV	FD_CAL_ST, CL 			; flag all drives for recalibration	(19)
					MOV	INT_13_STAT, CL 			; clear last operation flags		(19)
				
				;----------------------------------------------------------------------------;
				; Re-enable FDC by setting bit 2 to 1.
				; Wait for Interrupt (WIF) from FDC
				;
					OR	AL, MASK FDCEN			; set FDC enable 				(4)
					OUT	DX, AL				; send to FDC
					STI 						; enable interrupts
					CALL	FDC_WAIT_SENSE			; wait for FDC to signal interrupt
					JC	INT_13_0_RESET_BAD
					CMP	AL, 11000000B			; was successful reset?
					JZ	INT_13_0_RESET_DONE		; jump if success, AH = 0
				INT_13_0_RESET_BAD:
					MOV	AH, FDC_ST_ERR_FDC		; otherwise, controller failure
				INT_13_0_RESET_DONE:
					MOV	INT_13_STAT, AH			; set last result
					;JNZ	INT_13_DONE				; exit if there was an error (why not?)
				
				;----------------------------------------------------------------------------;
				; (Re)send Specify bytes to FDC
				;
					MOV	AL, FDC_CMD_SPEC 			; [0] FDC Specify command
					CALL	FDC_SEND 				; send command in AL, CF if error
					JC	INT_13_DONE
					MOV	AL, DBT.SRT				; [1] step rate time, head unload time
					CALL	FDC_SEND_PARAM
					JC	INT_13_DONE
					MOV	AL, DBT.HLT_ND			; [2] head load time (01H), DMA mode (ND)
					CALL	FDC_SEND_PARAM
				INT_13_0_DONE:
					JMP	SHORT INT_13_DONE
				INT_13_0 ENDP
				
 = BYTE PTR [DI]		;----------------------------------------------------------------------------;
 = BYTE PTR [DI][FDC_LAST_S	; INT 13, 1: Get disk status
   T-FD_LAST_OP]
				;----------------------------------------------------------------------------;
 EC59				; Output: AL and AH = status of last operation
 EC59  FB			;----------------------------------------------------------------------------;
 EC5A  FC			INT_13_1 PROC
 EC5B  1E				POP	AX 					; discard original AX
 EC5C  57				MOV	AL, INT_13_STAT 			; AL = last operation status
 EC5D  52				MOV	AH, AL				; AH = last operation status
 EC5E  51				JMP	SHORT INT_13_EXIT
 EC5F  53			INT_13_1 ENDP
 EC60  50			
 EC61  53			;----------------------------------------------------------------------------;
 EC62  BB ---- R		; DMA page boundary overrun
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 124 - 1


 EC65  8E DB			;
 EC67  5B			FDC_DMA_BOUND:
 EC68  BF 0041 R			OR	INT_13_STAT, FDC_ST_DMA_64K	; DMA boundary error
 EC6B  80 FC 01				STC						; re-set CF
 EC6E  72 29				JMP	SHORT FDC_INIT_DMA_EXIT		; rebalance stack and exit
 EC70  74 73			
 EC72  80 FA 03			;----------------------------------------------------------------------------;
 EC75  77 08			; INT 13, AH=2-5: FDC read/write operations
 EC77  C6 05 00			;----------------------------------------------------------------------------;
 EC7A  80 FC 06			; All commands:
 EC7D  72 73			;
 EC7F				; 	AL = number of sectors to read  (1-128 dec.)
 EC7F  C6 05 01			;	AH = function number
 EC82				;	CH = track/cylinder number  (0-1023 dec., see below)
 EC82  B0 02			;	CL = sector number  (1-17 dec.)
 EC84  E8 02AD			;	DH = head number  (0-15 dec.)
 EC87  A2 0040 R		;	DL = drive number (0=A:, 1=2nd floppy, 80h=drive 0, 81h=drive 1)
 EC8A  58			;	ES:BX = pointer to buffer
 EC8B  8A 25			;----------------------------------------------------------------------------;
 EC8D				; Things you must do:
 EC8D  5B			;
 EC8E  59			;	1. Set FD_MOTOR_ST read/write flag for operation
 EC8F  5A			;	2. Motor ON (update BDA)
 EC90  5F			;		- is motor already on? Skip wait for spin up
 EC91  1F			;		- wait only for writes?
 EC92  80 FC 01			;		- check if recalibration is necessary
 EC95  F5			;	3. Set up DMA
				;	4. seek drive DL to cylinder CH, head DH
 EC96  CA 0002		     1		RETF	2
				; 	5. send command
				;	6. wait for interrupt
				;	7. fetch results
				;	8. Check FDC status bytes for result
				;
				; Things you should do:
				;	- Check if drive is valid? Check if exists in BDA and not a hard drive
				;----------------------------------------------------------------------------;
				INT_13_2_5 PROC
					CALL	FDC_SEEK 				; Turn on motor, CH = track, DL = drive
				INT_13_0A_DONE:
					JC	INT_13_DONE				; exit if seek error
					PUSH	AX					; save function / sector count
					PUSH	DX					; save head / drive
					XCHG	AX, DX 				; DL = sectors count
					MOV	AL, DH				; AL = function number
					MOV	DH, DMA_MR <1,0,0,2,2> 		; set DMA 8237A write/format mode 2 (AH = 3,5)
					OR	FD_MOTOR_ST, MASK FWRT		; turn on write flag default
					TEST	AL, 3 AND 5				; is write (3) or format (5)?
					JNZ	INT_13_2_5_SETUP_DMA		; if so, proceed to setup
					AND	FD_MOTOR_ST, NOT MASK FWRT	; else read or verify (turn off BDA write flag)
					MOV	DH, DMA_MR <1,0,0,0,2> 		; 8237A verify mode 0 (AH = 4)
					CMP	AL, 4 				; is verify?
					JE	INT_13_2_5_SETUP_DMA		; if so, proceed to setup
					MOV	DH, DMA_MR <1,0,0,1,2> 		; else set 8237A read mode 1 (AH = 2)
				INT_13_2_5_SETUP_DMA:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 125 - 1


					XCHG	AX, DX				; AL = sectors to read, AH = DMA mode
											; fall through to set up DMA
				
				;-------------------------------------------------------------------------
				; FDC_INIT_DMA: Configure DMA channel 2 for FDC operation
				;-------------------------------------------------------------------------
				; Input:
				;  AL = sectors to read
				;  AH = DMA mode:
				;	01000110 (46H) - Read
 EC99				;	01000010 (42H) - Verify
 EC99  BA 03F2			;	01001010 (4AH) - Write
 EC9C  FA			; 	01 			; Mode: Single mode select
 EC9D  A0 003F R		; 	  0  			; Address increment
 ECA0  8A E8			;	   0 			; Auto-initialization disable
 ECA2  24 0F			;	    xx		; 00=verify, 01=write, 10=read, 11=unused
 ECA4  74 0E			;	      10		; Channel 2 select
				;  ES:BX = pointer to buffer
				;
				; Output:
				;  CF = 0 success, 1 if error DMA exceeds segment
				;-------------------------------------------------------------------------
 ECA6  D0 E8			; Things you must do:
 ECA8  A8 04			;	- Calculate # of bytes to transfer by multiplying AL (sectors) by
 ECAA  74 02			;		sector size in INT 1E Disk Base Table.
 ECAC  B0 03			;	- Calculate linear memory address from ES:BX and normalize to
 ECAE				;		Paragraph:Offset (P:FFFFH).
				;	- Verify that Offset + Byte Count does not exceed the remaining
				;		space in that paragraph. The DMA controller can only select one
				;		paragraph bank at a time, so writes will NOT wrap to next para.
 ECAE  B1 04			;		Exit with DMA Boundary error if segment is exceeded.
 ECB0  D2 E5			;	- Reset the high/low byte flip-flop (send any value to I/O port 0CH)
				;	- Set DMA mode for Channel 2 to either Verify, Read or Write/Format
 ECB2  0A C5			;	- Disable interrupts while programming DMA
				;	- Set the DMA Page (memory paragraph) for DMA channel 2 (I/O port 81H)
				;	- Set the DMA Byte Counter to size of transfer minus 1 (since
				;		DMA's counter is 0-indexed)
				;	- Set the DMA Address register to beginning of DMA buffer from ES:BX
				;	- Enable interrupts and unmask DMA Channel 2
				;
 ECB4				;-------------------------------------------------------------------------
 ECB4  0C 08			; References:
 ECB6  EE			;  https://pdf1.alldatasheet.com/datasheet-pdf/view/127822/AMD/8237A.html
 ECB7  33 C9			;  https://wiki.osdev.org/ISA_DMA#Floppy_Disk_DMA_Initialization
 ECB9  88 0E 003E R		;  https://stackoverflow.com/questions/52396915/how-to-write-assembly-language-to-make-dma-works
 ECBD  88 0D			;  https://userpages.umbc.edu/~squire/intel_book.pdf
				;-------------------------------------------------------------------------
				FDC_INIT_DMA:
					PUSH	CX					; save track / sector
					OUT	DMA_FF, AL				; DMA clear flip-flop (port 0CH) (any value)
					MOV	DX, ES 				; get and shift ES by one nibble
 ECBF  0C 04						IF CPU_TYPE EQ CPU_V20
 ECC1  EE				ROL	DX, 4					; V20 only
 ECC2  FB						ELSE
 ECC3  E8 0203				MOV	CL, 4					; DL = highest and lowest nibble of ES
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 126 - 1


 ECC6  72 04				ROL	DX, CL				; DH = middle nibbles
 ECC8  3C C0						ENDIF
 ECCA  74 02				XCHG	AL, AH				; AL = DMA mode, AH = sectors to read
 ECCC					OUT	DMA_MODE, AL			; write to DMA mode reg (port 0BH)
 ECCC  B4 20				XOR	AL, AL				; AX = sectors to read << 8
 ECCE					XCHG	AX, CX				; CX = sectors, AX = scratch
 ECCE  88 25				MOV	AL, DBT.FBPS			; get bytes/sector param (0=128, 1=256, 2=512, 3=102
				4)
					CALL	INT_1E_PARAM			; AL = shift count (default 2 => 512)
					XCHG	AX, CX				; AX = sectors, CL = bytes per sector shifts
					SHR	AX, 1					; adjust shift for bytes/sector * 128
					SHL	AX, CL				; AX = bytes to transfer (AX * 2^CL)
					DEC	AX					; AX = bytes to transfer - 1
 ECD0  B0 03				XCHG	AX, CX				; CX = bytes to transfer - 1
 ECD2  E8 01B3				MOV	AL, DL				; AL = highest and lowest nibble of ES
 ECD5  72 AB				AND	AL, 0FH				; AL = only high nibble of ES
 ECD7  B0 00				AND	DL, 0F0H				; DX = low three nibbles of ES (shifted left
				 1 nibble)
 ECD9  E8 01A9				ADD	DX, BX				; DX = DMA start offset for transfer
 ECDC  72 A4				ADC	AL, 0					; AL = DMA page
 ECDE  B0 01				MOV	BX, DX				; check that buffer offset + length does not exceed 
				segment
 ECE0  E8 01A2				ADD	BX, CX				; BX = DMA end offset, test for boundary overflow
 ECE3					JC	FDC_DMA_BOUND			; error if DMA access across 64k boundary
 ECE3  EB 9D				CLI						; Disable interrupts
 ECE5					OUT	DMA_P_C2, AL 			; set DMA Channel 2 Page Address Register (port 81H)
					XCHG	AX, DX				; AL = address low byte, AH = high byte (4)
					OUT	DMA_2_A, AL				;
					XCHG	AL, AH 				; AH = address low byte, AL = high byte (4)
					OUT	DMA_2_A, AL				;
					XCHG	AX, CX				; AL = byte/count low byte, AH = high byte (4)
					OUT	DMA_2_C, AL				;
 ECE5					XCHG	AL, AH				; AH = byte/count low byte, AL = high byte (4)
 ECE5  58				OUT	DMA_2_C, AL
 ECE6  8A 05				STI						; Enable interrupts
 ECE8  8A E0				MOV	AL, DMA_SMR <0, 2>		; DMA clear single channel 2 mask bit
 ECEA  EB A1				OUT	DMA_MASK, AL			; Unmask DMA Channel 2 (port 0AH)
 ECEC				FDC_INIT_DMA_EXIT:
					POP	CX					; restore track / sector
					POP	DX 					; restore drive number DL
					POP	AX					; restore function number AH
					JC	INT_13_0_DONE			; exit if DMA error
 ECEC				
 ECEC  80 0D 09			;-------------------------------------------------------------------------
 ECEF  F9			; Set FDC command byte
 ECF0  EB 66			;
					MOV	AL, FDC_CB <1,1,,FDC_CMD_WR>	; FDC Write Data - Multi-Track, MFM
					CMP	AH, 3 				; is write?
					JE	FDC_RWVF				; jump if write
					MOV	AL, FDC_CB <0,1,,FDC_CMD_FMT>	; FDC Format Track - Single Track, MFM
					CMP	AH, 5 				; is format command?
					JE	FDC_RWVF 				; jump if format
					MOV	AL, FDC_CB <1,1,1,FDC_CMD_RD>	; FDC Read Data - MT, MFM, Skip deleted
				
				;-------------------------------------------------------------------------
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 127 - 1


				; FDC_RWVF: read, write, verify or format sectors
				;-------------------------------------------------------------------------
				; Input:
				;	AL = FDC command
				;	AH = function
				;	DL = drive
				;	DH = head
				;-------------------------------------------------------------------------
				FDC_RWVF:
					PUSH	AX					; preserve AH function number
					CALL	FDC_SEND 				; [0] send command in AL, CF if error
					POP	AX
					JC	FDC_RWV_ERR
					MOV	AL, DH				; AL = head
					XCHG	AX, DX				; AL = drive, AH = head, DL = head, DH = function
					AND	AX, 103H				;  xxxxx     ; unused
					SHL	AH, 1					;       h    ; head number (bit 3)
					SHL	AH, 1					;        dd  ; drive number (bit 1,2)
					OR	AL, AH 				; [1] head / drive
					CALL	FDC_SEND 				; send command in AL, CF if error
					JC	FDC_RWV_ERR
					CMP	DH, 5					; is format?
 ECF2					JE	FDC_FORMAT
 ECF2  E8 0110			
 ECF5				;-------------------------------------------------------------------------
 ECF5  72 8B			; FDC_RWV: read, write or verify sectors
 ECF7  50			;-------------------------------------------------------------------------
 ECF8  52			; Input:
 ECF9  92			;	CH = track/cylinder number (0-39)
 ECFA  8A C6			;	CL = sector number (1-17)
 ECFC  B6 4A			;	DL = head number (0-1)
 ECFE  80 0E 003F R 80		; 	(All registers clobbered)
 ED03  A8 01			;
 ED05  75 0D			; Output:
 ED07  80 26 003F R 7F		;	AL = number of sectors read, written or verified
 ED0C  B6 42			;-------------------------------------------------------------------------
 ED0E  3C 04			FDC_RWV PROC
 ED10  74 02				MOV	AL, CH 				; [2] cylinder number
 ED12  B6 46				CALL	FDC_SEND 				; send command in AL, CF if error
 ED14					JC	FDC_RWV_ERR
 ED14  92				MOV	AL, DL 				; [3] head number
					CALL	FDC_SEND 				; send command in AL, CF if error
					JC	FDC_RWV_ERR
					MOV	AL, CL 				; [4] sector number
					CALL	FDC_SEND 				; send command in AL, CF if error
					JC	FDC_RWV_ERR
					MOV	AL, DBT.FBPS			; [5] bytes per sector
					CALL	FDC_SEND_PARAM			; 2 = 512 bytes
					JC	FDC_RWV_ERR 
					MOV	AL, DBT.SPT				; [6] end of track (last sector in track)
					CALL	FDC_SEND_PARAM
					JC	FDC_RWV_ERR
					MOV	AL, DBT.SGAP			; [7] sector gap length
					CALL	FDC_SEND_PARAM
					JC	FDC_RWV_ERR
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 128 - 1


					MOV	AL, DBT.LSEC			; [8] data length (if cmd byte 5==0)
				
				;-------------------------------------------------------------------------
				; Send last param and wait for status
				;
				FDC_RWV_SEND_WAIT:
					CALL	FDC_SEND_PARAM
					JC	FDC_RWV_ERR
					CALL	FDC_WAIT_STATUS			; wait for WIF and get status
					JC	FDC_RWV_ERR				; check for timeout error
											; fall through for FDC SEC COUNT
				
				;-------------------------------------------------------------------------
				; FDC_SEC_COUNT: get the number of sectors read/verified/written
				;-------------------------------------------------------------------------
				; Input:
				;	CH = start track/cylinder number (0-39)
				;	CL = start sector number (1-17)
				;	DL = head number (0-1)
				; Ouput:
				;	AL = sectors transferred
				;
				; Note: If the operation finishes at the last head/sector of a track, 
				;	FDC will report the head/track/sector position to be the beginning 
				;	of the next track.
				;-------------------------------------------------------------------------
				FDC_SEC_COUNT PROC
					MOV	AH, FDC_LAST_ST.SEC		; AL = FDC reported end sector
					MOV	DH, DL				; DH = start head
					MOV	DL, CH				; DL = start track
					CMP	DX, WORD PTR FDC_LAST_ST.CYL	; end on the same head and track?
					JE	FDC_SEC_COUNT_SAME		; if not, rolled to next head or track
 ED15				
 ED15  51			;----------------------------------------------------------------------------;
 ED16  E6 0C			; FDC has ended on a different head or track. Calculate the correct number of
 ED18  8C C2			; sectors spanned.
				;
					MOV	AL, DBT.SPT				; get INT 1E sectors per track
					CALL	INT_1E_PARAM			; AL = last sector (# of SPT)
 ED1A  B1 04				CMP	DH, FDC_LAST_ST.HEAD		; end on same head but different track?
 ED1C  D3 C2				JNE	FDC_SEC_COUNT_SAME_CYL		; if so, has spanned a full head
					SHL	AL, 1					; two tracks worth of sectors
 ED1E  86 C4			FDC_SEC_COUNT_SAME_CYL:
 ED20  E6 0B				ADD	AH, AL				; add ending sector
 ED22  32 C0			FDC_SEC_COUNT_SAME:
 ED24  91				MOV	AL, AH				; AL = last_sector - starting_sector
 ED25  B0 03				SUB	AL, CL				;   returns AL = sectors read
 ED27  E8 020A			FDC_SEC_COUNT ENDP
 ED2A  91			
 ED2B  D1 E8			FDC_RWV ENDP					; fall through for exit
 ED2D  D3 E0			
 ED2F  48			;----------------------------------------------------------------------------;
 ED30  91			; Done with all disk operations and return AL
 ED31  8A C2			;
 ED33  24 0F			INT_13_2_5_DONE:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 129 - 1


 ED35  80 E2 F0				POP	CX					; discard original AX from INT_13 PROC
 ED38  03 D3				PUSH	AX					; replace with AL = sectors read
 ED3A  14 00			INT_13_2_5_EXIT:
 ED3C  8B DA				JMP	INT_13_DONE
 ED3E  03 D9			
 ED40  72 AA			;----------------------------------------------------------------------------;
 ED42  FA			; Clear AL and exit on any read/write error
 ED43  E6 81			;
 ED45  92			FDC_RWV_ERR:
 ED46  E6 04			FDC_FORMAT_ERR:
 ED48  86 C4				MOV	AL, 0					; on error: sectors read = 0
 ED4A  E6 04				JMP	SHORT INT_13_2_5_DONE
 ED4C  91			
 ED4D  E6 05			;----------------------------------------------------------------------------;
 ED4F  86 C4			; INT 13, 5: Format Track
 ED51  E6 05			;----------------------------------------------------------------------------;
 ED53  FB			; Input:
 ED54  B0 02			;	AH = 05
 ED56  E6 0A			;	AL = interleave value (XT only) / sectors per track
 ED58				;	CX = track/cylinder number (see below for format)
 ED58  59			;	DL = head number  (0-15 dec.)
 ED59  5A			;	ES:BX = pointer to block of "track address fields" (provided by DOS)
 ED5A  58			;----------------------------------------------------------------------------;
 ED5B  72 86			FDC_FORMAT PROC
					MOV	AL, DBT.FBPS			; [2] bytes per sector
					CALL	FDC_SEND_PARAM
					JC	FDC_FORMAT_ERR
					MOV	AL, DBT.SPT				; [3] sectors per track
 ED5D  B0 C5				CALL	FDC_SEND_PARAM
 ED5F  80 FC 03				JC	FDC_FORMAT_ERR
 ED62  74 09				MOV	AL, DBT.FGAP			; [4] format gap length
 ED64  B0 4D				CALL	FDC_SEND_PARAM
 ED66  80 FC 05				JC	FDC_FORMAT_ERR
 ED69  74 02				MOV	AL, DBT.FFILL			; [5] format fill byte
 ED6B  B0 E6				MOV	CL, 1					; format always starts at sector 1
					JMP	SHORT FDC_RWV_SEND_WAIT		; send, wait for WIF and get status
				FDC_FORMAT ENDP
				
				INT_13_2_5 ENDP
				
				;-------------------------------------------------------------------------
				; FDC_SEEK: Seek to track
				;-------------------------------------------------------------------------
				; Input:
				;	CH = track
 ED6D				;	DL = drive
 ED6D  50			;-------------------------------------------------------------------------
 ED6E  E8 0117			FDC_SEEK PROC
 ED71  58				PUSH	AX
 ED72  72 72				CALL	FDC_RECAL 				; recalibrate if needed
 ED74  8A C6				JC	FDC_SEEK_RECAL_ERR
 ED76  92				MOV	AL, FDC_CMD_SEEK			; seek command (0FH)
 ED77  25 0103				CALL	FDC_SEND 				; send command, CF if error
 ED7A  D0 E4				JC	FDC_SEEK_ERR
 ED7C  D0 E4				MOV	AL, DL 				; AL = drive number
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 130 - 1


 ED7E  0A C4				CALL	FDC_SEND 				; send command, CF if error
 ED80  E8 0105				JC	FDC_SEEK_ERR			; necessary?
 ED83  72 61				MOV	AL, CH 				; AL = track number
 ED85  80 FE 05				CALL	FDC_SEND 				; send command, CF if error
 ED88  74 60				JC	FDC_SEEK_ERR
					CALL	FDC_WAIT_SENSE			; wait for WIF, sense and get status
					JC	FDC_SEEK_ERR
					XOR 	AL, 01100000b			; select interesting bits
					TEST	AL, 01100000b			; ZF = abnormal term. AND seek complete
					JZ	FDC_SEEK_ERR
							IF ARCH_TYPE NE ARCH_EMU
					MOV	AX, DBT.HDST
					CALL	INT_1E_PARAM			; AL = head settle time (ms)
					CALL	IO_DELAY_MS				; delay AX ms
							ENDIF
					CLC
				FDC_SEEK_DONE:
					POP	AX
 ED8A					RET
 ED8A  8A C5			FDC_SEEK_ERR:
 ED8C  E8 00F9				OR	INT_13_STAT, FDC_ST_ERR_SEEK
 ED8F  72 55			FDC_SEEK_RECAL_ERR:
 ED91  8A C2				STC
 ED93  E8 00F2				JMP	SHORT FDC_SEEK_DONE
 ED96  72 4E			FDC_SEEK ENDP
 ED98  8A C1			
 ED9A  E8 00EB			;-------------------------------------------------------------------------
 ED9D  72 47			; FDC_MOTOR_ON: Turn on motor
 ED9F  B0 03			;-------------------------------------------------------------------------
 EDA1  E8 00E1			; Input:
 EDA4  72 40			; 	DL = drive number
 EDA6  B0 04			; Clobbers: CX
 EDA8  E8 00DA			;-------------------------------------------------------------------------
 EDAB  72 39			; Things you must do:
 EDAD  B0 05			;	- is motor already on? Skip wait for spin up
 EDAF  E8 00D3			;	- wait only for writes?
 EDB2  72 32			;	- check if recalibration is necessary
 EDB4  B0 06			;
				; Things you should do:
				;	- check if drive is valid in BDA?
				;-------------------------------------------------------------------------
				FDC_MOTOR_ON PROC
 EDB6					PUSH	AX
 EDB6  E8 00CC				PUSH	DX
 EDB9  72 2B			
 EDBB  E8 0147			;-------------------------------------------------------------------------
 EDBE  72 26			; Convert drive number to motor run format
				;
					MOV	CL, DL 				; move to CL for shift
					AND	CL, MASK FDSEL			; isolate selected drive number in CL
					MOV	AX, 110H 				; AH -> RUN_ST, AL -> FDC byte
					SHL	AX, CL 				; shift drive flags
					CLI 						; disable interrupts
					MOV	CH, FD_MOTOR_ST			; get current RUN_ST
					TEST	CH, AH 				; is drive already running?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 131 - 1


					JNZ	FDC_DRV_ALREADY_ON		; skip startup if so
					OR	AL, CL 				; combine drive number to FDC byte
					OR	AL, MASK FDDMA OR MASK FDCEN	; set DMA and controller enable flags
					MOV	DX, FDC_CTRL			; turn on motor
					OUT	DX, AL				; port 3F2H, FDC Digital Output
					MOV	AL, CH 				; AL = FD_MOTOR_ST
					AND	AL, NOT MASK FMOT 		; clear motor status of FD_MOTOR_ST
					OR	AL, AH				; combine nibbles
 EDC0					MOV	AH, 255				; restart timer to max for motor spinup
 EDC0  8A 26 0047 R			MOV	WORD PTR FD_MOTOR_ST, AX	; write to motor status and timer
 EDC4  8A F2				STI 						; enable interrupts
 EDC6  8A D5				TEST	AL, MASK FWRT			; Delay for motor spinup if write operation
 EDC8  3B 16 0045 R			JZ	FDC_DRIVE_STARTED 		; if not, bypass delay
 EDCC  74 0F			
				;-------------------------------------------------------------------------
				; Delay using timer tick counter
				;
					MOV	AL, DBT.FMST			; AL = INT_1E[10]
					CALL	INT_1E_PARAM 			; AL = motor startup time (in 125ms)
 EDCE  B0 04				CALL	IO_WAIT_MS_125			; wait AL * 125ms
 EDD0  E8 0161			
 EDD3  3A 36 0046 R		FDC_DRV_ALREADY_ON:
 EDD7  75 02				MOV	AL, DBT.FMCT 			; AL = INT_1E[2]
 EDD9  D0 E0				CALL	INT_1E_PARAM			; AL = reset motor counter
 EDDB					MOV	FD_MOTOR_CT, AL
 EDDB  02 E0				STI
 EDDD				FDC_DRIVE_STARTED:
 EDDD  8A C4				POP	DX
 EDDF  2A C1				POP	AX
 EDE1					RET
				FDC_MOTOR_ON ENDP
 EDE1				
				;----------------------------------------------------------------------------;
				; FDC_RECV: Wait for FDC ready to send and read next FDC Status byte into AL
				;----------------------------------------------------------------------------;
				; Timeout is 5 timer ticks = ~275ms.
 EDE1				;
 EDE1  59			; Input: None
 EDE2  50			; Output:
 EDE3				;	AL = top of FDC status stack
 EDE3  E9 FE9C			;	AH = 80H if error, 0 if success
				;	CF if timeout or error
				;----------------------------------------------------------------------------;
				FDC_RECV PROC
					PUSH	BX
 EDE6					XOR	BX, BX				; flag is 0 if RECV operation
 EDE6					MOV	BH, AL				; save byte to send
 EDE6  B0 00				JMP	SHORT FDC_SEND_RECV
 EDE8  EB F7			
				;----------------------------------------------------------------------------;
				; FDC_SEND_PARAM: Wait for FDC ready and send a floppy param in AL
				;----------------------------------------------------------------------------;
				; Same as below except AL input is INT_1E param index
				;----------------------------------------------------------------------------;
				FDC_SEND_PARAM PROC
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 132 - 1


					CALL	INT_1E_PARAM 			; AL = INT_1E[AL] param
				
				;----------------------------------------------------------------------------;
				; FDC_SEND: Wait for FDC ready to receive and send a single command
				;----------------------------------------------------------------------------;
 EDEA				; Timeout is 5 timer ticks = ~275ms.
 EDEA  B0 03			;
 EDEC  E8 0096			; Input:
 EDEF  72 F5			;	AL = byte to send to FDC
 EDF1  B0 04			;
 EDF3  E8 008F			; Output:
 EDF6  72 EE			;	AL = status register
 EDF8  B0 07			;	AH = 80H if error, 0 if success
 EDFA  E8 0088			;	CF and ZF if error
 EDFD  72 E7			;----------------------------------------------------------------------------;
 EDFF  B0 08			FDC_SEND PROC
 EE01  B1 01				PUSH	BX
 EE03  EB B1				MOV	BH, AL				; save byte to send
 EE05					MOV	BL, 1					; flag is 1 if SEND operation
				
 EE05				FDC_SEND_RECV:
					PUSH	CX
					PUSH	DX 					; call-preserve used registers
				
				;----------------------------------------------------------------------------;
				; Wait for FDC I/O direction = CPU to FDC and Data Reg Ready
				;
					MOV	DX, FDC_STAT 			; port 3F4H - FDC Main Status Register
					MOV	CX, 5					; CX = # of ticks to wait
 EE05					MOV	AH, BYTE PTR TIMER.LW		; get starting tick counter low byte
 EE05  50			
 EE06  E8 0189			FDC_SEND_WAIT_POLL:
 EE09  72 2F				IN	AL, DX				; AL = FDC status register
 EE0B  B0 0F				TEST	AL, AL				; is DRR = I/O to/from CPU?
 EE0D  E8 0078				JNS	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
 EE10  72 25			
 EE12  8A C2			;----------------------------------------------------------------------------;
 EE14  E8 0071			; FDC is ready for I/O
 EE17  72 1E			;
 EE19  8A C5				INC	DX 					; port 3F5H - FDC Command Status Register
 EE1B  E8 006A				TEST	BL, BL				; is send or receive?
 EE1E  72 17				JZ	FDC_RECV_WAIT_POLL		; jump if receive
 EE20  E8 00A6			
 EE23  72 12			;----------------------------------------------------------------------------;
 EE25  34 60			; SEND operation
 EE27  A8 60			;----------------------------------------------------------------------------;
 EE29  74 0C			FDC_SEND_WAIT_POLL_1:
					TEST	AL, MASK FIOD			; is I/O direction = CPU to FDC (0)?
 EE2B  B8 0009				JNZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
 EE2E  E8 0103			
 EE31  E8 094A			;----------------------------------------------------------------------------;
				; Status is ready to send
 EE34  F8			;
 EE35				FDC_SEND_READY:
 EE35  58				MOV	AL, BH				; restore AL byte to send
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 133 - 1


 EE36  C3				OUT	DX, AL				; send command
 EE37					JMP	SHORT FDC_WAIT_DONE		; status = success (0), CF = 0 and done
 EE37  80 0D 40			
 EE3A				;----------------------------------------------------------------------------;
 EE3A  F9			; RECEIVE operation
 EE3B  EB F8			;----------------------------------------------------------------------------;
 EE3D				FDC_RECV_WAIT_POLL:
					TEST	AL, MASK FIOD			; is I/O direction = FDC to CPU (1)?
					JZ	FDC_SEND_WAIT_TIMER		; if not, check if timeout has elapsed
				
				;----------------------------------------------------------------------------;
				; Data is ready to read
				;
				FDC_RECV_READY:
					IN	AL, DX				; read from FDC
				
				;----------------------------------------------------------------------------;
				; Completed with success
				;
				FDC_WAIT_DONE:
					XOR	AH, AH 				; status = success (0), CF = 0
				
				FDC_WAIT_EXIT:
 EE3D					POP	DX
 EE3D  50				POP	CX
 EE3E  52				POP	BX
					RET
				
				;----------------------------------------------------------------------------;
				; Check if timeout has expired
 EE3F  8A CA			;
 EE41  80 E1 03			FDC_SEND_WAIT_TIMER:
 EE44  B8 0110				MOV	AL, BYTE PTR TIMER.LW		; get current tick counter
 EE47  D3 E0				CMP	AL, AH				; still the same?
 EE49  FA				JZ	FDC_SEND_WAIT_POLL		; loop if the same
 EE4A  8A 2E 003F R			MOV	AH, AL				; otherwise, save new tick value to AH
 EE4E  84 EC				LOOPNZ FDC_SEND_WAIT_POLL		; loop until # of ticks (CX) has elapsed
 EE50  75 20			
 EE52  0A C1			FDC_WAIT_TIMEOUT:
 EE54  0C 0C				MOV	AH, FDC_ST_TIMEOUT 		; time out, drive not ready error
 EE56  BA 03F2				OR	INT_13_STAT, AH			; set flag in BDA
 EE59  EE				STC						; set error
 EE5A  8A C5				JMP	SHORT	FDC_WAIT_EXIT
 EE5C  24 F0			
 EE5E  0A C4			FDC_SEND ENDP
 EE60  B4 FF			FDC_SEND_PARAM ENDP
 EE62  A3 003F R		FDC_RECV ENDP
 EE65  FB			
 EE66  A8 80			;-------------------------------------------------------------------------
 EE68  74 11			; FDC_WAIT_SENSE: wait for WIF, sense status and get status bytes
				;-------------------------------------------------------------------------
				; Output:
				;	CF if error
				;	AL = FDC_LAST_ST (BDA Floppy drive status)
 EE6A  B0 0A			;	AH clobbered
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 134 - 1


 EE6C  E8 00C5			;-------------------------------------------------------------------------
 EE6F  E8 0908			FDC_WAIT_SENSE PROC
					CALL	FDC_WAIT_INT 			; wait for WIF
 EE72					JC	FDC_WAIT_SENSE_EXIT
 EE72  B0 02				MOV	AL, FDC_CMD_SENSE			; sense Interrupt status
 EE74  E8 00BD				CALL	FDC_SEND
 EE77  A2 0040 R		
 EE7A  FB			;----------------------------------------------------------------------------;
 EE7B				; FDC_RECV_STATUS:
 EE7B  5A			;----------------------------------------------------------------------------;
 EE7C  58			; Output:
 EE7D  C3			;	CF if FDC read/timeout error
 EE7E				;	NZ if result status error
				;
				;	AL = FDC_LAST_ST (BDA Floppy drive status), if success
				;	AH clobbered
				;----------------------------------------------------------------------------;
				FDC_RECV_STATUS PROC
					JC	FDC_WAIT_SENSE_EXIT		; return if timeout error
											; fall through to FDC_RECV_ALL
				
				;----------------------------------------------------------------------------;
				; FDC_RECV_ALL: Pop all status bytes from FDC to BDA
				;----------------------------------------------------------------------------;
				; Check for FDC errors and set FD_LAST_OP if necessary
 EE7E				;----------------------------------------------------------------------------;
 EE7E  53			FDC_RECV_ALL PROC
 EE7F  33 DB				PUSH	ES
 EE81  8A F8				PUSH	CX
 EE83  EB 08				PUSH	DI					; preserve DI (FD_LAST_OP)
					PUSH	DX
					MOV	DX, FDC_STAT
					MOV	AX, SEG _BDA
					MOV	ES, AX
					;MOV	DI, OFFSET FDC_LAST_ST 		; FDC Command Status Last Result
					INC	DI					; DI = FDC_LAST_ST (previously FD_LAST_OP)
 EE85					MOV	CX, 7					; loop up to 7 FDC bytes
 EE85  E8 00AC			FDC_RECV_ALL_LOOP:
					CALL	FDC_RECV				; AL = next byte, AH = 0 if success
					JC	FDC_RECV_ALL_DONE			; CF if failure
					STOSB						; write to BDA
				
				;----------------------------------------------------------------------------;
				; Additional delay for FDC to settle
				;
						IF IS_TURBO
					MOV	AL, 20				; [4]
						ELSE
					MOV	AL, 10				; [4]
						ENDIF
				FDC_RECV_DELAY:
					DEC	AX					; [3]
 EE88					JNZ	FDC_RECV_DELAY			; [4+16n]
 EE88  53			
 EE89  8A F8			;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 135 - 1


 EE8B  B3 01			; Check for additional bytes to be read from FDC registers
				;
 EE8D					IN	AL, DX				; DX = 03F4H
 EE8D  51				TEST	AL, MASK FDRW 			; is FDC R/W command in progress flag?
 EE8E  52				LOOPNZ FDC_RECV_ALL_LOOP		; loop until no flag or 7 bytes read
					JCXZ	FDC_RECV_CHECK_ERR 		; if all done, check for error
					XOR	AL, AL 				; otherwise, zero out rest of
					REP	STOSB					;  results in BDA
				FDC_RECV_CHECK_ERR:
 EE8F  BA 03F4				MOV	AL, FDC_LAST_ST.SB0 		; AL = last FDC status byte 0
 EE92  B9 0005				TEST	AL, MASK FR0CS			; check Last Command Status
 EE95  8A 26 006C R		FDC_RECV_ALL_DONE:
					POP	DX
 EE99					POP	DI
 EE99  EC				POP	CX
 EE9A  84 C0				POP	ES
 EE9C  79 19			FDC_WAIT_SENSE_EXIT:
					RET
				FDC_RECV_ALL ENDP
				FDC_RECV_STATUS ENDP
				FDC_WAIT_SENSE ENDP
 EE9E  42			
 EE9F  84 DB			;-------------------------------------------------------------------------
 EEA1  74 09			; FDC_WAIT_STATUS: Wait for WIF, get status bytes and check for error
				;-------------------------------------------------------------------------
				FDC_WAIT_STATUS PROC
					CALL	FDC_WAIT_INT 			; wait for WIF
					CALL	FDC_RECV_STATUS			; read FDC status into BDA
 EEA3											; CF if FDC error, NZ if status error
 EEA3  A8 40				JBE	FDC_WAIT_ERR_EXIT_OK		; exit if ZF or CF error
 EEA5  75 10			
				;-------------------------------------------------------------------------
				; FDC_WAIT_STATUS_ERR: Map FDC Command Status Register 1 to BDA error codes
				;-------------------------------------------------------------------------
				; Input:
 EEA7				;	AL = Last result from FDC_LAST_ST
 EEA7  8A C7			; Output:
 EEA9  EE			;	CF if error
 EEAA  EB 05			;	AH/AL = BDA Floppy drive status
				;-------------------------------------------------------------------------
				FDC_WAIT_STATUS_ERR PROC
					PUSH	SI
					TEST	AL, 01000000B			; command terminated abnormally?
 EEAC					MOV	AL, FDC_ST_ERR_FDC		; if not, FDC error
 EEAC  A8 40				JZ	FDC_WAIT_STATUS_ERR_DONE
 EEAE  74 07				MOV	AH, FDC_LAST_ST.SB1		; AH = last status byte 1
					TEST	AH, AH
					JZ	FDC_WAIT_STATUS_ERR_DONE	; skip if AH = 0
					MOV	SI, OFFSET FDC_ERR1_MAP
				FDC_ERR_MAP_LOOP:
 EEB0					LODS	BYTE PTR CS:[SI]			; fetch next error byte
 EEB0  EC				SHL	AH, 1					; CF if this status flag
					JA	FDC_ERR_MAP_LOOP			; loop if NC (not this flag)
											;  and NZ (more flags to check)
				FDC_WAIT_STATUS_ERR_DONE:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 136 - 1


					MOV	AH, AL				; AH = last result
 EEB1				FDC_WAIT_ERR_EXIT:
 EEB1  32 E4				POP	SI
					OR	INT_13_STAT, AH			; BDA 40:41H
 EEB3					STC
 EEB3  5A			FDC_WAIT_ERR_EXIT_OK:
 EEB4  59				RET
 EEB5  5B			
 EEB6  C3			;-------------------------------------------------------------------------
				; Note: Must check from most sig bit to lowest since higher
				; bits are more meaningful.
				;
				FDC_ERR1_MAP LABEL BYTE
 EEB7					DB	FDC_ST_ERR_SEC			; 80 end of cylinder
 EEB7  A0 006C R			DB	FDC_ST_ERR_FDC			; 40 unused (always zero)
 EEBA  38 E0				DB	FDC_ST_ERR_CRC			; 20 data error CRC
 EEBC  74 DB				DB	FDC_ST_DMA_OVR			; 10 DMA timeout/overrun
 EEBE  8A E0				DB	FDC_ST_ERR_FDC			; 08 unused (always zero)
 EEC0  E0 D7				DB	FDC_ST_ERR_SEC			; 04 Sector Not Found
					DB	FDC_ST_ERR_WP			; 02 Write Protect
 EEC2					DB	FDC_ST_ERR_MARK			; 01 Address mark not found or bad sector
 EEC2  B4 80			
 EEC4  08 25			FDC_WAIT_STATUS_ERR ENDP
 EEC6  F9			FDC_WAIT_STATUS ENDP
 EEC7  EB EA			
				;----------------------------------------------------------------------------;
 EEC9				; Retrieve a parameter value from the DBT by index
 EEC9				;----------------------------------------------------------------------------;
 EEC9				; Input:
				;	AL = parameter index (bounds not checked)
				; Output:
				;	AL = byte
				;
				; Size: 14 bytes
				;----------------------------------------------------------------------------;
				INT_1E_PARAM PROC
					PUSH	DS
					PUSH	BX
 EEC9					XOR	BX, BX 				; BX = IVT
 EEC9  E8 009F				MOV	DS, BX 				; DS = IVT
 EECC  72 36						ASSUME DS:_IVT
 EECE  B0 08				LDS	BX, _INT_1EH			; set DS:BX to INT_1E
 EED0  E8 FFB5				XLAT 						; AL = byte
					POP	BX
					POP	DS
					RET
				INT_1E_PARAM ENDP
				
				;
				; 21 BYTES HERE
				;
				BYTES_HERE	INT_0E
				
				;----------------------------------------------------------------------------;
 EED3				; INT 0EH - Floppy Disk Interrupt IRQ6
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 137 - 1


 EED3  72 2F			;----------------------------------------------------------------------------;
				; This interrupt is issued upon floppy disk I/O completion and sets the
				; floppy disk working interrupt flag at 40:3E, bit 7.
				;----------------------------------------------------------------------------;
						ORG 0EF57H
				INT_0E PROC
						ASSUME DS:_BDA
					STI						; necessary?
 EED5					PUSH	AX
 EED5  06				PUSH	DS
 EED6  51				MOV	AX, SEG _BDA 			; DS = BDA segment
 EED7  57				MOV	DS, AX
 EED8  52				OR	FD_CAL_ST, MASK FWIF		; turn on working interrupt flag
 EED9  BA 03F4				MOV	AL, OCW2 <001b> 			; End of Interrupt OCW
 EEDC  B8 ---- R			OUT	INT_P0, AL				; write EOI to port 0
 EEDF  8E C0				POP	DS
					POP	AX
 EEE1  47				IRET
 EEE2  B9 0007			INT_0E ENDP
 EEE5				
 EEE5  E8 FF96			;----------------------------------------------------------------------------;
 EEE8  72 16			; FDC_WAIT_INT: Wait for BDA Working Interrupt Flag from FDC
 EEEA  AA			;----------------------------------------------------------------------------;
				; Input: DS = BDA
				; Output: CF if timeout
				;----------------------------------------------------------------------------;
				FDC_WAIT_INT PROC
					STI						; ensure interrupts are on
 EEEB  B0 14				PUSH	AX 					; call preserve regs
					PUSH	CX
					MOV	CX, 2 * (1000/55) + 1		; timeout ~2 sec (37 ticks)
				FDC_WAIT_INT_LOOP1:
 EEED					MOV	AX, TIMER.LW			; AX = time ticks
 EEED  48			FDC_WAIT_INT_LOOP2:
 EEEE  75 FD				TEST	FD_CAL_ST, MASK FWIF 		; check for WIF in FD_CAL_ST (3EH)
					JNZ	FDC_WAIT_INT_OK			; if so, exit
							IF FDC_HLT_WAIT GT 0
					HLT						; wait for any INT
							ELSE
 EEF0  EC				NOP						; allow extra time for INTs
 EEF1  A8 10						ENDIF
 EEF3  E0 F0				CMP	AX, TIMER.LW			; has timer tick changed?
 EEF5  E3 04				JZ	FDC_WAIT_INT_LOOP2		; if not, wait for next INT
 EEF7  32 C0				LOOP	FDC_WAIT_INT_LOOP1		; decrement tick counter and resume loop
 EEF9  F3/ AA				OR	INT_13_STAT, FDC_ST_TIMEOUT 	; FDC result set time out, drive not ready
 EEFB					STC
 EEFB  A0 0042 R			JMP	SHORT FDC_WAIT_INT_DONE
 EEFE  A8 C0			FDC_WAIT_INT_OK:
 EF00					AND	FD_CAL_ST, NOT MASK FWIF 	; clear working interrupt flag
 EF00  5A			FDC_WAIT_INT_DONE:
 EF01  5F				POP	CX
 EF02  59				POP	AX
 EF03  07				RET
 EF04				FDC_WAIT_INT ENDP
 EF04  C3			
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 138 - 1


 EF05				;-------------------------------------------------------------------------
 EF05				; FDC_RECAL: recalibrate drive, if necessary
 EF05				;-------------------------------------------------------------------------
				; Input:
				;	DL = drive to recalibrate
				; Output:
				;	CF if error
 EF05				;
 EF05  E8 0063			; AX clobbered
 EF08  E8 FFC8			;-------------------------------------------------------------------------
				FDC_RECAL PROC
 EF0B  76 1E				PUSH	CX
					CALL	FDC_MOTOR_ON			; ensure motor is on
					MOV	CL, DL 				; move to CL for shift
					AND	CL, 0011B 				; mask just drive number in CL
					MOV	AL, 0001B 				; AL shift to FDC drive # bit
					SHL	AL, CL 				; shift drive flags
					TEST	AL, FD_CAL_ST 			; 0 means drive is uncalibrated
					JNZ	FDC_RECAL_DONE 			; if drive is calibrated, exit
					MOV	CH, AL 				; CH = drive bits
					MOV	AL, FDC_CMD_RECAL 		; recalibrate command (07H)
					CALL	FDC_SEND 				; send command, CF if error
 EF0D					JC	FDC_RECAL_ERR
 EF0D  56				MOV	AL, CL 				; AL = drive number
 EF0E  A8 40				CALL	FDC_SEND 				; send command, CF if error
 EF10  B0 20				;JC	FDC_RECAL_ERR			; (necessary?)
 EF12  74 11				CALL	FDC_WAIT_SENSE 			; wait for WIF, sense and get status in AL
 EF14  8A 26 0043 R			JC	FDC_RECAL_ERR
 EF18  84 E4				XOR 	AL, 01100000B			; select interesting bits
 EF1A  74 09				TEST	AL, 01100000B			; ZF = abnormal term AND seek complete
 EF1C  BE EF2C R			STC						; presume failure
 EF1F					JZ	FDC_RECAL_ERR			; jump if error
 EF1F  2E: AC				OR	FD_CAL_ST, CH 			; mark drive as calibrated and CLC
 EF21  D0 E4			FDC_RECAL_ERR:
 EF23  77 FA			FDC_RECAL_DONE:
					POP	CX
 EF25					RET
 EF25  8A E0			FDC_RECAL ENDP
 EF27				
 EF27  5E			INT_13 ENDP
 EF28  08 25			
 EF2A  F9			;
 EF2B				; 0 BYTES HERE
 EF2B  C3			;
				BYTES_HERE	INT_1E
				
				;----------------------------------------------------------------------------;
				; INT 1E - Disk Initialization Parameter Table Vector
				;----------------------------------------------------------------------------;
 EF2C				; Provides a "pluggable" method to allow additional disk ROMs or DOS to 
 EF2C  04			; replace this table.
 EF2D  20			;
 EF2E  10			;  00  Head Step Rate (SRT) = 0CH = 12ms
 EF2F  08			;      Head Unload Time (HUT) = 0FH (16ms increments) = 240ms(?)
 EF30  20			;  01  Head Load Time = 01H (2ms increments) = 2ms
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 139 - 1


 EF31  04			;  02  timer ticks to wait before disk motor shutoff = 37
 EF32  03			;  03  512 bytes per sector (0=128, 1=256, 2=512, 3=1024) = 2
 EF33  02			;  04  sectors per track (last sector number) = 8
				;  05  inter-block gap length/gap between sectors = 02AH
 EF34				;  06  data length, if sector length not specified = 0FFH
 EF34				;  07  gap length between sectors for format = 50H
				;  08  fill byte for formatted sectors = 0F6H
				;  09  head settle time in milliseconds = 25
				;  0A  motor startup time in eighths of a second = 4
				;  MFM = 2
				;
				; https://stanislavs.org/helppc/dbt.html
				; https://stanislavs.org/helppc/765.html
				; https://stanislavs.org/helppc/int_1e.html
				;----------------------------------------------------------------------------;
						ORG 	0EFC7H
				INT_1E	DBT 	<0CFH, 0010B, 37, 2, 8, 2AH, 0FFH, 50H, 0F6H, 25, 4>
 EF34				
 EF34  1E			;----------------------------------------------------------------------------;
 EF35  53			; INT 17 - Printer BIOS Services
 EF36  33 DB			;----------------------------------------------------------------------------;
 EF38  8E DB			;	INT 17,0   Print character
				;	INT 17,1   Initialize printer port
 EF3A  C5 1E 0078 R		;	INT 17,2   Read printer port status
 EF3E  D7			;
 EF3F  5B			; https://www.stanislavs.org/helppc/ports.html
 EF40  1F			; https://en.wikipedia.org/wiki/Parallel_port#IBM_PC_implementation
 EF41  C3			; http://www.techhelpmanual.com/907-parallel_printer_adapter_ports.html
 EF42				;----------------------------------------------------------------------------;
				; Things you must do (on all calls):
				; - Verify printer is within range 0-2.
				; - Verify printer index is detected and get I/O address.
				; - Return AH = 0 if any of the above are not met.
				; - Do the function call
 EF42			     1			LOCAL LBL
			     1	
 = 0015			     1	BYTES_HERE_INT_0E = INT_0E-$
			     1	
			     1			IFDEF BYTES_HERE_INT_0E
			     1			IF2
			     1			IF BYTES_HERE_INT_0E LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_0E (BYTES_HERE_INT_0E)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				; - Get port status and return in AH for any valid calls.
				;
				; Things you should do:
				; - Get installed printer count via INT 11H
				;
				;----------------------------------------------------------------------------;
						ORG 0EFD2H
				INT_17 PROC
 EF57						ASSUME DS:_BDA
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 140 - 1


					STI 						; enable interrupts
 EF57  FB				CMP	DX, 2					; is greater than 2?
 EF58  50				JA	INT_17_IRET 			; if so, exit
 EF59  1E				PUSH	DX					; call-preserve working regs
 EF5A  B8 ---- R			PUSH	DI
 EF5D  8E D8				PUSH	CX
 EF5F  80 0E 003E R 80			PUSH	AX
 EF64  B0 20				PUSH	DS
 EF66  E6 20				MOV	CX, SEG _BDA 			; CH = 0, CL = 40H
 EF68  1F				MOV	DS, CX				; DS = BDA
 EF69  58				MOV	DI, DX 				; DI = LPT port index (0-2)
 EF6A  CF				MOV	CL, LPT_TIME_B[DI]		; CX = port timeout
 EF6B					SHL	DI, 1 				; convert to word-aligned index
					MOV	DX, LPT_ADDR_B[DI]		; DX = data port address
					POP	DS 					; restore DS
					TEST	DX, DX 				; is port index valid (detected)?
					JZ	INT_17_DONE 			; if not, exit
					DEC	AH
					JZ	INT_17_1				; AH = 1 then init
					JG	INT_17_2	 			; AH = 2 then status
 EF6B											; AH = 0 fall through to print
 EF6B  FB			
 EF6C  50			;----------------------------------------------------------------------------;
 EF6D  51			; AH = 0 - Print Character
 EF6E  B9 0025			;----------------------------------------------------------------------------;
 EF71				; Write character and returns status
 EF71  A1 006C R		;
 EF74				; Input:
 EF74  F6 06 003E R 80		;	AH = -1 (not 0)
 EF79  75 0F			;	AL = character to print
				;	CX = timeout "value" (the number of 64k loops)
 EF7B  F4			;	DX = LPT data port (278, 378, 3BC)
				;
				; Output:
				;	AH = printer status, see AH = 2
 EF7C  3B 06 006C R		;
 EF80  74 F2			;----------------------------------------------------------------------------;
 EF82  E2 ED			; 765	    |			- LCX		unused
 EF84  80 0D 80			;    4    |			- LCIRQ	0 = IRQ disable, 1=IRQ enable for ACK
 EF87  F9			;     3   |			- LCDR	1 = printer reads output,  (pin 17)
 EF88  EB 05			;      2  |			- LCINI	0 = initialize printer,  (pin 16)
 EF8A				;       1 |			- LCLF	1 = auto line feed,  (pin 14)
 EF8A  80 26 003E R 7F		;        0|			- LCOUT	1 = output data to printer,  (pin 1)
 EF8F				; PRN_CTRL RECORD	LCX:3,LCIRQ:1,LCDR:1,LCINI:1,LCLF:1,LCOUT:1
 EF8F  59			;----------------------------------------------------------------------------;
 EF90  58			INT_17_0:
 EF91  C3				OUT	DX, AL			; write the character to data port
 EF92					INC	DX				; DX to status port
				INT_17_0_TIMEOUT_LOOP:
					XOR	DI, DI			; set abitrary timeout counter
				INT_17_0_BUSY_LOOP:
					IN	AL, DX			; read status port
					TEST	AL, MASK LPBZ 		; printer busy?
					JNZ	INT_17_0_OK			; if not, toggle strobe pin and exit
					DEC	DI
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 141 - 1


					JNZ	INT_17_0_BUSY_LOOP
					LOOP	INT_17_0_TIMEOUT_LOOP 	; loop BDA/LPT timeout value
					OR	AL, MASK LPTO		; printer timed out - set flag
					JMP	SHORT INT_17_2_STATUS_2	; exit with status in AL
 EF92				INT_17_0_OK:
 EF92  51				MOV	AL, MASK LCDR OR MASK LCINI OR MASK LCOUT ; /strobe pin HIGH
 EF93  E8 FEA7				INC	DX 				; DX = control port
 EF96  8A CA				PUSH	DX				; I/O delay
 EF98  80 E1 03				OUT	DX, AL
 EF9B  B0 01				POP	DX				; I/O delay
 EF9D  D2 E0				MOV	AL, MASK LCDR OR MASK LCINI	; /strobe pin LOW
 EF9F  84 06 003E R			OUT	DX, AL
 EFA3  75 1E				DEC	DX 				; reset to data port
 EFA5  8A E8				DEC	DX				; and fall through to status
 EFA7  B0 07			
 EFA9  E8 FEDC			;----------------------------------------------------------------------------;
 EFAC  72 15			; AH = 2 - Read printer port status
 EFAE  8A C1			;----------------------------------------------------------------------------;
 EFB0  E8 FED5			; Return status of specified printer port
				;
 EFB3  E8 FF13			; Input:
 EFB6  72 0B			;	AH = 1 (not 2)
 EFB8  34 60			;	DX = LPT data port (278, 378, 3BC)
 EFBA  A8 60			;
 EFBC  F9			; Output:
 EFBD  74 04			;	AH = status:
 EFBF  08 2E 003E R		;
 EFC3				;		|7|6|5|4|3|2|1|0|  Printer status bits
 EFC3				;		 | | | | | | | `---- time out		(always 0)
 EFC3  59			;		 | | | | | `------- unused
 EFC4  C3			;		 | | | | `-------- I/O error		Pin 15
 EFC5				;		 | | | `--------- selected		Pin 13
				;		 | | `---------- out of paper		Pin 12
 EFC5				;		 | `----------- acknowledge		Pin 10
				;		 `------------ not busy			/Pin 11
				;
				; PRN_STAT RECORD	LPBZ:1,LPACK:1,LPOP:1,LPSEL:1,LPIO:1,LPX:2,LPTO:1
				;----------------------------------------------------------------------------;
				INT_17_2:
 EFC5			     1			LOCAL LBL
			     1	
 = 0002			     1	BYTES_HERE_INT_1E = INT_1E-$
			     1	
			     1			IFDEF BYTES_HERE_INT_1E
			     1			IF2
			     1			IF BYTES_HERE_INT_1E LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_1E (BYTES_HERE_INT_1E)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					INC	DX 				; DX to status port
				INT_17_2_STATUS:
					IN	AL, DX			; AL = status
					AND	AL, NOT (MASK LPX OR MASK LPTO)	; mask time-out pins
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 142 - 1


				INT_17_2_STATUS_2:
					XOR	AL, MASK LPACK OR MASK LPIO ; acknowledge and error are active low
					MOV	CH, AL			; save status to CH so AL can be restored
				INT_17_DONE:
					POP	AX				; restore AL
					MOV	AH, CH			; AH = status
					POP	CX
					POP	DI
					POP	DX
				INT_17_IRET:
					IRET
				
				;----------------------------------------------------------------------------;
				; AH = 1 - Initialize printer port
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0 (not 1)
				;	DX = LPT data port (278, 378, 3BC)
				;
				; Output:
				;	AH = status, see AH = 2
				;----------------------------------------------------------------------------;
 EFC7 CF 02 25 02 08 2A		INT_17_1:
       FF 50 F6 19 04
					MOV	AL, MASK LCDR		; printer reads output = 1
					INC	DX
					INC	DX				; DX = control port
					OUT	DX, AL			; send to control port
					MOV	CH, HIGH 800H		; delay 800H-ish loops
					IO_DELAY 				; wait, then CX = 0
					OR	AL, MASK LCINI		; initialize printer = 1
					OUT	DX, AL			; send to control port
					DEC	DX				; DX = status port
					JMP	SHORT INT_17_2_STATUS	; small delay, read status and return
				INT_17 ENDP
				
				CRLF_SHOW_CURSOR PROC
				;----------------------------------------------------------------------------;
				; CRLF then show cursor display (this exists to utilize the free bytes here)
				;----------------------------------------------------------------------------;
					CALL	CRLF
				
				;----------------------------------------------------------------------------;
				; Show cursor display - restores saved cursor in CURSOR_DEFAULT
				;----------------------------------------------------------------------------;
				; Input:
				; 	DS = BDA
				; Clobbers CX
 EFD2				;----------------------------------------------------------------------------;
				SHOW_CURSOR PROC
 EFD2  FB					ASSUME DS:_BDA
 EFD3  83 FA 02				MOV	CX, CURSOR_DEFAULT	; reset to original
 EFD6  77 4A				JMP	SHORT SET_CURSOR
 EFD8  52			
 EFD9  57			;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 143 - 1


 EFDA  51			; Hide cursor display
 EFDB  50			;----------------------------------------------------------------------------;
 EFDC  1E			; Clobbers CX
 EFDD  B9 ---- R		;----------------------------------------------------------------------------;
 EFE0  8E D9			HIDE_CURSOR PROC
 EFE2  8B FA				MOV	CX, 2000H			; hide cursor
 EFE4  8A 4D 78			
 EFE7  D1 E7			;----------------------------------------------------------------------------;
 EFE9  8B 55 08			; Set Video Cursor
 EFEC  1F			;----------------------------------------------------------------------------;
 EFED  85 D2			SET_CURSOR PROC
 EFEF  74 2B				PUSH	AX
 EFF1  FE CC				MOV	AH, 1
 EFF3  74 2E				INT	10H
 EFF5  7F 1D				POP	AX
					RET
				SET_CURSOR ENDP
				
				HIDE_CURSOR ENDP
				SHOW_CURSOR ENDP
				CRLF_SHOW_CURSOR ENDP
				
				;
				; 0 BYTES HERE
				;
				BYTES_HERE	INT_10_JMP
				
				;----------------------------------------------------------------------------;
				; INT 10h - Function Jump Table
				;----------------------------------------------------------------------------;
						ORG 0F045H
				INT_10_JMP LABEL WORD
					DW	OFFSET INT_10_0		; AH = 0 - Set video mode
					DW	OFFSET INT_10_1		; AH = 1 - Set cursor type
					DW	OFFSET INT_10_2		; AH = 2 - Set cursor position
					DW	OFFSET INT_10_3		; AH = 3 - Read cursor position
					DW	OFFSET INT_10_RET		; AH = 4 - Read light pen (not supported)
					DW	OFFSET INT_10_5		; AH = 5 - Select active display page
					DW	OFFSET INT_10_6		; AH = 6 - Scroll active page up
					DW	OFFSET INT_10_7		; AH = 7 - Scroll active page down
 EFF7					DW	OFFSET INT_10_8		; AH = 8 - Read character and attribute at cursor
 EFF7  EE				DW	OFFSET INT_10_9		; AH = 9 - Write character and attribute at cursor
 EFF8  42				DW	OFFSET INT_10_A		; AH = A - Write character at current cursor
 EFF9					DW	OFFSET INT_10_B		; AH = B - Set color palette
 EFF9  33 FF				DW	OFFSET INT_10_C		; AH = C - Write graphics pixel at coordinate
 EFFB					DW	OFFSET INT_10_D		; AH = D - Read graphics pixel at coordinate
 EFFB  EC				DW	OFFSET INT_10_E		; AH = E - Write text in teletype mode
 EFFC  A8 80				DW	OFFSET INT_10_F		; AH = F - Get current video state
 EFFE  75 09			
 F000  4F			;----------------------------------------------------------------------------;
 F001  75 F8			; INT 10h - Video BIOS Services
 F003  E2 F4			;----------------------------------------------------------------------------;
 F005  0C 01			; BIOS Interface to CGA/MDA display adapters.
 F007  EB 0F			;----------------------------------------------------------------------------;
 F009				; References and Info Sources:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 144 - 1


 F009  B0 0D			;  "PC System Programming", Tischer
 F00B  42			;  "Programmer's Guide to PC Video Systems", Second Edition, Wilton
 F00C  52			;  https://github.com/joncampbell123/dosbox-x/blob/master/src/ints/int10_char.cpp
 F00D  EE			;  https://github.com/joncampbell123/dosbox-x/issues/256
 F00E  5A			;  https://www.seasip.info/VintagePC/cga.html
 F00F  B0 0C			;  https://www.reenigne.org/blog/crtc-emulation-for-mess/
 F011  EE			;  (many other posts and articles...)
 F012  4A			;
 F013  4A			; Thx to @Raffzahn for "clean room" specs for various display routines.
				;----------------------------------------------------------------------------;
						ORG 0F065H
				INT_10 PROC
					STI					; enable interrupts
					CMP	AH, 0FH			; function > 15?
					JA	INT_10_IRET			; exit if function not valid
					PUSH	ES				; always preserve these registers
					PUSH	DS
					PUSH	DI
					MOV	DI, SEG _BDA		; DS = BDA segment
					MOV	DS, DI
					MOV	DI, AX			; save AX
					XCHG	AH, AL			; AL = function, AH = video mode
					CLD					; string instructions forward direction
					SHL	AL, 1				; word align index
					CBW					; AX = jump index
					XCHG	AX, DI			; restore AX, DI = jump offset
					CALL	CS:INT_10_JMP[DI]
				INT_10_DONE:
					POP	DI
					POP	DS
					POP	ES
				INT_10_IRET:
					IRET
 F014				
 F014  42			;----------------------------------------------------------------------------;
 F015				; Is Current video mode text or GFX?
 F015  EC			;----------------------------------------------------------------------------;
 F016  24 F8			; Input:
 F018				; 	DS = BDA (040h)
 F018  34 48			; Output:
 F01A  8A E8			;	AL = current video mode
 F01C				; 	ZF = 0 if CGA GFX (modes 4-6)
 F01C  58			;	ZF = 1 if CGA/MDA Text (modes 0-3 and 7)
 F01D  8A E5			;	CF = 1 if MDA
 F01F  59			;----------------------------------------------------------------------------;
 F020  5F			INT_10_IS_TXT PROC
 F021  5A				MOV	AL, VID_MODE
 F022					CMP	AL, 7				; ZF if mode MDA
 F022  CF				CMC					; CF if MDA
					JZ	INT_10_IS_TXT_DONE
					TEST	AL, 4 AND 5 AND 6		; NZ if GFX modes 4,5,6?
				INT_10_IS_TXT_DONE:
					RET
				INT_10_IS_TXT ENDP
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 145 - 1


				;----------------------------------------------------------------------------;
				; Is Current video CGA 80 col?
				;----------------------------------------------------------------------------;
				; Output:
				;	ZF = 1 if mode is 2 or 3
 F023				;	ZF = 0 all others
 F023  B0 08			;----------------------------------------------------------------------------;
 F025  42			INT_10_IS_CGA80 PROC
 F026  42				PUSH	AX
 F027  EE				PUSH	DS
 F028  B5 08				MOV	AX, SEG _BDA
					MOV	DS, AX
			     1			LOCAL _DONE
 F02A			     1	??0024:
 F02A  E2 FE		     1		LOOP	??0024					; long delay for I/O
 F02C  0C 04				MOV	AL, VID_MODE
 F02E  EE				CMP	AL, 2				; is mode 2?
 F02F  4A				JZ	INT_10_IS_CGA80_DONE
 F030  EB E3				CMP	AL, 3				; is mode 3?
 F032				INT_10_IS_CGA80_DONE:
					POP	DS
 F032					POP	AX
					RET
				INT_10_IS_CGA80 ENDP
				
 F032  E8 06E1			;
				; 1 BYTE HERE
				;
				BYTES_HERE	INT_1D
				
				;----------------------------------------------------------------------------;
				; INT 1D - Video mode register value table 
				;----------------------------------------------------------------------------;
				; https://stanislavs.org/helppc/6845.html
 F035				;----------------------------------------------------------------------------;
						ORG 0F0A4H					; 116 bytes
 F035  8B 0E 00E8 R		INT_1D PROC
 F039  EB 03			
				; 40x25 CGA text
				INT_1D_40		CRTC	<38H,28H,2DH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H>
				O_INT_1D_40		EQU	INT_1D_40-INT_1D		; 40x25 mode data offset
				
				; 80x25 CGA text
				INT_1D_80		CRTC	<71H,50H,5AH,0AH,1FH,06H,19H,1CH,02H,07H,06H,07H>
 F03B				O_INT_1D_80		EQU	INT_1D_80-INT_1D		; 80x25 mode data offset
 F03B  B9 2000			
				; 320x200 CGA graphics
				INT_1D_GFX		CRTC	<38H,28H,2DH,0AH,7FH,06H,64H,70H,02H,01H,06H,07H>
				O_INT_1D_GFX	EQU	INT_1D_GFX-INT_1D		; 320x200 mode data offset
				
 F03E				; MDA text
 F03E  50			INT_1D_MDA		CRTC	<61H,50H,52H,0FH,19H,06H,19H,19H,02H,0DH,0BH,0CH>
 F03F  B4 01			O_INT_1D_MDA	EQU	INT_1D_MDA-INT_1D		; MDA mode data offset
 F041  CD 10			
 F043  58			INT_1D ENDP
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 146 - 1


 F044  C3			
 F045				;----------------------------------------------------------------------------;
				; INT 10,0 - Set video mode
 F045				;----------------------------------------------------------------------------;
 F045				; AL = video mode:
 F045				;   0000  00  M 40x25 B/W text (CGA)
				;   0001  01  C 40x25 16 color text (CGA)
				;   0010  02  M 80x25 16 shades of gray text (CGA)
				;   0011  03  C 80x25 16 color text (CGA)
				;   0100  04  C 320x200 4 color graphics (CGA)
				;   0101  05  C 320x200 4 color graphics (CGA)
 F045			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_10_JMP = INT_10_JMP-$
			     1	
			     1			IFDEF BYTES_HERE_INT_10_JMP
			     1			IF2
			     1			IF BYTES_HERE_INT_10_JMP LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_10_JMP (BYTES_HERE_INT_10_JMP)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				;   0110  06  M 640x200 B/W graphics (CGA)
				;   0111  07  M 80x25 Monochrome text (MDA,HERC)
				;
				; AX clobbered
				;----------------------------------------------------------------------------;
 F045				; Things you must do:
 F045  F0E4 R			; 	1. Check that the new video mode is valid: 0-7. For MDA, the mode
 F047  F19F R			;		will always be 7. If CGA mode > 6, reset in current mode.
 F049  F1B5 R			;	2. Clear the video BDA block data
 F04B  F1FB R			;	3. Determine the type of adapter from motherboard switches
 F04D  F19E R			;	4. Disable the adapter to reprogram it.
 F04F  F20C R			;	5. Based on new input mode and MB switches, determine:
 F051  F234 R			;		- Adapter base I/O port (03B4H for MDA, 03D4H for CGA)
 F053  F233 R			;		- RAM base segment (0B000H for MDA, 0B800H for CGA)
 F055  F347 R			;		- RAM size (16K for CGA gfx, 4K for 80x25 text, 2K for 40x25 text)
 F057  F3E8 R			;		- RAM fill data (0 for gfx, space char with attribute 7 for text)
 F059  F3E8 R			;		- Corresponding entry from INT 1DH CRTD table for new video mode
 F05B  F4D2 R			;		- Corresponding mode byte from CRT_MODE table
 F05D  F4FD R			;	6. Clear regen RAM by filling with data from above
 F05F  F524 R			;	7. Write data from CRTD table to adapter registers to set mode
 F061  F576 R			;	8. Write CGA palette register
 F063  F5E5 R			;	9. Enable adapter with new mode byte
				;
				;----------------------------------------------------------------------------;
				INT_10_0 PROC
					PUSH	BX
					PUSH	DX
					PUSH	BP
					PUSH	CX
					PUSH	SI
					MOV	DI, OFFSET VID_MODE		; start with VID_MODE (49H)
					CMP	AL, 7					; is new video mode > 7?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 147 - 1


					JB	INT_10_0_1				; if not, is valid mode
					MOV	AL, [DI]				; otherwise use current mode
				INT_10_0_1:
					XCHG	AX, BX				; BL = new video mode
				
				;----------------------------------------------------------------------------;
				; Clear all video data in BDA
				;
 F065					XOR	AX, AX
 F065  FB				MOV	CX, L_VID_BDA / 2			; Video data in BDA (in WORDs)
 F066  80 FC 0F				PUSH	DS
 F069  77 19				POP	ES					; ES = BDA
 F06B  06				REP	STOSW					; clear data, set CX = 0
 F06C  1E			
 F06D  57			;----------------------------------------------------------------------------;
 F06E  BF ---- R		; Determine video adapter type and new mode and re-program 6845
 F071  8E DF			;
 F073  8B F8				MOV	AL, BYTE PTR EQUIP_FLAGS	; get BDA equipment flags
 F075  86 E0				XOR	AL, MASK VIDM			; isolate video switches
 F077  FC				AND	AL, 11B SHL VIDM			; is switch MDA (ON-ON)?
 F078  D0 E0				MOV	AL, 0					; 0 = CGA disable video signal
 F07A  98				MOV	SI, O_INT_1D_80			; SI = CGA 80 CRTD offset
 F07B  97				MOV	BH, VID_DEF_COLS			; default 80 columns
 F07C  2E: FF 95 F045 R			MOV	CH, HIGH OFFSET MDA_MEM		; Total MDA video memory = 1000H (4K)
 F081					MOV	AH, CH				; MDA/CGA 80x25 page size = 1000H (4K)
 F081  5F				MOV	DI, DBW <VID_ATTR, VID_SP>	; fill memory with attr 7 and space
 F082  1F				JNZ	INT_10_0_IS_CGA
 F083  07				INC	AX					; 1 = MDA disable video signal value
 F084					MOV	BP, SEG _MDA_MEM			; BP = MDA memory segment (0B000H)
 F084  CF				MOV	DX, MDA_CTRL			; MDA Mode Select Register (03B8H)
					MOV	BL, 7					; only valid MDA display mode is 7
					MOV	SI, O_INT_1D_MDA			; SI = MDA CRTD offset
					JMP	SHORT INT_10_0_DETECT_DONE	; MDA mode selected, continue
				INT_10_0_IS_CGA:
					MOV	CH, HIGH OFFSET CGA_MEM		; Total CGA video memory = 4000H (16K)
					MOV	DX, CGA_CTRL			; CGA Mode Select Register (03D8H)
					MOV	BP, SEG _CGA_MEM			; BP = CGA memory segment (0B800H)
					TEST	BL, 0100B				; text or gfx mode?
					JZ	INT_10_0_IS_CGA_TEXT		; jump if text
				INT_10_0_IS_CGA_GFX:
					MOV	SI, O_INT_1D_GFX			; SI = CGA GFX CRTD offset
					MOV	AH, HIGH OFFSET CGA_MEM		; CGA gfx page size = 4000H (16K)
 F085					XOR	DI, DI				; DI = memory fill 0's
 F085  A0 0049 R			TEST	BL, 0010B				; is 80 or 40 col text?
 F088  3C 07				JNZ	INT_10_0_DETECT_DONE		; jump if 80
 F08A  F5				JMP	SHORT INT_10_0_IS_40_COL	; else set 40 columns
 F08B  74 02			INT_10_0_IS_CGA_TEXT:
 F08D  A8 04				TEST	BL, 0010B				; is 80 or 40 col text?
 F08F					JNZ	INT_10_0_DETECT_DONE		; jump if 80
 F08F  C3				MOV	AH, HIGH OFFSET CGA_MEM_40	; CGA 40x25 page size = 800H (2K)
 F090					XOR	SI, SI				; SI = CGA 40 CRTD offset (00H)
				INT_10_0_IS_40_COL:
					SHR	BH, 1					; BH = 40 columns
				INT_10_0_DETECT_DONE:
					MOV	WORD PTR VID_MODE, BX		; write BDA video mode and columns
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 148 - 1


					MOV	ES, BP				; ES = video memory segment
					MOV	VID_MEM_SEG, BP			; write video segment for later
					OUT	DX, AL				; disable video
					MOV	BYTE PTR VID_BUF_SZ[1], AH	; write BDA video page size
 F090					SUB	DL, 4					; DX = 6845 index register port
 F090  50				MOV	VID_PORT, DX			; write BDA video I/O port
 F091  1E				MOV	BP, BX				; save video mode to BP
 F092  B8 ---- R		
 F095  8E D8			;----------------------------------------------------------------------------;
 F097  A0 0049 R		; Fill video regen/memory
 F09A  3C 02			;
 F09C  74 02				XCHG	AX, DI				; AX = fill byte
 F09E  3C 03				XOR	DI, DI				; start at offset 0
 F0A0					SHR	CX, 1					; WORD size counter
 F0A0  1F				REP	STOSW
 F0A1  58			
 F0A2  C3			;----------------------------------------------------------------------------;
 F0A3				; Write CRTC data to 6845 registers
				;
					PUSH	DS					; save DS = BDA
					XOR	AX, AX
					MOV	VID_PAGE, AL			; video page 1 = 0
					MOV	DS, AX				; DS = IVT
 F0A3			     1			LOCAL LBL
			     1	
 = 0001			     1	BYTES_HERE_INT_1D = INT_1D-$
			     1	
			     1			IFDEF BYTES_HERE_INT_1D
			     1			IF2
			     1			IF BYTES_HERE_INT_1D LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_1D (BYTES_HERE_INT_1D)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
							ASSUME DS:_IVT
					LDS	BX, _INT_1DH			; DS:BX = BIOS:INT_1D
					MOV	DI, WORD PTR [BX][SI].CSL	; DI = cursor type (start and end)
					MOV	CL, SIZE CRTC			; size of CRTC data
				INT_10_0_CRTC_LOOP:
					MOV	AH, [BX][SI]			; AH = next byte from table
					OUT	DX, AX				; write AH to register index AL
 F0A4					INC	AX					; next register index
					INC	SI					; next byte in table
					LOOP	INT_10_0_CRTC_LOOP
 F0A4 38 28 2D 0A 1F 06		
       19 1C 02 07 06 07
       00 00 00 00
 = 0000				;----------------------------------------------------------------------------;
				; Send mode and color bytes to 6845
				;
 F0B4 71 50 5A 0A 1F 06			XCHG	AX, BP				; AL = new video mode
       19 1C 02 07 06 07
       00 00 00 00
 = 0010					CMP	AL, 6					; is CGA color gfx mode?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 149 - 1


					MOV	AH, VID_CSGFX <>			; use for 640x200 mode 6
					JE	INT_10_0_COLOR_BYTE		; jump if so
 F0C4 38 28 2D 0A 7F 06			MOV	AH, VID_CSTXT <>			; otherwise use for text/low gfx
       64 70 02 01 06 07
       00 00 00 00
 = 0020				INT_10_0_COLOR_BYTE:
					MOV	BX, OFFSET CRT_MODE
					XLAT						; AL = control byte data
 F0D4 61 50 52 0F 19 06					ASSUME DS:_BDA
       19 19 02 0D 0B 0C
       00 00 00 00
 = 0030					POP	DS					; DS = BDA
					ADD	DL, 4					; DX = control reg
 F0E4					MOV	WORD PTR VID_MODE_REG, AX	; write mode and color to BDA
					OUT	DX, AX				; write mode and color to 6845
					XCHG	AX, DI				; AX = cursor bytes from CRTC table
					XCHG	AH, AL				; convert endian for cursor bytes
					MOV	VID_CURS_TYPE, AX			; write cursor type to BDA
					POP	SI
					POP	CX
					POP	BP
					POP	DX
					POP	BX
				INT_10_RET:
					RET
				INT_10_0 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,1 - Set cursor type
				;----------------------------------------------------------------------------;
				; Input:
				;	CH = cursor starting scan line (cursor top) (low order 5 bits)
				;	CL = cursor ending scan line (cursor bottom) (low order 5 bits)
				;----------------------------------------------------------------------------;
				INT_10_1 PROC
					PUSH	DX
					XCHG	AX, DI			; save AX
					MOV	VID_CURS_TYPE, CX		; write new cursor to BDA
					MOV	AL, CRTC.CSL		; AL = Cursor start index (scan line)
					MOV	AH, CH			; CH = cursor starting scan line (top)
					MOV	DX, VID_PORT		; DX = 6845 index register port
					OUT	DX, AX			; write AH to 6845 reg index in AL
					INC	AX				; AL = Cursor end index (scan line)
					MOV	AH, CL			; CL = cursor ending scan line (bottom)
					OUT	DX, AX			; write AH to 6845 reg index in AL
					XCHG	AX, DI			; restore AX
					POP	DX
					RET
				INT_10_1 ENDP
 F0E4				
 F0E4  53			;----------------------------------------------------------------------------;
 F0E5  52			; INT 10,2 - Set cursor position
 F0E6  55			;----------------------------------------------------------------------------;
 F0E7  51			; Input:
 F0E8  56			;	AH = 02
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 150 - 1


 F0E9  BF 0049 R		;	BH = page number (0 for graphics modes)
 F0EC  3C 07			;	DH = row
 F0EE  72 02			;	DL = column
 F0F0  8A 05			;----------------------------------------------------------------------------;	
 F0F2				; Things you must do:
 F0F2  93			;	1. Update the BDA Cursor position (50H-5FH) with the new video page
				;		with the new cursor position
				;	2. Calculate the memory address of the cursor's position, and set it
				;		to the 6845 Cursor address register
				;
 F0F3  33 C0			; Things you should do:
 F0F5  B9 000F			;	- Make sure page number is valid for adapter type and current mode
 F0F8  1E			;
 F0F9  07			;----------------------------------------------------------------------------;	
 F0FA  F3/ AB			INT_10_2 PROC
					PUSH	AX
					MOV	AL, BH			; AL = new video page
					CMP	AL, 7				; is new video page > 7?
					JA	INT_10_2_DONE		; if so, not valid, return
 F0FC  A0 0010 R		
 F0FF  34 30			;----------------------------------------------------------------------------;
 F101  24 30			; 1. Set cursor position in BDA
 F103  B0 00			;
 F105  BE 0010				CBW					; AX = page number
 F108  B7 50				XCHG	AX, DI			; DI = page number
 F10A  B5 34 R				SHL	DI, 1				; word align index
 F10C  8A E5				MOV	VID_CURS_POS[DI], DX	; write to page cursor position in BDA
 F10E  BF 0720				CMP	VID_PAGE, BH		; is this the current page?
 F111  75 0E				JNZ	INT_10_2_DONE		; if not, do nothing and exit
 F113  40				PUSH	BX
 F114  BD ---- R			PUSH	DX
 F117  BA 03B8			
 F11A  B3 07			;----------------------------------------------------------------------------;
 F11C  BE 0030			; 2. Set cursor position in 6845 Cursor address register
 F11F  EB 26			;
 F121				INT_10_SET_CUR_OFFSET:
 F121  B5 64 R				MOV	AL, BYTE PTR VID_COLS	; AL = screen cols
 F123  BA 03D8				MUL	DH				; AX = row * screen cols
 F126  BD ---- R			XOR	DH, DH			; DX = col
 F129  F6 C3 04				ADD	AX, DX			; AX = ( row * screen cols ) + col
 F12C  74 0E									; AX = byte offset for cursor position to page memor
				y
 F12E					MOV	BX, VID_SEG
 F12E  BE 0020				SHR	BX, 1				; byte align
 F131  B4 64 R				ADD	BX, AX
 F133  33 FF				MOV	AL, CA_H			; 6845 Cursor address high reg (0EH)
 F135  F6 C3 02				MOV	AH, BH			; Cursor address (MSB)
 F138  75 0D				MOV	DX, VID_PORT
 F13A  EB 09				OUT	DX, AX			; write AH to index AL
 F13C					INC	AX				; AL = CA_L (0FH)
 F13C  F6 C3 02				MOV	AH, BL			; Cursor address (LSB)
 F13F  75 06				OUT	DX, AX			; write AH to index AL
 F141  B4 2C R				POP	DX
 F143  33 F6				POP	BX
 F145				INT_10_2_DONE:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 151 - 1


 F145  D0 EF				POP	AX
 F147					RET
 F147  89 1E 0049 R		INT_10_2 ENDP
 F14B  8E C5			
 F14D  89 2E 00EA R		;----------------------------------------------------------------------------;
 F151  EE			; INT 10,3 - Read cursor position and Size for current page
 F152  88 26 004D R		;----------------------------------------------------------------------------;
 F156  80 EA 04			; Output:
 F159  89 16 0063 R		;	ZF = 0 and BH = 0 if MDA/CGA GFX
 F15D  8B EB			;  	ZF = 1 and BH = VID_PAGE if CGA text
				;----------------------------------------------------------------------------;
				INT_10_3_CUR_PAGE PROC
					XOR	BH, BH			; BH = 0
					TEST	VID_MODE, 0100B		; is >= 4?
 F15F  97				JNZ	INT_10_3			; jump if not MDA or GFX
 F160  33 FF				MOV	BH, VID_PAGE		; otherwise BH = VID_PAGE
 F162  D1 E9			
 F164  F3/ AB			;----------------------------------------------------------------------------;
				; INT 10,3 - Read cursor position and Size
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 03
 F166  1E			;	BH = video page
 F167  33 C0			; Output:
 F169  A2 0062 R		;	CH = cursor starting scan line (low order 5 bits)
 F16C  8E D8			;	CL = cursor ending scan line (low order 5 bits)
				;	DH = row
 F16E  C5 1E 0074 R		;	DL = column
 F172  8B 78 0A			;----------------------------------------------------------------------------;
 F175  B1 10			INT_10_3 PROC
 F177					PUSH	AX
 F177  8A 20				MOV	AL, BH			; AL = video page
 F179  EF				CBW					; AX = video page
 F17A  40				XCHG	AX, DI			; DI = video page
 F17B  46				SHL	DI, 1				; word align index
 F17C  E2 F9				MOV	DX, VID_CURS_POS[DI]
					MOV	CX, VID_CURS_TYPE
					POP	AX
					RET
				INT_10_3 ENDP
 F17E  95			INT_10_3_CUR_PAGE ENDP
 F17F  3C 06			
 F181  B4 3F			;----------------------------------------------------------------------------;
 F183  74 02			; INT 10,5 - Select active display page
 F185  B4 30			;----------------------------------------------------------------------------;
 F187				; Input:
 F187  BB F60F R		;	AH = 05
 F18A  D7			;	AL = new page number
				;----------------------------------------------------------------------------;
 F18B  1F			; Things you must do:
 F18C  80 C2 04			;	1. Write the new page number to BDA (40:62H)
 F18F  A3 0065 R		;	2. Calculate new regen buffer page offset and update BDA and
 F192  EF			;		6845 Start address register
 F193  97			;	3. Calculate the memory address of the cursor's position, and set it
 F194  86 E0			;		to the 6845 Cursor address register
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 152 - 1


 F196  A3 0060 R		;
 F199  5E			; Things you should do:
 F19A  59			;	- Bounds check that page number is valid for adapter and current mode?
 F19B  5D			;----------------------------------------------------------------------------;
 F19C  5A			INT_10_5 PROC
 F19D  5B				PUSH	AX
 F19E					PUSH	BX
 F19E  C3				PUSH	DX
 F19F				
				;----------------------------------------------------------------------------;
				; 1. Write the new page number to BDA (40:62H).
				;
					MOV	VID_PAGE, AL
					CBW					; AX = video page
					XCHG	AX, DI			; DI = page number (save for later)
				
				;----------------------------------------------------------------------------;
 F19F				; 2. Calculate new regen buffer page offset and update BDA and 
 F19F  52			;	6845 Start address register
 F1A0  97			;
 F1A1  89 0E 0060 R			MOV	AX, VID_BUF_SZ		; AX = Size of video regen buffer (bytes)
 F1A5  B0 0A				MUL	DI				; AX = offset of start of page regen buffer
 F1A7  8A E5				MOV	VID_SEG, AX			; write to BDA
 F1A9  8B 16 0063 R			SHR	AX, 1				; video segment byte-indexed
 F1AD  EF				MOV	BL, AL			; AH = Start address (MSB), BL = (LSB)
 F1AE  40				MOV	AL, CRTC.SA_H		; 6845 Start address register
 F1AF  8A E1				MOV	DX, VID_PORT		; 6845 I/O port address
 F1B1  EF				OUT	DX, AX			; write AH (MSB) to index AL
 F1B2  97				INC	AX				; AL = 0DH
 F1B3  5A				MOV	AH, BL			; AH = Start address (LSB)
 F1B4  C3				OUT	DX, AX			; write AH (LSB) to index AL
 F1B5				
				;----------------------------------------------------------------------------;
				; 3. Set cursor position in 6845 Cursor address register
				;
					SHL	DI, 1				; get the current cursor position
					MOV	DX, VID_CURS_POS[DI]	; DH/DL = cursor position on current page
					JMP	INT_10_SET_CUR_OFFSET	; write it to the new page's offset on 6845
				
				INT_10_5 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,7 - Scroll active page down
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = number of lines to scroll, previous lines are
				;	     blanked, if 0 or AL > screen size, window is blanked
				;	BH = attribute to be used on blank line
				;	CH = row of upper left corner of scroll window
				;	CL = column of upper left corner of scroll window
				;	DH = row of lower right corner of scroll window
				;	DL = column of lower right corner of scroll window
 F1B5				;----------------------------------------------------------------------------;
 F1B5  50			;
 F1B6  8A C7			;   0000  00  M 40x25 B/W text (CGA)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 153 - 1


 F1B8  3C 07			;   0001  01  C 40x25 16 color text (CGA)
 F1BA  77 30			;   0010  02  M 80x25 16 shades of gray text (CGA)
				;   0011  03  C 80x25 16 color text (CGA)
				;   0100  04  C 320x200 4 color graphics (CGA)
				;   0101  05  C 320x200 4 color graphics (CGA)
				;   0110  06  M 640x200 B/W graphics (CGA)
 F1BC  98			;   0111  07  M 80x25 Monochrome text (MDA)
 F1BD  97			;----------------------------------------------------------------------------;
 F1BE  D1 E7			; Things you must do:
 F1C0  89 95 0050 R		; 	1. Calculate coordinates of existing rectangle and new rectangle.
 F1C4  38 3E 0062 R		;	2. Convert to memory video RAM addresses
 F1C8  75 22			;	3. If CGA 80 col, disable video during video RAM operations
 F1CA  53			;	4. If rows to scroll > 0, copy each row, starting at the left column.
 F1CB  52			;	   If scroll up, start from the top of the overlapping area and copy
				;	   downward. If scroll down, start at the bottom and copy upward.
				;	5. If rows to scroll > height of rectangle, fill the remaining rows
				;	   with spaces.
				;
 F1CC				;----------------------------------------------------------------------------;
 F1CC  A0 004A R		; NOTE: The original XT BIOS (and maybe clones) appear to have a bug where
 F1CF  F6 E6			; if the lines to scroll (AL) is greater than the height of the rectangle
 F1D1  32 F6			; it will scroll incorrectly.
 F1D3  03 C2			; TODO: Fix this "bug" or be consistent with XT behavior?
				;----------------------------------------------------------------------------;
 F1D5  8B 1E 004E R		INT_10_7 PROC
 F1D9  D1 EB				STD					; Set direction flag
 F1DB  03 D8			
 F1DD  B0 0E			;----------------------------------------------------------------------------;
 F1DF  8A E7			; INT 10,6 - Scroll active page up
 F1E1  8B 16 0063 R		;----------------------------------------------------------------------------;
 F1E5  EF			; Input: same as INT 10,7 above
 F1E6  40			;----------------------------------------------------------------------------;
 F1E7  8A E3			INT_10_6 PROC
 F1E9  EF			
 F1EA  5A				PUSH	AX				; call-preserve these registers
 F1EB  5B				PUSH	BX
 F1EC					PUSH	SI
 F1EC  58				PUSH	BP
 F1ED  C3			
 F1EE					MOV	SI, VID_MEM_SEG		; video/regen RAM segment (B800 or B000)
					MOV	ES, SI
				
				;----------------------------------------------------------------------------;
				; Register Check:
				;	AH = saved flags - ZF if scroll up
				;	AL = number of rows to scroll
				;	BH = attribute to be used on blank line
				;	BL = scratch
 F1EE				;	CH = row of upper left corner of scroll window
 F1EE  32 FF			;	CL = column of upper left corner of scroll window
 F1F0  F6 06 0049 R 04		;	DH = row of lower right corner of scroll window
 F1F5  75 04			;	DL = column of lower right corner of scroll window
 F1F7  8A 3E 0062 R		;
					CMP	AH, 6				; is scroll up?
					LAHF					; save ZF if scroll up
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 154 - 1


					MOV	BP, AX			; save original AL / AH flags
					MOV	DI, DX			; save original DX
					JNZ	INT_10_CHECK_BOUNDS	; jump if scroll down
				
				;----------------------------------------------------------------------------;
				; On scroll up, the new rectangle to scroll is above the old one so start the
				; bottom left of the new rectangle at the top left of the old one. This 
				; will be later adjusted by the number of rows to scroll.
				;
					MOV	DX, CX			; if scroll up, DX becomes "top"
				
 F1FB				;----------------------------------------------------------------------------;
 F1FB  50			; Make sure lower right column does not exceed screen width
 F1FC  8A C7			;
 F1FE  98			INT_10_CHECK_BOUNDS:
 F1FF  97				MOV	AL, BYTE PTR VID_COLS	; AL = video mode columns
 F200  D1 E7				CMP	DL, AL			; is rect right column > screen columns?
 F202  8B 95 0050 R			JB	INT_10_BOUNDS_OK
 F206  8B 0E 0060 R			MOV	DL, AL			; number of screen columns (80 or 40)
 F20A  58				DEC	DX				; fixup for 0-based column index (0-79, etc)
 F20B  C3			INT_10_BOUNDS_OK:
 F20C					MUL	DH				; AX = memory offset of col 0 of new bottom row
 F20C					MOV	DH, AL			; save AL
				
				;----------------------------------------------------------------------------;
				; Is graphics mode?
				;
					CALL	INT_10_IS_TXT		; NZ if CGA GFX, ZR if CGA/MDA Text
					MOV	AL, DH			; restore AL
					MOV	DH, 0				; DX = lower right column position
					PUSH	DS				; save BDA data SEG
					JNZ	INT_10_SCR_GFX
				
				;----------------------------------------------------------------------------;
				; Scroll in text mode
				;----------------------------------------------------------------------------;
				; To calculate scroll memory offsets:
				;
				;  rect_height = rect_height + 1
				;  next_row = screen_cols - rect_width
				;
 F20C				;  if scroll down:
 F20C  50			; 	rect_height = - rect_height
 F20D  53			;	next_row = - next_row
 F20E  52			;
				;  new_top = old_top - rect_height
				;  new_bottom = old_bottom - rect_height
				;
				INT_10_SCR_TXT:
 F20F  A2 0062 R			ADD	DX, AX			; DX = byte offset of new bottom row and col
 F212  98				SHL	DX, 1				; WORD-align memory offset
 F213  97				ADD	DX, VID_SEG			; DX = memory offset bottom row/col in video page
					MOV	SI, DX			; SI = memory offset of new rect bottom (midpoint)
					XCHG	DI, DX			; DI = new rect bottom, DX = row/col pos.
					SUB	DX, CX			; DH = rect height (rows), DL = rect width (cols)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 155 - 1


					MOV	CX, VID_COLS		; CL = current video mode cols (80 or 40), CH = 0
					MOV	AX, ES			; source and destination is video/regen RAM
 F214  A1 004C R			MOV	DS, AX
 F217  F7 E7				MOV	AX, BP			; AL = # of rows to scroll
 F219  A3 004E R			SHL	CL, 1				; WORD-align bytes per full row (now 160 or 80)
 F21C  D1 E8				MUL	CL				; AX = size in WORDs of full rows to scroll
 F21E  8A D8				XCHG	AX, BP			; AL = # rows, AH = func, BP = WORD size of rect. rows
 F220  B0 0C				ADD	DX, 101H			; convert 0-based indexes to 1-based loop counters
 F222  8B 16 0063 R			SAHF					; set ZF if scroll up
 F226  EF				MOV	AH, BH			; AH = fill attribute byte
 F227  40				PUSHF					; save scroll direction flag (out of registers!)
 F228  8A E3				MOV	BX, CX			; BX = WORD size of one screen row (80 or 160)
 F22A  EF				MOV	CL, DL			; CX = BYTE size of one rectangle row
					SUB	BX, CX			; BX = WORD offset btwn end of rect. col and start col
					SUB	BX, CX			;  on next row (subtract twice to WORD align)
					POPF					; set ZF if scroll up
					JZ	INT_10_CGA_CHECK		; jump if scroll up
 F22B  D1 E7			
 F22D  8B 95 0050 R		;----------------------------------------------------------------------------;
 F231  EB 99			; On scroll down, subtract (instead of add) the difference between the end 
				; of the current rectangle and the next row start.
 F233				;
				; The start address of source rectangle will also be above (instead of below)
				; the destination rectangle.
				;
				; These offsets are then added the top/bottom of current rectangle to get the
				; new rectangle coords, either above or below depending on scroll direction.
				;
					NEG	BX				; BX = - WORD size offset to start of next row
					NEG	BP				; BP = - WORD size of region of rows to scroll
				
				INT_10_CGA_CHECK:
								IF CGA_SNOW_REMOVE GT 0
				;----------------------------------------------------------------------------;
				; If CGA, blank video during memory writes to avoid "CGA snow" effect
				;
					CALL	INT_10_IS_CGA80		; ZF if CGA 80, NZ if not
					PUSHF					; save flags to use same result at end
					JNZ	INT_10_6_CHECK_CLS	; jump if not mode 2 or 3 CGA 80 col text
				
				;----------------------------------------------------------------------------;
				; Blank CRTC video during memory writes to avoid "CGA snow" effect.
				;
				INT_10_CGA_DISABLE:
					PUSH	AX
					PUSH	DX
					MOV	DX, CGA_STAT		; CGA Status (3DAH)
				INT_10_CGA_WAIT:
					IN	AL, DX			; get CRTC status register
								IF CGA_SNOW_REMOVE EQ 3
					TEST	AL, MASK VSVS OR MASK VSHS	; in HSYNC or VSYNC?
								ELSE
					TEST	AL, MASK VSVS 		; is in VSYNC?
								ENDIF
					JZ	INT_10_CGA_WAIT		; loop until it is
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 156 - 1


					MOV	DL, LOW CGA_CTRL		; CGA Control (3D8H)
					MOV	AL, 00100101B		; Mode 80x25 text, BW, disable video, blink
					OUT	DX, AL			; disable video
					POP	DX
					POP	AX
								ENDIF
 F233				
 F233  FD			INT_10_6_CHECK_CLS:
					TEST	AL, AL			; is number of lines to scroll 0?
					JZ	INT_10_6_TXT_CLR		; if so, skip move and only clear
				
				;----------------------------------------------------------------------------;
				; Move scrolled window rectangle to new location in video memory 
				;
 F234					SUB	DH, AL			; DH = rect height - lines to scroll
					JZ	INT_10_6_TXT_CLR_1	; is number of lines to move 0?
 F234  50				ADD	SI, BP			; SI = source row starting address
 F235  53			INT_10_6_TXT_MOVE_LOOP:
 F236  56				MOV	CL, DL			; CX = number of columns (chars) to move
 F237  55				REP	MOVSW				; copy row from [DS:SI] to [ES:DI]
					ADD	DI, BX			; move to start of next row
 F238  8B 36 00EA R			ADD	SI, BX
 F23C  8E C6				DEC	DH
					JNZ	INT_10_6_TXT_MOVE_LOOP	; loop through all rows
				INT_10_6_TXT_CLR_1:
					MOV	DH, AL			; DH = remaining lines to clear
				
				;----------------------------------------------------------------------------;
				; Clear (fill with spaces) the newly cleared area
				;
				INT_10_6_TXT_CLR:
					MOV	AL, VID_SP			; fill blank lines with spaces
				INT_10_6_TXT_CLR_LOOP:
					MOV	CL, DL			; write rect width number of blank chars
					REP	STOSW				; write attribute and space to col
 F23E  80 FC 06				ADD	DI, BX			; move to start of next row
 F241  9F				DEC	DH
 F242  8B E8				JNZ	INT_10_6_TXT_CLR_LOOP	; loop through all rows
 F244  8B FA							IF CGA_SNOW_REMOVE GT 0
 F246  75 02				POPF					; ZF if CGA/80, NZ if not
								ENDIF
					POP	DS				; restore BDA SEG
				
								IF CGA_SNOW_REMOVE GT 0
					JNZ	INT_10_6_DONE		; jump if not CGA/80
				;----------------------------------------------------------------------------;
 F248  8B D1			; If is CGA 80 column, re-enable the video signal
				;
INT_10_6_ENABLE_CGA:
					MOV	AL, VID_MODE_REG		; reload the current control register
					MOV	DX, CGA_CTRL
 F24A					OUT	DX, AL			; write to CGA Control Register
 F24A  A0 004A R						ENDIF
 F24D  38 C2			
 F24F  72 03			INT_10_6_DONE:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 157 - 1


 F251  8A D0				POP	BP
 F253  4A				POP	SI
 F254					POP	BX
 F254  F6 E6				POP	AX
 F256  8A F0				RET
				
				;----------------------------------------------------------------------------;
				; INT 10,6/7 - Scroll up or down in graphics mode
				;----------------------------------------------------------------------------;
 F258  E8 FE2A			; Input:
 F25B  8A C6			;	AX = memory offset of col 0 of new bottom row
 F25D  B6 00			;	BH = attribute to be used on blank line
 F25F  1E			;	BL = (scratch)
 F260  75 5E			;	BP (high) = flags (ZF if scroll up, NZ if scroll down)
				;	CH = row/Y of upper left corner of scroll window
				;	CL = column/X of upper left corner of scroll window
				;	DX = lower right column/X position
				;	DI = original row/column parameter
				;
				; Perform BitBlt operation within video RAM.
				;----------------------------------------------------------------------------;
				INT_10_SCR_GFX PROC
					SHL	AX, 1				; BYTE (char) align memory offset for line
					SHL	AX, 1				;  (default for 640x200)
					ADD	DX, AX
					XCHG	DX, DI			; DI = memory offset of new rect bottom
										; DX = original row/col
					ADD	DX, 101H			; use 0-based indexes for 1-based counters
					SUB	DX, CX			; DH = rect height, DL = rect width
					XCHG	AX, BP			; restore original AL / AH = func flag
 F262					MOV	BL, AL			; BL = lines to scroll
 F262  03 D0				MOV	BP, 80			; 1 scanline = 80 bytes
 F264  D1 E2				MOV	CX, 2				; CL = 2, CH = 0 (needed later for counters)
 F266  03 16 004E R			SHL	DH, CL			; rect height * char (row) height / 2 fields
 F26A  8B F2				SHL	BL, CL			; lines to scroll * char height / 2 fields
 F26C  87 FA				CMP	VID_MODE, 6			; is 640x200 mode?
 F26E  2B D1				JZ	INT_10_SCR_GFX_2		; jump if so
 F270  8B 0E 004A R		
 F274  8C C0			;----------------------------------------------------------------------------;
 F276  8E D8			; is 320x200/4 color - adjust to 2 bits per pixel (16 bits per glyph)
 F278  8B C5			;
 F27A  D0 E1				SHL	DI, 1				; WORD (char) align mem offset
 F27C  F6 E1				SHL	DL, 1				; WORD (char) align rect width
 F27E  95				SAHF					; set ZF if scroll up
 F27F  81 C2 0101			JZ	INT_10_SCR_GFX_RDY	; jump if scroll up
 F283  9E			
 F284  8A E7			;----------------------------------------------------------------------------;
 F286  9C			; is 320x200 AND scroll down
 F287  8B D9			;
 F289  8A CA				INC	DI				; fixup start address for last pixel
 F28B  2B D9			
 F28D  2B D9			INT_10_SCR_GFX_2:
 F28F  9D				SAHF					; set ZF if scroll up
 F290  74 04				JZ	INT_10_SCR_GFX_RDY	; jump if scroll up
				
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 158 - 1


				;----------------------------------------------------------------------------;
				; is scroll down
				;
					ADD	DI, 240			; fixup bottom row of new rect.
					NEG	BP				; if scroll down, subtract offset instead
				
				;----------------------------------------------------------------------------;
				; ready to begin
				;
				INT_10_SCR_GFX_RDY:
 F292  F7 DB				TEST	AL, AL			; is number of lines to scroll 0?
 F294  F7 DD				JZ	INT_10_SCR_GFX_CLR	; if so, skip move and only clear
				
 F296				;----------------------------------------------------------------------------;
				; Bit block transfer pixel data in video memory
				;
					MOV	SI, DI			; SI = mem offset of new rectangle
					MOV	AX, BP			; AL = 1 scanline (80 if up, -80 if down)
					IMUL	BL				; AX = offset of lines to scroll * +/- 80
					ADD	SI, AX			; SI = mem offset of old rectangle
					MOV	AX, ES			; set DS to video regen segment
					MOV	DS, AX			;  for source (old) rectangle
					PUSH	BX				; save lines to clear and attribute
					SUB	DH, BL			; DH = # of lines to write
					;JZ	INT_10_SCR_GFX_CLR_1	; check that loop > 1 (necessary?)
					MOV	AX, SI			; save source
					MOV	BX, DI			; save destination
				INT_10_SCR_GFX_MOVE_LOOP:
					MOV	CL, DL			; # of pixels to copy
					REP	MOVSB				; copy odd field
					MOV	SI, CGA_MEM_FLD		; vid mem offset for interlaced field
					MOV	DI, SI
					ADD	SI, AX			; add to line offset
					ADD	DI, BX
					MOV	CL, DL			; # of pixels to copy
					REP	MOVSB				; copy even field
					ADD	AX, BP			; move to next line
					ADD	BX, BP
					MOV	SI, AX			; reset source
					MOV	DI, BX			; reset dest
					DEC	DH
					JNZ	INT_10_SCR_GFX_MOVE_LOOP
					POP	BX
				
 F296				;----------------------------------------------------------------------------;
 F296  84 C0			; Clear old window rectangle
 F298  74 14			;
				INT_10_SCR_GFX_CLR_1:
					MOV	DH, BL			; # of lines to clear
				INT_10_SCR_GFX_CLR:
					MOV	AL, BH			; AL = attribute/color byte to write
 F29A  2A F0				MOV	SI, DI			; save destination
 F29C  74 0E			INT_10_SCR_GFX_CLR_LOOP:
 F29E  03 F5				MOV	CL, DL			; # of pixels to clear
 F2A0					REP	STOSB				; clear odd field
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 159 - 1


 F2A0  8A CA				MOV	DI, CGA_MEM_FLD		; vid mem offset for interlaced field
 F2A2  F3/ A5				ADD	DI, SI
 F2A4  03 FB				MOV	CL, DL			; # of pixels to clear
 F2A6  03 F3				REP	STOSB				; clear even field
 F2A8  FE CE				ADD	SI, BP			; move to next line
 F2AA  75 F4				MOV	DI, SI			; reset dest
 F2AC					DEC	DH
 F2AC  8A F0				JNZ	INT_10_SCR_GFX_CLR_LOOP
					POP	DS
					JMP	INT_10_6_DONE
				
				INT_10_SCR_GFX ENDP
 F2AE				
 F2AE  B0 20			INT_10_6 ENDP
 F2B0				INT_10_7 ENDP
 F2B0  8A CA			
 F2B2  F3/ AB			;----------------------------------------------------------------------------;
 F2B4  03 FB			; INT 10,8 - Read character and attribute at cursor
 F2B6  FE CE			;----------------------------------------------------------------------------;
 F2B8  75 F6			; Input:
				;	BH = display page
				; Output:
				;	AH = attribute of character (alpha modes only)
 F2BA  1F			;	AL = character at cursor position
				;
				; http://www.techhelpmanual.com/92-cga_video_snow_and_cls_flash.html
				;----------------------------------------------------------------------------;
				INT_10_8 PROC
					MOV	DI, VID_MEM_SEG		; ES = video RAM segment
					MOV	ES, DI
					CALL	INT_10_GET_CUR_ADDR	; DI = video RAM offset of cursor
					MOV	AL, VID_MODE		; AL = current video mode (0-7)
					CMP	AL, 7				; is MDA mode 7?
					JNZ	INT_10_8_CHK_CGA		; if not, jump to check CGA or gfx
				
				;----------------------------------------------------------------------------;
 F2BB				; Standard, fast routine
 F2BB  5D			;
 F2BC  5E			INT_10_8_FAST:
 F2BD  5B				MOV	AX, ES:[DI]			; just read from memory and return
 F2BE  58				RET
 F2BF  C3			
				INT_10_8_CHK_CGA:
					SHR	AL, 1				; Video modes: 0=40,1=80,2=low-gfx,3=hi-gfx
					CMP	AL, 1				; is CGA modes 2,3?
							IF CGA_SNOW_REMOVE GT 0
					JNE	INT_10_8_NOT_CGA		; jump if not
				
				;----------------------------------------------------------------------------;
				; CGA snow-removal routine. Wait for a blanking interval before read.
				;
					PUSH	DX
					MOV	DX, CGA_STAT
					CGA_WAIT_SYNC
					MOV	AX, ES:[DI]
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 160 - 1


					STI
					POP	DX
					JMP	SHORT INT_10_8_FAST
 F2C0				
 F2C0  D1 E0			INT_10_8_NOT_CGA:
 F2C2  D1 E0						ENDIF
 F2C4  03 D0			
 F2C6  87 D7				JBE	INT_10_8_FAST		; if not GFX modes 4,5,6 jump to fast text
										; fall through to graphics
 F2C8  81 C2 0101		
 F2CC  2B D1			;----------------------------------------------------------------------------;
 F2CE  95			; INT 10,8 - Read character and attribute at cursor in CGA graphic mode
 F2CF  8A D8			;----------------------------------------------------------------------------;
 F2D1  BD 0050			; Input:
 F2D4  B9 0002			;	AL = 3 if high res, 2 if low-res
 F2D7  D2 E6			;	ES = video mem segment
 F2D9  D2 E3			; Output:
 F2DB  80 3E 0049 R 06		;	AH = 0
 F2E0  74 08			;	AL = character at cursor position, 0 if not found
				;----------------------------------------------------------------------------;
				INT_10_8_MODE_GFX PROC
					PUSH	BX
					PUSH	CX
 F2E2  D1 E7				PUSH	DX
 F2E4  D0 E2				PUSH	SI
 F2E6  9E				SUB	SP, 8				; reserve 8 bytes for target bitmap
 F2E7  74 0A			
				;----------------------------------------------------------------------------;
				; Lookup page, calculate charpos and set up data segments
				;
					CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor
 F2E9  47				MOV	SI, DI			; SI = memory offset of curr. cursor
					MOV	DI, SP			; DI = start of temp space
 F2EA					PUSH	ES				; DS = ES
 F2EA  9E				POP	DS
 F2EB  74 06				PUSH	SS				; ES = SS
					POP	ES
					MOV	CX, 4				; loop counter for high and low res
					MOV	DX, CGA_MEM_FLD		; CGA memory interlace field offset
					CMP	AL, 3				; is high-res graphics mode?
 F2ED  81 C7 00F0			JZ	INT_10_8_GFX_HIGH		; jump to handle high-res 1 bpp spacing
 F2F1  F7 DD			
				;----------------------------------------------------------------------------;
				; Low-res - Load and pack 8 character bytes from video mem into [DS:BP]
				;----------------------------------------------------------------------------;
				INT_10_8_MODE_GFX_LOW:
 F2F3					SHL	SI, 1				; align for two bytes/char in 320x200
 F2F3  84 C0			
 F2F5  74 33			INT_10_8_GFX_LOW_1:
					MOV	AX, [SI]			; AX = next two chars from video mem
					XCHG	AL, AH			; convert endian from WORD read
				
				;----------------------------------------------------------------------------;
 F2F7  8B F7			; Shift and OR the color bits together so that non-zero value will produce 1
 F2F9  8B C5			;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 161 - 1


 F2FB  F6 EB				MOV	BX, AX			; copy bit pattern
 F2FD  03 F0				SHL	AX, 1				; shift low bit into high bit
 F2FF  8C C0				OR	BX, AX			; make high bit a 1 if either bit is 1
 F301  8E D8			
 F303  53			;----------------------------------------------------------------------------;
 F304  2A F3			; Copy the only odd bits from the WORD value into a BYTE value.
				;
 F306  8B C6				MOV	AH, 8				; loop through the eight 2 bpp values
 F308  8B DF			INT_10_8_GFX_LOW_2:
 F30A					SHL	BX, 1				; even bit into CF
 F30A  8A CA				ADC	AL, AL			; shift CF onto low order bit
 F30C  F3/ A4				SHL	BX, 1				; discard pixel odd bit
 F30E  BE 2000				DEC	AH				; dec loop counter
 F311  8B FE				JNZ	INT_10_8_GFX_LOW_2
 F313  03 F0				STOSB					; save byte to local storage
 F315  03 FB				XOR	SI, DX			; toggle video field memory offset
 F317  8A CA				TEST	SI, DX			; is next field even?
 F319  F3/ A4				JNZ	INT_10_8_GFX_LOW_1	; jump if next field is even
 F31B  03 C5				ADD	SI, 80			; if next field is odd, move to next line
 F31D  03 DD				LOOP	INT_10_8_GFX_LOW_1	; loop all 8 bitmap bytes and fall through
 F31F  8B F0			
 F321  8B FB			;----------------------------------------------------------------------------;
 F323  FE CE			; Do a linear search (uh, time complexity anyone?) of ROM BIOS and INT 1Fh 
 F325  75 E3			; for the 8x8 1 bpp bitmap at the cursor position.
 F327  5B			;
				INT_10_8_GFX_SEARCH:
					MOV	DI, SP			; DI = char bitmap from video mem
					MOV	SI, OFFSET GFX_CHARSET	; SI = BIOS ROM table
					MOV	BX, CS			; DS = CS
 F328					MOV	DS, BX
 F328  8A F3				XOR	AX, AX			; start codepoint counter at 0
 F32A				INT_10_8_GFX_SEARCH_TBL:
 F32A  8A C7				MOV	BX, 128			; loop counter for each charset table
 F32C  8B F7			INT_10_8_GFX_SEARCH_CHR:
 F32E					PUSH	SI				; save target bitmap and ROM table offsets
 F32E  8A CA				PUSH	DI
 F330  F3/ AA				MOV	CL, 4				; compare [CS:SI] (ROM table) to
 F332  BF 2000				REPE	CMPSW				;  [ES:DI] (char bitmap from vid mem)
 F335  03 FE				POP	DI				; restart target bitmap at beginning 
 F337  8A CA				POP	SI				; ROM table always advanced by 8 
 F339  F3/ AA				JE	INT_10_8_GFX_DONE		; end search if match found
 F33B  03 F5				ADD	SI, 8				; next char in table
 F33D  8B FE				INC	AL				; next codepoint to try
 F33F  FE CE				JZ	INT_10_8_GFX_DONE		; if AL > 255, char not found
 F341  75 EB				DEC	BX				; dec charset loop counter
 F343  1F				JNZ	INT_10_8_GFX_SEARCH_CHR	; loop until end of table set
 F344  E9 FF74			
				;----------------------------------------------------------------------------;
 F347				; Search again in user charset at 0000:007C (INT 1Fh).
				;
 F347					CWD					; DX = 0000h
 F347					MOV	DS, DX			; DS = IVT
							ASSUME DS:_IVT
					LDS	SI, _INT_1FH		; DS:SI = user charset
							ASSUME DS:_BDA
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 162 - 1


					MOV	DX, DS			; see if custom table has been vectored
					OR	DX, SI			;  and not the default of 0000:0000
					JNZ	INT_10_8_GFX_SEARCH_TBL	; if so, continue search
					XOR	AX, AX			; otherwise return not found (0)
				INT_10_8_GFX_DONE:
					ADD	SP, 8				; restore stack pointer
					POP	SI
					POP	DX
					POP	CX
 F347					POP	BX
 F347  8B 3E 00EA R			RET
 F34B  8E C7			
 F34D  E8 029D			;----------------------------------------------------------------------------;
 F350  A0 0049 R		; High-res - Load 8 character bytes from video mem into [DS:BP]
 F353  3C 07			;----------------------------------------------------------------------------;
 F355  75 04			INT_10_8_GFX_HIGH:
					MOVSB					; copy odd field
					DEC	SI				; undo MOVSB source inc
					XOR	SI, DX			; toggle video field memory offset
					MOVSB					; copy even field
 F357					XOR	SI, DX			; toggle video field memory offset back
 F357  26: 8B 05			ADD	SI, 80-1			; move to next line (undo MOVSB inc of SI)
 F35A  C3				LOOP	INT_10_8_GFX_HIGH		; loop 8 times
					JMP	INT_10_8_GFX_SEARCH	; rejoin the search
 F35B				
 F35B  D0 E8			INT_10_8_MODE_GFX ENDP
 F35D  3C 01			
				INT_10_8 ENDP
				
				;----------------------------------------------------------------------------;
				; INT 10,9 - Write character and attribute at cursor
				;----------------------------------------------------------------------------;
				; INT 10,A - Write character at current cursor
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 09 or 0A
				;	AL = ASCII character to write
				;	BH = display page  (or mode 13h, background pixel value)
				;	BL = foreground color (graphics mode only)
				;	CX = count of characters to write (CX >= 1)
				;
				; This code is performance sensitive, so jumps are prioritizied
				; and some code is duplicated to avoid jumps. For example, AH=0AH is used 
				; far more frequently than 09H so it gets the fall through cases.
 F35F  76 F6			;----------------------------------------------------------------------------;
				INT_10_9 PROC
				INT_10_A PROC
					PUSH	CX
					PUSH	AX				; save AX
					MOV	DI, VID_MEM_SEG
					MOV	ES, DI			; ES = video regen memory segment
					CALL	INT_10_GET_CUR_ADDR	; DI = video RAM offset of cursor
					MOV	AL, VID_MODE		; AL = current video mode (0-7)
					CMP	AL, 7				; is MDA mode 7?
					JNZ	INT_10_CHK_CGA		; if not, jump to check CGA
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 163 - 1


				
				;----------------------------------------------------------------------------;
 F361				; Use standard, fast routine for direct video memory writes
 F361  53			;
 F362  51			INT_10_9A_FAST:
 F363  52				POP	AX				; restore AX
 F364  56				CMP	AH, 9				; is function 9 (char + attribute)?
 F365  83 EC 08				JZ	INT_10_9_FAST		; if so, jump
				
				;----------------------------------------------------------------------------;
				; AH = 0AH: Write Character
				;
 F368  E8 0152			INT_10_A_FAST:
 F36B  8B F7				STOSB					; write char, skip attribute
 F36D  8B FC				INC	DI
 F36F  06				LOOP	INT_10_A_FAST
 F370  1F				POP	CX
 F371  16				RET
 F372  07			
 F373  B9 0004			;----------------------------------------------------------------------------;
 F376  BA 2000			; AH = 09H: Write Character and Attribute
 F379  3C 03			;
 F37B  74 5D			INT_10_9_FAST:
					MOV	AH, BL			; char attribute into high byte
					REP	STOSW				; write with attribute
					POP	CX
					RET
 F37D				
 F37D  D1 E6			INT_10_CHK_CGA:
					SHR	AL, 1				; group remaining video modes
 F37F					CMP	AL, 1				; is CGA modes 2,3?
 F37F  8B 04						IF CGA_SNOW_REMOVE GT 0
 F381  86 C4				JNE	INT_10_A_NOT_CGA		; jump if not
				
				;----------------------------------------------------------------------------;
				; Use slower CGA-specific snow-removal routines for memory writes during
				; screen blanking.
 F383  8B D8			;
 F385  D1 E0			INT_10_9A_CGA:
 F387  0B D8				POP	AX				; restore AX
					PUSH	BX				; save BX
					PUSH	DX
					MOV	DX, CGA_STAT
					CMP	AH, 9				; is function 9 (char + attribute)?
 F389  B4 08				JZ	INT_10_9_CGA
 F38B				
 F38B  D1 E3			;----------------------------------------------------------------------------;
 F38D  12 C0			; AH = 0AH: Write Character (CGA Text)
 F38F  D1 E3			;
 F391  FE CC			INT_10_A_CGA:
 F393  75 F6				XCHG	AX, BX			; save AX
 F395  AA				CGA_WAIT_SYNC			; wait for blanking to write memory
 F396  33 F2				XCHG	AX, BX			; restore AX
 F398  85 F2				STOSB					; write char, skip attribute
 F39A  75 E3				STI
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 164 - 1


 F39C  83 C6 50				INC	DI
 F39F  E2 DE				LOOP	INT_10_A_CGA
				INT_10_A_CGA_DONE:
					POP	DX
					POP	BX
					POP	CX
					RET
 F3A1				
 F3A1  8B FC			;----------------------------------------------------------------------------;
 F3A3  BE FA6E R		; AH = 09H: Write Character and Attribute (CGA Text)
 F3A6  8C CB			;
 F3A8  8E DB			INT_10_9_CGA:
 F3AA  33 C0				MOV	AH, BL			; char attribute into high byte
 F3AC				INT_10_9_CGA_LOOP:
 F3AC  BB 0080				XCHG	AX, BX			; save AX
 F3AF					CGA_WAIT_SYNC			; wait for blanking to write memory
 F3AF  56				XCHG	AX, BX			; restore AX
 F3B0  57				STOSW
 F3B1  B1 04				STI
 F3B3  F3/ A7				LOOP	INT_10_9_CGA_LOOP
 F3B5  5F				JMP	SHORT INT_10_A_CGA_DONE
 F3B6  5E			INT_10_A_NOT_CGA:
 F3B7  74 19						ENDIF
 F3B9  83 C6 08			
 F3BC  FE C0				JBE	INT_10_9A_FAST		; is not GFX modes 4,5,6 jump to fast text
 F3BE  74 12				POP	AX				; restore AX and fall through to graphics
 F3C0  4B			
 F3C1  75 EC			;----------------------------------------------------------------------------;
				; INT 10, 9 and A - Write character in CGA graphics mode
				;----------------------------------------------------------------------------;
				INT_10_9A_MODE_GFX PROC
					PUSH	AX
 F3C3  99				PUSH	BX
 F3C4  8E DA				PUSH	DX
					PUSH	SI
 F3C6  C5 36 007C R			PUSH	DS
					MOV	BH, VID_MODE		; BH = current video mode
 F3CA  8C DA				CALL	INT_10_GFX_CHARPOS	; DI = memory offset of curr. cursor
 F3CC  0B D6			
 F3CE  75 DC			;----------------------------------------------------------------------------;
 F3D0  33 C0			; If extended ASCII, use custom table revectored at 1Fh
 F3D2				;
 F3D2  83 C4 08				MOV	SI, OFFSET GFX_CHARSET	; default to lower set using BIOS table
 F3D5  5E				MOV	DX, CS			;  located in CS
 F3D6  5A				MOV	DS, DX			; DS = CS
 F3D7  59				TEST	AL, AL			; is extended (AL > 127)?
 F3D8  5B				JNS	INT_10_9A_GFX_2		; Jump if not
 F3D9  C3				AND	AL, 01111111b		; AL = low 7 bits of CP
					XOR	DX, DX			; Set DS to IVT to load DS and SI from
					MOV	DS, DX			; INT 1Fh
							ASSUME DS:_IVT
					LDS	SI, _INT_1FH		; use custom font table
 F3DA							ASSUME DS:_BDA
 F3DA  A4			
 F3DB  4E			INT_10_9A_GFX_2:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 165 - 1


 F3DC  33 F2				CBW					; AH = 0
 F3DE  A4				SHL	AX, 1				; AX = char * 8
 F3DF  33 F2				SHL	AX, 1
 F3E1  83 C6 4F				SHL	AX, 1
 F3E4  E2 F4				ADD	SI, AX			; SI = offset in char table
 F3E6  EB B9				CMP	BH, 6
					JE	INT_10_9A_GFX_HIGH	; jump if high res
 F3E8				
				;----------------------------------------------------------------------------;
 F3E8				; Low-res (320x200) graphics modes 4-5
				;----------------------------------------------------------------------------;
				; Input:
				;	AX = ASCII character to write * 8 bytes
				;	BH = video mode
				;	BL = foreground color
				;	CX = number of times to repeat character
				;	DS:SI = start of character offset in font bitmap table
				;	ES:DI = cursor location in video RAM
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. Transform each BYTE of 1 bit glyph into 2 bpp color WORD
				;	2. If BL has high bit set, XOR new char with current char
				;	3. Write new bitmap to CGA interlaced video memory
				;----------------------------------------------------------------------------;
				INT_10_9A_GFX_LOW:
					MOV	DL, BL			; DL = foreground color bits
					AND	DX, 0011b			; zero extend 2 bit color
 F3E8				
 F3E8				;----------------------------------------------------------------------------;
 F3E8  51			; Repeat/expand 2 color bits in DL into into DX
 F3E9  50			;
 F3EA  8B 3E 00EA R		INT_10_9A_GFX_FG:
 F3EE  8E C7				OR	DH, DL			; copy 2 bits
 F3F0  E8 01FA				SHL	DL, 1				; move color bits to next position
 F3F3  A0 0049 R			SHL	DL, 1
 F3F6  3C 07				JNZ	INT_10_9A_GFX_FG		; loop until DL = 0
 F3F8  75 12				MOV	DL, DH			; copy to both bytes of DX
				
				;----------------------------------------------------------------------------;
				; Repeat for number of chars to write in CX to create color mask
				;
 F3FA					SHL	DI, 1				; align for two bytes/char in 320x200
 F3FA  58			INT_10_9A_GFX_LOW_CHAR:
 F3FB  80 FC 09				PUSH	SI				; save char glyph start offset for each loop
 F3FE  74 06				PUSH	DI				; start each char at first row of vid mem
				
				;----------------------------------------------------------------------------;
				; Transform glyph bitmap to 2 bit color and move into video memory
				;
 F400					PUSH	CX				; save repeat counter
 F400  AA				MOV	CX, 8				; loop 8 bytes
 F401  47			INT_10_9A_GFX_LOW_BYTE:
 F402  E2 FC				LODSB					; Load next byte
 F404  59			
 F405  C3			;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 166 - 1


				; Parallel-deposit bits of input char and transform 1 bit pixel into 2 bpp
				;
					PUSH	BX
					PUSH	CX				; save bitmap counter
 F406					XOR	BX, BX			; clear output
 F406  8A E3				MOV	CL, 8				; loop 8 bits of input char
 F408  F3/ AB			INT_10_9A_GFX_LOW_PDEP:
 F40A  59				SHL	AL, 1				; CF = source pixel bit
 F40B  C3				LAHF					; save CF
					RCL	BX, 1				; shift CF into next bit
 F40C					SAHF					; restore CF
 F40C  D0 E8				RCL	BX, 1				; shift CF into next bit again
 F40E  3C 01				LOOP	INT_10_9A_GFX_LOW_PDEP
					XCHG	AX, BX			; AX = result
					XCHG	AL, AH			; convert endian
					POP	CX
					POP	BX
					AND	AX, DX			; combine with color mask
				
				;----------------------------------------------------------------------------;
				; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color
				;
					TEST	BL, BL			; high bit set?
					JNS	INT_10_9A_GFX_LOW_WR	; jump if not
					XOR	AX, ES:[DI]			; XOR byte for current field
				INT_10_9A_GFX_LOW_WR:
					MOV	ES:[DI], AX			; write 2 bytes to video memory
					XOR	DI, CGA_MEM_FLD		; alternate video fields
					TEST	DI, CGA_MEM_FLD		; is an even field next?
					JNZ	INT_10_9A_GFX_LOW_NEXT	; jump if even (use same offset for even)
					ADD	DI, 80			; if next is odd, move to next bitmap row
				INT_10_9A_GFX_LOW_NEXT:
					LOOP	INT_10_9A_GFX_LOW_BYTE	; loop 8 glyph bytes/lines
				
					POP	CX				; restore repeat counter
					POP	DI
					POP	SI
					INC	DI				; move to next video mem WORD offset
					INC	DI
					LOOP	INT_10_9A_GFX_LOW_CHAR	; repeat for CX number of chars
				
				INT_10_9A_MODE_GFX_DONE:
					POP	DS
					POP	SI
					POP	DX
					POP	BX
					POP	AX
				
				INT_10_9A_MODE_GFX_EXIT:
					POP	CX				; restore CX and rebalance stack
					RET
				
				;----------------------------------------------------------------------------;
				; High-res (640x200) graphics mode 6
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 167 - 1


				; Input:
				;	AX = ASCII character to write * 8 bytes
				;	BH = current video mode
				;	BL = foreground color
				;	CX = number of times to repeat character
				;	DS:SI = start of character offset in font bitmap table
 F410  76 E8			;	ES:DI = cursor location in video RAM
 F412  58			;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. If BL has high bit set, XOR new char with current char
				;	2. Write new bitmap to CGA interlaced video memory
				;----------------------------------------------------------------------------;
 F413				
 F413  50			;----------------------------------------------------------------------------;
 F414  53			; Repeat for number of chars to write in CX
 F415  52			;
 F416  56			INT_10_9A_GFX_HIGH:
 F417  1E				PUSH	SI				; save char glyph start offset for each loop
 F418  8A 3E 0049 R			PUSH	DI				; start each char at first row of vid mem
 F41C  E8 009E			
				;----------------------------------------------------------------------------;
				; Copy glyph bitmap to interlaced video memory
				;
					MOV	BH, 4				; loop 4 words (8 bytes)
 F41F  BE FA6E R		INT_10_9A_GFX_HIGH_WORD:
 F422  8C CA				LODSW					; load next two glyph rows
 F424  8E DA			
 F426  84 C0			;----------------------------------------------------------------------------;
 F428  79 0A			; In gfx mode, if BL bit 7=1 then value of BL is XOR'ed with the bg color
 F42A  24 7F			;
 F42C  33 D2				TEST	BL, BL			; high bit set?
 F42E  8E DA				JNS	INT_10_9A_GFX_HIGH_WR	; jump if not
					XOR	AL, ES:[DI]			; XOR byte on odd field
 F430  C5 36 007C R			XOR	AH, ES:CGA_MEM_FLD[DI]	; and even field
				
				;----------------------------------------------------------------------------;
 F434				; Write next two bytes to each field
 F434  98			;
 F435  D1 E0			INT_10_9A_GFX_HIGH_WR:
 F437  D1 E0				STOSB					; write odd field in AL
 F439  D1 E0				MOV	ES:CGA_MEM_FLD[DI][-1], AH	; write even field in AH
 F43B  03 F0				ADD	DI, 80-1			; move to next bitmap row
 F43D  80 FF 06				DEC	BH
 F440  74 56				JNZ	INT_10_9A_GFX_HIGH_WORD	; loop 4 words
					POP	DI				; restore video mem cursor offset
					POP	SI				; restore start of glyph
					INC	DI				; move to next video mem BYTE offset 
					LOOP	INT_10_9A_GFX_HIGH	; repeat for CX number of chars
				
					JMP	INT_10_9A_MODE_GFX_DONE	; exit
				
				;----------------------------------------------------------------------------;
				; Calculate graphics memory address for current current position
				;----------------------------------------------------------------------------;
				; Input: DS = BDA
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 168 - 1


				; Output:
				;	DI = Current cursor vid mem offset
				;
				; Clobbers DX
				;----------------------------------------------------------------------------;
				INT_10_GFX_CHARPOS PROC
 F442					MOV	DI, AX			; save original AX
 F442  8A D3				MOV	AL, BYTE PTR VID_COLS	; AL = screen mode cols (40 or 80)
 F444  83 E2 03				MOV	DX, VID_CURS_POS		; DH = cursor row pos, DL = column
					MUL	DH				; AX = screen cols * current row
					SHL	AX, 1				; AX = AX * 4
					SHL	AX, 1				; (8 rows / 2 fields)
					XCHG	AX, DX			; AL = current column, DX = row offset
 F447					CBW					; AX = current column
 F447  0A F2				ADD	AX, DX			; AX = current row/column vid mem offset
 F449  D0 E2				XCHG	AX, DI			; AX = original, DI = row/col vid mem offset
 F44B  D0 E2				RET
 F44D  75 F8			INT_10_GFX_CHARPOS ENDP
 F44F  8A D6			
				INT_10_9A_MODE_GFX ENDP
				
				INT_10_A ENDP
				INT_10_9 ENDP
 F451  D1 E7			
 F453				;----------------------------------------------------------------------------;
 F453  56			; INT 10,B - Set color palette
 F454  57			;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0B
				;	BH = palette color ID
				;	   = 0 to set background and border color
 F455  51			;	   = 1 to select 4 color palette
 F456  B9 0008			;	BL = color value (when BH = 0)
 F459				;	   = palette value (when BH = 1)
 F459  AC			;----------------------------------------------------------------------------;
				;	|7|6|5|4|3|2|1|0|  3D9 Color Select Register (Graphics)
				;	 | | | | | `-------- RGB for background
				;	 | | | | `--------- intensity
				;	 | | | `---------- unused
 F45A  53			;	 | | `----------- 1 = palette 1, 0=palette 0 (see below)
 F45B  51			;	 `-------------- unused
 F45C  33 DB			;	  Palette 0 = green, red, brown
 F45E  B1 08			;	  Palette 1 = cyan, magenta, white
 F460				;
 F460  D0 E0			; VID_CSGFX	RECORD	CGPH:2=11B,CGPL:1,CGX:1,CGIN:1,CGBG:3
 F462  9F			;----------------------------------------------------------------------------;
 F463  D1 D3			INT_10_B PROC
 F465  9E				PUSH	AX
 F466  D1 D3				MOV	AL, VID_COLOR			; get current color byte
 F468  E2 F6				TEST	BH, BH				; set BG/border or palette?
 F46A  93				JNZ	INT_10_B_SET_PAL			; jump if set palette
 F46B  86 C4			INT_10_B_SET_COL:
 F46D  59				AND	AL, MASK CGPH OR MASK CGPL	; isolate current palette
 F46E  5B				AND	BL, 00011111B			; isolate color bits
 F46F  23 C2				JMP	SHORT INT_10_B_DONE
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 169 - 1


				INT_10_B_SET_PAL:
					AND	AL, NOT MASK CGPL			; clear palette bit
					AND	BL, 00000001B			; isolate palette selector bit
							IF CPU_TYPE	EQ CPU_V20
 F471  84 DB				ROR	BL, 3					; move low bit into bit 5
 F473  79 03						ELSE
 F475  26: 33 05			REPT	3
 F478					ROR	BL, 1					; move low bit into bit 5	ENDM
 F478  26: 89 05					ENDIF
 F47B  81 F7 2000		INT_10_B_DONE:
 F47F  F7 C7 2000			OR	AL, BL				; combine bytes
 F483  75 03				MOV	VID_COLOR, AL			; save to BDA
 F485  83 C7 50				PUSH	DX
 F488					MOV	DX, VID_PORT
 F488  E2 CF				ADD	DL, 5					; DX = 03D9H
					OUT	DX, AL				; send to CGA Color Select Register
 F48A  59				POP	DX
 F48B  5F				POP	AX
 F48C  5E				RET
 F48D  47			INT_10_B ENDP
 F48E  47			
 F48F  E2 C2			;----------------------------------------------------------------------------;
				; INT 10,C - Write graphics pixel at coordinate
 F491				;----------------------------------------------------------------------------;
 F491  1F			; Input:
 F492  5E			;	AL = color value (XOR'ed with current pixel if bit 7=1)
 F493  5A			;	BH = page number, see VIDEO PAGES
 F494  5B			;	CX = column number (zero based)
 F495  58			;	DX = row number (zero based)
				;----------------------------------------------------------------------------;
 F496				INT_10_C PROC
 F496  59				PUSH	AX
 F497  C3				PUSH	CX
					MOV	DI, VID_MEM_SEG		; ES to video memory
					MOV	ES, DI
					CALL	INT_10_GFX_PIXEL		; DI = memory offset, AH/CL mask/counter
					MOV	CH, AL			; save original AL
					AND	AL, AH			; mask only selected pixel
					SHL	AL, CL			; shift into correct bit position
					TEST	CH, CH			; is high bit of color value set?
					JS	INT_10_C_XOR		; if so, XOR byte in memory
					SHL	AH, CL			; shift mask for pixel position
					NOT	AH				; invert mask to clear current pixel
					AND	AH, ES:[DI]			; clear pixel bits
					OR	AL, AH			; replace with new pixel value
					STOSB					; write to video buffer
				INT_10_C_DONE:
					POP	CX
					POP	AX
					RET
				INT_10_C_XOR:
					XOR	ES:[DI], AL			; just XOR and 'XIT
					JMP	SHORT INT_10_C_DONE
 F498				INT_10_C ENDP
 F498  56			
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 170 - 1


 F499  57			;----------------------------------------------------------------------------;
				; INT 10,D - Read graphics pixel at coordinate
				;----------------------------------------------------------------------------;
				; Input:
				;	BH = page number
 F49A  B7 04			;	CX = X / column (zero based)
 F49C				;	DX = Y / row (zero based)
 F49C  AD			; Output:
				;	AL = color of pixel read
				;	AH clobbered
				;----------------------------------------------------------------------------;
				INT_10_D PROC
 F49D  84 DB				PUSH	CX
 F49F  79 08				MOV	DI, VID_MEM_SEG		; ES to video memory
 F4A1  26: 32 05			MOV	ES, DI
 F4A4  26: 32 A5 2000			CALL	INT_10_GFX_PIXEL		; DI = memory offset, AH/CL mask/counter
					MOV	AL, ES:[DI]			; read packed pixel byte
					SHR	AL, CL			; shift into low order bit(s)
					AND	AL, AH			; mask only selected pixel
					POP	CX
 F4A9					RET
 F4A9  AA			INT_10_D ENDP
 F4AA  26: 88 A5 1FFF		
 F4AF  83 C7 4F			;----------------------------------------------------------------------------;
 F4B2  FE CF			; Get Video Memory Pixel Offset and Pixel Byte Mask
 F4B4  75 E6			;----------------------------------------------------------------------------;
 F4B6  5F			; Input:
 F4B7  5E			;	CX = X / column (zero based)
 F4B8  47			;	DX = Y / row (zero based)
 F4B9  E2 DD			;
				; Output
 F4BB  EB D4			;	DI = pixel byte offset
				;	AH = pixel data mask
				;	CL = pixel right shift counter
				;	CH = pixel index (big endian)
				;
				; Example of read:
				;	MOV	AL, PIXEL_DAT
				;	SHR	AL, CL
				;	AND	AL, AH
				;
				; http://www.techhelpmanual.com/89-video_memory_layouts.html
 F4BD				;----------------------------------------------------------------------------;
 F4BD  8B F8			INT_10_GFX_PIXEL PROC
 F4BF  A0 004A R			PUSH	BX
 F4C2  8B 16 0050 R			PUSH	DX
 F4C6  F6 E6			
 F4C8  D1 E0			;----------------------------------------------------------------------------;
 F4CA  D1 E0			; Calculate X offset
 F4CC  92			;
 F4CD  98				MOV	DI, CX		; DI = X position (zero based)
 F4CE  03 C2				SHR	DI, 1
 F4D0  97				SHR	DI, 1			; DI = DI / 4 (two bit alignment)
 F4D1  C3			
 F4D2				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 171 - 1


				; Unpack pixel bit(s)
 F4D2				;
					MOV	AH, 0011B		; pixel mask = 0011B
 F4D2					MOV	BL, AH		; index mask = 0011B (bits 0-3)
 F4D2					MOV	CH, CL		; save CH = CL
					MOV	CL, 1			; ROL multiplier = 1
					CMP	VID_MODE, 6		; is 640x200 gfx mode?
					JB	NOT_HI_RES		; if low-res, skip
				
				;----------------------------------------------------------------------------;
				; Is "high res" (640x200)
				;
					SHR	AH, 1			; pixel mask = 0001B
					RCL	BL, 1			; index mask = 0111B (bits 0-7)
					DEC	CX			; ROL multiplier = 0
					SHR	DI, 1			; DI = DI / 8 (one bit alignment)
				NOT_HI_RES:
				
				;----------------------------------------------------------------------------;
				; Calculate right-shift counter:
				; - 640x200: CL = (7 - i) * 1
				; - 320x200: CL = (3 - i) * 2
				;
					AND	CH, BL		; CH = packed pixel index
					SUB	BL, CH		; calculate right-shift counter
					SHL	BL, CL		; multiply by 1 (high res) or 2 (low res)
					MOV	CL, BL		; CL = shift count
				
 F4D2				;----------------------------------------------------------------------------;
 F4D2  50			; Calculate Y offset
 F4D3  A0 0066 R		;
 F4D6  84 FF			; Y offset = (DX / 2) * 80 + 2000H[DX is odd]
 F4D8  75 07			;
 F4DA					SHR	DX, 1			; DX = DX / 2
 F4DA  24 E0				XCHG	DL, DH		; DX = DX << 8
 F4DC  80 E3 1F				JNC	FIELD_EVEN		; is odd or even field?
 F4DF  EB 0B				ADD	DI, CGA_MEM_FLD	; odd field address offset
 F4E1				FIELD_EVEN:
 F4E1  24 DF				SHR	DX, 1
 F4E3  80 E3 01				SHR	DX, 1
					ADD	DI, DX		; DI += (DX / 2) * 16
					SHR	DX, 1
					SHR	DX, 1
					ADD	DI, DX		; DI += (DX / 2) * 64
					POP	DX
					POP	BX
 F4E6  D0 CB		     1		ROR	BL, 1					; move low bit into bit 5
 F4E8  D0 CB		     1		ROR	BL, 1					; move low bit into bit 5
 F4EA  D0 CB		     1		ROR	BL, 1					; move low bit into bit 5
					RET
 F4EC				INT_10_GFX_PIXEL ENDP
 F4EC  0A C3			
 F4EE  A2 0066 R		;----------------------------------------------------------------------------;
 F4F1  52			; INT 10,E - Write text in teletype mode
 F4F2  8B 16 0063 R		;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 172 - 1


 F4F6  80 C2 05			; Input:
 F4F9  EE			;	AH = 0E
 F4FA  5A			;	AL = ASCII character to write
 F4FB  58			;	BH = page number (text modes) - override it with BDA value though
 F4FC  C3			;	BL = foreground pixel color (graphics modes)
 F4FD				;
				; Output:
				;	Character to console
				;	All registers preserved
				;----------------------------------------------------------------------------;
				; Things you must do:
				;	1. Get video page from BDA - ignore what was passed in BH (why?)
				;	2. Get cursor location (INT 10,3) and keep it handy.
				;	3. Check for the four special control codes: BELL(7), BS(8), LF(A), CR(D)
				;		- BELL: beep and exit
				;		- Backspace: if cursor column is 0, exit else DEC col and go to 6
 F4FD				;		- CR: set cursor to column 0 and go to step 6
 F4FD  50			;		- LF: increment row and go to step 5 to check if scroll is needed
 F4FE  51			;	4. Write the char to the current position (INT 10,A)
 F4FF  8B 3E 00EA R		;	5. If new row > last row, scroll up 1 row (INT 10,8).
 F503  8E C7			;	6. Update cursor position (INT 10,6)
 F505  E8 002F			;
 F508  8A E8			;----------------------------------------------------------------------------;
 F50A  22 C4			INT_10_E PROC
 F50C  D2 E0				PUSH	AX
 F50E  84 ED				PUSH	BX
 F510  78 0D				PUSH	CX
 F512  D2 E4				PUSH	DX
 F514  F6 D4				CALL	INT_10_3_CUR_PAGE		; Get cursor pos: DH = row, DL = column
 F516  26: 22 25			CMP	AL, CR			; is maybe a control code?
 F519  0A C4				JBE	INT_10_E_CTRL		; if so, jump to handle it
 F51B  AA			
 F51C				;----------------------------------------------------------------------------;
 F51C  59			; Handle a regular char
 F51D  58			;
 F51E  C3			INT_10_E_CHAR:
 F51F					MOV	CX, 1				; repeat only once
 F51F  26: 30 05			CALL	INT_10_A			; write char in AL at current row/col
 F522  EB F8			
 F524				;----------------------------------------------------------------------------;
				; Handle line wrap
				;
					MOV	CL, BYTE PTR VID_COLS	; get screen cols
					DEC	CX				; fix 0 index
					CMP	DL, CL			; reached end of screen cols?
					JB	NEXT_COL			; jump if not
					MOV	DL, -1			; else move to first col and next row 
				NEXT_COL:
					INC	DX				; move to next column (and maybe row)
				
				;----------------------------------------------------------------------------;
				; Scroll if necessary
 F524				;
 F524  51			INT_10_E_SCROLL:
 F525  8B 3E 00EA R			CMP	DH, VID_DEF_ROWS		; moved past last row?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 173 - 1


 F529  8E C7				JBE	INT_10_E_CURS		; if not, no scroll necessary
 F52B  E8 0009				XOR	AH, AH			; attribute = 0 if gfx mode
 F52E  26: 8A 05			DEC	DH				; undo row scroll
 F531  D2 E8				CALL	INT_10_IS_TXT		; ZF = 1 if CGA/MDA Text, ZF = 0 if gfx
 F533  22 C4				JNZ	INT_10_E_SCROLL_UP	; jump if graphics
 F535  59				CALL	INT_10_8			; Read character: AH = attribute, AL = char
 F536  C3			
 F537				;----------------------------------------------------------------------------;
				; Scroll up one line
				;
				INT_10_E_SCROLL_UP:
					PUSH	BX				; save video page (BH)
					XCHG	AX, BX			; BH = attribute
					MOV	AX, DBW <6, 1>		; AH = 06H Scroll Window Up, AL = 1 line
					XOR	CX, CX			; scroll top left: CH = row 0, CL = col 0
					PUSH	DX				; save cursor bottom
					MOV	DL, BYTE PTR VID_COLS	; DL = right-most column
					MOV	DH, VID_DEF_ROWS		; DH = bottom row (always 24)
					DEC	DX				; fixup 0-indexed column
					CLD
					CALL	INT_10_6			; INT 10H, 06H Scroll Window Up
					POP	DX				; restore cursor bottom
					POP	BX				; restore video page (BH)
				
				;----------------------------------------------------------------------------;
				; Set new cursor position
				;
				INT_10_E_CURS:
					CALL	INT_10_2			; set cursor pos: BH = page, row = DH, col = DL
 F537				
 F537  53			INT_10_E_DONE:
 F538  52				POP	DX
					POP	CX
					POP	BX
					POP	AX
					RET
 F539  8B F9			
 F53B  D1 EF			;----------------------------------------------------------------------------;
 F53D  D1 EF			; Handle control codes
				;
				INT_10_E_CTRL:
					JZ	INT_10_E_CR			; ZF = CR (from above)
					CMP	AL, LF			; is an LF?
 F53F  B4 03				JZ	INT_10_E_LF
 F541  8A DC				CMP	AL, BS			; is a backspace?
 F543  8A E9				JZ	INT_10_E_BS
 F545  B1 01				CMP	AL, BELL			; Isabelle?
 F547  80 3E 0049 R 06			JNZ	INT_10_E_CHAR		; otherwise, handle as a normal char
 F54C  72 07			INT_10_E_BELL:
					POP	DX				; clear stack, beep and exit
					POP	CX
					POP	BX
					POP	AX
 F54E  D0 EC				JMP	BEEP				; standard BEEP and RET
 F550  D0 D3			INT_10_E_CR:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 174 - 1


 F552  49				XOR	DL, DL			; move to column 0
 F553  D1 EF				JMP	INT_10_E_CURS		; update cursor
 F555				INT_10_E_LF:
					INC	DH				; move to next row
					JMP	INT_10_E_SCROLL		; maybe scroll
				INT_10_E_BS:
					TEST	DL, DL			; is first column? (can't backspace further)
					JZ	INT_10_E_DONE		; if so, do nothing and exit
					DEC	DX				; back space one column
 F555  22 EB				JMP	INT_10_E_SCROLL		; maybe scroll
 F557  2A DD			
 F559  D2 E3			INT_10_E ENDP
 F55B  8A CB			
				;----------------------------------------------------------------------------;
				; INT 10,F - Get current video state
				;----------------------------------------------------------------------------;
				; Input:
				;	AH = 0F
				; Output
 F55D  D1 EA			;	AH = number of screen columns
 F55F  86 D6			;	AL = mode currently set
 F561  73 04			;	BH = current display page
 F563  81 C7 2000		;----------------------------------------------------------------------------;
 F567				INT_10_F PROC
 F567  D1 EA				MOV	AX, WORD PTR VID_MODE
 F569  D1 EA				MOV	BH, VID_PAGE
 F56B  03 FA				RET
 F56D  D1 EA			INT_10_F ENDP
 F56F  D1 EA			
 F571  03 FA			;----------------------------------------------------------------------------;
 F573  5A			; Get video memory offset for current cursor position
 F574  5B			;----------------------------------------------------------------------------;
 F575  C3			; Input:
 F576				;	BH = current video page
				; Output
				;	DI = memory offset of current cursor in memory
				;----------------------------------------------------------------------------;
				INT_10_GET_CUR_ADDR PROC
					PUSH	AX
					PUSH	DX
					MOV	AL, BH			; AL = display page
					CBW					; AX = page number
					XCHG	AX, DI			; DI = page number
					MOV	AX, VID_BUF_SZ		; AX = VID_BUF_SZ
					MUL	DI				; AX = page size * page (base offset)
					SHL	DI, 1				; word align index
					MOV	DX, VID_CURS_POS[DI]	; DX = cursor position on page
					XCHG	AX, DI			; DI = page base offset
					MOV	AL, BYTE PTR VID_COLS
					MUL	DH				; AX = screen cols * current row
					XCHG	AX, DX			; DX = rows offset, AL = current col
					CBW					; AX = current col
					ADD	AX, DX			; AX = page relative cursor offset
					SHL	AX, 1				; word align
					ADD	DI, AX			; DI = memory offset of cursor
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 175 - 1


					POP	DX
					POP	AX
					RET
				INT_10_GET_CUR_ADDR ENDP
				
				;----------------------------------------------------------------------------;
 F576				; 6845 CRT mode control register values
 F576  50			;----------------------------------------------------------------------------;
 F577  53			; CGA:
 F578  51			;	|7|6|5|4|3|2|1|0|  3D8H Mode Select Register
 F579  52			;	     | | | | | `---- 1 = 80x25 text, 0 = 40x25 text
 F57A  E8 FC71			;	     | | | | `----- 1 = 320x200 graphics, 0 = text (unused on MDA)
 F57D  3C 0D			;	     | | | `------ 1 = B/W, 0 = color (unused on MDA)
 F57F  76 40			;	     | | `------- 1 = enable video signal
				;	     | `-------- 1 = 640x200 B/W graphics (unused on MDA)
				;	     `--------- 1 = blink, 0 = no blink
				; MDA:
				;	|7|6|5|4|3|2|1|0|  3B8 CRT Control Port
 F581				;	     | | | | | `---- 1 = 80x25 text
 F581  B9 0001			;	     | | | `------- unused
 F584  E8 FE61			;	     | | `-------- 1 = enable video signal
				;	     | `--------- unused
				;	     `---------- 1 = blinking on
				;
				; source: https://stanislavs.org/helppc/6845.html
 F587  8A 0E 004A R		;----------------------------------------------------------------------------;
 F58B  49			CRT_MODE	DB	101100B	; 00: 40x25 B/W text (CGA)
 F58C  38 CA					DB	101000B	; 01: 40x25 16 color text (CGA)
 F58E  72 02					DB 	101101B	; 02: 80x25 16 shades of gray text (CGA)
 F590  B2 FF					DB	101001B	; 03: 80x25 16 color text (CGA)
 F592						DB	101010B	; 04: 320x200 4 color graphics (CGA)
 F592  42					DB	101110B	; 05: 320x200 4 color graphics (CGA)
						DB	011110B	; 06: 640x200 B/W graphics (CGA)
						DB	101001B	; 07: 80x25 Monochrome text (MDA, HERC)
				
				INT_10 ENDP
 F593				
 F593  80 FE 18			;----------------------------------------------------------------------------;
 F596  76 21			; Display system hardware config
 F598  32 E4			;----------------------------------------------------------------------------;
 F59A  FE CE			; Input:
 F59C  E8 FAE6			;	DS = BDA (0040)
 F59F  75 03			;
 F5A1  E8 FDA3			; Clobs AX, BX, CX, SI
				; Size: 133 bytes
				;----------------------------------------------------------------------------;
				POST_SYS_CONFIG PROC
						ASSUME DS:_BDA
 F5A4				
 F5A4  53						IF POST_VIDEO_TYPE EQ 1
 F5A5  93				CALL	POST_SYS_VIDEO
 F5A6  B8 0601						ENDIF
 F5A9  33 C9			
 F5AB  52			;----------------------------------------------------------------------------;
 F5AC  8A 16 004A R		; Display CPU type
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 176 - 1


 F5B0  B6 18			;
 F5B2  4A				POST_COL_1	POST_CPU, POST_CLR_VAL1	; display 'CPU' left column
 F5B3  FC										;  SI default to 8088
 F5B4  E8 FC7D			CPU_CHECK_TYPE_2:
 F5B7  5A				TEST_GFLAG  V20				; ZF = 0 if V20, ZF = 1 if 8088
 F5B8  5B				JZ	CPU_CHECK_TYPE_2_DONE		; jump if 8088
					MOV	SI, OFFSET POST_V20		; if not, is V20
				CPU_CHECK_TYPE_2_DONE:
					CALL	OUT_SZ				; write CPU type
					POST_COL_END				; end first column
 F5B9				
 F5B9  E8 FBF9			;----------------------------------------------------------------------------;
				; Display FPU/math co-processor
 F5BC				;
 F5BC  5A			FPU_CHECK:
 F5BD  59				POST_COL_2  POST_FPU, POST_CLR_VAL1	; SI default to '8087'
 F5BE  5B				TEST_EFLAG  FPU				; was FPU detected?
 F5BF  58				JNZ	FPU_DISP_DONE			; jump to output if FPU
 F5C0  C3				MOV	SI, OFFSET POST_NONE		; otherwise 'None'
				FPU_DISP_DONE:
					CALL	OUT_SZ				; display string
					POST_COL_END_NL				; end second column, move to NL
				
 F5C1				;----------------------------------------------------------------------------;
 F5C1  74 13			; Display LPT ports
 F5C3  3C 0A			;
 F5C5  74 13				POST_COL_1	POST_LPT, POST_CLR_VAL2
 F5C7  3C 08				GET_EFLAG  LPT				; AX = number of LPT ports
 F5C9  74 13				XCHG	AX, CX				; CX = number of ports
 F5CB  3C 07				MOV	SI, OFFSET LPT_ADDR
 F5CD  75 B2				CALL	SHOW_PORT_COUNT
 F5CF				
 F5CF  5A			;----------------------------------------------------------------------------;
 F5D0  59			; Display COM ports
 F5D1  5B			;
 F5D2  58				POST_COL_2	POST_COM, POST_CLR_VAL2
 F5D3  E9 F2D8				GET_EFLAG  COM				; AX = number of COM ports
 F5D6					XCHG	AX, CX				; CX = number of ports
 F5D6  32 D2				XOR	SI, SI				; OFFSET COM_ADDR = 0000H
 F5D8  EB DF			
 F5DA				;----------------------------------------------------------------------------;
 F5DA  FE C6			; Display I/O addresses of COM or LPT ports on POST
 F5DC  EB B5			;----------------------------------------------------------------------------;
 F5DE				; Input:
 F5DE  84 D2			;	SI = WORD array of ports
 F5E0  74 DA			;	CX = number of ports to show
 F5E2  4A			;----------------------------------------------------------------------------;
 F5E3  EB AE			SHOW_PORT_COUNT PROC
					JCXZ	PORT_COUNT_NONE			; if no ports, display 'None'
 F5E5				PORT_COUNT_LOOP:
					LODSW	
					CALL	WORD_HEX				; display I/O address in hex
					CALL	SPACE					; separate ports with space
					LOOP	PORT_COUNT_LOOP
					MOV	SI, OFFSET POST_RSEP[1]		; skip leading space in right sep.
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 177 - 1


					JMP	SHORT POST_END_COL_STR		; display end with sep. in SI and RET
				PORT_COUNT_NONE:
					PRINT_SZ  POST_NONE			; display 'None'
					JMP	SHORT POST_END_COL		; display end sep and RET
				SHOW_PORT_COUNT ENDP
				
 F5E5				POST_SYS_CONFIG ENDP
 F5E5  A1 0049 R		
 F5E8  8A 3E 0062 R		;----------------------------------------------------------------------------;
 F5EC  C3			; Write POST column label and start separator 
 F5ED				;----------------------------------------------------------------------------;
				; - Start new line
				; - display column name in color 1
				; - display left separator in color 1
				; - set color for inner text to be color 2
				;----------------------------------------------------------------------------;
				; Input:
				; - SI: column name string
				; - BL: inner text color/attribute
				;
 F5ED				; Output:
 F5ED  50			; - SI: beginning of next adjacent string
 F5EE  52			; - CX: inner text color length = POST_TAB_COL_I
 F5EF  8A C7			;----------------------------------------------------------------------------;
 F5F1  98			POST_COL PROC
 F5F2  97			
 F5F3  A1 004C R		;----------------------------------------------------------------------------;
 F5F6  F7 E7			; Handle 40 column mode - move to next line and fall through to col 1
 F5F8  D1 E7			;
 F5FA  8B 95 0050 R		POST_START_COL_2_40:
 F5FE  97				CALL	CRLF				; move to next line
 F5FF  A0 004A R			POP	AX				; rebalance stack
 F602  F6 E6			POST_START_COL_1 PROC
 F604  92				PUSH	AX
 F605  98				MOV	AL, POST_COL_W		; column 1 tab width
 F606  03 C2			POST_START_COL_START:
 F608  D1 E0				PUSH	BX				; save inner text color
 F60A  03 F8				MOV	AH, BL			; save text color
 F60C  5A				MOV	CX, POST_COL_VT		; set attribute on next CX # of chars
 F60D  58				MOV	BX, LOW POST_CLR_TXT	; set outer text color
 F60E  C3				CALL	OUT_SZ_ATTR			; write SI string with attribute
 F60F					CALL	MOVE_COL			; move cursor to separator column
					PUSH	SI				; save end of string
					MOV	SI, OFFSET POST_LSEP	; write separator string with
					CALL	OUT_SZ			;  existing attributes
					MOV	BL, AH			; restore text color
					DEC	SI				; [SI] = previous null char
					MOV	CL, POST_TAB_COL_I	; CX = repeat times
					PUSH	CX				; save for return
					CALL	OUT_SZ_ATTR			; set attributes, skip null string
					POP	CX				; CX = inner text color length
					POP	SI				; restore string position
					POP	BX				; BL = attribute for next CX chars
					POP	AX
					RET
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 178 - 1


				POST_START_COL_1 ENDP
				
				;----------------------------------------------------------------------------;
				; Same as POST_START_COL_1 except starts at column 2
				;----------------------------------------------------------------------------;
				POST_START_COL_2 PROC
							ASSUME DS:_BDA
					PUSH	AX
					MOV	AH, 0FH			; get video mode
 F60F 2C				INT	10H				; AL = video mode
 F610  28				CMP	AL, 1				; is 40 column mode?
 F611  2D				JLE	POST_START_COL_2_40
 F612  29				MOV	AL, POST_TAB_COL		; move to start of column 2
 F613  2A				CALL	MOVE_COL
 F614  2E				MOV	AL, POST_TAB_COL+POST_COL_W	; set abs. position for column 2 tab
 F615  1E				JMP	POST_START_COL_START
 F616  29			POST_START_COL_2 ENDP
				
 F617				;----------------------------------------------------------------------------;
				; Same as POST_END_COL and displays a CRLF
				;----------------------------------------------------------------------------;
				POST_END_COL_NL PROC
					CALL	POST_END_COL
					JMP	SHORT CRLF			; write CRLF and RET
				POST_END_COL_NL ENDP
				
				;----------------------------------------------------------------------------;
				; Write POST column end separator 
				;----------------------------------------------------------------------------;
 F617				; Display right separator in color POST_CLR_TXT
				; Clobbers: BX
				;----------------------------------------------------------------------------;
				POST_END_COL PROC NEAR
 F617  E8 F024				MOV	SI, OFFSET POST_RSEP
				
				;----------------------------------------------------------------------------;
				; POST_END_COL_STR: Write POST column end separator
				;----------------------------------------------------------------------------;
				; Input: CS:SI
				;----------------------------------------------------------------------------;
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 F61A  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 F61C  BE E4A2 R	     1		MOV	SI, OFFSET POST_CPU
 F61F  E8 0072		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
				POST_END_COL_STR PROC NEAR
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 179 - 1


 F622					MOV	CX, 2
					MOV	BX, LOW POST_CLR_TXT	; Fall through to OUT_SZ_ATTR and RET
 F622  F6 06 0012 R 04	     1		TEST	GB_FLAGS, MASK V20
 F627  74 03			
 F629  BE E4CA R		;----------------------------------------------------------------------------;
 F62C				; Write a zero-terminated string to console with attributes, no cursor move
 F62C  E8 00BE			;----------------------------------------------------------------------------;
				; Sets attribute in BL for the next CX number of characters, past end of string.
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 F62F  E8 00A0		     1		CALL	POST_END_COL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				;
				; Input: CS:SI = String, CX = length, BL = attribute, BH = video page
				; Output: SI = end of string
				;----------------------------------------------------------------------------;
 F632				OUT_SZ_ATTR PROC
					PUSH	AX
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 F632  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 F634  BE E4AB R	     1		MOV	SI, OFFSET POST_FPU
 F637  E8 0081		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				
			     1				IF FPU LT 8
 F63A  F6 06 0010 R 02	     1		TEST	BYTE PTR EQUIP_FLAGS, LOW MASK FPU
			     1				ELSE
			     1		TEST	BYTE PTR EQUIP_FLAGS[1], HIGH MASK FPU
			     1				ENDIF
 F63F  75 03			;----------------------------------------------------------------------------;
 F641  BE F945 R		; Filter MDA attributes - Remove underline, blink and ensure text is visible
 F644				;
 F644  E8 00A6			MDA_COLOR_FIX:
					CALL	INT_10_IS_TXT		; CF if MDA
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 F647  E8 0083		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
					JNC	OUT_SZ_ATTR_SET		; skip if not MDA
					AND	BL, 01111111B		; remove MDA blink attr
					OR	BL, 00000010B		; remove MDA underline attr
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 180 - 1


				
				OUT_SZ_ATTR_SET:
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL2		; BH = 0, BL = attribute
			     1			ELSE
 F64A  B3 0E		     1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute
			     1			ENDIF
 F64C  BE E4CE R	     1		MOV	SI, OFFSET POST_LPT
 F64F  E8 0042		     1		CALL	POST_START_COL_1
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
			     1	
					MOV	AX, DBW <9, VID_SP>	; write empty char with attr CX # of times
			     1			LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
			     1				IFNB <>
			     1		PUSH	CX					; save CX
			     1		PUSH	DS
			     1		MOV	CX, SEG _BDA			; DS = BDA
			     1		MOV	DS, CX
			     1				ENDIF
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Shift if flag is in high byte to low for byte operations
			     1	;
			     1				IF LPT LT 8		; is in low byte?
			     1	??0027	= MASK LPT
			     1	??0028	= LPT AND 0111B
			     1	??0029	= EQUIP_FLAGS[0]			; low BDA flags byte
			     1				ELSE				; is in high byte
 = 00C0			     1	??0027	= HIGH MASK LPT
 = 0006			     1	??0028	= (LPT - 8) AND 0111B
 = 0011			     1	??0029	= EQUIP_FLAGS[1]			; high BDA flags byte
			     1				ENDIF
			     1	
 F652  A0 0011 R	     1		MOV	AL, BYTE PTR ??0029
 F655  25 00C0		     1		AND	AX, ??0027			; clear AH
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Determine optimal number of shifts based on bit position and shift
			     1	; right or left depending on fewest.
			     1	;
			     1				IF CPU_TYPE	EQ CPU_V20
			     1					IF ??0028 GT 4
			     1		ROL	AL, 8-??0028			; shift value into position
			     1					ELSE
			     1		ROR	AL, ??0028			; shift value into position
			     1					ENDIF
			     1				ELSE
			     1					IF ??0028 GT 4
 F658  B1 02		     1		MOV	CL, 8-??0028			; CL = bit(s) position of record
 F65A  D2 C0		     1		ROL	AL, CL				; shift value into position
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 181 - 1


			     1					ELSE
			     1		MOV	CL, ??0028			; CL = bit(s) position of record
			     1		ROR	AL, CL				; shift value into position
			     1					ENDIF
			     1				ENDIF
			     1				IFNB <>
			     1		POP	DS
			     1		POP	CX
			     1				ENDIF
 F65C  91				INT	10H
 F65D  BE 0008 R			POP	AX				; Fall through to OUT_SZ and RET
 F660  E8 0015			
				;----------------------------------------------------------------------------;
				; Display a zero-terminated string in BIOS at CS:[SI]
				;----------------------------------------------------------------------------;
				; Input: CS:SI = String, BH = video page
				; Size: 24 bytes
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL2		; BH = 0, BL = attribute
			     1			ELSE
 F663  B3 0E		     1		MOV	BL, LOW POST_CLR_VAL2		; BL = attribute
			     1			ENDIF
 F665  BE E4D2 R	     1		MOV	SI, OFFSET POST_COM
 F668  E8 0050		     1		CALL	POST_START_COL_2
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
				;----------------------------------------------------------------------------;
			     1			LOCAL FLAG_MASK, FLAG_BIT, FLAG_MEM
			     1				IFNB <>
			     1		PUSH	CX					; save CX
			     1		PUSH	DS
			     1		MOV	CX, SEG _BDA			; DS = BDA
			     1		MOV	DS, CX
			     1				ENDIF
			     1	
			     1	;----------------------------------------------------------------------------;
			     1	; Shift if flag is in high byte to low for byte operations
			     1	;
			     1				IF COM LT 8		; is in low byte?
			     1	??002A	= MASK COM
			     1	??002B	= COM AND 0111B
			     1	??002C	= EQUIP_FLAGS[0]			; low BDA flags byte
			     1				ELSE				; is in high byte
 = 000E			     1	??002A	= HIGH MASK COM
 = 0001			     1	??002B	= (COM - 8) AND 0111B
 = 0011			     1	??002C	= EQUIP_FLAGS[1]			; high BDA flags byte
			     1				ENDIF
			     1	
 F66B  A0 0011 R	     1		MOV	AL, BYTE PTR ??002C
 F66E  83 E0 0E		     1		AND	AX, ??002A			; clear AH
			     1	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 182 - 1


			     1	;----------------------------------------------------------------------------;
			     1	; Determine optimal number of shifts based on bit position and shift
			     1	; right or left depending on fewest.
			     1	;
			     1				IF CPU_TYPE	EQ CPU_V20
			     1					IF ??002B GT 4
			     1		ROL	AL, 8-??002B			; shift value into position
			     1					ELSE
			     1		ROR	AL, ??002B			; shift value into position
			     1					ENDIF
			     1				ELSE
			     1					IF ??002B GT 4
			     1		MOV	CL, 8-??002B			; CL = bit(s) position of record
			     1		ROL	AL, CL				; shift value into position
			     1					ELSE
 F671  B1 01		     1		MOV	CL, ??002B			; CL = bit(s) position of record
 F673  D2 C8		     1		ROR	AL, CL				; shift value into position
			     1					ENDIF
			     1				ENDIF
			     1				IFNB <>
			     1		POP	DS
			     1		POP	CX
			     1				ENDIF
 F675  91			OUT_SZ PROC
 F676  33 F6				PUSH	AX
					MOV	AH, 0EH			; TTY output
				OUT_SZ_LOOP:
					LODS	BYTE PTR CS:[SI]		; AL = CS:[SI++]
					TEST	AL, AL			; is zero terminator?
					JZ	OUT_SZ_DONE			; if so, exit
					INT	10H
					JMP	SHORT OUT_SZ_LOOP
				OUT_SZ_DONE:
 F678					POP	AX
 F678  E3 0E				RET
 F67A				OUT_SZ ENDP
 F67A  AD			OUT_SZ_ATTR ENDP
 F67B  E8 00D6			POST_END_COL_STR ENDP
 F67E  E8 009E			POST_END_COL ENDP
 F681  E2 F7			
 F683  BE E4E3 R		;----------------------------------------------------------------------------;
 F686  EB 4D			; Locate cursor to column on current line
 F688				;----------------------------------------------------------------------------;
				; Input:
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <POST_NONE>,<SI>			; if SZ is not SI
 F688  BE F945 R	     1		MOV	SI, OFFSET POST_NONE
			     1			ENDIF
 F68B  E8 005F		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 F68E  EB 42			; - AL = new col
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 183 - 1


 F690				;
				; Size: 23 bytes
 F690				;----------------------------------------------------------------------------;
				MOVE_COL PROC
					PUSH	AX				; must preserve all of these
					PUSH	BX
					PUSH	CX
					PUSH	DX
					PUSH	AX				; preserve AL on INT 10H call
					XOR	BH, BH 			; video page 0
					MOV	AH, 3 			; get cursor position
					INT	10H 				; DH = row, DL = column
					POP	AX
				MOVE_COL_SET:
					MOV	DL, AL			; set new column
					MOV	AH, 2 			; set cursor position
					INT	10H 				; row = DH, column = DL
					POP	DX
					POP	CX
					POP	BX
 F690					POP	AX
					RET
				MOVE_COL ENDP
				POST_COL ENDP
				
 F690				;----------------------------------------------------------------------------;
 F690  E8 0083			; Display a zero-terminated string in BIOS at CS:[SI] with ending NL
 F693  58			;----------------------------------------------------------------------------;
 F694				; Input: CS:SI = String
 F694  50			; Size: 12 bytes
 F695  B0 06			;----------------------------------------------------------------------------;
 F697				OUTLN_SZ PROC
 F697  53				CALL	OUT_SZ			; write original string in SI
 F698  8A E3									; fall through to CRLF
 F69A  B9 0009			
 F69D  BB 0003			;----------------------------------------------------------------------------;
 F6A0  E8 0038			; Write a CRLF string to console
 F6A3  E8 0056			;----------------------------------------------------------------------------;
 F6A6  56			CRLF PROC
 F6A7  BE E4DE R			PRINT_SZ  NL_Z, 1
 F6AA  E8 0040				RET
 F6AD  8A DC			CRLF ENDP
 F6AF  4E			
 F6B0  B1 13			OUTLN_SZ ENDP
 F6B2  51			
 F6B3  E8 0025			;----------------------------------------------------------------------------;
 F6B6  59			; Write a space char to console (8 bytes)
 F6B7  5E			;----------------------------------------------------------------------------;
 F6B8  5B			SPACE PROC
 F6B9  58				PUSH	AX				; no clobbery AX
 F6BA  C3				MOV	AX, DBW <0EH, ' '>	; AH = 0Eh, AL = space char
 F6BB					INT	10H				; send to console
					POP	AX
					RET
				SPACE ENDP
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 184 - 1


				
 F6BB				;----------------------------------------------------------------------------;
				; Write Unsigned word as decimal to console - no clobber helper
 F6BB  50			;----------------------------------------------------------------------------;
 F6BC  B4 0F			; Input: AX value
 F6BE  CD 10			; Size: 33 bytes
 F6C0  3C 01			;----------------------------------------------------------------------------;
 F6C2  7E CC			OUT_DECU PROC
 F6C4  B0 20				PUSH	AX
 F6C6  E8 0033				PUSH	BX
 F6C9  B0 26				PUSH	DX
 F6CB  EB CA				CALL	OUT_DECU_R
 F6CD					POP	DX
					POP	BX
					POP	AX
					RET
				
 F6CD				;----------------------------------------------------------------------------;
 F6CD  E8 0002			; Write Unsigned word as decimal to console
 F6D0  EB 44			;----------------------------------------------------------------------------;
 F6D2				; Input: AX value
				; Clobbers AX, BX, DX
				;----------------------------------------------------------------------------;
				OUT_DECU_R PROC
					MOV	BX, 10			; decimal divisor = 10
				OUT_DECU_DIV:
					XOR	DX, DX 			; clear high word of dividend
					DIV	BX				; AX = DX:AX / 10, DX = DX:AX % 10
 F6D2					TEST	AX, AX			; is zero?
 F6D2  BE E4E2 R			JZ	OUT_DECU_DONE		; loop while AX > 0
					PUSH	DX				; save remainder digit
					CALL	OUT_DECU_DIV		; recursive call to next division
					POP	DX				; restore digit
				OUT_DECU_DONE:
					XCHG	AX, DX			; AL = digit, AH = 0
				OUT_DECU_OUT_R:
 F6D5					XOR	AX, DBW <0EH, '0'>	; ASCII convert digit, AH = 0EH
 F6D5  B9 0002				INT	10H
 F6D8  BB 0003				RET
				OUT_DECU_R ENDP
				OUT_DECU ENDP
				
				;----------------------------------------------------------------------------;
				; Write DWORD BX:AX as HEX to console
				;----------------------------------------------------------------------------;
				; Input: BX:AX - 32 bit value to write
				; WORDS are separated by a colon ex: 1234:ABCD
				;
 F6DB				; AX clobbered
 F6DB  50			; Size: 50 bytes
				;----------------------------------------------------------------------------;
				DWORD_HEX PROC
					PUSH	AX 				; save AX
					MOV	AX, BX
 F6DC					CALL	WORD_HEX 			; write AX to console as HEX
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 185 - 1


 F6DC  E8 F9A6				MOV	AL, ':'
 F6DF  73 06				CALL	OUT_CHAR			; Write char in AL to console
 F6E1  80 E3 7F				POP	AX 				; restore AX
 F6E4  80 CB 02			
				;--------------------------------------------------------------------------
 F6E7				; Write WORD AX as HEX to console
 F6E7  B8 0920			;--------------------------------------------------------------------------
 F6EA  CD 10			WORD_HEX PROC
 F6EC  58				PUSH	AX 				; save AX
					MOV	AL, AH 			; move high byte into low byte
					CALL	BYTE_HEX 			; write byte as HEX to console
					POP	AX 				; restore AX
				
				;--------------------------------------------------------------------------
				; Write BYTE AL as HEX to console
				;--------------------------------------------------------------------------
 F6ED				BYTE_HEX PROC
 F6ED  50				PUSH	AX 				; save AL
 F6EE  B4 0E						IF CPU_TYPE	EQ CPU_V20
 F6F0					DB	0FH, 28H, 0C0H		; ROL4 AL ; swap nibbles (V20 only)
 F6F0  2E: AC						ELSE
 F6F2  84 C0				REPT	4
 F6F4  74 04				SHR	AL, 1				; move high nibble to low nibble	ENDM
 F6F6  CD 10						ENDIF
 F6F8  EB F6				CALL	NIB_HEX 			; write low nibble of AL as HEX to console
 F6FA					POP	AX 				; restore AL
 F6FA  58			
 F6FB  C3			;--------------------------------------------------------------------------
 F6FC				; Write low nibble of AL as HEX to console
 F6FC				;--------------------------------------------------------------------------
 F6FC				NIB_HEX PROC
 F6FC					AND	AL, 0FH 			; isolate low nibble
					CMP	AL, 0AH 			; if < 0Ah, CF=1 and setup a -1 for ASCII
										;  adjust since 'A'-'9' is 7 (not 6)
					SBB	AL, -('0'+66H+1) 		; BCD bias for ASCII (30h + 66h + CF)
										;  AF = AL < 0Ah, CF = 1
										;  if > 9, high_nibble = 0Ah
										;  if <=9, high_nibble = 09h
					DAS					; BCD adjust to ASCII
										;  if low_nibble < 0Ah, low_nibble -= 6
										;  high_nibble -= 6
 F6FC				
 F6FC  50			;--------------------------------------------------------------------------
 F6FD  53			; Write char in AL to console
 F6FE  51			;--------------------------------------------------------------------------
 F6FF  52			OUT_CHAR PROC
 F700  50				PUSH	AX
 F701  32 FF				PUSH	BX
 F703  B4 03				XOR	BX, BX			; video page = 0
 F705  CD 10				MOV	AH, 0EH			; Write AL to screen tty mode
 F707  58				INT	10H				; send to console
 F708					POP	BX
 F708  8A D0				POP	AX
 F70A  B4 02				RET
 F70C  CD 10			
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 186 - 1


 F70E  5A			OUT_CHAR ENDP
 F70F  59			NIB_HEX ENDP
 F710  5B			BYTE_HEX ENDP
 F711  58			WORD_HEX ENDP
 F712  C3			DWORD_HEX ENDP
 F713				
 F713				;----------------------------------------------------------------------------;
				; Delay using PIT counter increments of 125 ms
				;----------------------------------------------------------------------------;
				; Input:
				;	AL = wait in 125 ms increments
				;
				; AX clobbered
				; Size: 53 bytes
 F713				;----------------------------------------------------------------------------;
 F713  E8 FFD7			IO_WAIT_MS_125 PROC
					MOV	AH, 125
					MUL	AH				; AX = wait in 1 ms
				
				;----------------------------------------------------------------------------;
				; Delay using PIT counter increments of 1 ms
 F716				;----------------------------------------------------------------------------;
				; - Calculate the total number of PIT ticks necessary (where 1,193,000 = 1s)
			     1			IFNB	<1>
 F716  56		     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <NL_Z>,<SI>			; if SZ is not SI
 F717  BE E46B R	     1		MOV	SI, OFFSET NL_Z
			     1			ENDIF
 F71A  E8 FFD0		     1		CALL	OUT_SZ
			     1			IFNB	<1>
 F71D  5E		     1		POP	SI
			     1			ENDIF
 F71E  C3			; - Latch the PIT and draw down the countdown total on each read.
 F71F				; - Exit when countdown underflows.
				;
 F71F				; Note: Mode 3 (Square Wave) decements the readable counter by 2, so the
				; effective frequency of the counter is actually 2,386,360 Hz.
				;
				; Input:
				;	AX = wait in number of ms (clobbered)
 F71F				;
 F71F  50			; Based on contribution by @Raffzahn (under CC BY-SA 4.0):
 F720  B8 0E20			; https://retrocomputing.stackexchange.com/a/24874/21323
 F723  CD 10			;
 F725  58			; https://stanislavs.org/helppc/8253.html
 F726  C3			;----------------------------------------------------------------------------;
 F727				IO_DELAY_MS PROC
					PUSH	BX
					MOV	BX, 1193 * 2		; 1,193,180 / 1000 ms * 2 = 2,386 ticks/ms
				IO_DELAY_TICK PROC
					XCHG	AX, BX			; BX = wait ms
					PUSH	CX
					PUSH	DX
					MUL	BX				; DX:AX = countdown of PIT ticks to wait
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 187 - 1


 F727					XCHG	AX, BX			; DX:BX = countdown ticks
 F727  50				CALL	IO_WAIT_LATCH		; AX = start read
 F728  53				MOV	CX, AX			; CX = last read
 F729  52			IO_WAIT_MS_LOOP:
 F72A  E8 0004				CALL	IO_WAIT_LATCH		; AX = current counter reading
 F72D  5A				SUB	CX, AX			; CX = # of ticks elapsed since last reading
 F72E  5B				SUB	BX, CX			; subtract change in ticks from countdown
 F72F  58				MOV	CX, AX			; CX = save the last read
 F730  C3				SBB	DX, 0				; borrow out of high word (if necessary)
					JAE	IO_WAIT_MS_LOOP		; loop while countdown >= 0
					POP	DX
					POP	CX
					POP	BX
				IO_WAIT_MS_DONE:
					RET
				IO_WAIT_LATCH:
 F731					MOV	AL, PIT_CW <0, 0>		; Counter 0, Latch (00b)
 F731  BB 000A				PUSHF					; save current IF
 F734					CLI					; disable interrupts
 F734  33 D2				OUT	PIT_CTRL, AL		; Write command to CTC
 F736  F7 F3				IN	AL, PIT_CH0			; Read low byte of Counter 0 latch
 F738  85 C0				MOV	AH, AL			; Save it
 F73A  74 05				IN	AL, PIT_CH0			; Read high byte of Counter 0 latch
 F73C  52				POPF					; restore IF state
 F73D  E8 FFF4				XCHG	AL, AH			; convert endian
 F740  5A				RET
 F741				IO_DELAY_TICK ENDP
 F741  92			IO_DELAY_MS ENDP
 F742				IO_WAIT_MS_125 ENDP
 F742  35 0E30			
 F745  CD 10						IF POST_VIDEO_TYPE EQ 1
 F747  C3			;----------------------------------------------------------------------------;
 F748				; POST Video Adapter Type Strings (1 of 2)
 F748				; 12 bytes
				;
				POST_VGA		DB	'VGA', 0
				POST_EGA		DB	'EGA', 0
				POST_CGA		DB	'CGA', 0
							ENDIF
				
				;
				; 1 BYTES HERE
				;
				BYTES_HERE	INT_12
 F748				
 F748  50			;----------------------------------------------------------------------------;
 F749  8B C3			; INT 12H - Memory Size Determination
 F74B  E8 0006			;----------------------------------------------------------------------------;
 F74E  B0 3A			; Output
 F750  E8 001C			;	AX = number of contiguous 1k memory blocks found at startup
 F753  58			;----------------------------------------------------------------------------;
						ORG 0F841H
				INT_12 PROC
						ASSUME DS:_BDA
					STI 					; Interrupts on
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 188 - 1


 F754					PUSH	DS 				; save DS
 F754  50				MOV	AX, SEG _BDA
 F755  8A C4				MOV	DS, AX 			; DS = BDA
 F757  E8 0001				MOV	AX, MEM_SZ_KB 		; AX = DS:[MEM_SZ_KB]
 F75A  58				POP	DS
					IRET
				INT_12 ENDP
				
				;----------------------------------------------------------------------------;
 F75B				; INT 11H - BIOS Equipment Determination / BIOS Equipment Flags
 F75B  50			;----------------------------------------------------------------------------;
				; Output
				;	AX = data stored at BIOS Data Area location 0040:0010
				;----------------------------------------------------------------------------;
						ORG 0F84DH
				INT_11 PROC
						ASSUME DS:_BDA
 F75C  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
 F75E  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
 F760  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
 F762  D0 E8		     1		SHR	AL, 1				; move high nibble to low nibble
					STI 					; Interrupts on
 F764  E8 0001				PUSH	DS 				; save DS
 F767  58				MOV	AX, SEG _BDA
					MOV	DS, AX 			; DS = BDA
					MOV	AX, EQUIP_FLAGS
					POP	DS
					IRET
 F768				INT_11 ENDP
 F768  24 0F			
 F76A  3C 0A			;----------------------------------------------------------------------------;
				; INT 15 - System BIOS Services / Cassette
 F76C  1C 69			;----------------------------------------------------------------------------;
				;	INT 15,0  Turn cassette motor on
				;	INT 15,1  Turn cassette motor off
				;	INT 15,2  Read blocks from cassette
 F76E  2F			;	INT 15,3  Write blocks to cassette
				;
				; Output:
				;	CF = 1, AH = 86H (unsupported/no cassette present)
				;
				; https://stanislavs.org/helppc/int_15.html
				; http://www.ctyme.com/intr/int-15.htm
 F76F				; http://www.techhelpmanual.com/212-int_15h__at_extended_services___apm.html
 F76F  50			;----------------------------------------------------------------------------;
 F770  53					ORG 0F859H
 F771  33 DB			INT_15 PROC
 F773  B4 0E				STI					; return with interrupts enabled
 F775  CD 10						IF CASSETTE EQ 1
 F777  5B				CMP	AH, 3				; cassette function 0-3?
 F778  58				JBE	INT_15_CASS
 F779  C3						ENDIF
				
 F77A					MOV	AH, 86H 			; return with unsupported function
 F77A				INT_15_EXIT:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 189 - 1


 F77A					CMP	AH, 1				; set CF if error (AH > 0)
 F77A					CMC
 F77A					IRET_F				; IRET with current flags
				
							IF CASSETTE EQ 1
				;----------------------------------------------------------------------------;
				; INT 15H - 5150 Cassette
				;----------------------------------------------------------------------------;
				; Input:
				;	ZF if AH = 3 (result of 'CMP AH, 3')
				;
				;----------------------------------------------------------------------------;
				; Huge thx to @Raffzahn for clean room specs!
 F77A				;
 F77A  B4 7D			; Further reading:
 F77C  F6 E4			;  https://nerdlypleasures.blogspot.com/2014/04/tape-cassettes-storage-with-ibm-pc-and.html
				;  http://fileformats.archiveteam.org/wiki/IBM_PC_data_cassette
				;  http://brutmanlabs.org/Cassette_Waveforms/Cassette_Waveforms.html
				;----------------------------------------------------------------------------;
				INT_15_CASS PROC
							ASSUME DS:_BDA
					PUSH	DS
					PUSH	DX				; scratch register
					MOV	DX, SEG _BDA		; DS = BDA
					MOV	DS, DX
					MOV	BIOS_BREAK, DH		; clear BIOS break key flag
					MOV	AL, AH			; AL = function
					LAHF					; save 'CMP AH, 3' flags
					DEC	AL				; is motor off function?
					JZ	CAS_MOTOR_OFF_DONE	; turn motor off and exit
										; otherwise fall through, turn on motor
										; and do read/write operation or exit
				
				;----------------------------------------------------------------------------;
				; INT 15,0 - Turn Cassette Motor On
 F77E				;----------------------------------------------------------------------------;
 F77E  53			; Input:
 F77F  BB 0952			;	AH = 00
 F782				;
 F782  93			; - all programs using the cassette must actually turn on
 F783  51			;	the device before use
 F784  52			; - there is a noticeable delay between turn-on and device ready
 F785  F7 E3			; - a noticeable clicking noise can be heard by switching the
 F787  93			;	cassette on and off
 F788  E8 0014			;----------------------------------------------------------------------------;
 F78B  8B C8			
 F78D				CAS_MOTOR_ON:
 F78D  E8 000F			;----------------------------------------------------------------------------;
 F790  2B C8			; - Disable Speaker
 F792  2B D9			; - Switch on Motor
 F794  8B C8			; - Wait ca 0.5s
 F796  83 DA 00			;
 F799  73 F2				IN	AL, PPI_B			; read current PPI B
 F79B  5A				AND	AL, NOT MASK PBSP	AND NOT MASK PBCM	; Disable Speaker and
 F79C  59									; turn on (clear) motor bit
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 190 - 1


 F79D  5B				OUT	PPI_B, AL			; send to PPI B
 F79E					SAHF					; restore 'CMP AH, 3' flags
 F79E  C3				JPE	CAS_MOTOR_WAIT		; jump if read/write
 F79F										; otherwise fall through to exit
 F79F  B0 00			
 F7A1  9C			;----------------------------------------------------------------------------;
 F7A2  FA			; Return with success
 F7A3  E6 43			;
 F7A5  E4 40			INT_15_DONE_OK:
 F7A7  8A E0				MOV	AH, 0				; return with success
 F7A9  E4 40			
 F7AB  9D			;----------------------------------------------------------------------------;
 F7AC  86 C4			; Return with status in AH 
 F7AE  C3			;
 F7AF				INT_15_DONE:
 F7AF					POP	DX				; restore working registers
 F7AF				
				INT_15_DONE_NO_DX:			; return without restoring DX
					POP	DS
					JMP	SHORT INT_15_EXIT
				
				;----------------------------------------------------------------------------;
				; Turn off motor and return success (only read operation returns non-success)
 F7AF 56 47 41 00		;
 F7B3 45 47 41 00		CAS_MOTOR_OFF_DONE:
 F7B7 43 47 41 00			CALL	CAS_TIMER_ON_MOTOR_OFF		
					JMP	SHORT INT_15_DONE_OK	; return with success
				
				;----------------------------------------------------------------------------;
				; Re-enable timer and turn off motor
				;
				CAS_TIMER_ON_MOTOR_OFF PROC
 F7BB			     1			LOCAL LBL
			     1	
 = 0086			     1	BYTES_HERE_INT_12 = INT_12-$
			     1	
			     1			IFDEF BYTES_HERE_INT_12
			     1			IF2
			     1			IF BYTES_HERE_INT_12 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_12 (BYTES_HERE_INT_12)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					IN	AL, INT_IMR			; Re-enable timer interrupt
					AND	AL, NOT MASK IRQ0		; unmask IRQ 0 (INT 8 Timer)
					OUT	INT_IMR, AL
				CAS_TIMER_ON_MOTOR_OFF ENDP
				
				;----------------------------------------------------------------------------;
				; INT 15,1 - Turn Cassette Motor Off
				;----------------------------------------------------------------------------;
 F841				; Input:
				;	AH = 01
 F841  FB			;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 191 - 1


 F842  1E			; - all programs using the cassette should turn off
 F843  B8 ---- R		;	the device after use
 F846  8E D8			; - a noticeable clicking noise can be heard by switching the
 F848  A1 0013 R		;	cassette on and off
 F84B  1F			;----------------------------------------------------------------------------;
 F84C  CF			CAS_MOTOR_OFF PROC
 F84D					IN	AL, PPI_B			; read current PPI port B status
					OR	AL, MASK PBCM 		; turn off (SET) motor bit
					OUT	PPI_B, AL			; write back to port B	
					RET
				CAS_MOTOR_OFF ENDP
				
				;----------------------------------------------------------------------------;
				; Is Read/Write operation: Wait 0.5 sec for motor spinup
				;
 F84D				CAS_MOTOR_WAIT:
					PUSHF					; save flags
 F84D  FB				MOV	AX, 500			; delay for 500ms
 F84E  1E				CALL	IO_DELAY_MS
 F84F  B8 ---- R		
 F852  8E D8			;----------------------------------------------------------------------------;
 F854  A1 0010 R		; Disable "noisy" INT 08h timer interrupt (could affect timing)
 F857  1F			;
 F858  CF				IN	AL, INT_IMR			; read IMR register
 F859					OR	AL, MASK IRQ0		; mask IRQ 0 (INT 8 Timer)
					OUT	INT_IMR, AL			; write IMR
				
					POPF					; ZF if write, NZ if read
					JZ	CAS_WRITE			; AH = 3 write
					JMP	NEAR PTR CAS_READ		; near jump to read
				
				;----------------------------------------------------------------------------;
				; INT 15,3 - Write Blocks to Cassette
				;----------------------------------------------------------------------------;
				; Write a "chunk" of blocks to tape:
				;
				; Input:
				;	AH = 03
				;	CX = count of bytes to write
				;	ES:BX = pointer to data buffer
				;
				; Output:
 F859				;	AX clobbered
 F859  FB			;	CX = zero
				;	ES:BX = pointer to byte following last byte written
				;	Flags preserved
				;----------------------------------------------------------------------------;
				; Format:
				; - One bit zero  (to start at defined timing)
 F85A  B4 86			; - 256 bytes FFh (=2048 bits of 1) (Leader)
 F85C				; - One bit zero  (for sync)
 F85C  80 FC 01			; - One byte 16h  (sync byte - MSB first)
 F85F  F5			; - 1..n Data Blocks
				; - 4 bytes FFh   (=32 bits of 1)
 F860  CA 0002		     1		RETF	2
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 192 - 1


				;
				; Notes:
				; - data is actually written in 256 byte blocks
				; - if CX is less than 256, then the block is padded
				; - no error detection/correction is available for writing
				;----------------------------------------------------------------------------;
				;       1 |			- PBSP	0=turn off speaker, 1=turn on
				;        0|			- PBST	0=turn off timer 2, 1=turn on
				;----------------------------------------------------------------------------;
				CAS_WRITE PROC
				
				;----------------------------------------------------------------------------;
				; Set Timer 2 to mode square and enable
				;
					MOV	AL, PIT_CW <2, 11B, 3>	; Select Timer 2, LE, Mode 3 (square), Binary
					OUT	PIT_CTRL, AL		; (10 11 011 0) Send to PIT control word (43H)
					IN	AL, PPI_B			; read PPI B
					OR	AL, MASK PBST		; turn on timer 2
					OUT	PPI_B, AL			; send to PPI B
				
				;----------------------------------------------------------------------------;
				; One bit zero (to start at defined timing)
				;
					CALL	CAS_WRITE_BIT		; start output bit is 0 (already NC from OR)
				
				;----------------------------------------------------------------------------;
				; 256 bytes FFh (=2048 bits of 1) (Leader)
				;
					PUSH	CX				; save outer byte loop counter
				CAS_WRITE_LEADER:
					STC					; leader output bit is 1
					MOV	CX, 256 * 8			; leader is 2048 bits
				CAS_WRITE_LEADER_LOOP:
					CALL	CAS_WRITE_BIT		; set timer to correct bit, wait for full cycle
					LOOP	CAS_WRITE_LEADER_LOOP
					POP	CX				; restore outer byte loop counter
				
				;----------------------------------------------------------------------------;
				; One bit zero (for sync)
				;
					CLC					; sync output bit is 0
					CALL	CAS_WRITE_BIT
				
				;----------------------------------------------------------------------------;
				; One byte 16h (sync byte - MSB first)
				;
					MOV	AL, SYN			; SYN C0 control char
					CALL	CAS_WRITE_BYTE		; write sync byte
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BLOCKS: Output 1..n Data Blocks
				;----------------------------------------------------------------------------;
				;- Output loop (BLOCK)
				;  - Init CRC
				;  - Block loop (BYTE)
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 193 - 1


				;
				; Input: CX = blocks to write
				;----------------------------------------------------------------------------;
				CAS_WRITE_BLOCKS PROC
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BLOCK: loop until 256 bytes transfered
				;----------------------------------------------------------------------------;
				; - Fetch byte if not exhausted
				; - Byte loop (BIT)
				;
				CAS_WRITE_BLOCK PROC
					MOV	CAS_CRC, CAS_CRC_PRE	; Init CRC preset
					XOR	DX, DX			; block counter DX = 0
				CAS_WRITE_BLOCK_LOOP:
					MOV	AL, ES:[BX]			; AL = next byte
					INC	BX
					CALL	CAS_WRITE_BYTE		; write to cassette
					DEC	DL				; loop until 00
					LOOPNZ CAS_WRITE_BLOCK_LOOP	; loop while DX > 0 and CX > 0
					JZ	CAS_WRITE_CRC		; if DX = 0, current block is done
				
				;----------------------------------------------------------------------------;
				; CX is 0, DX > 0 - done writing bytes, fill the remaining space in the
				; 256 byte block with same char.
				;
				CAS_WRITE_BLOCK_PAD:
					XCHG	CX, DX			; otherwise write out the rest
				CAS_WRITE_PAD_LOOP:
					CALL	CAS_WRITE_BYTE
					LOOP	CAS_WRITE_PAD_LOOP
					XCHG	CX, DX			; restore CX
				
				;----------------------------------------------------------------------------;
				; Done writing block and DX = 0
				; - Write One's complement of CRC to cassette
				;
				CAS_WRITE_CRC:
					MOV	AX, CAS_CRC			; get working CRC
					NOT	AX				; one's complement it
					CALL	CAS_WRITE_WORD		; write to cassette
				
				CAS_WRITE_BLOCK ENDP
				
				;----------------------------------------------------------------------------;
				;- Do output loop while still input bytes
				;
					INC	CX				; any more bytes left to write?
					LOOP	CAS_WRITE_BLOCK		; write another block if so
				
				CAS_WRITE_BLOCKS ENDP
				
				;----------------------------------------------------------------------------;
				; Finish transfer
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 194 - 1


				; Write 4 Byte FF trailer (32 bits of 1) / 4 bytes FFh   (=32 bits of 1)
				;
				CAS_WRITE_TRAILER:
					STC					; trailer output bit is 1
					MOV	CL, 4 * 8			; trailer is 4 bytes
				CAS_WRITE_TRAILER_LOOP:
					CALL	CAS_WRITE_BIT		; set timer to CF bit, wait for full cycle
					LOOP	CAS_WRITE_TRAILER_LOOP
				
				;----------------------------------------------------------------------------;
				;- Turn off timer 2
				;- Set Timer 2 to 1
				;
					MOV	AL, PIT_CW <2, 11B, 0>	; Select Timer 2, LE, Mode off, Binary
					OUT	PIT_CTRL, AL		; (10 11 000 0) Send to PIT control word
				
				;----------------------------------------------------------------------------;
				;- Re-enable INT 8 timer interrupt
				;- Switch Motor off and exit
				;
					JMP	 SHORT CAS_MOTOR_OFF_DONE
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BIT: Write a single bit to tape
				;----------------------------------------------------------------------------;
				; Input:
				; 	CF bit: 1 or 0 (preserved)
				;
				; AL preserved, AH clobbered
				;----------------------------------------------------------------------------;
				; Things you must do:
				;
				; - Extract MSB (RCL)
				; - Write 0 or 1
				; 	- 0 = 2.015 KHz (592 timer cycles)
				;	- 1 = 1.007 KHz (1184 timer cycles)
				; - Add to CRC message
				;----------------------------------------------------------------------------;
				CAS_WRITE_BIT PROC
					LAHF					; preserve CF flag
					PUSH	AX				; preserve AX
					MOV	AX, BEEP_1K7		; set for 1 = ~1 ms  (1.007 KHz = 1,193,180/1184)
					JC	CAS_START_TIMER		; if input bit is a 1, AX already set
					SHR	AX, 1				; set for 0 = ~0.5ms (2.015 KHz = 1,193,180/592)
				CAS_START_TIMER:
					OUT	PIT_CH2, AL			; send low byte to timer
				 	XCHG	AL, AH 			; select high byte
				 	OUT	PIT_CH2, AL			; send high byte to timer
				
				;----------------------------------------------------------------------------;
				; Read Timer 2 and wait a full rising and falling flank
				;
				CAS_WRITE_RISE:
					IN	AL, PPI_C			; read PPI C
					TEST	AL, MASK PCT2		; is cassette output low?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 195 - 1


					JZ	CAS_WRITE_RISE		; loop until rise
				CAS_WRITE_FALL:
					IN	AL, PPI_C			; read PPI C
					TEST	AL, MASK PCT2		; is cassette output high?
					JNZ	CAS_WRITE_FALL		; loop until fall
				 	POP	AX				; restore AL for next call
				 	SAHF					; restore CF flag for next call
					RET
				CAS_WRITE_BIT ENDP
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_WORD: Write a little endian word to tape
				;----------------------------------------------------------------------------;
				; Input:
				; 	AX: word to write (preserved)
				;----------------------------------------------------------------------------;
				CAS_WRITE_WORD PROC
					XCHG	AH, AL			; MSB first
					CALL	CAS_WRITE_BYTE		; write MSB
					XCHG	AH, AL			; LSB
										; fall through to write LSB
				
				;----------------------------------------------------------------------------;
				; CAS_WRITE_BYTE: Write a single byte to tape
				;----------------------------------------------------------------------------;
				; Input:
				; 	AL: byte to write (preserved)
				;----------------------------------------------------------------------------;
				CAS_WRITE_BYTE PROC
					PUSH	AX
					PUSH	CX
					MOV	CX, 8				; loop 8 bits
				CAS_WRITE_BYTE_LOOP:
					SHL	AL, 1				; CF = next bit to write
					CALL	CAS_WRITE_BIT		; write bit in CF
					CALL	CAS_CRC_ADD			; add to working CRC
					LOOP	CAS_WRITE_BYTE_LOOP
					POP	CX
					POP	AX
					RET
				CAS_WRITE_BYTE ENDP
				CAS_WRITE_WORD ENDP
				
				CAS_WRITE ENDP
				
				;----------------------------------------------------------------------------;
				; CAS_CRC_ADD: Add current bit to CRC message
				;----------------------------------------------------------------------------;
				; Input:
				;	CF = bit to add
				;----------------------------------------------------------------------------;
				; This is (effectively) CRC16-CCITT as used by IBM for SDLC/HDLC. It uses a
				; 0FFFFh initial/preset value, 1021h polynomial and has an expected residue
				; value of 01D0Fh.
				;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 196 - 1


				; cf = ( ( crc & 0x8000 ) >> 15 ) ^ CF;
				; if ( cf ) {
				;	crc = crc ^ 0x0810;
				; }
				; crc = crc << 1 | cf;
				; return crc;
				;
				; https://stackoverflow.com/questions/62771192/crc16-ccitt-calculation
				; http://bitsavers.trailing-edge.com/pdf/ibm/datacomm/GA27-3093-3_SDLC_Concepts_Jun86.pdf
				;----------------------------------------------------------------------------;
				CAS_CRC_PRE		EQU	0FFFFh	; Cassette CRC16-CCITT preset value
				CAS_CRC_RES		EQU	01D0Fh	; Cassette CRC16-CCITT residue value
				CAS_CRC_POLY 	EQU 	01021h	; Cassette CRC16-CCITT polynomial
				
				CAS_CRC_ADD PROC
					XCHG	AX, CAS_CRC			; get working CRC, save AX
					RCR	AX, 1				; set up for RCL
					RCL	AX, 1				; OF = MSB(AX) XOR CF
					CLC					; CF = OF
					JNO	CAS_CRC_SHIFT		; if OF: AX = AX XOR 0810h
					XOR	AX, CAS_CRC_POLY SHR 1	; divide by polynomial (already shifted)
					STC					; CF = OF
				CAS_CRC_SHIFT:
					ADC	AX, AX			; shift and add bit to working CRC value
					XCHG	CAS_CRC, AX			; store working CRC, restore AX
					RET
				CAS_CRC_ADD ENDP
				
				;----------------------------------------------------------------------------; 
				; INT 15,2 - Read Blocks from Cassette 
				;----------------------------------------------------------------------------; 
				; Input:
				;	AH = 02
				;	CX = count of bytes to read
				;	ES:BX = pointer to data buffer
				;
				; Output:
				;	CF = 1 if error
				;	AH = result:
				;	  00h = successful
				;	  01h = CRC error
				;	  02h = bad tape signals / data transition lost
				;	  04h = no data / timeout / general failure
				;
				;	DX = count of bytes actually read
				;	ES:BX = pointer to byte following last byte read
				;----------------------------------------------------------------------------;
				; Notes:
				;
				; - Data is transferred in 256 byte blocks, though only the
				;	number of bytes requested are actually stored
				; - Mask INT 8 Timer interrupts (IRQ 0) during actual read 
				;	(could affect timing)
				;
				; Data Format:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 197 - 1


				;
				; - One bit zero  (to start at defined timing)
				; - 256 bytes FFh (2048 bits of 1) (Leader)
				; - One bit zero  (for sync)
				; - One byte 16h  (sync byte - MSB first)
				; - 1..n Data Blocks
				; - 4 bytes FFh   (=32 bits of 1)
				;----------------------------------------------------------------------------;
				CAS_READ PROC NEAR
					PUSH	SI				; call-preserve SI
					MOV	SI, 5				; set timeout/retry counter
					PUSH	DI
					MOV	DI, BX			; DI = output buffer
					PUSH	CX				; save bytes to read
				
				;----------------------------------------------------------------------------;
				; CAS_READ_HEADER_START: Search for leader
				;----------------------------------------------------------------------------;
				; - Must read at least 32 bytes of FFh
				; - Timeout/Error if > 1000 invalid bytes are read
				; - Must check for Ctrl-Break in all loops
				; - Retry reading header 5 times
				;----------------------------------------------------------------------------;
				CAS_READ_HEADER_START:
					IN	AL, PPI_C			; read PPI C
					AND	AL, MASK PCCI		; mask only cassette input
					MOV	CAS_PREV, AL		; save initial value
				
				;----------------------------------------------------------------------------;
				; Continue reading until a valid cycle detected or timeout
				;
					MOV	CX, 1000 * 8 * 2		; timeout is 1000 bytes
				CAS_READ_HEADER_LOOP:
					TEST	BIOS_BREAK, 10000000b	; Test BIOS break flag
					JNZ	CAS_READ_ERR_1		; Break key was hit
					CALL	CAS_READ_CYCLE		; loop until bit detected or timeout
					LOOPZ	CAS_READ_HEADER_LOOP
					JCXZ	CAS_READ_ERR		; return with general error
				
				;----------------------------------------------------------------------------;
				; Read Leader up to sync bit:
				; - If read error, start over from beginning
				; - Read at least 32 consecutive FFh bytes
				;	- if >= 32 bytes
				;		- if 0, read corresponding high cycle and continue
				;		- if 1, continue reading until sync bit (0) detected
				;	- if < 32 bytes and 0 read, start over from beginning
				;
					MOV	CX, 32 * 8 * 2		; leader must be at least 32 bytes
				CAS_READ_HEADER_LOOP_1:
					TEST	BIOS_BREAK, 10000000b	; Test BIOS break flag
				CAS_READ_ERR_1:				; (short jump hack)
					JNZ	CAS_READ_ERR		; exit if break key was hit
				
				;----------------------------------------------------------------------------;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 198 - 1


				; Read cycle transition, start over if error
				;
					CALL	CAS_READ_CYCLE		; read (ZF if failure, NZ if success)
					JZ	CAS_READ_HEADER_START	; if error, start over 32 byte count
				
				;----------------------------------------------------------------------------;
				; Calculate cycle length - is a 1 or 0?
				;
					CMP	DX, (BEEP_1K7+BEEP_2K)/2; is cycle > 1 length + 33%?
					JCXZ	CAS_READ_HEADER_SYNC	; if at least 32 FFh bytes, check for sync bit
					JB	CAS_READ_HEADER_START	; if a 0 and not 32 FFh's, start over
					LOOP	CAS_READ_HEADER_LOOP_1	; otherwise decrement counter of 1's.
				
				;----------------------------------------------------------------------------;
				; At least 32 x 1's have been found (CX = 0):
				; - if bit is 0, it is the sync bit
				; - if bit is 1, keep reading out the remaining 1's
				;
				CAS_READ_HEADER_SYNC:
					JAE	CAS_READ_HEADER_LOOP_1	; jump if 1 is read (keep reading for 1's)
					CALL	CAS_READ_CYCLE		; wait for sync bit high cycle to complete
				
				;----------------------------------------------------------------------------;
				; Read and verify sync byte
				;
					CALL	CAS_READ_BYTE		; read first byte
					CMP	AL, SYN			; is sync byte?
					JNE	CAS_READ_ERR		; error if not
				
				;----------------------------------------------------------------------------;
				; CAS_READ_BLOCKS
				;----------------------------------------------------------------------------;
				; - Reset CRC to initial preset
				; - Always loop 256 times (bytes)
				; - Check for Ctrl-Break
				; - If successful read, write to ES:[DI]
				; - If failed read, exit with data error (04h)
				; - If requested bytes < 256, read (and discard) remaining bytes
				; - Read and verify CRC. If bad CRC exit with CRC error (01h)
				; - If CX > 0, restart block loop
				;----------------------------------------------------------------------------;
					POP	CX				; restore counter
					PUSH	CX				; rebalance stack
				CAS_READ_BLOCKS PROC
					MOV	CAS_CRC, CAS_CRC_PRE	; set CRC to initial preset
					MOV	BH, 0				; loop 256 bytes
				CAS_READ_BLOCK_LOOP:
					TEST	BIOS_BREAK, 10000000b	; Test BIOS break flag
					JNZ	CAS_READ_ERR		; exit if break key was hit
					CALL	CAS_READ_BYTE		; read next full byte
					MOV	AH, 2				; data error
					JC	CAS_READ_EXIT		; exit if error
					STOSB					; write to output buffer
					DEC	BH				; dec block counter
					LOOPNZ CAS_READ_BLOCK_LOOP	; loop if block and byte counters > 0
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 199 - 1


					JZ	CAS_READ_VERIFY_CRC	; if end of requested bytes, jump to CRC
				
				;----------------------------------------------------------------------------;
				; CX is 0, DX > 0 - done reading bytes, skip the remaining padding bytes
				;
					MOV	CL, BH			; CX = remaining bytes to read
				CAS_READ_BLOCK_PAD:
					CALL	CAS_READ_BYTE		; read next full byte
					JC	CAS_READ_ERR		; exit if error
					LOOP	CAS_READ_BLOCK_PAD
				
				;----------------------------------------------------------------------------;
				; Verify CRC - read CRC bytes and compare to known residue
				;
				; https://stackoverflow.com/questions/241605/crc-preset-and-residue
				;
				CAS_READ_VERIFY_CRC:
					CALL	CAS_READ_WORD		; read final two CRC bytes, adding to CRC
					JC	CAS_READ_ERR		; 
					CMP	CAS_CRC, CAS_CRC_RES	; is expected CRC-CCITT residue (01D0Fh)?
					MOV	AH, 1				; CRC error
					JNE	CAS_READ_EXIT
					INC	CX				; any more bytes left to read?
					LOOP	CAS_READ_BLOCKS		; if so, read another block
					MOV	AH, 0				; no error
					JMP	SHORT CAS_READ_EXIT
				
				CAS_READ_BLOCKS ENDP
				
				;----------------------------------------------------------------------------;
				; General / timeout error
				;
				CAS_READ_ERR PROC
					DEC	SI				; dec retry counter
					JNZ	CAS_READ_HEADER_START	; if not 0, retry header read
					MOV	AH, 4				; general/timeout error
				CAS_READ_ERR ENDP
				
				;----------------------------------------------------------------------------;
				; Re-enable interrupts, set return values
				;
				CAS_READ_EXIT:
					POP	DX				; DX = original bytes to read
					SUB	DX, CX			; DX = actual bytes read (subtract bytes remaining)
					MOV	BX, DI			; BX = pointer to end of output buffer
					POP	DI				; restore original DI
					POP	SI
					POP	DS				; discard original DX
					CALL	CAS_TIMER_ON_MOTOR_OFF	; Re-enable timer and motor off
					JMP	INT_15_DONE_NO_DX		; exit without restoring DX
				
				;----------------------------------------------------------------------------;
				; CAS_READ_WORD: read 16 bits, add to working CRC
				;----------------------------------------------------------------------------;
				; Output:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 200 - 1


				;	AX = word read (little endian)
				;	CF if error
				;----------------------------------------------------------------------------;
				CAS_READ_WORD PROC
					CALL	CAS_READ_BYTE
					JC	CAS_READ_BYTE_RET
				
				;----------------------------------------------------------------------------;
				; CAS_READ_BYTE: read 8 bits, add to working CRC
				;----------------------------------------------------------------------------;
				; Output:
				;	AL = byte read
				;	CF if error
				;
				; Clobbers: AH, BL, DX
				;----------------------------------------------------------------------------;
				CAS_READ_BYTE PROC
					PUSH	CX				; save CX
					MOV	CX, 8				; loop 8 bits
				
				;----------------------------------------------------------------------------;
				; CAS_READ_BIT: read 1 bit (2 cycles)
				;----------------------------------------------------------------------------;
				CAS_READ_BIT PROC
				CAS_READ_BIT_LOOP:
					CALL	CAS_READ_CYCLE		; DX = read low cycle length
					STC					; presume failure
					JZ	CAS_READ_BYTE_EXIT	; exit if unable to read
					PUSH	DX				; save low length
					CALL	CAS_READ_CYCLE		; DX = read high cycle length
					POP	AX				; AX = low length
					STC					; presume failure
					JZ	CAS_READ_BYTE_EXIT
					ADD	AX, DX			; AX = full cycle length
				
				;----------------------------------------------------------------------------;
				; Determine bit value based on full cycle duration with 33% tolerance.
				;
				; 1: 2t * 1193180 (Hz) / 1007 Hz = ~ 2368 ticks
				; 0: 2t * 1193180 (Hz) / 2014 Hz = ~ 1184 ticks
				; (Note: raw timer counter readings are doubled, so must be adjusted by 2x)
				;
				; BEEP_1K7 = 1184 ticks = ~1007 Hz
				; BEEP_2K  = 592 ticks  = ~2014 Hz
				;
				; Use median of values to determine maximum length of a '1' bit cycle:
				; 1184 + 592 -> 1776 / 2 = ~ 1344 Hz = ~ 33% tolerance
				;
					MOV	DX, BEEP_1K7 + BEEP_2K	; DX = median cycle length
					CMP	DX, AX			; above or below median freq?
					CALL	CAS_CRC_ADD			; add bit to working CRC
					CMP	DX, AX			; above or below median freq?
					ADC	BL, BL			; add bit to result
					LOOP	CAS_READ_BIT_LOOP
					MOV	AL, BL			; AL = result
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 201 - 1


				CAS_READ_BIT ENDP
					CLC					; no error
				CAS_READ_BYTE_EXIT:
					POP	CX
				CAS_READ_BYTE_RET:
					RET
				
				CAS_READ_BYTE ENDP
				CAS_READ_WORD ENDP
				
				;----------------------------------------------------------------------------;
				; CAS_READ_CYCLE: read 1 cycle
				;----------------------------------------------------------------------------;
				; Time a single cycle of a bit 
				; Output:
				;	AX = counter reading
				;	DX = lendth of cycle in counter ticks
				;	NZ if success
				;	ZF if failure (cycle exceeded maximum possible length)
				;----------------------------------------------------------------------------;
				CAS_READ_CYCLE PROC
					PUSH	CX				; call-preserve CX
					MOV	CX, 100			; timeout value
					MOV	AH, CAS_PREV		; AH last input register value
				CAS_READ_CYCLE_LOOP:
					IN	AL, PPI_C			; read PPI C
					AND	AL, MASK PCCI		; mask only cassette input
					CMP	AL, AH			; ZF if reading is same as last
					LOOPZ	CAS_READ_CYCLE_LOOP	; loop until change or timeout
					MOV	CAS_PREV, AL		; save new input value
					CALL	IO_WAIT_LATCH		; latch and read PIT counter into AX
					MOV	DX, CAS_TIME_CNT		; DX = last counter reading
					SUB	DX, AX			; DX = difference of last and current
					MOV	CAS_TIME_CNT, AX		; update counter read
					TEST	CX, CX			; ZF if timeout, NZ if success
					POP	CX
					RET
				CAS_READ_CYCLE ENDP
				CAS_READ ENDP
				
				INT_15_CASS ENDP
							ENDIF			; ENDIF CASSETTE EQ 1
				INT_15 ENDP
				
				;----------------------------------------------------------------------------;
				;
				; Features not included in 5150/Cassette build go below:
				;
				;----------------------------------------------------------------------------;
				
							IF POST_HD_PARMS EQ 1
				;----------------------------------------------------------------------------;
				; Display Hard Drive Parameters
				;----------------------------------------------------------------------------;
				; Display info for POST in drive DL
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 202 - 1


				;
				; Input:
				;	DL = drive #
				; Output:
				;	AH = status
				;
				; AL clobbered
				;
				; Size: 99 bytes
				;----------------------------------------------------------------------------;
				SHOW_DISK_PARAMS PROC
					PUSH	BX					; call preserve BX and CX
					PUSH	CX
					PUSH	DX					; save drive ID
					PUSH	DX					; save drive ID again
					CALL	GET_DISK_PARAMS			; AL=heads, BX=cyl, CL=sec, DL=drive
					POP	DX					; don't need drive count here
					PUSH	AX					; save return status in AH
					JC	SHOW_DISK_PARAMS_DONE		; exit if error getting drive
				
					SET_SZ_ATTR	 POST_CLR_TXT, 1, 1	; set next char to be text color
					XCHG	AX, DX				; AL = drive ID, DX = # of heads
				
				;----------------------------------------------------------------------------;
				; Display Drive letter
				;
					AND	AL, 0011B				; only drives 0-3
					ADD	AL, 'C'				; convert to drive letter
					CALL	OUT_CHAR
					PUSH	CX					; save sectors/track
					PUSH	DX					; save heads
				
				;----------------------------------------------------------------------------;
				; Display HD size: MiB = C*H*S*512/1024/1024 = C*H*S/2048
				;
					XCHG	AX, DX				; AX = # of heads
					MUL	CL					; AX = heads * sectors
					MUL	BX					; DX:AX = heads * sectors * cyl
					MOV	CX, 1024 * (1024 / 512)		; AX = DX:AX / 2048
					DIV	CX					; (size in MB)
					POST_COL_1	POST_HD, POST_CLR_VAL1, 1 ; write column, SI = POST_MB
					CALL	OUT_DECU				; print size in MB
				
				;----------------------------------------------------------------------------;
				; Display HD geometry
				;
					CALL	OUT_SZ				; 'MB ('
					XCHG	AX, BX				; AX = cylinders, BX = size in MB
					CALL	OUT_DECU_R				; print # cylinders
					CALL	SPACE
					POP	AX					; AX = heads
					CALL	OUT_DECU_R				; print # heads
					CALL	SPACE
					POP	AX					; AX = sectors/track
					CALL	OUT_DECU_R				; print sec/track
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 203 - 1


					MOV	AL, POST_HD_CHS_R			; ')'
					CALL	OUT_CHAR
					POST_COL_END_NL
				SHOW_DISK_PARAMS_DONE:
					POP	AX					; restore return status
					POP	DX
					POP	CX
					POP	BX
					RET
				
				SHOW_DISK_PARAMS ENDP
				
							ENDIF
				
							IF POST_TEST_SEEK EQ 1
				;-------------------------------------------------------------------------
				; FDC_RECAL_SEEK_TEST: Reset, Recalibrate and Seek test a floppy drive at POST
				;-------------------------------------------------------------------------
				; Input:
				;	DL = drive # to test (0 = A:, 1 = B:, etc)
				; Output:
				;	CF if error
				;	Clobbers SI, AX
				;
				; Size: 38 bytes
				;-------------------------------------------------------------------------
				FDC_RECAL_SEEK_TEST PROC
					PUSH	CX
					CALL	FDC_RECAL				; Motor on, recal, DL = drive
					JC	FDC_TEST_DRIVE_EXIT		; exit if error
					JWB	FDC_TEST_DRIVE_DONE		; skip seek tests on warm boot
					IO_DELAY					; short pause before seek, CX=0
					MOV	SI, OFFSET FDC_SEEK_TRACKS
				FDC_TEST_DRIVE_SEEK:
					LODS	BYTE PTR CS:[SI]			; next track to seek
					MOV	CH, AL				; CH = track
					PUSH	CX					; CX clobbered by FDC_SEEK
					CALL	FDC_SEEK				; CH = track, DL = drive
					POP	CX					; restore CX
					JCXZ	FDC_TEST_DRIVE_DONE		; exit if track = 0
					JNC	FDC_TEST_DRIVE_SEEK		; loop unless error
				FDC_TEST_DRIVE_DONE:
							IF IS_TURBO
					MOV	CH, 80H				; longer delay for faster PCs
							ELSE
					MOV	CH, 40H
							ENDIF
					IO_DELAY					; delay between drives
				FDC_TEST_DRIVE_EXIT:
					POP	CX
					RET
				
				;----------------------------------------------------------------------------;
				; Track seek pattern for POST seek test
				;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 204 - 1


				FDC_SEEK_TRACKS	DB	38, 2, 19, 0		; tracks (0 is end)
				
				FDC_RECAL_SEEK_TEST ENDP
							ENDIF
				
							IF IS_TURBO
				;----------------------------------------------------------------------------;
				; Handle Turbo speed mode toggle from INT 09h keyboard interrupt
				;----------------------------------------------------------------------------;
				; Size: 15 bytes
				;----------------------------------------------------------------------------;
				INT_KB_TOGGLE_TURBO PROC
							IF ARCH_TYPE EQ ARCH_TD3300
					IN	AL, TD_TURBO			; read current state
					CMP	AL, MASK TDSS			; turbo on? (NZ = turbo)
							ELSE
								IF ARCH_TYPE EQ ARCH_EHB
					MOV	DX, V40_WCR1			; V40 W/S register
					IN	AL, DX				; FF = slow, 0 = Turbo
					NOT	AL					; flip bits
								ELSE
					IN	AL, PPI_B				; read standard PPI register
								ENDIF			; /IF ARCH_TYPE EQ ARCH_EHB
					TEST	AL, MASK PBTB			; is in Turbo mode?
							ENDIF				; /IF ARCH_TYPE EQ ARCH_TD3300
					JNZ	INT_KB_TURBO_IS_ON		; if so, only one meep since
 F863					CALL	MEEP					;  switching to low speed
				INT_KB_TURBO_IS_ON:
					CALL	MEEP
					JMP	TOGGLE_TURBO
				INT_KB_TOGGLE_TURBO ENDP
							ENDIF
				
						IF RANDOM_TAGLINE EQ 1
				;----------------------------------------------------------------------------;
				; Display BIOS name and random tagline
				;----------------------------------------------------------------------------;
				; String is chosen from low two bits of BP
				; Clobbers: AX
				;----------------------------------------------------------------------------;
				HELLO_RAND_TAGLINE PROC
					PRINT_SZ  TOP_BANNER		; display main banner
					MOV	AX, BP			; get random bits from BP
					POST_FLAG_CLR  GRND		; clear random bits from BP
					AND	AX, MASK GRND		; mask only low 2 bits
					XCHG	AX, SI			; SI = string offset table
					SHL	SI, 1				; word align
					MOV	SI, CS:TAGS[SI]		; SI = chosen tagline offset
					PRINT_SZ  SI			; display tagline
 F863					PRINTLN_SZ  COPYRIGHT		; display copyright message
 F863  53				RET
 F864  51			
 F865  52			;----------------------------------------------------------------------------;
 F866  52			; Three additional random taglines
 F867  E8 EEB4			;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 205 - 1


 F86A  5A			TAG1		DB	'An Energy Star Foe', 0
 F86B  50			TAG2		DB	'Abort, Retry, Succeed', 0
 F86C  72 4F			TAG3		DB	'When life gives you lemonade', 0
				;		DB	'Smoke Edition'
				;		DB	'Reimagined without Ray Tracing', 0
			     1			IFNB	<1>
 F86E  50		     1		PUSH	AX
 F86F  53		     1		PUSH	BX
 F870  51		     1		PUSH	CX
			     1			ENDIF ; IFNB
 F871  B8 0920		     1		MOV	AX, DBW <9, VID_SP>	; AH = write char w/attr, AL = space
			     1			IFDIFI <POST_CLR_TXT>,<BL>	; if ATTR is not BL
 F874  BB 0003		     1		MOV	BX, LOW POST_CLR_TXT		; BH = video page 0, BL = attribute
			     1			ENDIF	; IFDIFI
 F877  B9 0001		     1		MOV	CX, 1			; CX = repeat times
 F87A  CD 10		     1		INT	10H
			     1			IFNB	<1>
 F87C  59		     1		POP	CX
 F87D  5B		     1		POP	BX
 F87E  58		     1		POP	AX
			     1			ENDIF	; IFNB
 F87F  92			;		DB	'Now 97% asbestos-free', 0
				;		DB	'Ought to be enough for anybody', 0
				
				;----------------------------------------------------------------------------;
				; Offset table for taglines
 F880  24 03			;
 F882  04 43			TAGS		DW	OFFSET TAG0, OFFSET TAG1, OFFSET TAG2, OFFSET TAG3
 F884  E8 FEE8			
 F887  51			HELLO_RAND_TAGLINE ENDP
 F888  52					ENDIF
				
				;----------------------------------------------------------------------------;
				; POST Video Adapter Type Strings (2 of 2)
				; 11 bytes
 F889  92			;
 F88A  F6 E1							IF POST_VIDEO_TYPE EQ 1
 F88C  F7 E3			POST_VIDEO		DB	'Video', 0
 F88E  B9 0800							ENDIF
 F891  F7 F1			POST_NONE		DB	'None', 0	; must be after POST_VIDEO
				
			     1			IFNB	<1>
 F893  53		     1		PUSH	BX					; save BX
			     1			ENDIF
			     1			IFNB	<>
			     1		MOV	BX, LOW POST_CLR_VAL1		; BH = 0, BL = attribute
			     1			ELSE
 F894  B3 0A		     1		MOV	BL, LOW POST_CLR_VAL1		; BL = attribute
			     1			ENDIF
 F896  BE E4B4 R	     1		MOV	SI, OFFSET POST_HD
 F899  E8 FDF8		     1		CALL	POST_START_COL_1
			     1			IFNB	<1>
 F89C  5B		     1		POP	BX
			     1			ENDIF
			     1	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 206 - 1


 F89D  E8 FE87			;
				; 252 BYTES HERE / (0 BYTES HERE 5150)
				;
				BYTES_HERE	GFX_CHARSET
				
 F8A0  E8 FE4A			;----------------------------------------------------------------------------;
 F8A3  93			; INT 1F - 8x8 Font bitmaps
 F8A4  E8 FE8A			;----------------------------------------------------------------------------;
 F8A7  E8 FE75			; Font bitmaps from "VileR", (CC BY-SA 4.0)
 F8AA  58			; https://int10h.org/oldschool-pc-fonts/
 F8AB  E8 FE83			;----------------------------------------------------------------------------;
 F8AE  E8 FE6E					ORG 0FA6EH
 F8B1  58			GFX_CHARSET LABEL BYTE
 F8B2  E8 FE7C				DB   000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 00H
 F8B5  B0 29				DB   07EH, 081H, 0A5H, 081H, 0BDH, 099H, 081H, 07EH	; 01H
 F8B7  E8 FEB5				DB   07EH, 0DBH, 0FFH, 0FFH, 0C3H, 0E7H, 07EH, 000H	; 02H
					DB   036H, 07FH, 07FH, 07FH, 03EH, 01CH, 008H, 000H	; 03H
			     1			IFNB	<>
			     1		PUSH	BX					; save BX
			     1			ENDIF
 F8BA  E8 FE10		     1		CALL	POST_END_COL_NL
			     1			IFNB	<>
			     1		POP	BX
			     1			ENDIF
 F8BD					DB   008H, 01CH, 03EH, 07FH, 03EH, 01CH, 008H, 000H	; 04H
 F8BD  58				DB   018H, 03CH, 018H, 066H, 0FFH, 066H, 018H, 03CH	; 05H
 F8BE  5A				DB   008H, 01CH, 03EH, 07FH, 07FH, 03EH, 008H, 01CH	; 06H
 F8BF  59				DB   000H, 000H, 018H, 03CH, 03CH, 018H, 000H, 000H	; 07H
 F8C0  5B				DB   0FFH, 0FFH, 0E7H, 0C3H, 0C3H, 0E7H, 0FFH, 0FFH	; 08H
 F8C1  C3				DB   000H, 03CH, 066H, 042H, 042H, 066H, 03CH, 000H	; 09H
					DB   0FFH, 0C3H, 099H, 0BDH, 0BDH, 099H, 0C3H, 0FFH	; 0AH
 F8C2					DB   03FH, 00DH, 01CH, 03EH, 063H, 063H, 03EH, 000H	; 0BH
					DB   03EH, 063H, 063H, 03EH, 01CH, 07FH, 01CH, 000H	; 0CH
					DB   00EH, 00FH, 00DH, 00DH, 01CH, 07FH, 01CH, 000H	; 0DH
					DB   00FH, 03BH, 037H, 03BH, 033H, 037H, 077H, 070H	; 0EH
					DB   018H, 0DBH, 03CH, 0E7H, 03CH, 0DBH, 018H, 000H	; 0FH
					DB   060H, 078H, 07EH, 07FH, 07EH, 078H, 060H, 000H	; 10H
					DB   003H, 00FH, 03FH, 07FH, 03FH, 00FH, 003H, 000H	; 11H
					DB   018H, 03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H	; 12H
					DB   066H, 066H, 066H, 066H, 066H, 000H, 066H, 000H	; 13H
					DB   03FH, 06DH, 06DH, 03DH, 00DH, 00DH, 00DH, 000H	; 14H
					DB   03FH, 070H, 03EH, 063H, 063H, 03EH, 007H, 07EH	; 15H
					DB   000H, 000H, 000H, 000H, 0FFH, 0FFH, 0FFH, 000H	; 16H
					DB   03CH, 07EH, 018H, 018H, 07EH, 03CH, 018H, 07EH	; 17H
					DB   018H, 03CH, 07EH, 018H, 018H, 018H, 018H, 000H	; 18H
					DB   018H, 018H, 018H, 018H, 07EH, 03CH, 018H, 000H	; 19H
					DB   018H, 00CH, 006H, 07FH, 006H, 00CH, 018H, 000H	; 1AH
					DB   00CH, 018H, 030H, 07FH, 030H, 018H, 00CH, 000H	; 1BH
					DB   000H, 000H, 000H, 060H, 060H, 07FH, 000H, 000H	; 1CH
					DB   000H, 024H, 066H, 0FFH, 066H, 024H, 000H, 000H	; 1DH
					DB   008H, 01CH, 01CH, 03EH, 03EH, 07FH, 07FH, 000H	; 1EH
					DB   07FH, 07FH, 03EH, 03EH, 01CH, 01CH, 008H, 000H	; 1FH
					DB   000H, 000H, 000H, 000H, 000H, 000H, 000H, 000H	; 20H  
					DB   018H, 018H, 018H, 018H, 018H, 000H, 018H, 000H	; 21H !
					DB   033H, 066H, 0CCH, 000H, 000H, 000H, 000H, 000H	; 22H "
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 207 - 1


					DB   036H, 036H, 07FH, 036H, 036H, 07FH, 036H, 036H	; 23H #
					DB   018H, 07EH, 058H, 038H, 01CH, 01AH, 07EH, 018H	; 24H $
					DB   0E3H, 0A6H, 0ECH, 018H, 037H, 065H, 0C7H, 000H	; 25H %
					DB   03CH, 066H, 03CH, 038H, 06DH, 066H, 03DH, 000H	; 26H &
					DB   006H, 00CH, 018H, 000H, 000H, 000H, 000H, 000H	; 27H '
					DB   01CH, 030H, 060H, 060H, 060H, 030H, 01CH, 000H	; 28H (
					DB   038H, 00CH, 006H, 006H, 006H, 00CH, 038H, 000H	; 29H )
					DB   063H, 036H, 01CH, 07FH, 01CH, 036H, 063H, 000H	; 2AH *
					DB   018H, 018H, 018H, 07EH, 018H, 018H, 018H, 000H	; 2BH +
					DB   000H, 000H, 000H, 000H, 000H, 018H, 018H, 030H	; 2CH ,
					DB   000H, 000H, 000H, 07EH, 000H, 000H, 000H, 000H	; 2DH -
					DB   000H, 000H, 000H, 000H, 000H, 018H, 018H, 000H	; 2EH .
					DB   002H, 006H, 00CH, 018H, 030H, 060H, 040H, 000H	; 2FH /
					DB   03EH, 063H, 063H, 06BH, 063H, 063H, 03EH, 000H	; 30H 0
					DB   01CH, 03CH, 00CH, 00CH, 00CH, 00CH, 00CH, 000H	; 31H 1
					DB   03EH, 063H, 003H, 00EH, 038H, 060H, 07FH, 000H	; 32H 2
					DB   07CH, 006H, 006H, 03CH, 006H, 006H, 07CH, 000H	; 33H 3
					DB   00EH, 01EH, 036H, 066H, 07FH, 006H, 006H, 000H	; 34H 4
					DB   07EH, 060H, 07CH, 006H, 006H, 006H, 07CH, 000H	; 35H 5
					DB   01EH, 030H, 060H, 07EH, 063H, 063H, 03EH, 000H	; 36H 6
					DB   07EH, 066H, 00CH, 018H, 030H, 030H, 030H, 000H	; 37H 7
					DB   03EH, 063H, 036H, 01CH, 036H, 063H, 03EH, 000H	; 38H 8
					DB   03EH, 063H, 063H, 03FH, 003H, 006H, 07CH, 000H	; 39H 9
					DB   000H, 000H, 018H, 018H, 000H, 018H, 018H, 000H	; 3AH :
					DB   000H, 000H, 018H, 018H, 000H, 018H, 018H, 030H	; 3BH ;
					DB   00CH, 018H, 030H, 060H, 030H, 018H, 00CH, 000H	; 3CH <
					DB   000H, 000H, 07EH, 000H, 07EH, 000H, 000H, 000H	; 3DH =
					DB   030H, 018H, 00CH, 006H, 00CH, 018H, 030H, 000H	; 3EH >
					DB   03EH, 063H, 006H, 00CH, 00CH, 000H, 00CH, 000H	; 3FH ?
					DB   03EH, 063H, 06FH, 069H, 06FH, 060H, 03FH, 000H	; 40H @
					DB   03CH, 066H, 066H, 07EH, 066H, 066H, 066H, 000H	; 41H A
					DB   07EH, 063H, 063H, 07EH, 063H, 063H, 07EH, 000H	; 42H B
 F8C2					DB   01EH, 033H, 060H, 060H, 060H, 033H, 01EH, 000H	; 43H C
					DB   07CH, 066H, 063H, 063H, 063H, 066H, 07CH, 000H	; 44H D
					DB   07EH, 060H, 060H, 07CH, 060H, 060H, 07EH, 000H	; 45H E
					DB   07EH, 060H, 060H, 07CH, 060H, 060H, 060H, 000H	; 46H F
					DB   01EH, 033H, 063H, 060H, 067H, 033H, 01EH, 000H	; 47H G
					DB   063H, 063H, 063H, 07FH, 063H, 063H, 063H, 000H	; 48H H
					DB   03CH, 018H, 018H, 018H, 018H, 018H, 03CH, 000H	; 49H I
					DB   006H, 006H, 006H, 006H, 066H, 066H, 03CH, 000H	; 4AH J
					DB   063H, 066H, 06CH, 078H, 06CH, 066H, 063H, 000H	; 4BH K
					DB   030H, 030H, 030H, 030H, 030H, 030H, 03FH, 000H	; 4CH L
 F8C2  E4 61				DB   063H, 077H, 07FH, 06BH, 063H, 063H, 063H, 000H	; 4DH M
					DB   063H, 073H, 07BH, 06FH, 067H, 063H, 063H, 000H	; 4EH N
 F8C4  A8 04				DB   03EH, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 4FH O
					DB   07EH, 063H, 063H, 07EH, 060H, 060H, 060H, 000H	; 50H P
 F8C6  75 03				DB   03EH, 063H, 063H, 063H, 07BH, 06EH, 03CH, 007H	; 51H Q
 F8C8  E8 EFFA				DB   07EH, 063H, 063H, 07EH, 06CH, 066H, 063H, 000H	; 52H R
 F8CB					DB   03EH, 063H, 030H, 01CH, 006H, 063H, 03EH, 000H	; 53H S
 F8CB  E8 EFF7				DB   07EH, 018H, 018H, 018H, 018H, 018H, 018H, 000H	; 54H T
 F8CE  E9 E9D4				DB   063H, 063H, 063H, 063H, 063H, 063H, 03EH, 000H	; 55H U
 F8D1					DB   063H, 063H, 063H, 063H, 036H, 01CH, 008H, 000H	; 56H V
					DB   063H, 063H, 063H, 06BH, 06BH, 07FH, 036H, 000H	; 57H W
					DB   063H, 063H, 036H, 01CH, 036H, 063H, 063H, 000H	; 58H X
					DB   063H, 063H, 063H, 03EH, 00CH, 00CH, 00CH, 000H	; 59H Y
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 208 - 1


					DB   07FH, 006H, 00CH, 018H, 030H, 060H, 07FH, 000H	; 5AH Z
					DB   03EH, 030H, 030H, 030H, 030H, 030H, 03EH, 000H	; 5BH [
					DB   040H, 060H, 030H, 018H, 00CH, 006H, 002H, 000H	; 5CH \
					DB   03EH, 006H, 006H, 006H, 006H, 006H, 03EH, 000H	; 5DH ]
					DB   01CH, 036H, 063H, 000H, 000H, 000H, 000H, 000H	; 5EH ^
					DB   000H, 000H, 000H, 000H, 000H, 000H, 000H, 0FFH	; 5FH _
 F8D1					DB   030H, 018H, 00CH, 000H, 000H, 000H, 000H, 000H	; 60H `
					DB   000H, 000H, 03CH, 006H, 03EH, 066H, 03FH, 000H	; 61H a
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <TOP_BANNER>,<SI>			; if SZ is not SI
 F8D1  BE E000 R	     1		MOV	SI, OFFSET TOP_BANNER
			     1			ENDIF
 F8D4  E8 FE16		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 F8D7  8B C5				DB   060H, 060H, 07CH, 066H, 066H, 066H, 07CH, 000H	; 62H b
					DB   000H, 000H, 03EH, 063H, 060H, 060H, 03FH, 000H	; 63H c
			     1				IF CPU_TYPE	EQ CPU_V20
			     1		CLR1_BP   GRND				; V20 only: CLR1 BP, GRND
			     1				ELSE
 F8D9  83 E5 FC		     1		AND	BP, NOT MASK GRND			; Clear flag
			     1				ENDIF
 F8DC  83 E0 03				DB   006H, 006H, 03EH, 066H, 066H, 066H, 03EH, 000H	; 64H d
 F8DF  96				DB   000H, 000H, 03CH, 066H, 07CH, 060H, 03EH, 000H	; 65H e
 F8E0  D1 E6				DB   01EH, 030H, 030H, 07CH, 030H, 030H, 030H, 000H	; 66H f
 F8E2  2E: 8B B4 F937 R			DB   000H, 000H, 03FH, 063H, 063H, 03FH, 003H, 07EH	; 67H g
					DB   060H, 060H, 06CH, 076H, 066H, 066H, 066H, 000H	; 68H h
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <SI>,<SI>			; if SZ is not SI
			     1		MOV	SI, OFFSET SI
			     1			ENDIF
 F8E7  E8 FE03		     1		CALL	OUT_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
					DB   018H, 000H, 038H, 018H, 018H, 018H, 018H, 000H	; 69H i
			     1			IFNB	<>
			     1		PUSH	SI					; save SI
			     1			ENDIF
			     1			IFDIFI <COPYRIGHT>,<SI>			; if SZ is not SI
 F8EA  BE E031 R	     1		MOV	SI, OFFSET COPYRIGHT
			     1			ENDIF
 F8ED  E8 FE23		     1		CALL	OUTLN_SZ
			     1			IFNB	<>
			     1		POP	SI
			     1			ENDIF
 F8F0  C3				DB   006H, 000H, 006H, 006H, 006H, 006H, 066H, 03CH	; 6AH j
					DB   060H, 060H, 066H, 06CH, 078H, 06CH, 066H, 000H	; 6BH k
					DB   018H, 018H, 018H, 018H, 018H, 018H, 00CH, 000H	; 6CH l
					DB   000H, 000H, 076H, 07FH, 06BH, 06BH, 063H, 000H	; 6DH m
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 209 - 1


					DB   000H, 000H, 06CH, 076H, 066H, 066H, 066H, 000H	; 6EH n
 F8F1 41 6E 20 45 6E 65			DB   000H, 000H, 03EH, 063H, 063H, 063H, 03EH, 000H	; 6FH o
       72 67 79 20 53 74
       61 72 20 46 6F 65
       00
 F904 41 62 6F 72 74 2C			DB   000H, 000H, 07CH, 066H, 066H, 07CH, 060H, 060H	; 70H p
       20 52 65 74 72 79
       2C 20 53 75 63 63
       65 65 64 00
 F91A 57 68 65 6E 20 6C			DB   000H, 000H, 03EH, 066H, 066H, 03EH, 006H, 006H	; 71H q
       69 66 65 20 67 69
       76 65 73 20 79 6F
       75 20 6C 65 6D 6F
       6E 61 64 65 00
					DB   000H, 000H, 036H, 03BH, 030H, 030H, 030H, 000H	; 72H r
					DB   000H, 000H, 03EH, 070H, 03CH, 00EH, 07CH, 000H	; 73H s
					DB   018H, 018H, 07EH, 018H, 018H, 018H, 00EH, 000H	; 74H t
					DB   000H, 000H, 066H, 066H, 066H, 066H, 03BH, 000H	; 75H u
					DB   000H, 000H, 066H, 066H, 066H, 03CH, 018H, 000H	; 76H v
					DB   000H, 000H, 063H, 063H, 06BH, 07FH, 036H, 000H	; 77H w
					DB   000H, 000H, 063H, 036H, 01CH, 036H, 063H, 000H	; 78H x
					DB   000H, 000H, 066H, 066H, 066H, 03EH, 006H, 07CH	; 79H y
 F937 E00E R F8F1 R F904 R		DB   000H, 000H, 07EH, 00CH, 018H, 030H, 07EH, 000H	; 7AH z
       F91A R
					DB   00EH, 018H, 018H, 078H, 018H, 018H, 00EH, 000H	; 7BH {
 F93F					DB   018H, 018H, 018H, 000H, 018H, 018H, 018H, 000H	; 7CH |
					DB   070H, 018H, 018H, 00EH, 018H, 018H, 070H, 000H	; 7DH }
					DB   03BH, 06EH, 000H, 000H, 000H, 000H, 000H, 000H	; 7EH ~
					DB   018H, 03CH, 066H, 0C3H, 0C3H, 0FFH, 000H, 000H	; 7FH
				
				;----------------------------------------------------------------------------;
				; INT 1A - System and "Real Time" Clock BIOS Services
				;----------------------------------------------------------------------------;
 F93F 56 69 64 65 6F 00		; INT 1A,0   Read system clock counter
				; INT 1A,1   Set system clock counter
 F945 4E 6F 6E 65 00		;----------------------------------------------------------------------------;
						ORG 0FE6EH
				INT_1A PROC
						ASSUME DS:_BDA
					STI
					SUB	AH, 1 				; is function 0 or 1?
 F94A			     1			LOCAL LBL
			     1	
 = 0124			     1	BYTES_HERE_GFX_CHARSET = GFX_CHARSET-$
			     1	
			     1			IFDEF BYTES_HERE_GFX_CHARSET
			     1			IF2
			     1			IF BYTES_HERE_GFX_CHARSET LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: GFX_CHARSET (BYTES_HERE_GFX_CHARSET)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					JA	INT_1A_EXIT 			; if not, exit
					PUSH	DS
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 210 - 1


					PUSH	SI
					MOV	SI, SEG _BDA 			; get BDA segment
					MOV	DS, SI 				; DS = BDA
					MOV	SI, OFFSET TIMER			; SI = BIOS Timer
					CLI 						; disable interrupts
					JZ	INT_1A_SET 				; AH = 1, jump to Set clock
 FA6E											; AH = 0, fall through to Read
 FA6E  00 00 00 00 00 00	
       00 00
 FA76  7E 81 A5 81 BD 99	;----------------------------------------------------------------------------;
       81 7E
 FA7E  7E DB FF FF C3 E7	; INT 1A,0   Read system clock counter
       7E 00
 FA86  36 7F 7F 7F 3E 1C	;----------------------------------------------------------------------------;
       08 00
 FA8E  08 1C 3E 7F 3E 1C	; Output:
       08 00
 FA96  18 3C 18 66 FF 66	;	AL = midnight flag, 1 if 24 hours passed since reset
       18 3C
 FA9E  08 1C 3E 7F 7F 3E	;	CX = high order word of tick count
       08 1C
 FAA6  00 00 18 3C 3C 18	;	DX = low order word of tick count
       00 00
 FAAE  FF FF E7 C3 C3 E7	;----------------------------------------------------------------------------;
       FF FF
 FAB6  00 3C 66 42 42 66	INT_1A_READ PROC
       3C 00
 FABE  FF C3 99 BD BD 99		LODSW 					; AX = low word of timer
       C3 FF
 FAC6  3F 0D 1C 3E 63 63		XCHG	AX, DX
       3E 00
 FACE  3E 63 63 3E 1C 7F		LODSW 					; AX = high word of timer
       1C 00
 FAD6  0E 0F 0D 0D 1C 7F		XCHG	AX, CX
       1C 00
 FADE  0F 3B 37 3B 33 37		XOR	AX, AX				; reset midnight flag to 0
       77 70
 FAE6  18 DB 3C E7 3C DB		XCHG	AL, [SI]				; AL = BDA flag, BDA = 0
       18 00
 FAEE  60 78 7E 7F 7E 78	INT_1A_DONE:
       60 00
 FAF6  03 0F 3F 7F 3F 0F		STI 						; re-enable interrupts
       03 00
 FAFE  18 3C 7E 18 18 7E		POP	SI
       3C 18
 FB06  66 66 66 66 66 00		POP	DS
       66 00
 FB0E  3F 6D 6D 3D 0D 0D	INT_1A_EXIT:
       0D 00
 FB16  3F 70 3E 63 63 3E		IRET
       07 7E
 FB1E  00 00 00 00 FF FF	INT_1A_READ ENDP
       FF 00
 FB26  3C 7E 18 18 7E 3C	
       18 7E
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 211 - 1


 FB2E  18 3C 7E 18 18 18	;----------------------------------------------------------------------------;
       18 00
 FB36  18 18 18 18 7E 3C	; INT 1A,1   Set system clock counter
       18 00
 FB3E  18 0C 06 7F 06 0C	;----------------------------------------------------------------------------;
       18 00
 FB46  0C 18 30 7F 30 18	; Input:
       0C 00
 FB4E  00 00 00 60 60 7F	;	AH = 0
       00 00
 FB56  00 24 66 FF 66 24	;	CX = high order word of tick count
       00 00
 FB5E  08 1C 1C 3E 3E 7F	;	DX = low order word of tick count
       7F 00
 FB66  7F 7F 3E 3E 1C 1C	;----------------------------------------------------------------------------;
       08 00
 FB6E  00 00 00 00 00 00	INT_1A_SET PROC
       00 00
 FB76  18 18 18 18 18 00		MOV	[SI].LW, DX				; set low word ticks (seconds)
       18 00
 FB7E  33 66 CC 00 00 00		MOV	[SI].HW, CX				; set high word ticks (hours)
       00 00
 FB86  36 36 7F 36 36 7F		MOV	[SI].OF, AH				; reset midnight counter (0)
       36 36
 FB8E  18 7E 58 38 1C 1A		JMP	SHORT INT_1A_DONE
       7E 18
 FB96  E3 A6 EC 18 37 65	INT_1A_SET ENDP
       C7 00
 FB9E  3C 66 3C 38 6D 66	
       3D 00
 FBA6  06 0C 18 00 00 00	INT_1A ENDP
       00 00
 FBAE  1C 30 60 60 60 30	
       1C 00
 FBB6  38 0C 06 06 06 0C	INT_08_PROC PROC
       38 00
 FBBE  63 36 1C 7F 1C 36	;----------------------------------------------------------------------------;
       63 00
 FBC6  18 18 18 7E 18 18	; INT 8 - Floppy Motor shutoff has elapsed - shut off motor
       18 00
 FBCE  00 00 00 00 00 18	;----------------------------------------------------------------------------;
       18 30
 FBD6  00 00 00 7E 00 00	INT_08_MOTOR_OFF:
       00 00
 FBDE  00 00 00 00 00 18		MOV	AL, NOT MASK FMOT			; BDA motor off on all drives
       18 00
 FBE6  02 06 0C 18 30 60		AND	FD_MOTOR_ST, AL			; write to BDA
       40 00
 FBEE  3E 63 63 6B 63 63		XOR	AL, NOT MASK FDSEL		; FDC motor off on all drives
       3E 00
 FBF6  1C 3C 0C 0C 0C 0C		MOV	DX, FDC_CTRL 			; FD control port
       0C 00
 FBFE  3E 63 03 0E 38 60		OUT	DX, AL 				; write to controller
       7F 00
 FC06  7C 06 06 3C 06 06		JMP	SHORT INT_08_INT_1C
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 212 - 1


       7C 00
 FC0E  0E 1E 36 66 7F 06	
       06 00
 FC16  7E 60 7C 06 06 06	;
       7C 00
 FC1E  1E 30 60 7E 63 63	; 0 BYTES HERE
       3E 00
 FC26  7E 66 0C 18 30 30	;
       30 00
 FC2E  3E 63 36 1C 36 63	BYTES_HERE	INT_08
       3E 00
 FC36  3E 63 63 3F 03 06	
       7C 00
 FC3E  00 00 18 18 00 18	;----------------------------------------------------------------------------;
       18 00
 FC46  00 00 18 18 00 18	; INT 8 - Timer
       18 30
 FC4E  0C 18 30 60 30 18	;----------------------------------------------------------------------------;
       0C 00
 FC56  00 00 7E 00 7E 00	; - Run 18.2 times per second by PIT Timer
       00 00
 FC5E  30 18 0C 06 0C 18	; - f = 1193180 / 10000H
       30 00
 FC66  3E 63 06 0C 0C 00	; - Increment 32 bit counter, overflows at 24 hours + 9.67 sec
       0C 00
 FC6E  3E 63 6F 69 6F 60	;	( 3600s/h - 65,536t / ( 1,193,180t/s / 65,536t ) ) * 24h = ~9.67s
       3F 00
 FC76  3C 66 66 7E 66 66	; - Decrement floppy disk motor timeout counter
       66 00
 FC7E  7E 63 63 7E 63 63	;  	  if reaches 0, turns off motor
       7E 00
 FC86  1E 33 60 60 60 33	; - only take jumps on special cases
       1E 00
 FC8E  7C 66 63 63 63 66	;
       7C 00
 FC96  7E 60 60 7C 60 60	; IMPORTANT NOTE: ROM BASIC's INT 1CH handler clobbers DX, so DX
       7E 00
 FC9E  7E 60 60 7C 60 60	; MUST be call-preserved here.
       60 00
 FCA6  1E 33 63 60 67 33	;----------------------------------------------------------------------------;
       1E 00
 FCAE  63 63 63 7F 63 63			ORG 0FEA5H
       63 00
 FCB6  3C 18 18 18 18 18	INT_08 PROC
       3C 00
 FCBE  06 06 06 06 66 66			ASSUME DS:_BDA
       3C 00
 FCC6  63 66 6C 78 6C 66		PUSH	AX 					; save AX, DX, DS and DI
       63 00
 FCCE  30 30 30 30 30 30		PUSH	DX					; workaround ROM BASIC INT 1Ch bug
       3F 00
 FCD6  63 77 7F 6B 63 63		PUSH	DS
       63 00
 FCDE  63 73 7B 6F 67 63		PUSH	DI
       63 00
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 213 - 1


 FCE6  3E 63 63 63 63 63		MOV	AX, SEG _BDA 			; DS = BIOS Data Area
       3E 00
 FCEE  7E 63 63 7E 60 60		MOV	DS, AX
       60 00
 FCF6  3E 63 63 63 7B 6E		CWD						; DX = 0
       3C 07
 FCFE  7E 63 63 7E 6C 66	
       63 00
 FD06  3E 63 30 1C 06 63	;----------------------------------------------------------------------------;
       3E 00
 FD0E  7E 18 18 18 18 18	; Increment Timer
       18 00
 FD16  63 63 63 63 63 63	;
       3E 00
 FD1E  63 63 63 63 36 1C	INT_08_TICK_TIMER:				; Advance the time ticker
       08 00
 FD26  63 63 63 6B 6B 7F		MOV	DI, OFFSET TIMER 			; Low timer at BDA 0040:006C
       36 00
 FD2E  63 63 36 1C 36 63		ADD	[DI].LW, 1				; increment low word
       63 00
 FD36  63 63 63 3E 0C 0C		ADC	[DI].HW, DX				; maybe increment high word
       0C 00
 FD3E  7F 06 0C 18 30 60		CMP	[DI].HW, 24 			; rolled over to next day?
       7F 00
 FD46  3E 30 30 30 30 30		JAE	INT_08_TICK_DAY			; if so, check for day rollover
       3E 00
 FD4E  40 60 30 18 0C 06	
       02 00
 FD56  3E 06 06 06 06 06	;----------------------------------------------------------------------------;
       3E 00
 FD5E  1C 36 63 00 00 00	; Decrement Floppy Motor shutoff counter
       00 00
 FD66  00 00 00 00 00 00	;
       00 FF
 FD6E  30 18 0C 00 00 00	INT_08_FD_MOTOR: 					; Check if there is a motor timeout
       00 00
 FD76  00 00 3C 06 3E 66		STI						; interrupts back on
       3F 00
 FD7E  60 60 7C 66 66 66		DEC	FD_MOTOR_CT 			; increment counter, has reached 0?
       7C 00
 FD86  00 00 3E 63 60 60		JZ	INT_08_MOTOR_OFF			; if so, turn off motor
       3F 00
 FD8E  06 06 3E 66 66 66	
       3E 00
 FD96  00 00 3C 66 7C 60	;----------------------------------------------------------------------------;
       3E 00
 FD9E  1E 30 30 7C 30 30	; Call INT 1CH user vector
       30 00
 FDA6  00 00 3F 63 63 3F	;
       03 7E
 FDAE  60 60 6C 76 66 66	INT_08_INT_1C:
       66 00
 FDB6  18 00 38 18 18 18		INT	1CH					; call user timer hook
       18 00
 FDBE  06 00 06 06 06 06	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 214 - 1


       66 3C
 FDC6  60 60 66 6C 78 6C	;----------------------------------------------------------------------------;
       66 00
 FDCE  18 18 18 18 18 18	; Interrupt Complete - send EOI and return
       0C 00
 FDD6  00 00 76 7F 6B 6B	;
       63 00
 FDDE  00 00 6C 76 66 66	INT_08_EOI:
       66 00
 FDE6  00 00 3E 63 63 63		CLI						; disable interrupts for EOI
       3E 00
 FDEE  00 00 7C 66 66 7C		MOV	AL, OCW2 <001b> 			; End of Interrupt OCW
       60 60
 FDF6  00 00 3E 66 66 3E		OUT	INT_P0, AL				; write EOI to port 0
       06 06
 FDFE  00 00 36 3B 30 30		POP	DI
       30 00
 FE06  00 00 3E 70 3C 0E		POP	DS
       7C 00
 FE0E  18 18 7E 18 18 18		POP	DX					; restore DX
       0E 00
 FE16  00 00 66 66 66 66		POP	AX
       3B 00
 FE1E  00 00 66 66 66 3C		IRET
       18 00
 FE26  00 00 63 63 6B 7F	
       36 00
 FE2E  00 00 63 36 1C 36	;----------------------------------------------------------------------------;
       63 00
 FE36  00 00 66 66 66 3E	; Check if day has rolled over (24H + 9.67s) and reset 32 bit ticker if so
       06 7C
 FE3E  00 00 7E 0C 18 30	;
       7E 00
 FE46  0E 18 18 78 18 18	INT_08_TICK_DAY:
       0E 00
 FE4E  18 18 18 00 18 18		CMP	BYTE PTR [DI].LW, 176 		; has day rolled over?
       18 00
 FE56  70 18 18 0E 18 18		JB	INT_08_FD_MOTOR			; if not, handle FD motor timeout
       70 00
 FE5E  3B 6E 00 00 00 00	
       00 00
 FE66  18 3C 66 C3 C3 FF	;----------------------------------------------------------------------------;
       00 00
				; Timer has rolled over 24 hours - reset counters and increment midnight
				; http://www.ctyme.com/intr/rb-2271.htm
				; http://www.phatcode.net/res/246/files/pctim003.txt
				;
				INT_08_RESET:
					MOV	[DI].LW, DX				; TIMER low word = 0
					MOV	[DI].HW, DX				; TIMER high word = 0
					INC	[DI].OF				; increment TIMER midnight counter
 FE6E					JMP	INT_08_FD_MOTOR			; continue and check motor
				
 FE6E  FB			INT_08 ENDP
 FE6F  80 EC 01			INT_08_PROC ENDP
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 215 - 1


 FE72  77 18			
 FE74  1E			;
 FE75  56			; 3 BYTES HERE
 FE76  BE ---- R		;
 FE79  8E DE			BYTES_HERE	VECTOR_TABLE
 FE7B  BE 006C R		
 FE7E  FA			;----------------------------------------------------------------------------;
 FE7F  74 0C			; Interrupt Vector Table - These fill the IVT prior to bootstrap
				;----------------------------------------------------------------------------;
				; Each ISR is found at the compatibility offset described here:
				; https://www.intel.com/content/dam/doc/reference-guide/efi-compatibility-support-module-specificati
				on-v097.pdf
				;----------------------------------------------------------------------------;
						ORG 0FEE3H
				VECTOR_TABLE PROC
					DW  OFFSET INT_IRQ 		; INT 00
					DW  OFFSET INT_IRQ 		; INT 01
					DW  OFFSET INT_02 		; INT 02	NMI
					DW  OFFSET INT_IRQ 		; INT 03
 FE81					DW  OFFSET INT_IRQ 		; INT 04
 FE81  AD				DW  OFFSET INT_05 		; INT 05	Print Screen
 FE82  92				DW  OFFSET INT_IRQ 		; INT 06
 FE83  AD				DW  OFFSET INT_IRQ 		; INT 07
 FE84  91			
 FE85  33 C0			;----------------------------------------------------------------------------;
 FE87  86 04			; Compatibility fixed ORG for INT 08 - 1Eh
 FE89				;
 FE89  FB					ORG 0FEF3H
 FE8A  5E				DW  OFFSET INT_08 		; INT 08	IRQ0 System timer
 FE8B  1F				DW  OFFSET INT_09_POST		; INT 09	IRQ1 Keyboard IRQ (during POST)
 FE8C					DW  OFFSET INT_IRQ		; INT 0A	IRQ2 Reserved
 FE8C  CF				DW  OFFSET INT_IRQ		; INT 0B	IRQ3 COM2
 FE8D					DW  OFFSET INT_IRQ		; INT 0C	IRQ4 COM1
					DW  OFFSET INT_IRQ		; INT 0D	IRQ5 XT FDC
					DW  OFFSET INT_0E			; INT 0E	IRQ6 Floppy Controller
					DW  OFFSET INT_IRQ		; INT 0F	IRQ7 LPT
					DW  OFFSET INT_10			; INT 10	Video
					DW  OFFSET INT_11			; INT 11	Equipment Check
					DW  OFFSET INT_12			; INT 12	Memory Size
					DW  OFFSET INT_13			; INT 13	Floppy Disk
					DW  OFFSET INT_14			; INT 14	Serial Port
					DW  OFFSET INT_15			; INT 15	System Services
 FE8D					DW  OFFSET INT_16			; INT 16	Keyboard Services
 FE8D  89 14				DW  OFFSET INT_17			; INT 17	Printer
 FE8F  89 4C 02				DW  OFFSET INT_18 		; INT 18	Unbootable/ROM BASIC
 FE92  88 64 04				DW  OFFSET INT_19			; INT 19	Bootstrap
 FE95  EB F2				DW  OFFSET INT_1A			; INT 1A	Time of day
 FE97					DW  OFFSET INT_RET 		; INT 1B	Ctrl Brk
					DW  OFFSET INT_RET 		; INT 1C	Timer Tick
 FE97					DW  OFFSET INT_1D 		; INT 1D	CRTC param table
					DW  OFFSET INT_1E 		; INT 1E	Floppy param table
 FE97				L_VECTOR_TABLE = ($-VECTOR_TABLE)/2	; number of vectors 1Fh (31)
					DW  0 				; INT 1F	8x8 (CP 128-255) custom
										;		 video font table (0000:0000)
				VECTOR_TABLE ENDP
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 216 - 1


 FE97				
 FE97  B0 F0			;----------------------------------------------------------------------------;
 FE99  20 06 003F R		; INT_IRQ - Handle placeholder hardware interrupts
 FE9D  34 FC			;----------------------------------------------------------------------------;
 FE9F  BA 03F2			; ISR for any hardware interrupts that have yet to be vectored.
 FEA2  EE			; Acknowledge interrupt, mask the active one and write last HW interrupt to BDA.
 FEA3  EB 20			;
				; Output:
				;	INT_LAST = last interrupt or 0FFh if non-hardware/unknown interrupt
				;----------------------------------------------------------------------------;
						ORG 0FF23H
				INT_IRQ PROC
 FEA5			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_08 = INT_08-$
			     1	
			     1			IFDEF BYTES_HERE_INT_08
			     1			IF2
			     1			IF BYTES_HERE_INT_08 LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_08 (BYTES_HERE_INT_08)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
							ASSUME DS:_BDA
					PUSH	AX
					PUSH	DS				; save DS
					MOV	AL, OCW3 <,,,,11b> 	; AL = OCW3 Read ISR reg on next pulse
					OUT	INT_P0, AL			; write to PIC A0 (20h)
					MOV	AX, SEG _BDA 		; AH = 0, delay for PIC at least 1 clock pulse
					MOV	DS, AX			; set DS to BDA
					IN	AL, INT_P0			; get current In-Service Register (ISR)
					DEC	AX				; if ISR is zero there is no active hardware int
					JL	INT_IRQ_DONE		; if no active int, exit with INT_LAST = FFh
					INC	AX				; otherwise INT_LAST = active interrupt level
					MOV	AH, AL 			; restore ISR and save to AH
					IN	AL, INT_IMR			; get current Interrupt Mask Register (IMR)
					OR	AL, AH 			; mask active interrupt
					OUT	INT_IMR, AL			; write new IMR to PIC A1 (21h)
					MOV	AL, OCW2 <001b> 		; AL = OCW2 End of Interrupt
 FEA5					OUT	INT_P0, AL			; write EOI to PIC A0 (20h)
				INT_IRQ_DONE:
 FEA5  50				MOV	INT_LAST, AH	 	; save last interrupt to BDA
 FEA6  52				POP	DS
 FEA7  1E				POP	AX
 FEA8  57				IRET
 FEA9  B8 ---- R		
 FEAC  8E D8			INT_IRQ ENDP
 FEAE  99			
				;----------------------------------------------------------------------------;
				; Check if AL is alpha char [A-Za-z]
				;----------------------------------------------------------------------------;
				; Input:
 FEAF				;	AL = char 'A'-'Z' or 'a'-'z'
 FEAF  BF 006C R		; Output:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 217 - 1


 FEB2  83 05 01			;	CF = 0 (NC) if alpha, CF = 1 (CY) if not alpha
 FEB5  11 55 02			; Size: 12 bytes
 FEB8  83 7D 02 18		;----------------------------------------------------------------------------;
 FEBC  73 13			IS_ALPHA PROC
					PUSH	AX
					OR	AL, 'a'-'A'			; lowercase it for comparison
					CMP	AL, 'a'			; is less than 'a'?
					JB	IS_ALPHA_DONE		; CF if not alpha
 FEBE					CMP	AL, 'z'+1			; is greater than 'z'?
 FEBE  FB				CMC					; CF if not alpha
 FEBF  FE 0E 0040 R		IS_ALPHA_DONE:
 FEC3  74 D2				POP	AX
					RET
				IS_ALPHA ENDP
				
				; 0 BYTES HERE
 FEC5				
 FEC5  CD 1C			BYTES_HERE	INT_RET
				
				;----------------------------------------------------------------------------;
				; INT_RET - Handle placeholder software interrupts
				;----------------------------------------------------------------------------;
 FEC7						ORG 0FF53H
 FEC7  FA			INT_RET PROC
 FEC8  B0 20				IRET
 FECA  E6 20			INT_RET ENDP
 FECC  5F			
 FECD  1F			;----------------------------------------------------------------------------;
 FECE  5A			; INT 5 - Print Screen
 FECF  58			;----------------------------------------------------------------------------;
 FED0  CF			; Print the contents of the current screen/page.
				;
				; Output:
				; - Screen contents to PRN (BIOS printer 0)
				; - Status to BDA 50:0H:
 FED1				;	00	Print screen has not been called, or upon return
 FED1  80 3D B0			;			from a call there were no errors
 FED4  72 E8			;	01	Print screen is already in progress
				;	FF	Error encountered during printing
				;----------------------------------------------------------------------------;
				; Things you must do:
				; 	1. Check status (BDA 50:0H) to ensure PrtScn is not already in progress.
				;	2. Set working status to 1.
				;	3. Get the current screen size (columns) and video page.
 FED6				;	4. Save the current cursor position, then move to the top.
 FED6  89 15			;	5. Read the char at that position and send to printer.
 FED8  89 55 02			;	6. If last column reached, move screen cursor to start of next line
 FEDB  FE 45 04			;		and send CR and LF to printer to start new line.
 FEDE  EB DE			;	7. Keep looping until past the last row (always 25)
				;	8. Restore screen cursor position
 FEE0				;	9. Set BDA status to either success (0) or error (-1)
 FEE0				;----------------------------------------------------------------------------;
						ORG 0FF54H
				INT_05 PROC
							ASSUME DS:_BDA
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 218 - 1


					CLD						; string direction forward
					PUSH	AX
 FEE0			     1			LOCAL LBL
			     1	
 = 0003			     1	BYTES_HERE_VECTOR_TABLE = VECTOR_TABLE-$
			     1	
			     1			IFDEF BYTES_HERE_VECTOR_TABLE
			     1			IF2
			     1			IF BYTES_HERE_VECTOR_TABLE LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: VECTOR_TABLE (BYTES_HERE_VECTOR_TABLE)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
					PUSH	DI
					PUSH	ES
					MOV	DI, SEG _DOS_DAT
					MOV	ES, DI				; ES = seg 50H
					XOR	DI, DI				; DI = PTRSCN_ST (offset 00H)
					MOV	AL, 1					; print status = 1 (in progress)
					SCASB						; is in progress already?
					JZ	INT_05_EXIT				; if so, exit
 FEE3					STI						; Interrupts should be okay now
 FEE3  FF23 R				DEC	DI					; undo earlier SCASB increment
 FEE5  FF23 R				STOSB						; update status to 1
 FEE7  E2C3 R				PUSH	BX					; preserve working registers
 FEE9  FF23 R				PUSH	CX
 FEEB  FF23 R				PUSH	DX
 FEED  FF54 R				CALL	LPT_CRLF				; start print head on new line
 FEEF  FF23 R				JC	INT_05_DONE				; exit if print error
 FEF1  FF23 R				MOV	AH, 0FH				; get video state (columns)
					INT	10H					; AH = screen columns, BH = page
					MOV	BL, AH				; BL = screen columns
					DEC	BX					; fix 0 index
					MOV	AH, 3					; get cursor position
					INT	10H					; DH = cursor row, DL = cursor column
 FEF3  FEA5 R				PUSH	DX					; save starting cursor position
 FEF5  E934 R				XOR	DX, DX				; start position at row 0, col 0
 FEF7  FF23 R			INT_05_LOOP_1:
 FEF9  FF23 R				MOV	AH, 2					; set cursor position
 FEFB  FF23 R				INT	10H					; set cursor to DH=row, DL=col
 FEFD  FF23 R				MOV	AH, 8					; get char/attr at current position
 FEFF  EF57 R				INT	10H					; AL = char at current position
 FF01  FF23 R				CALL	LPT_CHAR				; print char in AL
 FF03  F065 R				JC	INT_05_DONE				; exit if print error
 FF05  F84D R				CMP	BL, DL				; end of screen cols?
 FF07  F841 R				JNE	INT_05_NEXT_COL			; jump if not
 FF09  EC59 R				MOV	DL, -1				; else move to first col and next row
 FF0B  E739 R				CALL	LPT_CRLF				; CR and LF to PRN
 FF0D  F859 R				JC	INT_05_DONE				; exit if print error
 FF0F  E82E R			INT_05_NEXT_COL:
 FF11  EFD2 R				INC	DX					; move to next column (and maybe row)
 FF13  E459 R				CMP	DH, VID_DEF_ROWS+1		; end of screen rows?
 FF15  E6F2 R				JNE	INT_05_LOOP_1			; loop while not last row, CF=0 when done
 FF17  FE6E R			INT_05_DONE:
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 219 - 1


 FF19  FF53 R				SBB	AL, AL				; print status: AL = 0 if NC, AL = -1 if CF
 FF1B  FF53 R				CLI						; make sure this completes w/o other INTs
 FF1D  F0A4 R				DEC	DI					; undo earlier STOSB increment
 FF1F  EFC7 R				STOSB						; update BDA status
 FF21 = 001F				POP	DX					; restore starting cursor position
 FF21  0000				MOV	AH, 2					; set cursor position in DH/DL
					INT	10H
 FF23					POP	DX
					POP	CX
					POP	BX
				INT_05_EXIT:
					POP	ES
					POP	DI
					POP	AX
					IRET
				
				;----------------------------------------------------------------------------;
				; LPT_CRLF - Write CR and LF to PRN
				;----------------------------------------------------------------------------;
 FF23				LPT_CRLF PROC
					MOV	AL, CR
 FF23  50				CALL	LPT_CHAR
 FF24  1E				;JC	LPT_CHAR_EXIT			; exit if print error
 FF25  B0 0B			
 FF27  E6 20			;----------------------------------------------------------------------------;
 FF29  B8 ---- R		; LPT_LF - Write LF to PRN
 FF2C  8E D8			;----------------------------------------------------------------------------;
 FF2E  E4 20			LPT_LF PROC
 FF30  48				MOV	AL, LF
 FF31  7C 0D			
 FF33  40			;----------------------------------------------------------------------------;
 FF34  8A E0			; LPT_CHAR - Write a char to PRN
 FF36  E4 21			;----------------------------------------------------------------------------;
 FF38  0A C4			; Input:
 FF3A  E6 21			;	AL = char to print
 FF3C  B0 20			; Output:
 FF3E  E6 20			;	CF = 1 (CY) if timeout
 FF40				;
 FF40  88 26 006B R		; AL clobbered if null
 FF44  1F			;----------------------------------------------------------------------------;
 FF45  58			LPT_CHAR PROC
 FF46  CF				PUSH	DX
					MOV	AH, 0					; Print Character function
 FF47					CWD						; DX = printer 0 (PRN)
					TEST	AL, AL				; was input char a null?
					JNZ	LPT_CHAR_OUT			; jump if not
					MOV	AL, ' '				; if so, use a space
				LPT_CHAR_OUT:
					INT	17H					; Print AL to PRN0
					SHR	AH, 1					; CF if timeout
					POP	DX
				LPT_CHAR_EXIT:
					RET
				LPT_CHAR ENDP
 FF47				LPT_LF ENDP
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 220 - 1


 FF47  50			LPT_CRLF ENDP
 FF48  0C 20			
 FF4A  3C 61			INT_05 ENDP
 FF4C  72 03			
 FF4E  3C 7B			;----------------------------------------------------------------------------;
 FF50  F5			; Check if a 8087 FPU is present and perform quick tests
 FF51				;----------------------------------------------------------------------------;
 FF51  58			; Input:
 FF52  C3			;	DI = any non-zero value
 FF53				; Output:
				;	ZF = 0 if no FPU, ZF = 1 if present
				;
				; Clobbers: BX, DI
				;
 FF53			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_INT_RET = INT_RET-$
			     1	
			     1			IFDEF BYTES_HERE_INT_RET
			     1			IF2
			     1			IF BYTES_HERE_INT_RET LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: INT_RET (BYTES_HERE_INT_RET)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
				; Sources:
				;   https://retrocomputing.stackexchange.com/questions/16529/detecting-the-external-x87-fpu
				;   Intel(R) App Note AP-485 "Intel(R) Processor Identification and the CPUID Instruction"
				;----------------------------------------------------------------------------;
				HAS_FPU PROC
 FF53					XCHG	AX, DI			; save AX
 FF53  CF				FNINIT 				; reset FPU, no wait
 FF54				
				;----------------------------------------------------------------------------;
				; Test Status Word
				;
				FPU_TEST_SW:
					PUSH	AX 				; init temp word to non-zero
					MOV	BX, SP	 		; use stack memory
					FNSTSW WORD PTR SS:[BX]		; store status word
					NOP					; delay to allow FPU to complete
					POP	AX 				; AX = control word if FNSTCW executed
					TEST	AL, AL 			; check exception flags
					JNZ	FPU_TEST_DONE		; if flags = 00, FPU is present
				
				;----------------------------------------------------------------------------;
				; Test Control Word
				;
				FPU_TEST_CW:
					PUSH	AX
					FNSTCW WORD PTR SS:[BX]		; store control word
					NOP					; delay to allow FPU to complete
					POP	AX 				; AX = control word
					XOR	AX, 0103FH 			; isolate interesting status flags
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 221 - 1


					AND	AX, 03FH 			; check for 8087 "signature"
										; ZF = 0 if no FPU
				FPU_TEST_DONE:
					XCHG	AX, DI			; restore AX
					RET
				HAS_FPU ENDP
 FF54				
				;
 FF54  FC			; 0 BYTES HERE
 FF55  50			;
 FF56  57			BYTES_HERE	VER
 FF57  06			
 FF58  BF ---- R		;-------------------------------------------------------------------------
 FF5B  8E C7			; Version and Build Strings
 FF5D  33 FF			;-------------------------------------------------------------------------
 FF5F  B0 01					ORG	0FFE0H
 FF61  AE			VER 	DB	'Ver: '
 FF62  74 44				DB	VER_NUM
 FF64  FB				DB	'-'				; Show CPU type and
 FF65  4F				DB	CPU_TYPE			; architecture target
 FF66  AA				DB	ARCH_TYPE
 FF67  53						IF ARCH_SUB_TYPE NE 0
 FF68  51				DB	ARCH_SUB_TYPE		; add optional ARCH sub-identifier
 FF69  52						ENDIF
 FF6A  E8 003F				DB	' '				; space before date
 FF6D  72 2C				DB	0
 FF6F  B4 0F			
 FF71  CD 10			;
 FF73  8A DC			; 0 BYTES HERE
 FF75  4B			;
 FF76  B4 03			BYTES_HERE	POWER_ON
 FF78  CD 10			
 FF7A  52			BIOS		ENDS
 FF7B  33 D2			
 FF7D				;============================================================================;
 FF7D  B4 02			;
 FF7F  CD 10			;				* * *    END OF BIOS   * * *
 FF81  B4 08			;
 FF83  CD 10			;============================================================================;
 FF85  E8 002B			
 FF88  72 11			END
 FF8A  38 D3			
 FF8C  75 07			;----------------------------------------------------------------------------;
 FF8E  B2 FF			; Text Auto-Formatting:
 FF90  E8 0019			;----------------------------------------------------------------------------;
 FF93  72 06			; Sublime Text syntax:
 FF95				; {
 FF95  42			; 	"tab_completion": false,
 FF96  80 FE 19			;	"auto_complete": false,
 FF99  75 E2			;	"tab_size": 6,
 FF9B				; }
 FF9B  1A C0			;----------------------------------------------------------------------------;
 FF9D  FA			;
 FF9E  4F			; Modeline magic for various editors
 FF9F  AA			;
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 222 - 1


 FFA0  5A			; /* vim: set tabstop=6:softtabstop=6:shiftwidth=6:noexpandtab */
 FFA1  B4 02			; # sublime: tab_completion false; auto_complete false; tab_size 6
 FFA3  CD 10
 FFA5  5A
 FFA6  59
 FFA7  5B
 FFA8
 FFA8  07
 FFA9  5F
 FFAA  58
 FFAB  CF
 FFAC
 FFAC  B0 0D
 FFAE  E8 0002
 FFB1
 FFB1  B0 0A
 FFB3
 FFB3  52
 FFB4  B4 00
 FFB6  99
 FFB7  84 C0
 FFB9  75 02
 FFBB  B0 20
 FFBD
 FFBD  CD 17
 FFBF  D0 EC
 FFC1  5A
 FFC2
 FFC2  C3
 FFC3
 FFC3
 FFC3
 FFC3
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 223 - 1


 FFC3
 FFC3  97
 FFC4  DB E3
 FFC6
 FFC6  50
 FFC7  8B DC
 FFC9  36: DD 3F
 FFCC  90
 FFCD  58
 FFCE  84 C0
 FFD0  75 0C
 FFD2
 FFD2  50
 FFD3  36: D9 3F
 FFD6  90
 FFD7  58
 FFD8  35 103F
 FFDB  83 E0 3F
 FFDE
 FFDE  97
 FFDF  C3
 FFE0
 FFE0			     1			LOCAL LBL
			     1	
 = 0000			     1	BYTES_HERE_VER = VER-$
			     1	
			     1			IFDEF BYTES_HERE_VER
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 224 - 1


			     1			IF2
			     1			IF BYTES_HERE_VER LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: VER (BYTES_HERE_VER)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
 FFE0 56 65 72 3A 20
 FFE5  30 2E 32 2E 34
 FFEA  2D
 FFEB  38
 FFEC  54
 FFED  20
 FFEE  00
 FFEF			     1			LOCAL LBL
			     1	
 = 0001			     1	BYTES_HERE_POWER_ON = POWER_ON-$
			     1	
			     1			IFDEF BYTES_HERE_POWER_ON
			     1			IF2
			     1			IF BYTES_HERE_POWER_ON LT 0
			     1			.ERR2
			     1		%OUT WARNING: Out of space at: POWER_ON (BYTES_HERE_POWER_ON)
			     1			ENDIF
			     1			ENDIF
			     1			ENDIF
 FFEF
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Page 225 - 1


Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 226 - 1




Macros:

                N a m e                 Type

BEEP_OFF . . . . . . . . . . . .	Proc
BEEP_ON  . . . . . . . . . . . .	Proc
BYTES_HERE . . . . . . . . . . .	Proc
CALL_NS  . . . . . . . . . . . .	Proc
CGA_WAIT_SYNC  . . . . . . . . .	Proc
CLR1_BP  . . . . . . . . . . . .	Proc
GET_EFLAG  . . . . . . . . . . .	Proc
IO_DELAY_LONG  . . . . . . . . .	Proc
IO_DELAY_SHORT . . . . . . . . .	Proc
IO_DELAY . . . . . . . . . . . .	Proc
IRET_F . . . . . . . . . . . . .	Proc
JNWB . . . . . . . . . . . . . .	Proc
JWB  . . . . . . . . . . . . . .	Proc
NOT1_BP  . . . . . . . . . . . .	Proc
POST_COL_1 . . . . . . . . . . .	Proc
POST_COL_2 . . . . . . . . . . .	Proc
POST_COL_END_NL  . . . . . . . .	Proc
POST_COL_END . . . . . . . . . .	Proc
POST_FLAG_CLR  . . . . . . . . .	Proc
POST_FLAG_FLIP . . . . . . . . .	Proc
POST_FLAG_SET  . . . . . . . . .	Proc
POST_FLAG_TEST . . . . . . . . .	Proc
PRINTLN_SZ . . . . . . . . . . .	Proc
PRINT_SZ . . . . . . . . . . . .	Proc
SET1_BP  . . . . . . . . . . . .	Proc
SET_EFLAG  . . . . . . . . . . .	Proc
SET_GFLAG  . . . . . . . . . . .	Proc
SET_SZ_ATTR  . . . . . . . . . .	Proc
TEST1_BP . . . . . . . . . . . .	Proc
TEST_EFLAG . . . . . . . . . . .	Proc
TEST_GFLAG . . . . . . . . . . .	Proc
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 227 - 1




Structures and Unions:

                N a m e                  Size
                                         Offset      Type

CRTC . . . . . . . . . . . . . .	 0010
  H_TC . . . . . . . . . . . . .	 0000	     Byte
  H_CL . . . . . . . . . . . . .	 0001	     Byte
  H_SP . . . . . . . . . . . . .	 0002	     Byte
  H_SW . . . . . . . . . . . . .	 0003	     Byte
  V_TL . . . . . . . . . . . . .	 0004	     Byte
  V_SL . . . . . . . . . . . . .	 0005	     Byte
  V_DR . . . . . . . . . . . . .	 0006	     Byte
  V_SP . . . . . . . . . . . . .	 0007	     Byte
  IL . . . . . . . . . . . . . .	 0008	     Byte
  MSL  . . . . . . . . . . . . .	 0009	     Byte
  CSL  . . . . . . . . . . . . .	 000A	     Byte
  CEL  . . . . . . . . . . . . .	 000B	     Byte
  SA_H . . . . . . . . . . . . .	 000C	     Byte
  SA_L . . . . . . . . . . . . .	 000D	     Byte
  CA_H . . . . . . . . . . . . .	 000E	     Byte
  CA_L . . . . . . . . . . . . .	 000F	     Byte
DBT  . . . . . . . . . . . . . .	 000B
  SRT  . . . . . . . . . . . . .	 0000	     Byte
  HLT_ND . . . . . . . . . . . .	 0001	     Byte
  FMCT . . . . . . . . . . . . .	 0002	     Byte
  FBPS . . . . . . . . . . . . .	 0003	     Byte
  SPT  . . . . . . . . . . . . .	 0004	     Byte
  SGAP . . . . . . . . . . . . .	 0005	     Byte
  LSEC . . . . . . . . . . . . .	 0006	     Byte
  FGAP . . . . . . . . . . . . .	 0007	     Byte
  FFILL  . . . . . . . . . . . .	 0008	     Byte
  HDST . . . . . . . . . . . . .	 0009	     Byte
  FMST . . . . . . . . . . . . .	 000A	     Byte
FDC_CSB  . . . . . . . . . . . .	 0007
  SB0  . . . . . . . . . . . . .	 0000	     Byte
  SB1  . . . . . . . . . . . . .	 0001	     Byte
  SB2  . . . . . . . . . . . . .	 0002	     Byte
  CYL  . . . . . . . . . . . . .	 0003	     Byte
  HEAD . . . . . . . . . . . . .	 0004	     Byte
  SEC  . . . . . . . . . . . . .	 0005	     Byte
  BPS  . . . . . . . . . . . . .	 0006	     Byte
TIMER_C  . . . . . . . . . . . .	 0005
  LW . . . . . . . . . . . . . .	 0000	     Word
  HW . . . . . . . . . . . . . .	 0002	     Word
  OF . . . . . . . . . . . . . .	 0004	     Byte
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 228 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

BEEP_SL  . . . . . . . . . . . .	 0008	   0002
  BEEP_S . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  BEEP_L . . . . . . . . . . . .	 0000	   0004	     000F     ?
COM_LCR  . . . . . . . . . . . .	 0008	   0007
  DLAB . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  LCBK . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  LCPD . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  LCEPS  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LCPEN  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LCSB . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  LCWLS  . . . . . . . . . . . .	 0000	   0002	     0003     ?
COM_LSR  . . . . . . . . . . . .	 0008	   0008
  LSX  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  TSRE . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  THRE . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  LBI  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LFE  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LPE  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  LOE  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  LDR  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
COM_MCR  . . . . . . . . . . . .	 0008	   0006
  MCRX . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  MCLB . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  MCO2 . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  MCO1 . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  RTS  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DTR  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
COM_MSR  . . . . . . . . . . . .	 0008	   0008
  MLSD . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  MRI  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  MDSR . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  MCTS . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  DDCD . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DRI  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DDSR . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DCTS . . . . . . . . . . . . .	 0000	   0001	     0001     ?
DBW  . . . . . . . . . . . . . .	 0010	   0002
  HWB  . . . . . . . . . . . . .	 0008	   0008	     FF00     ?
  LWB  . . . . . . . . . . . . .	 0000	   0008	     00FF     ?
DMA_CR . . . . . . . . . . . . .	 0008	   0008
  DACK . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  DREQ . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  DWS  . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  DPRI . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  DTIM . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  DDIS . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  DHLD . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  DM2M . . . . . . . . . . . . .	 0000	   0001	     0001     ?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 229 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

DMA_MR . . . . . . . . . . . . .	 0008	   0005
  DMM  . . . . . . . . . . . . .	 0006	   0002	     00C0      0001
  DMINC  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  DMAI . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  DMOP . . . . . . . . . . . . .	 0002	   0002	     000C     ?
  DMCH . . . . . . . . . . . . .	 0000	   0002	     0003     ?
DMA_SMR  . . . . . . . . . . . .	 0008	   0002
  SMCLR  . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  SMCH . . . . . . . . . . . . .	 0000	   0002	     0003     ?
DMA_SR . . . . . . . . . . . . .	 0008	   0008
  CR3  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  CR2  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  CR1  . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  CR0  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  TC3  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  TC2  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  TC1  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  TC0  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
DNB  . . . . . . . . . . . . . .	 0008	   0002
  HBN  . . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  LBN  . . . . . . . . . . . . .	 0000	   0004	     000F     ?
EFLAGS86 . . . . . . . . . . . .	 0008	   0008
  FSF  . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FZF  . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FR1  . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FAF  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FR2  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FPF  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FR3  . . . . . . . . . . . . .	 0001	   0001	     0002      0001
  FCF  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
EQFLAGS  . . . . . . . . . . . .	 0010	   000A
  LPT  . . . . . . . . . . . . .	 000E	   0002	     C000     ?
  X1 . . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  GAM  . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  COM  . . . . . . . . . . . . .	 0009	   0003	     0E00     ?
  DMA  . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  FLP  . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  VIDM . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  MBRAM  . . . . . . . . . . . .	 0002	   0002	     000C      0003
  FPU  . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  IPL  . . . . . . . . . . . . .	 0000	   0001	     0001      0000
FDC_CB . . . . . . . . . . . . .	 0008	   0004
  FC0MT  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FC0MF  . . . . . . . . . . . .	 0006	   0001	     0040      0001
  FC0SK  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FC0CMD . . . . . . . . . . . .	 0000	   0005	     001F     ?
FDC_DOR  . . . . . . . . . . . .	 0008	   0007
  FDMD . . . . . . . . . . . . .	 0007	   0001	     0080     ?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 230 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  FDMC . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FDMB . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FDMA . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FDDMA  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FDCEN  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FDSEL  . . . . . . . . . . . .	 0000	   0002	     0003     ?
FDC_MF . . . . . . . . . . . . .	 0008	   0003
  FWRT . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FMTBD  . . . . . . . . . . . .	 0004	   0003	     0070     ?
  FMOT . . . . . . . . . . . . .	 0000	   0004	     000F     ?
FDC_MODE . . . . . . . . . . . .	 0008	   0008
  FM1X . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FM1D . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FM1M . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FM18 . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FM0X . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FM0D . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FM0M . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  FM08 . . . . . . . . . . . . .	 0000	   0001	     0001     ?
FDC_MSR  . . . . . . . . . . . .	 0008	   0008
  FDRR . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FIOD . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  FDND . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FDRW . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  F3SK . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  F2SK . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  F1SK . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  F0SK . . . . . . . . . . . . .	 0000	   0001	     0001     ?
FDC_R0 . . . . . . . . . . . . .	 0008	   0006
  FR0CS  . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  FR0SK  . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FR0CHK . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FR0NR  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FR0HD  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FR0DRV . . . . . . . . . . . .	 0000	   0002	     0003     ?
FDC_SF . . . . . . . . . . . . .	 0008	   0006
  FWIF . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  FSTBD  . . . . . . . . . . . .	 0004	   0003	     0070     ?
  FCAL3  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FCAL2  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  FCAL1  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  FCAL0  . . . . . . . . . . . .	 0000	   0001	     0001     ?
FDC_STATE  . . . . . . . . . . .	 0008	   0005
  FSR  . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  FDDS . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  FSE  . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  FDX  . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  FSD  . . . . . . . . . . . . .	 0000	   0003	     0007     ?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 231 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

GFLAGS . . . . . . . . . . . . .	 0008	   0004
  GTBD1  . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  TURBO  . . . . . . . . . . . .	 0003	   0001	     0008     ?
  V20  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  GTBD2  . . . . . . . . . . . .	 0000	   0002	     0003     ?
ICW1 . . . . . . . . . . . . . .	 0008	   0005
  D4 . . . . . . . . . . . . . .	 0004	   0004	     00F0      0001
  LTIM . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  ADI  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  SNGL . . . . . . . . . . . . .	 0001	   0001	     0002      0001
  IC4  . . . . . . . . . . . . .	 0000	   0001	     0001      0001
ICW2 . . . . . . . . . . . . . .	 0008	   0002
  ICW2IVA  . . . . . . . . . . .	 0003	   0005	     00F8     ?
  ICW2X  . . . . . . . . . . . .	 0000	   0003	     0007      0000
ICW4 . . . . . . . . . . . . . .	 0008	   0004
  SFNM . . . . . . . . . . . . .	 0004	   0004	     00F0      0000
  ICWBUF . . . . . . . . . . . .	 0002	   0002	     000C     ?
  AEOI . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  uPM  . . . . . . . . . . . . .	 0000	   0001	     0001     ?
KBFLAGS1 . . . . . . . . . . . .	 0008	   0008
  K1IN . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  K1CL . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  K1NL . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  K1SL . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  K1AL . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  K1CT . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  K1LS . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  K1RS . . . . . . . . . . . . .	 0000	   0001	     0001     ?
KBFLAGS2 . . . . . . . . . . . .	 0008	   0008
  K2IN . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  K2CL . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  K2NL . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  K2SL . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  K2PA . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  K2SY . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  K2LA . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  K2LC . . . . . . . . . . . . .	 0000	   0001	     0001     ?
NMI  . . . . . . . . . . . . . .	 0008	   0002
  NMIE . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  NMIX . . . . . . . . . . . . .	 0000	   0007	     007F     ?
OCW1 . . . . . . . . . . . . . .	 0008	   0008
  IRQ7 . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  IRQ6 . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  IRQ5 . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  IRQ4 . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  IRQ3 . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  IRQ2 . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  IRQ1 . . . . . . . . . . . . .	 0001	   0001	     0002     ?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 232 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  IRQ0 . . . . . . . . . . . . .	 0000	   0001	     0001     ?
OCW2 . . . . . . . . . . . . . .	 0008	   0003
  O2CMD  . . . . . . . . . . . .	 0005	   0003	     00E0      0001
  O2X  . . . . . . . . . . . . .	 0003	   0002	     0018     ?
  O2L  . . . . . . . . . . . . .	 0000	   0003	     0007     ?
OCW3 . . . . . . . . . . . . . .	 0008	   0005
  O3D7 . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  ESMM . . . . . . . . . . . . .	 0005	   0002	     0060     ?
  O3D3 . . . . . . . . . . . . .	 0003	   0002	     0018      0001
  O3P  . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  O3RR . . . . . . . . . . . . .	 0000	   0002	     0003     ?
PFLAGS . . . . . . . . . . . . .	 0010	   000A
  WARM . . . . . . . . . . . . .	 000F	   0001	     8000     ?
  PKI  . . . . . . . . . . . . .	 000E	   0001	     4000     ?
  PKEY . . . . . . . . . . . . .	 000D	   0001	     2000     ?
  PFDC . . . . . . . . . . . . .	 000C	   0001	     1000     ?
  PFSK . . . . . . . . . . . . .	 000B	   0001	     0800     ?
  PDMA . . . . . . . . . . . . .	 000A	   0001	     0400     ?
  PMEM . . . . . . . . . . . . .	 0009	   0001	     0200     ?
  PFXX . . . . . . . . . . . . .	 0008	   0001	     0100     ?
  PTBD . . . . . . . . . . . . .	 0002	   0006	     00FC     ?
  GRND . . . . . . . . . . . . .	 0000	   0002	     0003     ?
PIT_CW . . . . . . . . . . . . .	 0008	   0004
  PCWSC  . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  PCWRW  . . . . . . . . . . . .	 0004	   0002	     0030     ?
  PCWM . . . . . . . . . . . . .	 0001	   0003	     000E     ?
  PCWBCD . . . . . . . . . . . .	 0000	   0001	     0001     ?
PPI_B_F  . . . . . . . . . . . .	 0008	   0008
  PBKB . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  PBKC . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PBIO . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  PBPC . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  PBSW . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  PBTB . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PBSP . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PBST . . . . . . . . . . . . .	 0000	   0001	     0001     ?
PPI_CR . . . . . . . . . . . . .	 0008	   0007
  PPEN . . . . . . . . . . . . .	 0007	   0001	     0080      0001
  PPAM . . . . . . . . . . . . .	 0005	   0002	     0060      0000
  PPAD . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  PPCU . . . . . . . . . . . . .	 0003	   0001	     0008      0001
  PPBM . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  PPBD . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PPCL . . . . . . . . . . . . .	 0000	   0001	     0001      0001
PPI_C_X_H  . . . . . . . . . . .	 0008	   0006
  PC2PE  . . . . . . . . . . . .	 0007	   0001	     0080     ?
  PC2IE  . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PC2T2  . . . . . . . . . . . .	 0005	   0001	     0020     ?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 233 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  PC2CI  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  PCDRV  . . . . . . . . . . . .	 0002	   0002	     000C     ?
  PCVID  . . . . . . . . . . . .	 0000	   0002	     0003     ?
PPI_C_X_L  . . . . . . . . . . .	 0008	   0007
  PCPE . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  PCIE . . . . . . . . . . . . .	 0006	   0001	     0040     ?
  PCT2 . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  PCCI . . . . . . . . . . . . .	 0004	   0001	     0010     ?
  PCMB . . . . . . . . . . . . .	 0002	   0002	     000C     ?
  PCFP . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  PCFD . . . . . . . . . . . . .	 0000	   0001	     0001     ?
PRN_CTRL . . . . . . . . . . . .	 0008	   0006
  LCX  . . . . . . . . . . . . .	 0005	   0003	     00E0     ?
  LCIRQ  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LCDR . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LCINI  . . . . . . . . . . . .	 0002	   0001	     0004     ?
  LCLF . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  LCOUT  . . . . . . . . . . . .	 0000	   0001	     0001     ?
PRN_STAT . . . . . . . . . . . .	 0008	   0007
  LPBZ . . . . . . . . . . . . .	 0007	   0001	     0080     ?
  LPACK  . . . . . . . . . . . .	 0006	   0001	     0040     ?
  LPOP . . . . . . . . . . . . .	 0005	   0001	     0020     ?
  LPSEL  . . . . . . . . . . . .	 0004	   0001	     0010     ?
  LPIO . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  LPX  . . . . . . . . . . . . .	 0001	   0002	     0006     ?
  LPTO . . . . . . . . . . . . .	 0000	   0001	     0001     ?
TD_UMA_CR  . . . . . . . . . . .	 0008	   0002
  TDUX . . . . . . . . . . . . .	 0001	   0007	     00FE     ?
  TDUB . . . . . . . . . . . . .	 0000	   0001	     0001     ?
TD_WS_CR . . . . . . . . . . . .	 0008	   0005
  TDWSI  . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  TDWSR  . . . . . . . . . . . .	 0004	   0002	     0030     ?
  TDWIO  . . . . . . . . . . . .	 0002	   0002	     000C     ?
  TDWRA  . . . . . . . . . . . .	 0001	   0001	     0002     ?
  TDWRO  . . . . . . . . . . . .	 0000	   0001	     0001     ?
V40_WCY1 . . . . . . . . . . . .	 0008	   0004
  IOW  . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  UMW  . . . . . . . . . . . . .	 0004	   0002	     0030     ?
  MMW  . . . . . . . . . . . . .	 0002	   0002	     000C     ?
  LMW  . . . . . . . . . . . . .	 0000	   0002	     0003     ?
VID_CSGFX  . . . . . . . . . . .	 0008	   0005
  CGPH . . . . . . . . . . . . .	 0006	   0002	     00C0     ?
  CGPL . . . . . . . . . . . . .	 0005	   0001	     0020      0001
  CGX  . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  CGIN . . . . . . . . . . . . .	 0003	   0001	     0008      0001
  CGBG . . . . . . . . . . . . .	 0000	   0003	     0007      0007
VID_CSTXT  . . . . . . . . . . .	 0008	   0004
  CTX  . . . . . . . . . . . . .	 0005	   0003	     00E0      0001
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 234 - 1




Records:

                N a m e                  Width     # fields
                                         Shift     Width     Mask      Initial

  CTBI . . . . . . . . . . . . .	 0004	   0001	     0010      0001
  CTIN . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  CTBC . . . . . . . . . . . . .	 0000	   0003	     0007     ?
VID_STAT . . . . . . . . . . . .	 0008	   0005
  VSX  . . . . . . . . . . . . .	 0004	   0004	     00F0     ?
  VSVS . . . . . . . . . . . . .	 0003	   0001	     0008     ?
  VSPE . . . . . . . . . . . . .	 0002	   0001	     0004     ?
  VSPT . . . . . . . . . . . . .	 0001	   0001	     0002     ?
  VSHS . . . . . . . . . . . . .	 0000	   0001	     0001     ?
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 235 - 1




Segments and Groups:

                N a m e                 Size     Length   Align   Combine Class

BIOS . . . . . . . . . . . . . .	16 Bit	 00010000 Para	  Private 
_BASIC . . . . . . . . . . . . .	16 Bit	 0000	  Abs	  Private 
_BDA_ABS . . . . . . . . . . . .	16 Bit	 0474	  Abs	  Private 
_BDA . . . . . . . . . . . . . .	16 Bit	 00ED	  Abs	  Private 
_BIOS  . . . . . . . . . . . . .	16 Bit	 FFF0	  Abs	  Private 
_BOOT_STACK  . . . . . . . . . .	16 Bit	 0102	  Abs	  Private 
_CGA_MEM . . . . . . . . . . . .	16 Bit	 4000	  Abs	  Private 
_DOS_DAT . . . . . . . . . . . .	16 Bit	 0034	  Abs	  Private 
_DOS_SEG . . . . . . . . . . . .	16 Bit	 0000	  Abs	  Private 
_IPL_SEG . . . . . . . . . . . .	16 Bit	 7E00	  Abs	  Private 
_IVT . . . . . . . . . . . . . .	16 Bit	 0080	  Abs	  Private 
_MDA_MEM . . . . . . . . . . . .	16 Bit	 1000	  Abs	  Private 
_OPT_ROM . . . . . . . . . . . .	16 Bit	 0000	  Abs	  Private 
_VID_BIOS  . . . . . . . . . . .	16 Bit	 0005	  Abs	  Private 
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 236 - 1




Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

BANNER_STRINGS . . . . . . . . .	P Near	 E46B	  BIOS	Length= 0037 Private
BEEP_OFF_P . . . . . . . . . . .	P Near	 E8EE	  BIOS	Length= 0007 Private
BEEP_ON_1  . . . . . . . . . . .	P Near	 E8E1	  BIOS	Length= 000D Private
BEEP_ON_P  . . . . . . . . . . .	P Near	 E8DB	  BIOS	Length= 0013 Private
BEEP . . . . . . . . . . . . . .	P Near	 E8AE	  BIOS	Length= 0014 Private
BIOS_ROM_SCAN  . . . . . . . . .	P Near	 E4E5	  BIOS	Length= 004B Private
BIOS_TOP . . . . . . . . . . . .	P Near	 E000	  BIOS	Length= 005B Private
BOOT . . . . . . . . . . . . . .	P Near	 E05B	  BIOS	Length= 0410 Private
BYTE_HEX . . . . . . . . . . . .	P Near	 F75B	  BIOS	Length= 001F Private
CRLF_SHOW_CURSOR . . . . . . . .	P Near	 F032	  BIOS	Length= 0013 Private
CRLF . . . . . . . . . . . . . .	P Near	 F716	  BIOS	Length= 0009 Private
DETECT_MEMORY  . . . . . . . . .	P Near	 E546	  BIOS	Length= 0094 Private
DWORD_HEX  . . . . . . . . . . .	P Near	 F748	  BIOS	Length= 0032 Private
FDC_FORMAT . . . . . . . . . . .	P Near	 EDEA	  BIOS	Length= 001B Private
FDC_MOTOR_ON . . . . . . . . . .	P Near	 EE3D	  BIOS	Length= 0041 Private
FDC_RECAL  . . . . . . . . . . .	P Near	 EF92	  BIOS	Length= 0033 Private
FDC_RECV_ALL . . . . . . . . . .	P Near	 EED5	  BIOS	Length= 0030 Private
FDC_RECV_STATUS  . . . . . . . .	P Near	 EED3	  BIOS	Length= 0032 Private
FDC_RECV . . . . . . . . . . . .	P Near	 EE7E	  BIOS	Length= 004B Private
FDC_RWV  . . . . . . . . . . . .	P Near	 ED8A	  BIOS	Length= 0057 Private
FDC_SEC_COUNT  . . . . . . . . .	P Near	 EDC0	  BIOS	Length= 0021 Private
FDC_SEEK . . . . . . . . . . . .	P Near	 EE05	  BIOS	Length= 0038 Private
FDC_SEND_PARAM . . . . . . . . .	P Near	 EE85	  BIOS	Length= 0044 Private
FDC_SEND . . . . . . . . . . . .	P Near	 EE88	  BIOS	Length= 0041 Private
FDC_WAIT_INT . . . . . . . . . .	P Near	 EF6B	  BIOS	Length= 0027 Private
FDC_WAIT_SENSE . . . . . . . . .	P Near	 EEC9	  BIOS	Length= 003C Private
FDC_WAIT_STATUS_ERR  . . . . . .	P Near	 EF0D	  BIOS	Length= 0027 Private
FDC_WAIT_STATUS  . . . . . . . .	P Near	 EF05	  BIOS	Length= 002F Private
GET_DISK_PARAMS  . . . . . . . .	P Near	 E71E	  BIOS	Length= 001B Private
HALT_BEEP  . . . . . . . . . . .	P Near	 E874	  BIOS	Length= 003A Private
HAS_FPU  . . . . . . . . . . . .	P Near	 FFC3	  BIOS	Length= 001D Private
HDD_POST_COUNT . . . . . . . . .	P Near	 E3DD	  BIOS	Length= 0013 Private
HDD_POST . . . . . . . . . . . .	P Near	 E3CF	  BIOS	Length= 002E Private
HELLO_RAND_TAGLINE . . . . . . .	P Near	 F8D1	  BIOS	Length= 006E Private
HIDE_CURSOR  . . . . . . . . . .	P Near	 F03B	  BIOS	Length= 000A Private
INT_02 . . . . . . . . . . . . .	P Near	 E2C3	  BIOS	Length= 0023 Private
INT_05 . . . . . . . . . . . . .	P Near	 FF54	  BIOS	Length= 006F Private
INT_08_PROC  . . . . . . . . . .	P Near	 FE97	  BIOS	Length= 0049 Private
INT_08 . . . . . . . . . . . . .	P Near	 FEA5	  BIOS	Length= 003B Private
INT_09_POST  . . . . . . . . . .	P Near	 E934	  BIOS	Length= 001B Private
INT_09 . . . . . . . . . . . . .	P Near	 E987	  BIOS	Length= 02D1 Private
INT_0E . . . . . . . . . . . . .	P Near	 EF57	  BIOS	Length= 0014 Private
INT_10_0 . . . . . . . . . . . .	P Near	 F0E4	  BIOS	Length= 00BB Private
INT_10_1 . . . . . . . . . . . .	P Near	 F19F	  BIOS	Length= 0016 Private
INT_10_2 . . . . . . . . . . . .	P Near	 F1B5	  BIOS	Length= 0039 Private
INT_10_3_CUR_PAGE  . . . . . . .	P Near	 F1EE	  BIOS	Length= 001E Private
INT_10_3 . . . . . . . . . . . .	P Near	 F1FB	  BIOS	Length= 0011 Private
INT_10_5 . . . . . . . . . . . .	P Near	 F20C	  BIOS	Length= 0027 Private
INT_10_6 . . . . . . . . . . . .	P Near	 F234	  BIOS	Length= 0113 Private
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 237 - 1




Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

INT_10_7 . . . . . . . . . . . .	P Near	 F233	  BIOS	Length= 0114 Private
INT_10_8_MODE_GFX  . . . . . . .	P Near	 F361	  BIOS	Length= 0087 Private
INT_10_8 . . . . . . . . . . . .	P Near	 F347	  BIOS	Length= 00A1 Private
INT_10_9A_MODE_GFX . . . . . . .	P Near	 F413	  BIOS	Length= 00BF Private
INT_10_9 . . . . . . . . . . . .	P Near	 F3E8	  BIOS	Length= 00EA Private
INT_10_A . . . . . . . . . . . .	P Near	 F3E8	  BIOS	Length= 00EA Private
INT_10_B . . . . . . . . . . . .	P Near	 F4D2	  BIOS	Length= 002B Private
INT_10_C . . . . . . . . . . . .	P Near	 F4FD	  BIOS	Length= 0027 Private
INT_10_D . . . . . . . . . . . .	P Near	 F524	  BIOS	Length= 0013 Private
INT_10_E . . . . . . . . . . . .	P Near	 F576	  BIOS	Length= 006F Private
INT_10_F . . . . . . . . . . . .	P Near	 F5E5	  BIOS	Length= 0008 Private
INT_10_GET_CUR_ADDR  . . . . . .	P Near	 F5ED	  BIOS	Length= 0022 Private
INT_10_GFX_CHARPOS . . . . . . .	P Near	 F4BD	  BIOS	Length= 0015 Private
INT_10_GFX_PIXEL . . . . . . . .	P Near	 F537	  BIOS	Length= 003F Private
INT_10_IS_CGA80  . . . . . . . .	P Near	 F090	  BIOS	Length= 0013 Private
INT_10_IS_TXT  . . . . . . . . .	P Near	 F085	  BIOS	Length= 000B Private
INT_10_SCR_GFX . . . . . . . . .	P Near	 F2C0	  BIOS	Length= 0087 Private
INT_10 . . . . . . . . . . . . .	P Near	 F065	  BIOS	Length= 05B2 Private
INT_11 . . . . . . . . . . . . .	P Near	 F84D	  BIOS	Length= 000C Private
INT_12 . . . . . . . . . . . . .	P Near	 F841	  BIOS	Length= 000C Private
INT_13_0 . . . . . . . . . . . .	P Near	 EC99	  BIOS	Length= 004C Private
INT_13_1 . . . . . . . . . . . .	P Near	 ECE5	  BIOS	Length= 0007 Private
INT_13_2_5 . . . . . . . . . . .	P Near	 ECF2	  BIOS	Length= 0119 Private
INT_13 . . . . . . . . . . . . .	P Near	 EC59	  BIOS	Length= 036C Private
INT_14_0 . . . . . . . . . . . .	P Near	 E764	  BIOS	Length= 0036 Private
INT_14_1 . . . . . . . . . . . .	P Near	 E79A	  BIOS	Length= 001E Private
INT_14_2 . . . . . . . . . . . .	P Near	 E7B8	  BIOS	Length= 0016 Private
INT_14_3 . . . . . . . . . . . .	P Near	 E78A	  BIOS	Length= 000A Private
INT_14_DONE  . . . . . . . . . .	P Near	 E794	  BIOS	Length= 0006 Private
INT_14_EXIT  . . . . . . . . . .	P Near	 E798	  BIOS	Length= 0002 Private
INT_14_POLL_PORT . . . . . . . .	P Near	 E7D6	  BIOS	Length= 0018 Private
INT_14_POLL  . . . . . . . . . .	P Near	 E7CE	  BIOS	Length= 0020 Private
INT_14 . . . . . . . . . . . . .	P Near	 E739	  BIOS	Length= 00B5 Private
INT_15 . . . . . . . . . . . . .	P Near	 F859	  BIOS	Length= 000A Private
INT_16 . . . . . . . . . . . . .	P Near	 E82E	  BIOS	Length= 0046 Private
INT_17 . . . . . . . . . . . . .	P Near	 EFD2	  BIOS	Length= 0060 Private
INT_18 . . . . . . . . . . . . .	P Near	 E459	  BIOS	Length= 0012 Private
INT_19 . . . . . . . . . . . . .	P Near	 E6F2	  BIOS	Length= 002C Private
INT_1A_READ  . . . . . . . . . .	P Near	 FE81	  BIOS	Length= 000C Private
INT_1A_SET . . . . . . . . . . .	P Near	 FE8D	  BIOS	Length= 000A Private
INT_1A . . . . . . . . . . . . .	P Near	 FE6E	  BIOS	Length= 0029 Private
INT_1D . . . . . . . . . . . . .	P Near	 F0A4	  BIOS	Length= 0040 Private
INT_1E_PARAM . . . . . . . . . .	P Near	 EF34	  BIOS	Length= 000E Private
INT_IRQ  . . . . . . . . . . . .	P Near	 FF23	  BIOS	Length= 0024 Private
INT_KB_ALT . . . . . . . . . . .	P Near	 EA80	  BIOS	Length= 0046 Private
INT_KB_CTRL_ALT  . . . . . . . .	P Near	 EB0D	  BIOS	Length= 0011 Private
INT_KB_CTRL_NO_ALT . . . . . . .	P Near	 EAC6	  BIOS	Length= 0042 Private
INT_KB_IS_FLAG . . . . . . . . .	P Near	 EB2C	  BIOS	Length= 0061 Private
INT_KB_SET_PAUSE . . . . . . . .	P Near	 E94F	  BIOS	Length= 0014 Private
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 238 - 1




Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

INT_KB_TOGGLE_TURBO  . . . . . .	P Near	 F8C2	  BIOS	Length= 000F Private
INT_RET  . . . . . . . . . . . .	P Near	 FF53	  BIOS	Length= 0001 Private
IO_DELAY_MS  . . . . . . . . . .	P Near	 F77E	  BIOS	Length= 0031 Private
IO_DELAY_TICK  . . . . . . . . .	P Near	 F782	  BIOS	Length= 002D Private
IO_WAIT_MS_125 . . . . . . . . .	P Near	 F77A	  BIOS	Length= 0035 Private
IS_ALPHA . . . . . . . . . . . .	P Near	 FF47	  BIOS	Length= 000C Private
KB_BUF_CLEAR . . . . . . . . . .	P Near	 EC47	  BIOS	Length= 0011 Private
KB_KEY_STATUS  . . . . . . . . .	P Near	 E840	  BIOS	Length= 0013 Private
KB_SHIFT_STATUS  . . . . . . . .	P Near	 E86F	  BIOS	Length= 0005 Private
KB_WAIT_READ . . . . . . . . . .	P Near	 E853	  BIOS	Length= 001C Private
LPT_CHAR . . . . . . . . . . . .	P Near	 FFB3	  BIOS	Length= 0010 Private
LPT_CRLF . . . . . . . . . . . .	P Near	 FFAC	  BIOS	Length= 0017 Private
LPT_LF . . . . . . . . . . . . .	P Near	 FFB1	  BIOS	Length= 0012 Private
MEEPMEEP . . . . . . . . . . . .	P Near	 E8C2	  BIOS	Length= 0019 Private
MEEP . . . . . . . . . . . . . .	P Near	 E8C5	  BIOS	Length= 0016 Private
MEM_ADDR_TEST  . . . . . . . . .	P Near	 E5DA	  BIOS	Length= 0026 Private
MEM_CHECK  . . . . . . . . . . .	P Near	 E608	  BIOS	Length= 000F Private
MEM_TEST . . . . . . . . . . . .	P Near	 E600	  BIOS	Length= 0017 Private
MOVE_COL . . . . . . . . . . . .	P Near	 F6FC	  BIOS	Length= 0017 Private
NIB_HEX  . . . . . . . . . . . .	P Near	 F768	  BIOS	Length= 0012 Private
NMI_RESET  . . . . . . . . . . .	P Near	 E81D	  BIOS	Length= 000B Private
OUTLN_SZ . . . . . . . . . . . .	P Near	 F713	  BIOS	Length= 000C Private
OUT_CHAR . . . . . . . . . . . .	P Near	 F76F	  BIOS	Length= 000B Private
OUT_DECU_R . . . . . . . . . . .	P Near	 F731	  BIOS	Length= 0017 Private
OUT_DECU . . . . . . . . . . . .	P Near	 F727	  BIOS	Length= 0021 Private
OUT_SZ_ATTR  . . . . . . . . . .	P Near	 F6DB	  BIOS	Length= 0021 Private
OUT_SZ . . . . . . . . . . . . .	P Near	 F6ED	  BIOS	Length= 000F Private
PORT_TEST  . . . . . . . . . . .	P Near	 E7EE	  BIOS	Length= 002F Private
POST_BOOT_TYPE . . . . . . . . .	P Near	 E617	  BIOS	Length= 0027 Private
POST_COL . . . . . . . . . . . .	P Near	 F690	  BIOS	Length= 0083 Private
POST_END_COL_NL  . . . . . . . .	P Near	 F6CD	  BIOS	Length= 0005 Private
POST_END_COL_STR . . . . . . . .	P Near	 F6D5	  BIOS	Length= 0027 Private
POST_END_COL . . . . . . . . . .	P Near	 F6D2	  BIOS	Length= 002A Private
POST_ERROR_MSG . . . . . . . . .	P Near	 E91E	  BIOS	Length= 0016 Private
POST_KB_RESET  . . . . . . . . .	P Near	 E352	  BIOS	Length= 005E Private
POST_START_COL_1 . . . . . . . .	P Near	 F694	  BIOS	Length= 0027 Private
POST_START_COL_2 . . . . . . . .	P Near	 F6BB	  BIOS	Length= 0012 Private
POST_STRINGS . . . . . . . . . .	P Near	 E4A2	  BIOS	Length= 0043 Private
POST_SYS_CONFIG  . . . . . . . .	P Near	 F617	  BIOS	Length= 0079 Private
POST_SYS_VIDEO . . . . . . . . .	P Near	 E63E	  BIOS	Length= 0054 Private
POWER_ON . . . . . . . . . . . .	P Far	 FFF0	  BIOS	Length= 0010 Private
ROM_CHECKSUM . . . . . . . . . .	P Near	 E530	  BIOS	Length= 0016 Private
SET_CURSOR . . . . . . . . . . .	P Near	 F03E	  BIOS	Length= 0007 Private
SHOW_CURSOR  . . . . . . . . . .	P Near	 F035	  BIOS	Length= 0010 Private
SHOW_DISK_PARAMS . . . . . . . .	P Near	 F863	  BIOS	Length= 005F Private
SHOW_PORT_COUNT  . . . . . . . .	P Near	 F678	  BIOS	Length= 0018 Private
SPACE  . . . . . . . . . . . . .	P Near	 F71F	  BIOS	Length= 0008 Private
STRINGS  . . . . . . . . . . . .	P Near	 E46B	  BIOS	Length= 007A Private
TOGGLE_TURBO . . . . . . . . . .	P Near	 E2A5	  BIOS	Length= 0016 Private
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 239 - 1




Procedures,  parameters and locals:

                N a m e                 Type     Value    Attr

VECTOR_TABLE . . . . . . . . . .	P Near	 FEE3	  BIOS	Length= 0040 Private
WORD_HEX . . . . . . . . . . . .	P Near	 F754	  BIOS	Length= 0026 Private
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 240 - 1




Symbols:

                N a m e                 Type     Value    Attr

??0001 . . . . . . . . . . . . .	L Near	 E120	  BIOS	
??0002 . . . . . . . . . . . . .	L Near	 E122	  BIOS	
??0003 . . . . . . . . . . . . .	L Near	 E14B	  BIOS	
??0004 . . . . . . . . . . . . .	L Near	 E14D	  BIOS	
??0005 . . . . . . . . . . . . .	L Near	 E15F	  BIOS	
??0006 . . . . . . . . . . . . .	L Near	 E161	  BIOS	
??0007 . . . . . . . . . . . . .	L Near	 E171	  BIOS	
??0008 . . . . . . . . . . . . .	L Near	 E173	  BIOS	
??0009 . . . . . . . . . . . . .	L Near	 E17B	  BIOS	
??000A . . . . . . . . . . . . .	L Near	 E17D	  BIOS	
??000B . . . . . . . . . . . . .	L Near	 E1BB	  BIOS	
??000C . . . . . . . . . . . . .	Number	 0030h	 
??000D . . . . . . . . . . . . .	Number	 0004h	 
??000E . . . . . . . . . . . . .	Number	 0010h	 
??0010 . . . . . . . . . . . . .	L Near	 E38B	  BIOS	
??0011 . . . . . . . . . . . . .	L Near	 E394	  BIOS	
??0012 . . . . . . . . . . . . .	L Near	 E409	  BIOS	
??0013 . . . . . . . . . . . . .	L Near	 E452	  BIOS	
??0016 . . . . . . . . . . . . .	L Near	 E7FD	  BIOS	
??0018 . . . . . . . . . . . . .	L Near	 E88C	  BIOS	
??0019 . . . . . . . . . . . . .	L Near	 E88E	  BIOS	
??001A . . . . . . . . . . . . .	L Near	 E890	  BIOS	
??001B . . . . . . . . . . . . .	L Near	 E897	  BIOS	
??001C . . . . . . . . . . . . .	L Near	 E899	  BIOS	
??001D . . . . . . . . . . . . .	L Near	 E89B	  BIOS	
??001E . . . . . . . . . . . . .	L Near	 E8D0	  BIOS	
??001F . . . . . . . . . . . . .	L Near	 E8D7	  BIOS	
??0024 . . . . . . . . . . . . .	L Near	 F02A	  BIOS	
??0027 . . . . . . . . . . . . .	Number	 00C0h	 
??0028 . . . . . . . . . . . . .	Number	 0006h	 
??0029 . . . . . . . . . . . . .	Number	 0011h	 
??002A . . . . . . . . . . . . .	Number	 000Eh	 
??002B . . . . . . . . . . . . .	Number	 0001h	 
??002C . . . . . . . . . . . . .	Number	 0011h	 
ANY_KEY  . . . . . . . . . . . .	Byte	 E48D	  BIOS	
ARCH_5150  . . . . . . . . . . .	Number	 0050h	 
ARCH_5160v2  . . . . . . . . . .	Number	 0059h	 
ARCH_5160  . . . . . . . . . . .	Number	 0058h	 
ARCH_EHB . . . . . . . . . . . .	Number	 0048h	 
ARCH_EMU . . . . . . . . . . . .	Number	 0045h	 
ARCH_FE2010  . . . . . . . . . .	Number	 0046h	 
ARCH_ID  . . . . . . . . . . . .	Number	 00FEh	 
ARCH_M88 . . . . . . . . . . . .	Number	 004Dh	 
ARCH_MIST  . . . . . . . . . . .	Number	 0049h	 
ARCH_SUB_TYPE  . . . . . . . . .	Number	 0000h	 
ARCH_TD3300  . . . . . . . . . .	Number	 0053h	 
ARCH_TURBO . . . . . . . . . . .	Number	 0054h	 
ARCH_TYPE  . . . . . . . . . . .	Text   	 ARCH_TURBO
ARCH_UM82  . . . . . . . . . . .	Number	 0055h	 
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 241 - 1




Symbols:

                N a m e                 Type     Value    Attr

ATKB_CMD . . . . . . . . . . . .	Number	 0064h	 
ATKB_IO  . . . . . . . . . . . .	Number	 0060h	 
BASE_RAM_ERROR . . . . . . . . .	L Near	 E163	  BIOS	
BASE_RAM_TEST  . . . . . . . . .	L Near	 E137	  BIOS	
BASE_RAM_ZERO  . . . . . . . . .	L Near	 E168	  BIOS	
BASIC_ROM  . . . . . . . . . . .	Number	 0001h	 
BASIC_TOP  . . . . . . . . . . .	Word	 0000	  _BASIC	
BEEP_1K7 . . . . . . . . . . . .	Number	 04A0h	 
BEEP_1K  . . . . . . . . . . . .	Number	 04B1h	 
BEEP_2K  . . . . . . . . . . . .	Number	 0250h	 
BEEP_A6  . . . . . . . . . . . .	Number	 054Ch	 
BEEP_B5  . . . . . . . . . . . .	Number	 0975h	 
BEEP_C5  . . . . . . . . . . . .	Number	 08F1h	 
BEEP_C6  . . . . . . . . . . . .	Number	 0474h	 
BEEP_DEFAULT . . . . . . . . . .	Text   	 BEEP_A6
BEEP_ERR_HIGH  . . . . . . . . .	Text   	 BEEP_F5
BEEP_ERR_LOW . . . . . . . . . .	Text   	 BEEP_C5
BEEP_F5  . . . . . . . . . . . .	Number	 06A5h	 
BEEP_G5  . . . . . . . . . . . .	Number	 05FAh	 
BELL . . . . . . . . . . . . . .	Number	 0007h	 
BIOS_BREAK . . . . . . . . . . .	Byte	 0071	  _BDA	
BIOS_INT_VECTORS_LOOP  . . . . .	L Near	 E1DB	  BIOS	
BIOS_VIDEO . . . . . . . . . . .	L Near	 E65D	  BIOS	
BLACK  . . . . . . . . . . . . .	Number	 0000h	 
BLOCK_LOOP_DONE  . . . . . . . .	L Near	 E561	  BIOS	
BLOCK_LOOP . . . . . . . . . . .	L Near	 E555	  BIOS	
BLUE . . . . . . . . . . . . . .	Number	 0009h	 
BOOT_DEVICE  . . . . . . . . . .	L Near	 E44A	  BIOS	
BOOT_FAIL  . . . . . . . . . . .	Byte	 E46E	  BIOS	
BOOT_NORMAL  . . . . . . . . . .	Number	 004Eh	 
BOOT_RETRY . . . . . . . . . . .	L Near	 E44D	  BIOS	
BOOT_SPEED . . . . . . . . . . .	Text   	 BOOT_TURBO
BOOT_TURBO . . . . . . . . . . .	Number	 0054h	 
BROWN  . . . . . . . . . . . . .	Number	 0006h	 
BS . . . . . . . . . . . . . . .	Number	 0008h	 
BULL . . . . . . . . . . . . . .	Number	 00F9h	 
BYTES_HERE_BOOT  . . . . . . . .	Number	 0000h	 
BYTES_HERE_GFX_CHARSET . . . . .	Number	 0124h	 
BYTES_HERE_INT_02  . . . . . . .	Number	 0008h	 
BYTES_HERE_INT_08  . . . . . . .	Number	 0000h	 
BYTES_HERE_INT_09  . . . . . . .	Number	 000Ch	 
BYTES_HERE_INT_0E  . . . . . . .	Number	 0015h	 
BYTES_HERE_INT_10_JMP  . . . . .	Number	 0000h	 
BYTES_HERE_INT_12  . . . . . . .	Number	 0086h	 
BYTES_HERE_INT_13  . . . . . . .	Number	 0001h	 
BYTES_HERE_INT_14  . . . . . . .	Number	 0000h	 
BYTES_HERE_INT_16  . . . . . . .	Number	 0000h	 
BYTES_HERE_INT_19  . . . . . . .	Number	 0060h	 
BYTES_HERE_INT_1D  . . . . . . .	Number	 0001h	 
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 242 - 1




Symbols:

                N a m e                 Type     Value    Attr

BYTES_HERE_INT_1E  . . . . . . .	Number	 0002h	 
BYTES_HERE_INT_RET . . . . . . .	Number	 0000h	 
BYTES_HERE_POWER_ON  . . . . . .	Number	 0001h	 
BYTES_HERE_VECTOR_TABLE  . . . .	Number	 0003h	 
BYTES_HERE_VER . . . . . . . . .	Number	 0000h	 
CASSETTE . . . . . . . . . . . .	Number	 0000h	 
CAS_CRC  . . . . . . . . . . . .	Word	 0069	  _BDA	
CAS_PREV . . . . . . . . . . . .	Byte	 006B	  _BDA	
CAS_TIME_CNT . . . . . . . . . .	Word	 0067	  _BDA	
CGA_CTRL . . . . . . . . . . . .	Number	 03D8h	 
CGA_MEM_40 . . . . . . . . . . .	Byte	 0800	  _CGA_MEM	
CGA_MEM_80 . . . . . . . . . . .	Byte	 1000	  _CGA_MEM	
CGA_MEM_FLD  . . . . . . . . . .	Number	 2000h	 
CGA_MEM_GFX  . . . . . . . . . .	Byte	 4000	  _CGA_MEM	
CGA_MEM_SZ . . . . . . . . . . .	Number	 4000h	 
CGA_MEM_TOP  . . . . . . . . . .	Byte	 0000	  _CGA_MEM	
CGA_MEM  . . . . . . . . . . . .	Byte	 4000	  _CGA_MEM	
CGA_SNOW_REMOVE  . . . . . . . .	Number	 0000h	 
CGA_STAT . . . . . . . . . . . .	Number	 03DAh	 
CHECKSUM_LOOP  . . . . . . . . .	L Near	 E53A	  BIOS	
CHECKSUM_OK  . . . . . . . . . .	L Near	 E0E3	  BIOS	
CHECKSUM_ROM . . . . . . . . . .	L Near	 E0D1	  BIOS	
CHECKSUM . . . . . . . . . . . .	L Near	 E0D8	  BIOS	
CHECK_ALT_ON . . . . . . . . . .	L Near	 EA98	  BIOS	
CHECK_BASIC_ROM  . . . . . . . .	L Near	 E1E9	  BIOS	
CHECK_EGA  . . . . . . . . . . .	L Near	 E678	  BIOS	
CHECK_ROM  . . . . . . . . . . .	L Near	 E4EA	  BIOS	
CHECK_TOP_ROW_NUM  . . . . . . .	L Near	 EA89	  BIOS	
CHECK_VGA  . . . . . . . . . . .	L Near	 E66A	  BIOS	
CLEAR_POST_SCREEN  . . . . . . .	L Near	 E436	  BIOS	
COLD_BOOT  . . . . . . . . . . .	Number	 0000h	 
COM1_DATA  . . . . . . . . . . .	Number	 03F8h	 
COM1_IER . . . . . . . . . . . .	Number	 03F9h	 
COM1_IIR . . . . . . . . . . . .	Number	 03FAh	 
COM1_LCR . . . . . . . . . . . .	Number	 03FBh	 
COM1_LSR . . . . . . . . . . . .	Number	 03FDh	 
COM1_MCR . . . . . . . . . . . .	Number	 03FCh	 
COM1_MSR . . . . . . . . . . . .	Number	 03FEh	 
COM1_SPR . . . . . . . . . . . .	Number	 03FFh	 
COM2_DATA  . . . . . . . . . . .	Number	 02F8h	 
COM3_DATA  . . . . . . . . . . .	Number	 03E8h	 
COM4_DATA  . . . . . . . . . . .	Number	 02E8h	 
COM_ADDR . . . . . . . . . . . .	Word	 0000	  _BDA	
COM_DETECT_LOOP  . . . . . . . .	L Near	 E309	  BIOS	
COM_TIME_B . . . . . . . . . . .	Number	 007Ch	 
COM_TIME . . . . . . . . . . . .	Byte	 007C	  _BDA	
COM_TO . . . . . . . . . . . . .	Number	 0001h	 
COPYRIGHT  . . . . . . . . . . .	Byte	 E031	  BIOS	
COPY_YEAR  . . . . . . . . . . .	Text   	 '2022-23'
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 243 - 1




Symbols:

                N a m e                 Type     Value    Attr

CPU_8088 . . . . . . . . . . . .	Number	 0038h	 
CPU_CHECK_TYPE_2_DONE  . . . . .	L Near	 F62C	  BIOS	
CPU_CHECK_TYPE_2 . . . . . . . .	L Near	 F622	  BIOS	
CPU_INST_TEST  . . . . . . . . .	L Near	 E087	  BIOS	
CPU_IS_V20 . . . . . . . . . . .	L Near	 E212	  BIOS	
CPU_REG_PASS . . . . . . . . . .	L Near	 E085	  BIOS	
CPU_REG_TEST . . . . . . . . . .	L Near	 E060	  BIOS	
CPU_TEST_PASS  . . . . . . . . .	L Near	 E0A1	  BIOS	
CPU_TYPE_8088  . . . . . . . . .	L Near	 E220	  BIOS	
CPU_TYPE_DONE  . . . . . . . . .	L Near	 E220	  BIOS	
CPU_TYPE . . . . . . . . . . . .	Text   	 CPU_8088
CPU_V20  . . . . . . . . . . . .	Number	 0056h	 
CRT_MODE . . . . . . . . . . . .	Byte	 F60F	  BIOS	
CR . . . . . . . . . . . . . . .	Number	 000Dh	 
CURL_BOT . . . . . . . . . . . .	Number	 00F5h	 
CURL_TOP . . . . . . . . . . . .	Number	 00F4h	 
CURSOR_DEFAULT . . . . . . . . .	Word	 00E8	  _BDA	
CYAN . . . . . . . . . . . . . .	Number	 0003h	 
DARKBLUE . . . . . . . . . . . .	Number	 0001h	 
DARKGRAY . . . . . . . . . . . .	Number	 0008h	 
DARKGREEN  . . . . . . . . . . .	Number	 0002h	 
DARKMAGENTA  . . . . . . . . . .	Number	 0005h	 
DARKRED  . . . . . . . . . . . .	Number	 0004h	 
DBLARROW . . . . . . . . . . . .	Number	 001Dh	 
DETECT_MEMORY_ERR_2  . . . . . .	L Near	 E5D1	  BIOS	
DETECT_MEMORY_ERR_DONE . . . . .	L Near	 E5D5	  BIOS	
DETECT_MEMORY_ERR  . . . . . . .	L Near	 E5A8	  BIOS	
DISABLE_NMI  . . . . . . . . . .	L Near	 E085	  BIOS	
DMA_0_A  . . . . . . . . . . . .	Number	 0000h	 
DMA_0_C  . . . . . . . . . . . .	Number	 0001h	 
DMA_1_A  . . . . . . . . . . . .	Number	 0002h	 
DMA_1_C  . . . . . . . . . . . .	Number	 0003h	 
DMA_2_A  . . . . . . . . . . . .	Number	 0004h	 
DMA_2_C  . . . . . . . . . . . .	Number	 0005h	 
DMA_3_A  . . . . . . . . . . . .	Number	 0006h	 
DMA_3_C  . . . . . . . . . . . .	Number	 0007h	 
DMA_CMD  . . . . . . . . . . . .	Number	 0008h	 
DMA_FF . . . . . . . . . . . . .	Number	 000Ch	 
DMA_MASKR  . . . . . . . . . . .	Number	 000Eh	 
DMA_MASK . . . . . . . . . . . .	Number	 000Ah	 
DMA_MMASK  . . . . . . . . . . .	Number	 000Fh	 
DMA_MODE . . . . . . . . . . . .	Number	 000Bh	 
DMA_PASS . . . . . . . . . . . .	L Near	 E126	  BIOS	
DMA_P_C0 . . . . . . . . . . . .	Number	 0087h	 
DMA_P_C1 . . . . . . . . . . . .	Number	 0083h	 
DMA_P_C2 . . . . . . . . . . . .	Number	 0081h	 
DMA_P_C3 . . . . . . . . . . . .	Number	 0082h	 
DMA_REQ  . . . . . . . . . . . .	Number	 0009h	 
DMA_RESET  . . . . . . . . . . .	Number	 000Dh	 
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 244 - 1




Symbols:

                N a m e                 Type     Value    Attr

DMA_SETUP_CH . . . . . . . . . .	L Near	 E132	  BIOS	
DONE_ZERO_ALL_RAM  . . . . . . .	L Near	 E5A5	  BIOS	
DOS_FD_PARAM . . . . . . . . . .	Byte	 0022	  _DOS_DAT	
DOT  . . . . . . . . . . . . . .	Number	 00FAh	 
DRAM_REFRESH . . . . . . . . . .	Number	 0000h	 
EQUIP_FLAGS  . . . . . . . . . .	EQFLAGS	 0010	  _BDA	
FD0_TRACK  . . . . . . . . . . .	Byte	 0094	  _BDA	
FD1_TRACK  . . . . . . . . . . .	Byte	 0095	  _BDA	
FDC_A_STAT . . . . . . . . . . .	Number	 03F0h	 
FDC_B_STAT . . . . . . . . . . .	Number	 03F1h	 
FDC_CMD_FMT  . . . . . . . . . .	Number	 000Dh	 
FDC_CMD_RDEL . . . . . . . . . .	Number	 000Ch	 
FDC_CMD_RD . . . . . . . . . . .	Number	 0006h	 
FDC_CMD_RECAL  . . . . . . . . .	Number	 0007h	 
FDC_CMD_RSID . . . . . . . . . .	Number	 000Ah	 
FDC_CMD_RTRK . . . . . . . . . .	Number	 0002h	 
FDC_CMD_SEEK . . . . . . . . . .	Number	 000Fh	 
FDC_CMD_SENSE  . . . . . . . . .	Number	 0008h	 
FDC_CMD_SPEC . . . . . . . . . .	Number	 0003h	 
FDC_CMD_STAT . . . . . . . . . .	Number	 0004h	 
FDC_CMD_WDEL . . . . . . . . . .	Number	 0009h	 
FDC_CMD_WR . . . . . . . . . . .	Number	 0005h	 
FDC_CTRL . . . . . . . . . . . .	Number	 03F2h	 
FDC_DATA . . . . . . . . . . . .	Number	 03F5h	 
FDC_DMA_BOUND  . . . . . . . . .	L Near	 ECEC	  BIOS	
FDC_DRIVE_STARTED  . . . . . . .	L Near	 EE7B	  BIOS	
FDC_DRV_ALREADY_ON . . . . . . .	L Near	 EE72	  BIOS	
FDC_ENABLE . . . . . . . . . . .	Number	 0000h	 
FDC_ERR1_MAP . . . . . . . . . .	Byte	 EF2C	  BIOS	
FDC_ERR_MAP_LOOP . . . . . . . .	L Near	 EF1F	  BIOS	
FDC_FORMAT_ERR . . . . . . . . .	L Near	 EDE6	  BIOS	
FDC_HLT_WAIT . . . . . . . . . .	Number	 0001h	 
FDC_INIT_DMA_EXIT  . . . . . . .	L Near	 ED58	  BIOS	
FDC_INIT_DMA . . . . . . . . . .	L Near	 ED15	  BIOS	
FDC_LAST_ST  . . . . . . . . . .	FDC_CSB	 0042	  _BDA	
FDC_RECAL_DONE . . . . . . . . .	L Near	 EFC3	  BIOS	
FDC_RECAL_ERR  . . . . . . . . .	L Near	 EFC3	  BIOS	
FDC_RECV_ALL_DONE  . . . . . . .	L Near	 EF00	  BIOS	
FDC_RECV_ALL_LOOP  . . . . . . .	L Near	 EEE5	  BIOS	
FDC_RECV_CHECK_ERR . . . . . . .	L Near	 EEFB	  BIOS	
FDC_RECV_DELAY . . . . . . . . .	L Near	 EEED	  BIOS	
FDC_RECV_READY . . . . . . . . .	L Near	 EEB0	  BIOS	
FDC_RECV_WAIT_POLL . . . . . . .	L Near	 EEAC	  BIOS	
FDC_RWVF . . . . . . . . . . . .	L Near	 ED6D	  BIOS	
FDC_RWV_ERR  . . . . . . . . . .	L Near	 EDE6	  BIOS	
FDC_RWV_SEND_WAIT  . . . . . . .	L Near	 EDB6	  BIOS	
FDC_SEC_COUNT_SAME_CYL . . . . .	L Near	 EDDB	  BIOS	
FDC_SEC_COUNT_SAME . . . . . . .	L Near	 EDDD	  BIOS	
FDC_SEEK_DONE  . . . . . . . . .	L Near	 EE35	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 245 - 1




Symbols:

                N a m e                 Type     Value    Attr

FDC_SEEK_ERR . . . . . . . . . .	L Near	 EE37	  BIOS	
FDC_SEEK_RECAL_ERR . . . . . . .	L Near	 EE3A	  BIOS	
FDC_SEND_READY . . . . . . . . .	L Near	 EEA7	  BIOS	
FDC_SEND_RECV  . . . . . . . . .	L Near	 EE8D	  BIOS	
FDC_SEND_WAIT_POLL_1 . . . . . .	L Near	 EEA3	  BIOS	
FDC_SEND_WAIT_POLL . . . . . . .	L Near	 EE99	  BIOS	
FDC_SEND_WAIT_TIMER  . . . . . .	L Near	 EEB7	  BIOS	
FDC_STAT . . . . . . . . . . . .	Number	 03F4h	 
FDC_ST_BADCMD  . . . . . . . . .	Number	 0001h	 
FDC_ST_DMA_64K . . . . . . . . .	Number	 0009h	 
FDC_ST_DMA_OVR . . . . . . . . .	Number	 0008h	 
FDC_ST_ERR_CRC . . . . . . . . .	Number	 0010h	 
FDC_ST_ERR_FDC . . . . . . . . .	Number	 0020h	 
FDC_ST_ERR_MARK  . . . . . . . .	Number	 0002h	 
FDC_ST_ERR_SEC . . . . . . . . .	Number	 0004h	 
FDC_ST_ERR_SEEK  . . . . . . . .	Number	 0040h	 
FDC_ST_ERR_WP  . . . . . . . . .	Number	 0003h	 
FDC_ST_OK  . . . . . . . . . . .	Number	 0000h	 
FDC_ST_SENSE . . . . . . . . . .	Number	 00FFh	 
FDC_ST_TIMEOUT . . . . . . . . .	Number	 0080h	 
FDC_WAIT_DONE  . . . . . . . . .	L Near	 EEB1	  BIOS	
FDC_WAIT_ERR_EXIT_OK . . . . . .	L Near	 EF2B	  BIOS	
FDC_WAIT_ERR_EXIT  . . . . . . .	L Near	 EF27	  BIOS	
FDC_WAIT_EXIT  . . . . . . . . .	L Near	 EEB3	  BIOS	
FDC_WAIT_INT_DONE  . . . . . . .	L Near	 EF8F	  BIOS	
FDC_WAIT_INT_LOOP1 . . . . . . .	L Near	 EF71	  BIOS	
FDC_WAIT_INT_LOOP2 . . . . . . .	L Near	 EF74	  BIOS	
FDC_WAIT_INT_OK  . . . . . . . .	L Near	 EF8A	  BIOS	
FDC_WAIT_SENSE_EXIT  . . . . . .	L Near	 EF04	  BIOS	
FDC_WAIT_STATUS_ERR_DONE . . . .	L Near	 EF25	  BIOS	
FDC_WAIT_TIMEOUT . . . . . . . .	L Near	 EEC2	  BIOS	
FD_AUTO_DETECT . . . . . . . . .	Number	 0000h	 
FD_CAL_ST  . . . . . . . . . . .	FDC_SF	 003E	  _BDA	
FD_LAST_OP . . . . . . . . . . .	Byte	 0041	  _BDA	
FD_MEDIA_ST  . . . . . . . . . .	FDC_STATE  0090	    _BDA	
FD_MODE  . . . . . . . . . . . .	FDC_MODE  008F	   _BDA	
FD_MOTOR_CT_ABS  . . . . . . . .	Byte	 0440	  _BDA_ABS	
FD_MOTOR_CT  . . . . . . . . . .	Byte	 0040	  _BDA	
FD_MOTOR_ST  . . . . . . . . . .	FDC_MF	 003F	  _BDA	
FE2010_CONF_REG  . . . . . . . .	Byte	 00EC	  _BDA	
FIELD_EVEN . . . . . . . . . . .	L Near	 F567	  BIOS	
FOUND_ROM  . . . . . . . . . . .	L Near	 E4FC	  BIOS	
FPU_CHECK  . . . . . . . . . . .	L Near	 F632	  BIOS	
FPU_DISP_DONE  . . . . . . . . .	L Near	 F644	  BIOS	
FPU_TEST_CW  . . . . . . . . . .	L Near	 FFD2	  BIOS	
FPU_TEST_DONE  . . . . . . . . .	L Near	 FFDE	  BIOS	
FPU_TEST_SW  . . . . . . . . . .	L Near	 FFC6	  BIOS	
GAME_CTRL  . . . . . . . . . . .	Number	 0201h	 
GB_FLAGS . . . . . . . . . . . .	GFLAGS	 0012	  _BDA	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 246 - 1




Symbols:

                N a m e                 Type     Value    Attr

GET_DISK_PARAMS_ERR  . . . . . .	L Near	 E738	  BIOS	
GET_SW_SETTINGS  . . . . . . . .	L Near	 E220	  BIOS	
GFX_CHARSET  . . . . . . . . . .	Byte	 FA6E	  BIOS	
GRAY . . . . . . . . . . . . . .	Number	 0007h	 
GREEN  . . . . . . . . . . . . .	Number	 000Ah	 
HALT_BEEP_1  . . . . . . . . . .	L Near	 E165	  BIOS	
HALT_BEEP_2  . . . . . . . . . .	L Near	 E267	  BIOS	
HALT_BEEP_REP  . . . . . . . . .	L Near	 E885	  BIOS	
HALT_BEEP_START_ODD  . . . . . .	L Near	 E883	  BIOS	
HALT_BEEP_START  . . . . . . . .	L Near	 E87C	  BIOS	
HALT_ERROR . . . . . . . . . . .	L Near	 E10E	  BIOS	
HDC_CTRL . . . . . . . . . . . .	Number	 0321h	 
HDC_DMA  . . . . . . . . . . . .	Number	 0323h	 
HDC_PULSE  . . . . . . . . . . .	Number	 0322h	 
HDC_READ . . . . . . . . . . . .	Number	 0320h	 
HDC_STAT . . . . . . . . . . . .	Number	 0324h	 
HDD_POST_DONE  . . . . . . . . .	L Near	 E3FD	  BIOS	
HDD_POST_NONE  . . . . . . . . .	L Near	 E3FA	  BIOS	
HDD_POST_SHOW_LOOP . . . . . . .	L Near	 E3F2	  BIOS	
HD_COUNT . . . . . . . . . . . .	Byte	 0075	  _BDA	
HD_CTRL  . . . . . . . . . . . .	Byte	 0076	  _BDA	
HD_LAST_ST . . . . . . . . . . .	Byte	 0074	  _BDA	
HD_PORT  . . . . . . . . . . . .	Byte	 0077	  _BDA	
HEART  . . . . . . . . . . . . .	Number	 0003h	 
HELLO_WORLD  . . . . . . . . . .	L Near	 E27D	  BIOS	
HL . . . . . . . . . . . . . . .	Number	 00C4h	 
INIT_DMA1  . . . . . . . . . . .	L Near	 E0E3	  BIOS	
INIT_PIT1_TEST_DONE  . . . . . .	L Near	 E110	  BIOS	
INIT_PIT1_TEST_READ  . . . . . .	L Near	 E0FE	  BIOS	
INIT_PIT1_TEST . . . . . . . . .	L Near	 E0F6	  BIOS	
INIT_PIT1  . . . . . . . . . . .	L Near	 E110	  BIOS	
INIT_ROM_BASIC_DONE  . . . . . .	L Near	 E20B	  BIOS	
INIT_ROM_BASIC_SEG . . . . . . .	L Near	 E1DF	  BIOS	
INIT_SW_INT_VECTORS  . . . . . .	L Near	 E1D2	  BIOS	
INIT_VIDEO . . . . . . . . . . .	L Near	 E0A3	  BIOS	
INT_02_AFTER . . . . . . . . . .	L Near	 E2E6	  BIOS	
INT_02_LOOP  . . . . . . . . . .	L Near	 E2E2	  BIOS	
INT_02_NMI_HALT  . . . . . . . .	L Near	 E2D6	  BIOS	
INT_02_NMI_PAR . . . . . . . . .	L Near	 E2CC	  BIOS	
INT_05_DONE  . . . . . . . . . .	L Near	 FF9B	  BIOS	
INT_05_EXIT  . . . . . . . . . .	L Near	 FFA8	  BIOS	
INT_05_LOOP_1  . . . . . . . . .	L Near	 FF7D	  BIOS	
INT_05_NEXT_COL  . . . . . . . .	L Near	 FF95	  BIOS	
INT_08_EOI . . . . . . . . . . .	L Near	 FEC7	  BIOS	
INT_08_FD_MOTOR  . . . . . . . .	L Near	 FEBE	  BIOS	
INT_08_INT_1C  . . . . . . . . .	L Near	 FEC5	  BIOS	
INT_08_MOTOR_OFF . . . . . . . .	L Near	 FE97	  BIOS	
INT_08_RESET . . . . . . . . . .	L Near	 FED6	  BIOS	
INT_08_TICK_DAY  . . . . . . . .	L Near	 FED1	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 247 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_08_TICK_TIMER  . . . . . . .	L Near	 FEAF	  BIOS	
INT_09_POST_DONE . . . . . . . .	L Near	 E943	  BIOS	
INT_10_0_1 . . . . . . . . . . .	L Near	 F0F2	  BIOS	
INT_10_0_COLOR_BYTE  . . . . . .	L Near	 F187	  BIOS	
INT_10_0_CRTC_LOOP . . . . . . .	L Near	 F177	  BIOS	
INT_10_0_DETECT_DONE . . . . . .	L Near	 F147	  BIOS	
INT_10_0_IS_40_COL . . . . . . .	L Near	 F145	  BIOS	
INT_10_0_IS_CGA_GFX  . . . . . .	L Near	 F12E	  BIOS	
INT_10_0_IS_CGA_TEXT . . . . . .	L Near	 F13C	  BIOS	
INT_10_0_IS_CGA  . . . . . . . .	L Near	 F121	  BIOS	
INT_10_2_DONE  . . . . . . . . .	L Near	 F1EC	  BIOS	
INT_10_6_CHECK_CLS . . . . . . .	L Near	 F296	  BIOS	
INT_10_6_DONE  . . . . . . . . .	L Near	 F2BB	  BIOS	
INT_10_6_TXT_CLR_1 . . . . . . .	L Near	 F2AC	  BIOS	
INT_10_6_TXT_CLR_LOOP  . . . . .	L Near	 F2B0	  BIOS	
INT_10_6_TXT_CLR . . . . . . . .	L Near	 F2AE	  BIOS	
INT_10_6_TXT_MOVE_LOOP . . . . .	L Near	 F2A0	  BIOS	
INT_10_8_CHK_CGA . . . . . . . .	L Near	 F35B	  BIOS	
INT_10_8_FAST  . . . . . . . . .	L Near	 F357	  BIOS	
INT_10_8_GFX_DONE  . . . . . . .	L Near	 F3D2	  BIOS	
INT_10_8_GFX_HIGH  . . . . . . .	L Near	 F3DA	  BIOS	
INT_10_8_GFX_LOW_1 . . . . . . .	L Near	 F37F	  BIOS	
INT_10_8_GFX_LOW_2 . . . . . . .	L Near	 F38B	  BIOS	
INT_10_8_GFX_SEARCH_CHR  . . . .	L Near	 F3AF	  BIOS	
INT_10_8_GFX_SEARCH_TBL  . . . .	L Near	 F3AC	  BIOS	
INT_10_8_GFX_SEARCH  . . . . . .	L Near	 F3A1	  BIOS	
INT_10_8_MODE_GFX_LOW  . . . . .	L Near	 F37D	  BIOS	
INT_10_9A_FAST . . . . . . . . .	L Near	 F3FA	  BIOS	
INT_10_9A_GFX_2  . . . . . . . .	L Near	 F434	  BIOS	
INT_10_9A_GFX_FG . . . . . . . .	L Near	 F447	  BIOS	
INT_10_9A_GFX_HIGH_WORD  . . . .	L Near	 F49C	  BIOS	
INT_10_9A_GFX_HIGH_WR  . . . . .	L Near	 F4A9	  BIOS	
INT_10_9A_GFX_HIGH . . . . . . .	L Near	 F498	  BIOS	
INT_10_9A_GFX_LOW_BYTE . . . . .	L Near	 F459	  BIOS	
INT_10_9A_GFX_LOW_CHAR . . . . .	L Near	 F453	  BIOS	
INT_10_9A_GFX_LOW_NEXT . . . . .	L Near	 F488	  BIOS	
INT_10_9A_GFX_LOW_PDEP . . . . .	L Near	 F460	  BIOS	
INT_10_9A_GFX_LOW_WR . . . . . .	L Near	 F478	  BIOS	
INT_10_9A_GFX_LOW  . . . . . . .	L Near	 F442	  BIOS	
INT_10_9A_MODE_GFX_DONE  . . . .	L Near	 F491	  BIOS	
INT_10_9A_MODE_GFX_EXIT  . . . .	L Near	 F496	  BIOS	
INT_10_9_FAST  . . . . . . . . .	L Near	 F406	  BIOS	
INT_10_A_FAST  . . . . . . . . .	L Near	 F400	  BIOS	
INT_10_BOUNDS_OK . . . . . . . .	L Near	 F254	  BIOS	
INT_10_B_DONE  . . . . . . . . .	L Near	 F4EC	  BIOS	
INT_10_B_SET_COL . . . . . . . .	L Near	 F4DA	  BIOS	
INT_10_B_SET_PAL . . . . . . . .	L Near	 F4E1	  BIOS	
INT_10_CGA_CHECK . . . . . . . .	L Near	 F296	  BIOS	
INT_10_CHECK_BOUNDS  . . . . . .	L Near	 F24A	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 248 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_10_CHK_CGA . . . . . . . . .	L Near	 F40C	  BIOS	
INT_10_C_DONE  . . . . . . . . .	L Near	 F51C	  BIOS	
INT_10_C_XOR . . . . . . . . . .	L Near	 F51F	  BIOS	
INT_10_DONE  . . . . . . . . . .	L Near	 F081	  BIOS	
INT_10_E_BELL  . . . . . . . . .	L Near	 F5CF	  BIOS	
INT_10_E_BS  . . . . . . . . . .	L Near	 F5DE	  BIOS	
INT_10_E_CHAR  . . . . . . . . .	L Near	 F581	  BIOS	
INT_10_E_CR  . . . . . . . . . .	L Near	 F5D6	  BIOS	
INT_10_E_CTRL  . . . . . . . . .	L Near	 F5C1	  BIOS	
INT_10_E_CURS  . . . . . . . . .	L Near	 F5B9	  BIOS	
INT_10_E_DONE  . . . . . . . . .	L Near	 F5BC	  BIOS	
INT_10_E_LF  . . . . . . . . . .	L Near	 F5DA	  BIOS	
INT_10_E_SCROLL_UP . . . . . . .	L Near	 F5A4	  BIOS	
INT_10_E_SCROLL  . . . . . . . .	L Near	 F593	  BIOS	
INT_10_IRET  . . . . . . . . . .	L Near	 F084	  BIOS	
INT_10_IS_CGA80_DONE . . . . . .	L Near	 F0A0	  BIOS	
INT_10_IS_TXT_DONE . . . . . . .	L Near	 F08F	  BIOS	
INT_10_JMP . . . . . . . . . . .	Word	 F045	  BIOS	
INT_10_RET . . . . . . . . . . .	L Near	 F19E	  BIOS	
INT_10_SCR_GFX_2 . . . . . . . .	L Near	 F2EA	  BIOS	
INT_10_SCR_GFX_CLR_1 . . . . . .	L Near	 F328	  BIOS	
INT_10_SCR_GFX_CLR_LOOP  . . . .	L Near	 F32E	  BIOS	
INT_10_SCR_GFX_CLR . . . . . . .	L Near	 F32A	  BIOS	
INT_10_SCR_GFX_MOVE_LOOP . . . .	L Near	 F30A	  BIOS	
INT_10_SCR_GFX_RDY . . . . . . .	L Near	 F2F3	  BIOS	
INT_10_SCR_TXT . . . . . . . . .	L Near	 F262	  BIOS	
INT_10_SET_CUR_OFFSET  . . . . .	L Near	 F1CC	  BIOS	
INT_13_0A_DONE . . . . . . . . .	L Near	 ECF5	  BIOS	
INT_13_0_1 . . . . . . . . . . .	L Near	 ECAE	  BIOS	
INT_13_0_2 . . . . . . . . . . .	L Near	 ECB4	  BIOS	
INT_13_0_DONE  . . . . . . . . .	L Near	 ECE3	  BIOS	
INT_13_0_RESET_BAD . . . . . . .	L Near	 ECCC	  BIOS	
INT_13_0_RESET_DONE  . . . . . .	L Near	 ECCE	  BIOS	
INT_13_2_5_DONE  . . . . . . . .	L Near	 EDE1	  BIOS	
INT_13_2_5_EXIT  . . . . . . . .	L Near	 EDE3	  BIOS	
INT_13_2_5_SETUP_DMA . . . . . .	L Near	 ED14	  BIOS	
INT_13_BAD_CMD . . . . . . . . .	L Near	 EC7F	  BIOS	
INT_13_DONE  . . . . . . . . . .	L Near	 EC82	  BIOS	
INT_13_EXIT  . . . . . . . . . .	L Near	 EC8D	  BIOS	
INT_13_LAST  . . . . . . . . . .	Text   	 BYTE PTR [DI][FDC_LAST_ST-FD_LAST_OP]
INT_13_STAT  . . . . . . . . . .	Text   	 BYTE PTR [DI]
INT_14_0_SET_BAUD  . . . . . . .	L Near	 E77C	  BIOS	
INT_14_0_SET_PSW . . . . . . . .	L Near	 E77F	  BIOS	
INT_14_POLL_DONE . . . . . . . .	L Near	 E7EC	  BIOS	
INT_14_POLL_LOOP . . . . . . . .	L Near	 E7DE	  BIOS	
INT_14_POLL_RET  . . . . . . . .	L Near	 E7ED	  BIOS	
INT_14_RW_ERR  . . . . . . . . .	L Near	 E7B3	  BIOS	
INT_15_EXIT  . . . . . . . . . .	L Near	 F85C	  BIOS	
INT_16_DONE  . . . . . . . . . .	L Near	 E86C	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 249 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_17_0_BUSY_LOOP . . . . . . .	L Near	 EFFB	  BIOS	
INT_17_0_OK  . . . . . . . . . .	L Near	 F009	  BIOS	
INT_17_0_TIMEOUT_LOOP  . . . . .	L Near	 EFF9	  BIOS	
INT_17_0 . . . . . . . . . . . .	L Near	 EFF7	  BIOS	
INT_17_1 . . . . . . . . . . . .	L Near	 F023	  BIOS	
INT_17_2_STATUS_2  . . . . . . .	L Near	 F018	  BIOS	
INT_17_2_STATUS  . . . . . . . .	L Near	 F015	  BIOS	
INT_17_2 . . . . . . . . . . . .	L Near	 F014	  BIOS	
INT_17_DONE  . . . . . . . . . .	L Near	 F01C	  BIOS	
INT_17_IRET  . . . . . . . . . .	L Near	 F022	  BIOS	
INT_19_BOOT_HD . . . . . . . . .	Number	 0000h	 
INT_19_IPL_FAIL  . . . . . . . .	L Near	 E71D	  BIOS	
INT_19_READ_MBR  . . . . . . . .	L Near	 E704	  BIOS	
INT_1A_DONE  . . . . . . . . . .	L Near	 FE89	  BIOS	
INT_1A_EXIT  . . . . . . . . . .	L Near	 FE8C	  BIOS	
INT_1D_40  . . . . . . . . . . .	CRTC	 F0A4	  BIOS	
INT_1D_80  . . . . . . . . . . .	CRTC	 F0B4	  BIOS	
INT_1D_GFX . . . . . . . . . . .	CRTC	 F0C4	  BIOS	
INT_1D_MDA . . . . . . . . . . .	CRTC	 F0D4	  BIOS	
INT_1E . . . . . . . . . . . . .	DBT	 EFC7	  BIOS	
INT_IMR  . . . . . . . . . . . .	Number	 0021h	 
INT_IRQ_DONE . . . . . . . . . .	L Near	 FF40	  BIOS	
INT_KB_ALT_BREAK . . . . . . . .	L Near	 EB8D	  BIOS	
INT_KB_ALT_SKIP  . . . . . . . .	Byte	 EC1B	  BIOS	
INT_KB_CHECK_CTRL_NUM  . . . . .	L Near	 E9F3	  BIOS	
INT_KB_CTRL_ALPHA  . . . . . . .	L Near	 EAED	  BIOS	
INT_KB_CTRL_ALT_1_DONE . . . . .	L Near	 EB29	  BIOS	
INT_KB_CTRL_ALT_1  . . . . . . .	L Near	 EB1E	  BIOS	
INT_KB_CTRL_ALT_DEL  . . . . . .	L Near	 EB12	  BIOS	
INT_KB_CTRL_ASC_TBL_DONE . . . .	L Near	 EAE0	  BIOS	
INT_KB_CTRL_ASC_TBL_LOOP . . . .	L Near	 EACD	  BIOS	
INT_KB_CTRL_ASC_TBL  . . . . . .	Byte	 E963	  BIOS	
INT_KB_CTRL_BREAK  . . . . . . .	L Near	 E9E7	  BIOS	
INT_KB_CTRL_NO_ALT_1 . . . . . .	L Near	 EAFB	  BIOS	
INT_KB_CTRL_NO_DONE  . . . . . .	L Near	 EADD	  BIOS	
INT_KB_CTRL_SCAN_TBL . . . . . .	Byte	 E96D	  BIOS	
INT_KB_CTRL  . . . . . . . . . .	L Near	 EB08	  BIOS	
INT_KB_DONE2 . . . . . . . . . .	L Near	 EAB0	  BIOS	
INT_KB_DONE3 . . . . . . . . . .	L Near	 EB64	  BIOS	
INT_KB_DONE_2  . . . . . . . . .	L Near	 E9FD	  BIOS	
INT_KB_DONE  . . . . . . . . . .	L Near	 EA77	  BIOS	
INT_KB_FLAG_CLEAR  . . . . . . .	L Near	 EB79	  BIOS	
INT_KB_FLAG_DONE . . . . . . . .	L Near	 EB8A	  BIOS	
INT_KB_FLAG_FOUND  . . . . . . .	L Near	 EB43	  BIOS	
INT_KB_FLAG_LOOP . . . . . . . .	L Near	 EB39	  BIOS	
INT_KB_FLAG_SET  . . . . . . . .	L Near	 EB86	  BIOS	
INT_KB_FLAG_TOGGLE . . . . . . .	L Near	 EB5A	  BIOS	
INT_KB_ICNS_BREAK  . . . . . . .	L Near	 EB4E	  BIOS	
INT_KB_ICNS_MAKE . . . . . . . .	L Near	 EB56	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 250 - 1




Symbols:

                N a m e                 Type     Value    Attr

INT_KB_IS_ALT_000  . . . . . . .	L Near	 EAA2	  BIOS	
INT_KB_MEEP_DONE . . . . . . . .	L Near	 E9FA	  BIOS	
INT_KB_NOT_ALT_000 . . . . . . .	L Near	 EAB2	  BIOS	
INT_KB_NOT_ICNS_1  . . . . . . .	L Near	 EB75	  BIOS	
INT_KB_NOT_ICNS  . . . . . . . .	L Near	 EB67	  BIOS	
INT_KB_PAUSE_LOOP  . . . . . . .	L Near	 E959	  BIOS	
INT_KB_PUT_BUFFER_2  . . . . . .	L Near	 EB9A	  BIOS	
INT_KB_TURBO_IS_ON . . . . . . .	L Near	 F8CB	  BIOS	
INT_LAST_ABS . . . . . . . . . .	Byte	 046B	  _BDA_ABS	
INT_LAST . . . . . . . . . . . .	Byte	 006B	  _BDA	
INT_P0 . . . . . . . . . . . . .	Number	 0020h	 
IO_WAIT_LATCH  . . . . . . . . .	L Near	 F79F	  BIOS	
IO_WAIT_MS_DONE  . . . . . . . .	L Near	 F79E	  BIOS	
IO_WAIT_MS_LOOP  . . . . . . . .	L Near	 F78D	  BIOS	
IPL_ID . . . . . . . . . . . . .	Word	 7DFE	  _IPL_SEG	
IPL_TOP  . . . . . . . . . . . .	Byte	 7C00	  _IPL_SEG	
ISA_TYPE . . . . . . . . . . . .	Byte	 FFFE	  BIOS	
IS_ALPHA_DONE  . . . . . . . . .	L Near	 FF51	  BIOS	
IS_TURBO . . . . . . . . . . . .	Number	 -0001h	  
KB_ALT . . . . . . . . . . . . .	Byte	 0019	  _BDA	
KB_BUF_END_B . . . . . . . . . .	Number	 003Eh	 
KB_BUF_END . . . . . . . . . . .	Word	 003E	  _BDA	
KB_BUF_HAS_KEY . . . . . . . . .	L Near	 E84F	  BIOS	
KB_BUF_HD  . . . . . . . . . . .	Word	 001A	  _BDA	
KB_BUF_ST  . . . . . . . . . . .	Word	 0080	  _BDA	
KB_BUF_TL  . . . . . . . . . . .	Word	 001C	  _BDA	
KB_BUF . . . . . . . . . . . . .	Word	 001E	  _BDA	
KB_FLAGS1  . . . . . . . . . . .	KBFLAGS1  0017	   _BDA	
KB_FLAGS2  . . . . . . . . . . .	KBFLAGS2  0018	   _BDA	
KB_FLAGS3  . . . . . . . . . . .	Byte	 0096	  _BDA	
KB_FLAGS4  . . . . . . . . . . .	Byte	 0097	  _BDA	
KB_FLAGS . . . . . . . . . . . .	Word	 0017	  _BDA	
KB_GET_READ  . . . . . . . . . .	L Near	 E868	  BIOS	
KB_HAPPY . . . . . . . . . . . .	L Near	 E3A0	  BIOS	
KB_HLT_WAIT  . . . . . . . . . .	Number	 0001h	 
KB_INT_CHAR  . . . . . . . . . .	L Near	 EA15	  BIOS	
KB_INT_CHECK_FN_ALT  . . . . . .	L Near	 E9C1	  BIOS	
KB_INT_CHECK_FN_CTRL . . . . . .	L Near	 E9D9	  BIOS	
KB_INT_CHECK_FN_KEY_DONE . . . .	L Near	 E9DE	  BIOS	
KB_INT_CHECK_FN_KEY  . . . . . .	L Near	 E9B2	  BIOS	
KB_INT_CHECK_FN_SHIFT  . . . . .	L Near	 E9CB	  BIOS	
KB_INT_CHECK_FULL  . . . . . . .	L Near	 EA6B	  BIOS	
KB_INT_IS_ALT_DONE . . . . . . .	L Near	 EA48	  BIOS	
KB_INT_IS_ALT  . . . . . . . . .	L Near	 EA39	  BIOS	
KB_INT_IS_CAPS_DONE  . . . . . .	L Near	 EA39	  BIOS	
KB_INT_IS_CAPS . . . . . . . . .	L Near	 EA2D	  BIOS	
KB_INT_IS_CTRL_DONE  . . . . . .	L Near	 EA50	  BIOS	
KB_INT_IS_CTRL . . . . . . . . .	L Near	 EA48	  BIOS	
KB_INT_IS_NUM_DONE . . . . . . .	L Near	 EA15	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 251 - 1




Symbols:

                N a m e                 Type     Value    Attr

KB_INT_IS_NUM  . . . . . . . . .	L Near	 E9FF	  BIOS	
KB_INT_IS_PAUSE  . . . . . . . .	L Near	 EA50	  BIOS	
KB_INT_NOT_FLAG  . . . . . . . .	L Near	 EA29	  BIOS	
KB_INT_PRTSC . . . . . . . . . .	L Near	 E9D5	  BIOS	
KB_INT_PUT_BUFFER_2  . . . . . .	L Near	 E9DC	  BIOS	
KB_INT_PUT_BUFFER  . . . . . . .	L Near	 EA5C	  BIOS	
KB_INT_SHIFT . . . . . . . . . .	L Near	 EA1C	  BIOS	
KB_INT_UC  . . . . . . . . . . .	L Near	 EA1D	  BIOS	
KB_INT_XLAT  . . . . . . . . . .	L Near	 EA20	  BIOS	
KB_KEY_STATUS_DONE . . . . . . .	L Near	 E849	  BIOS	
KB_RESET_TEST  . . . . . . . . .	L Near	 E37D	  BIOS	
KB_WAIT_READ_1 . . . . . . . . .	L Near	 E855	  BIOS	
KEY_FLAG_ON_TBL  . . . . . . . .	L Near	 EC13	  BIOS	
KEY_SCAN_TBL_HIGH  . . . . . . .	L Near	 EC27	  BIOS	
KEY_SCAN_TBL . . . . . . . . . .	L Near	 EB9D	  BIOS	
LF . . . . . . . . . . . . . . .	Number	 000Ah	 
LIGHTCYAN  . . . . . . . . . . .	Number	 000Bh	 
LPT_ADDR_B . . . . . . . . . . .	Number	 0008h	 
LPT_ADDR . . . . . . . . . . . .	Word	 0008	  _BDA	
LPT_CHAR_EXIT  . . . . . . . . .	L Near	 FFC2	  BIOS	
LPT_CHAR_OUT . . . . . . . . . .	L Near	 FFBD	  BIOS	
LPT_DETECT_LOOP  . . . . . . . .	L Near	 E331	  BIOS	
LPT_TIME_B . . . . . . . . . . .	Number	 0078h	 
LPT_TIME . . . . . . . . . . . .	Byte	 0078	  _BDA	
LPT_TO . . . . . . . . . . . . .	Number	 0014h	 
L_INT_KB_ALT_SKIP  . . . . . . .	Number	 000Ah	 
L_INT_KB_CTRL_ASC_TBL  . . . . .	Number	 000Ch	 
L_INT_KB_CTRL_SCAN_TBL . . . . .	Number	 0006h	 
L_KEY_FLAG_ON_TBL  . . . . . . .	Number	 0008h	 
L_KEY_SCAN_TBL . . . . . . . . .	Number	 00AAh	 
L_POST_ERRORS  . . . . . . . . .	Number	 0006h	 
L_POST_L . . . . . . . . . . . .	Number	 0002h	 
L_VECTOR_TABLE . . . . . . . . .	Number	 001Fh	 
L_VID_BDA  . . . . . . . . . . .	Number	 001Eh	 
MAGENTA  . . . . . . . . . . . .	Number	 000Dh	 
MAGIC_WORD . . . . . . . . . . .	Number	 AA55h	 
MAX_RAM  . . . . . . . . . . . .	Number	 02E0h	 
MBR_CHECK  . . . . . . . . . . .	Number	 0000h	 
MDA_COLOR_FIX  . . . . . . . . .	L Near	 F6DC	  BIOS	
MDA_CTRL . . . . . . . . . . . .	Number	 03B8h	 
MDA_MEM  . . . . . . . . . . . .	Byte	 1000	  _MDA_MEM	
MDA_STAT . . . . . . . . . . . .	Number	 03BAh	 
MEEP_DELAY . . . . . . . . . . .	Number	 0040h	 
MEM_ADDR_ERR . . . . . . . . . .	L Near	 E5FF	  BIOS	
MEM_ADDR_LOOP  . . . . . . . . .	L Near	 E5E1	  BIOS	
MEM_SZ_KB  . . . . . . . . . . .	Word	 0013	  _BDA	
MEM_SZ_PC  . . . . . . . . . . .	Word	 0015	  _BDA	
MEM_TEST_VERIFY  . . . . . . . .	L Near	 E60F	  BIOS	
MOVE_COL_SET . . . . . . . . . .	L Near	 F708	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 252 - 1




Symbols:

                N a m e                 Type     Value    Attr

NEXT_COL . . . . . . . . . . . .	L Near	 F592	  BIOS	
NEXT_COM_PORT  . . . . . . . . .	L Near	 E327	  BIOS	
NEXT_LPT_PORT  . . . . . . . . .	L Near	 E350	  BIOS	
NEXT_ROM . . . . . . . . . . . .	L Near	 E522	  BIOS	
NL2_ANY_KEY  . . . . . . . . . .	Byte	 E48A	  BIOS	
NL_ANY_KEY . . . . . . . . . . .	Byte	 E48B	  BIOS	
NL_Z . . . . . . . . . . . . . .	Byte	 E46B	  BIOS	
NMI_ERR_IO . . . . . . . . . . .	Byte	 E828	  BIOS	
NMI_ERR_PAR  . . . . . . . . . .	Byte	 E82A	  BIOS	
NMI_R0 . . . . . . . . . . . . .	Number	 00A0h	 
NOTE1  . . . . . . . . . . . . .	Number	 000Dh	 
NOTE2  . . . . . . . . . . . . .	Number	 000Eh	 
NOT_HI_RES . . . . . . . . . . .	L Near	 F555	  BIOS	
NO_COM_PORT  . . . . . . . . . .	L Near	 E31A	  BIOS	
NO_GAME_PORT . . . . . . . . . .	L Near	 E301	  BIOS	
NO_LPT_PORT  . . . . . . . . . .	L Near	 E345	  BIOS	
OPT_ROM_END  . . . . . . . . . .	Number	 FE00h	 
OUT_DECU_DIV . . . . . . . . . .	L Near	 F734	  BIOS	
OUT_DECU_DONE  . . . . . . . . .	L Near	 F741	  BIOS	
OUT_DECU_OUT_R . . . . . . . . .	L Near	 F742	  BIOS	
OUT_SZ_ATTR_SET  . . . . . . . .	L Near	 F6E7	  BIOS	
OUT_SZ_DONE  . . . . . . . . . .	L Near	 F6FA	  BIOS	
OUT_SZ_LOOP  . . . . . . . . . .	L Near	 F6F0	  BIOS	
O_INT_1D_40  . . . . . . . . . .	Number	 0000h	 
O_INT_1D_80  . . . . . . . . . .	Number	 0010h	 
O_INT_1D_GFX . . . . . . . . . .	Number	 0020h	 
O_INT_1D_MDA . . . . . . . . . .	Number	 0030h	 
PIC_INT_FAIL . . . . . . . . . .	L Near	 E1A2	  BIOS	
PIC_INT_PASS . . . . . . . . . .	L Near	 E1C6	  BIOS	
PIC_INT_TEST . . . . . . . . . .	L Near	 E1A8	  BIOS	
PIC_REG_PASS . . . . . . . . . .	L Near	 E1A4	  BIOS	
PIC_VECT_TMP_LOOP  . . . . . . .	L Near	 E1AC	  BIOS	
PIT_CH0  . . . . . . . . . . . .	Number	 0040h	 
PIT_CH1  . . . . . . . . . . . .	Number	 0041h	 
PIT_CH2  . . . . . . . . . . . .	Number	 0042h	 
PIT_CTRL . . . . . . . . . . . .	Number	 0043h	 
PORT_COUNT_LOOP  . . . . . . . .	L Near	 F67A	  BIOS	
PORT_COUNT_NONE  . . . . . . . .	L Near	 F688	  BIOS	
PORT_TEST_DONE . . . . . . . . .	L Near	 E81C	  BIOS	
POST_BOOT_TYPE_OUT . . . . . . .	L Near	 E628	  BIOS	
POST_BOOT  . . . . . . . . . . .	Byte	 E62F	  BIOS	
POST_CARD_PORT . . . . . . . . .	Number	 0080h	 
POST_CGA . . . . . . . . . . . .	Byte	 F7B7	  BIOS	
POST_CLR_COLD  . . . . . . . . .	Text   	 BLUE
POST_CLR_GB  . . . . . . . . . .	Text   	 GRAY
POST_CLR_TXT . . . . . . . . . .	Text   	 CYAN
POST_CLR_VAL1  . . . . . . . . .	Text   	 GREEN
POST_CLR_VAL2  . . . . . . . . .	Text   	 YELLOW
POST_CLR_WARM  . . . . . . . . .	Text   	 DARKRED
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 253 - 1




Symbols:

                N a m e                 Type     Value    Attr

POST_CLS . . . . . . . . . . . .	Number	 0000h	 
POST_COLD  . . . . . . . . . . .	Byte	 E639	  BIOS	
POST_COL_LBL_W . . . . . . . . .	Number	 0007h	 
POST_COL_PAD . . . . . . . . . .	Number	 0004h	 
POST_COL_VT  . . . . . . . . . .	Number	 0009h	 
POST_COL_W . . . . . . . . . . .	Number	 0006h	 
POST_COM . . . . . . . . . . . .	Byte	 E4D2	  BIOS	
POST_CPU_TEST  . . . . . . . . .	L Near	 E05D	  BIOS	
POST_CPU . . . . . . . . . . . .	Byte	 E4A2	  BIOS	
POST_DETECT_COM  . . . . . . . .	L Near	 E301	  BIOS	
POST_DETECT_GAM  . . . . . . . .	L Near	 E2F6	  BIOS	
POST_DETECT_LPT  . . . . . . . .	L Near	 E329	  BIOS	
POST_DETECT_PORTS  . . . . . . .	L Near	 E2F3	  BIOS	
POST_EGA . . . . . . . . . . . .	Byte	 F7B3	  BIOS	
POST_ERRORS  . . . . . . . . . .	Word	 E912	  BIOS	
POST_ERROR_MSG_EXIT  . . . . . .	L Near	 E933	  BIOS	
POST_ERROR_MSG_LOOP  . . . . . .	L Near	 E924	  BIOS	
POST_ERROR_MSG_NEXT  . . . . . .	L Near	 E931	  BIOS	
POST_ERROR . . . . . . . . . . .	L Near	 E416	  BIOS	
POST_ERR_ERR . . . . . . . . . .	Byte	 E8FC	  BIOS	
POST_ERR_PDMA  . . . . . . . . .	Byte	 E90E	  BIOS	
POST_ERR_PFDC  . . . . . . . . .	Byte	 E90A	  BIOS	
POST_ERR_PKEY  . . . . . . . . .	Byte	 E906	  BIOS	
POST_ERR_PKI . . . . . . . . . .	Byte	 E903	  BIOS	
POST_ERR_WAIT  . . . . . . . . .	Number	 0001h	 
POST_ERR . . . . . . . . . . . .	Byte	 E8F5	  BIOS	
POST_FDD . . . . . . . . . . . .	Byte	 E4D6	  BIOS	
POST_FLAG_DONE . . . . . . . . .	L Near	 E0B6	  BIOS	
POST_FPU . . . . . . . . . . . .	Byte	 E4AB	  BIOS	
POST_GLADOS  . . . . . . . . . .	Number	 0000h	 
POST_HDD . . . . . . . . . . . .	Byte	 E4DA	  BIOS	
POST_HD_CHECK  . . . . . . . . .	Number	 0001h	 
POST_HD_CHS_L  . . . . . . . . .	Number	 0028h	 
POST_HD_CHS_R  . . . . . . . . .	Number	 0029h	 
POST_HD_PARMS  . . . . . . . . .	Number	 0001h	 
POST_HD  . . . . . . . . . . . .	Byte	 E4B4	  BIOS	
POST_K_UNIT  . . . . . . . . . .	Text   	 'KB'
POST_LPT . . . . . . . . . . . .	Byte	 E4CE	  BIOS	
POST_LSEP  . . . . . . . . . . .	Byte	 E4DE	  BIOS	
POST_L . . . . . . . . . . . . .	Text   	 ' [ '
POST_MDA . . . . . . . . . . . .	Byte	 E68D	  BIOS	
POST_MEMORY  . . . . . . . . . .	Byte	 E4BC	  BIOS	
POST_M_UNIT  . . . . . . . . . .	Text   	 'MB'
POST_NONE  . . . . . . . . . . .	Byte	 F945	  BIOS	
POST_OK  . . . . . . . . . . . .	L Near	 E436	  BIOS	
POST_RSEP  . . . . . . . . . . .	Byte	 E4E2	  BIOS	
POST_R . . . . . . . . . . . . .	Text   	 ' ]'
POST_START_COL_2_40  . . . . . .	L Near	 F690	  BIOS	
POST_START_COL_START . . . . . .	L Near	 F697	  BIOS	
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 254 - 1




Symbols:

                N a m e                 Type     Value    Attr

POST_SYS_VIDEO_DONE  . . . . . .	L Near	 E686	  BIOS	
POST_TAB_COL_I . . . . . . . . .	Number	 0013h	 
POST_TAB_COL . . . . . . . . . .	Number	 0020h	 
POST_TEST_CHK_ROM  . . . . . . .	Number	 0001h	 
POST_TEST_DMA  . . . . . . . . .	Number	 0001h	 
POST_TEST_FD . . . . . . . . . .	Number	 0000h	 
POST_TEST_INST . . . . . . . . .	Number	 0001h	 
POST_TEST_KB . . . . . . . . . .	Number	 0001h	 
POST_TEST_PIC_INT  . . . . . . .	Number	 0001h	 
POST_TEST_PIC_REG  . . . . . . .	Number	 0001h	 
POST_TEST_PIT_1  . . . . . . . .	Number	 0001h	 
POST_TEST_SEEK . . . . . . . . .	Number	 0000h	 
POST_THEME . . . . . . . . . . .	Number	 0001h	 
POST_V20 . . . . . . . . . . . .	Byte	 E4CA	  BIOS	
POST_VGA . . . . . . . . . . . .	Byte	 F7AF	  BIOS	
POST_VIDEO_TYPE  . . . . . . . .	Number	 0001h	 
POST_VIDEO . . . . . . . . . . .	Byte	 F93F	  BIOS	
POST_WARM_COLD . . . . . . . . .	Number	 0001h	 
POST_WARM  . . . . . . . . . . .	Byte	 E634	  BIOS	
PPI_A  . . . . . . . . . . . . .	Number	 0060h	 
PPI_B_BOOT . . . . . . . . . . .	Number	 00ADh	 
PPI_B  . . . . . . . . . . . . .	Number	 0061h	 
PPI_CW . . . . . . . . . . . . .	Number	 0063h	 
PPI_C  . . . . . . . . . . . . .	Number	 0062h	 
PTRSCN_ST  . . . . . . . . . . .	Byte	 0000	  _DOS_DAT	
RAM_PARITY . . . . . . . . . . .	Number	 0000h	 
RAM_TEST_1 . . . . . . . . . . .	Number	 95A5h	 
RAM_TEST_2 . . . . . . . . . . .	Number	 739Dh	 
RAM_TEST_LONG  . . . . . . . . .	Number	 0000h	 
RAM_TEST . . . . . . . . . . . .	Number	 95A5h	 
RANDOM_TAGLINE . . . . . . . . .	Number	 0001h	 
RED  . . . . . . . . . . . . . .	Number	 000Ch	 
REL_DATE . . . . . . . . . . . .	Byte	 FFF5	  BIOS	
RESET_PPI  . . . . . . . . . . .	L Near	 E0C5	  BIOS	
RESET_VIDEO_DONE . . . . . . . .	L Near	 E27D	  BIOS	
RESET_VIDEO  . . . . . . . . . .	L Near	 E27B	  BIOS	
ROM_INIT_SP  . . . . . . . . . .	Word	 0069	  _BDA	
ROM_INIT_SS  . . . . . . . . . .	Word	 0067	  _BDA	
ROM_SCAN_DONE  . . . . . . . . .	L Near	 E52C	  BIOS	
RTC_DATA . . . . . . . . . . . .	Word	 00B0	  _BDA	
RTC_WAIT . . . . . . . . . . . .	Byte	 00A0	  _BDA	
SETTINGS_5160  . . . . . . . . .	L Near	 E223	  BIOS	
SETTINGS_DONE  . . . . . . . . .	L Near	 E23B	  BIOS	
SETTINGS_SAVE  . . . . . . . . .	L Near	 E246	  BIOS	
SHOW_DISK_PARAMS_DONE  . . . . .	L Near	 F8BD	  BIOS	
SQUARE . . . . . . . . . . . . .	Number	 00FEh	 
STACK_TOP  . . . . . . . . . . .	Word	 0100	  _BOOT_STACK	
SW1_FLP  . . . . . . . . . . . .	Number	 00C0h	 
SYN  . . . . . . . . . . . . . .	Number	 0016h	 
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 255 - 1




Symbols:

                N a m e                 Type     Value    Attr

TAG0 . . . . . . . . . . . . . .	Byte	 E00E	  BIOS	
TAG1 . . . . . . . . . . . . . .	Byte	 F8F1	  BIOS	
TAG2 . . . . . . . . . . . . . .	Byte	 F904	  BIOS	
TAG3 . . . . . . . . . . . . . .	Byte	 F91A	  BIOS	
TAGS . . . . . . . . . . . . . .	Word	 F937	  BIOS	
TD_TURBO . . . . . . . . . . . .	Number	 0090h	 
TD_UMA . . . . . . . . . . . . .	Number	 00E0h	 
TD_WS  . . . . . . . . . . . . .	Number	 0070h	 
TIMER  . . . . . . . . . . . . .	TIMER_C	 006C	  _BDA	
TOGGLE_TURBO_CURSOR  . . . . . .	L Near	 E2B6	  BIOS	
TOGGLE_TURBO_DONE  . . . . . . .	L Near	 E2B9	  BIOS	
TOP_BANNER . . . . . . . . . . .	Byte	 E000	  BIOS	
TRY_INT_18 . . . . . . . . . . .	L Near	 E457	  BIOS	
TURBO_NONE . . . . . . . . . . .	Number	 0000h	 
TURBO_REV  . . . . . . . . . . .	Number	 0002h	 
TURBO_STD  . . . . . . . . . . .	Number	 0001h	 
TURBO_TYPE . . . . . . . . . . .	Number	 0002h	 
UM82_SPEED . . . . . . . . . . .	Number	 00C0h	 
UM82_STATUS  . . . . . . . . . .	Number	 00E0h	 
UNITS_IEC  . . . . . . . . . . .	Number	 0000h	 
V40_WCR1 . . . . . . . . . . . .	Number	 FFF5h	 
V40_WCR2 . . . . . . . . . . . .	Number	 FFF6h	 
VER_DATE . . . . . . . . . . . .	Text   	 '05/19/23'
VER_NAME . . . . . . . . . . . .	Text   	 'GLaBIOS'
VER_NUM  . . . . . . . . . . . .	Text   	 '0.2.4'
VER  . . . . . . . . . . . . . .	Byte	 FFE0	  BIOS	
VID_ATTR . . . . . . . . . . . .	Text   	 DNB <BLACK, GRAY>
VID_BIOS_SZ  . . . . . . . . . .	Byte	 0002	  _VID_BIOS	
VID_BUF_SZ . . . . . . . . . . .	Word	 004C	  _BDA	
VID_COLOR  . . . . . . . . . . .	Byte	 0066	  _BDA	
VID_COLS . . . . . . . . . . . .	Word	 004A	  _BDA	
VID_CURS_POS . . . . . . . . . .	Word	 0050	  _BDA	
VID_CURS_TYPE  . . . . . . . . .	Word	 0060	  _BDA	
VID_DEF_COLS . . . . . . . . . .	Number	 0050h	 
VID_DEF_ROWS . . . . . . . . . .	Number	 0018h	 
VID_MEM_SEG  . . . . . . . . . .	Word	 00EA	  _BDA	
VID_MN . . . . . . . . . . . . .	Word	 0000	  _VID_BIOS	
VID_MODE_OK  . . . . . . . . . .	L Near	 E26A	  BIOS	
VID_MODE_REG . . . . . . . . . .	Byte	 0065	  _BDA	
VID_MODE . . . . . . . . . . . .	Byte	 0049	  _BDA	
VID_PAGE . . . . . . . . . . . .	Byte	 0062	  _BDA	
VID_PORT . . . . . . . . . . . .	Word	 0063	  _BDA	
VID_SEG  . . . . . . . . . . . .	Word	 004E	  _BDA	
VID_SP . . . . . . . . . . . . .	Number	 0020h	 
VID_VEC  . . . . . . . . . . . .	Word	 0003	  _VID_BIOS	
VL . . . . . . . . . . . . . . .	Number	 00B3h	 
WARM_BOOT_MEM  . . . . . . . . .	Number	 4321h	 
WARM_BOOT_SUS  . . . . . . . . .	Number	 5678h	 
WARM_BOOT_TEST . . . . . . . . .	Number	 9ABCh	 
Microsoft (R) Macro Assembler Version 6.11		    06/29/23 10:50:12
GLaBIOS							     Symbols 256 - 1




Symbols:

                N a m e                 Type     Value    Attr

WARM_BOOT  . . . . . . . . . . .	Number	 1234h	 
WARM_ENABLE  . . . . . . . . . .	Number	 0001h	 
WARM_FLAG_ABS  . . . . . . . . .	Word	 0472	  _BDA_ABS	
WARM_FLAG  . . . . . . . . . . .	Word	 0072	  _BDA	
WB_LOW_CHECK_OK  . . . . . . . .	L Near	 E80E	  BIOS	
WB_READ_LOOP . . . . . . . . . .	L Near	 E809	  BIOS	
WB_WRITE_1 . . . . . . . . . . .	L Near	 E7F4	  BIOS	
WB_WRITE_LOOP  . . . . . . . . .	L Near	 E7FA	  BIOS	
WHITE  . . . . . . . . . . . . .	Number	 000Fh	 
YELLOW . . . . . . . . . . . . .	Number	 000Eh	 
ZERO_ALL_RAM . . . . . . . . . .	L Near	 E57D	  BIOS	
ZERO_ALL_START . . . . . . . . .	L Near	 E59A	  BIOS	
_BIOS_TOP  . . . . . . . . . . .	Word	 E000	  _BIOS	
_BOOT  . . . . . . . . . . . . .	Word	 E05B	  _BIOS	
_INT_08H_SEG . . . . . . . . . .	Word	 0022	  _IVT	
_INT_08H . . . . . . . . . . . .	Word	 0020	  _IVT	
_INT_09H_SEG . . . . . . . . . .	Word	 0026	  _IVT	
_INT_09H . . . . . . . . . . . .	Word	 0024	  _IVT	
_INT_10H_SEG . . . . . . . . . .	Word	 0042	  _IVT	
_INT_10H . . . . . . . . . . . .	Word	 0040	  _IVT	
_INT_18H_SEG . . . . . . . . . .	Word	 0062	  _IVT	
_INT_18H . . . . . . . . . . . .	Word	 0060	  _IVT	
_INT_1DH . . . . . . . . . . . .	DWord	 0074	  _IVT	
_INT_1EH . . . . . . . . . . . .	DWord	 0078	  _IVT	
_INT_1FH . . . . . . . . . . . .	DWord	 007C	  _IVT	
_POWER_ON  . . . . . . . . . . .	Word	 FFF0	  _BIOS	
_TEMP_MEM  . . . . . . . . . . .	Byte	 0000	  _BOOT_STACK	

	   1 Warnings
	   0 Errors
